// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// file-map:scripts/c3runtime.js
var require_c3runtime = __commonJS({
  "file-map:scripts/c3runtime.js"(exports, module) {
    {
      let setMatrixArrayType2 = function(t) {
        ARRAY_TYPE = t;
      }, toRadian2 = function(t) {
        return t * degree;
      }, equals$92 = function(t, a) {
        return Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$82 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;
      }, clone$82 = function(t) {
        var a = new ARRAY_TYPE(4);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;
      }, copy$82 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;
      }, identity$52 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
      }, fromValues$82 = function(t, a, r, n) {
        var e = new ARRAY_TYPE(4);
        return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;
      }, set$82 = function(t, a, r, n, e) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;
      }, transpose$22 = function(t, a) {
        var r;
        return t === a ? (r = a[1], t[1] = a[2], t[2] = r) : (t[0] = a[0], t[1] = a[2], t[2] = a[1], t[3] = a[3]), t;
      }, invert$52 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = r * a - e * n;
        return o ? (t[0] = a * (o = 1 / o), t[1] = -n * o, t[2] = -e * o, t[3] = r * o, t) : null;
      }, adjoint$22 = function(t, a) {
        var r = a[0];
        return t[0] = a[3], t[1] = -a[1], t[2] = -a[2], t[3] = r, t;
      }, determinant$32 = function(t) {
        return t[0] * t[3] - t[2] * t[1];
      }, multiply$82 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], r = r[3];
        return t[0] = n * u + o * s, t[1] = e * u + a * s, t[2] = n * i + o * r, t[3] = e * i + a * r, t;
      }, rotate$42 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);
        return t[0] = n * r + o * u, t[1] = e * r + a * u, t[2] = n * -u + o * r, t[3] = e * -u + a * r, t;
      }, scale$82 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], r = r[1];
        return t[0] = n * u, t[1] = e * u, t[2] = o * r, t[3] = a * r, t;
      }, fromRotation$42 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t;
      }, fromScaling$32 = function(t, a) {
        return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t;
      }, str$82 = function(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, frob$32 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3]);
      }, LDU2 = function(t, a, r, n) {
        return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, a, r];
      }, add$82 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;
      }, subtract$62 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;
      }, exactEquals$82 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];
      }, equals$82 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], t = t[3], o = a[0], u = a[1], s = a[2], a = a[3];
        return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, multiplyScalar$32 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;
      }, multiplyScalarAndAdd$32 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;
      }, create$72 = function() {
        var t = new ARRAY_TYPE(6);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;
      }, clone$72 = function(t) {
        var a = new ARRAY_TYPE(6);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a;
      }, copy$72 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t;
      }, identity$42 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
      }, fromValues$72 = function(t, a, r, n, e, o) {
        var u = new ARRAY_TYPE(6);
        return u[0] = t, u[1] = a, u[2] = r, u[3] = n, u[4] = e, u[5] = o, u;
      }, set$72 = function(t, a, r, n, e, o, u) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t;
      }, invert$42 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], a = a[5], s = r * o - n * e;
        return s ? (t[0] = o * (s = 1 / s), t[1] = -n * s, t[2] = -e * s, t[3] = r * s, t[4] = (e * a - o * u) * s, t[5] = (n * u - r * a) * s, t) : null;
      }, determinant$22 = function(t) {
        return t[0] * t[3] - t[1] * t[2];
      }, multiply$72 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], c = r[1], l = r[2], $ = r[3], h = r[4], r = r[5];
        return t[0] = n * i + o * c, t[1] = e * i + u * c, t[2] = n * l + o * $, t[3] = e * l + u * $, t[4] = n * h + o * r + s, t[5] = e * h + u * r + a, t;
      }, rotate$32 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = Math.sin(r), r = Math.cos(r);
        return t[0] = n * r + o * i, t[1] = e * r + u * i, t[2] = n * -i + o * r, t[3] = e * -i + u * r, t[4] = s, t[5] = a, t;
      }, scale$72 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], r = r[1];
        return t[0] = n * i, t[1] = e * i, t[2] = o * r, t[3] = u * r, t[4] = s, t[5] = a, t;
      }, translate$32 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], r = r[1];
        return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = n * i + o * r + s, t[5] = e * i + u * r + a, t;
      }, fromRotation$32 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t[4] = 0, t[5] = 0, t;
      }, fromScaling$22 = function(t, a) {
        return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t[4] = 0, t[5] = 0, t;
      }, fromTranslation$32 = function(t, a) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = a[0], t[5] = a[1], t;
      }, str$72 = function(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
      }, frob$22 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
      }, add$72 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t;
      }, subtract$52 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t;
      }, multiplyScalar$22 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t;
      }, multiplyScalarAndAdd$22 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t;
      }, exactEquals$72 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5];
      }, equals$72 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], t = t[5], s = a[0], i = a[1], c = a[2], l = a[3], $ = a[4], a = a[5];
        return Math.abs(r - s) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - i) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(e - c) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(c)) && Math.abs(o - l) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(l)) && Math.abs(u - $) <= EPSILON * Math.max(1, Math.abs(u), Math.abs($)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$62 = function() {
        var t = new ARRAY_TYPE(9);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
      }, fromMat4$12 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[4], t[4] = a[5], t[5] = a[6], t[6] = a[8], t[7] = a[9], t[8] = a[10], t;
      }, clone$62 = function(t) {
        var a = new ARRAY_TYPE(9);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a;
      }, copy$62 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;
      }, fromValues$62 = function(t, a, r, n, e, o, u, s, i) {
        var c = new ARRAY_TYPE(9);
        return c[0] = t, c[1] = a, c[2] = r, c[3] = n, c[4] = e, c[5] = o, c[6] = u, c[7] = s, c[8] = i, c;
      }, set$62 = function(t, a, r, n, e, o, u, s, i, c) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t;
      }, identity$32 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, transpose$12 = function(t, a) {
        var r, n, e;
        return t === a ? (r = a[1], n = a[2], e = a[5], t[1] = a[3], t[2] = a[6], t[3] = r, t[5] = a[7], t[6] = n, t[7] = e) : (t[0] = a[0], t[1] = a[3], t[2] = a[6], t[3] = a[1], t[4] = a[4], t[5] = a[7], t[6] = a[2], t[7] = a[5], t[8] = a[8]), t;
      }, invert$32 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], a = a[8], l = a * u - s * c, $ = -a * o + s * i, h = c * o - u * i, f = r * l + n * $ + e * h;
        return f ? (t[0] = l * (f = 1 / f), t[1] = (-a * n + e * c) * f, t[2] = (s * n - e * u) * f, t[3] = $ * f, t[4] = (a * r - e * i) * f, t[5] = (-s * r + e * o) * f, t[6] = h * f, t[7] = (-c * r + n * i) * f, t[8] = (u * r - n * o) * f, t) : null;
      }, adjoint$12 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], a = a[8];
        return t[0] = u * a - s * c, t[1] = e * c - n * a, t[2] = n * s - e * u, t[3] = s * i - o * a, t[4] = r * a - e * i, t[5] = e * o - r * s, t[6] = o * c - u * i, t[7] = n * i - r * c, t[8] = r * u - n * o, t;
      }, determinant$12 = function(t) {
        var a = t[0], r = t[3], n = t[4], e = t[5], o = t[6], u = t[7], s = t[8];
        return a * (s * n - e * u) + t[1] * (-s * r + e * o) + t[2] * (u * r - n * o);
      }, multiply$62 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = r[0], h = r[1], f = r[2], M = r[3], m = r[4], d = r[5], v = r[6], b = r[7], r = r[8];
        return t[0] = $ * n + h * u + f * c, t[1] = $ * e + h * s + f * l, t[2] = $ * o + h * i + f * a, t[3] = M * n + m * u + d * c, t[4] = M * e + m * s + d * l, t[5] = M * o + m * i + d * a, t[6] = v * n + b * u + r * c, t[7] = v * e + b * s + r * l, t[8] = v * o + b * i + r * a, t;
      }, translate$22 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = r[0], r = r[1];
        return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = $ * n + r * u + c, t[7] = $ * e + r * s + l, t[8] = $ * o + r * i + a, t;
      }, rotate$22 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = Math.sin(r), r = Math.cos(r);
        return t[0] = r * n + $ * u, t[1] = r * e + $ * s, t[2] = r * o + $ * i, t[3] = r * u - $ * n, t[4] = r * s - $ * e, t[5] = r * i - $ * o, t[6] = c, t[7] = l, t[8] = a, t;
      }, scale$62 = function(t, a, r) {
        var n = r[0], r = r[1];
        return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = r * a[3], t[4] = r * a[4], t[5] = r * a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;
      }, fromTranslation$22 = function(t, a) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = a[0], t[7] = a[1], t[8] = 1, t;
      }, fromRotation$22 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = a, t[1] = r, t[2] = 0, t[3] = -r, t[4] = a, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, fromScaling$12 = function(t, a) {
        return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = a[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
      }, fromMat2d2 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = 0, t[3] = a[2], t[4] = a[3], t[5] = 0, t[6] = a[4], t[7] = a[5], t[8] = 1, t;
      }, fromQuat$12 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = r + r, u = n + n, s = e + e, r = r * o, i = n * o, n = n * u, c = e * o, l = e * u, e = e * s, o = a * o, u = a * u, a = a * s;
        return t[0] = 1 - n - e, t[3] = i - a, t[6] = c + u, t[1] = i + a, t[4] = 1 - r - e, t[7] = l - o, t[2] = c - u, t[5] = l + o, t[8] = 1 - r - n, t;
      }, normalFromMat42 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, l = l * a - f * M, q = $ * d - h * m, $ = $ * a - f * m, h = h * a - f * d, f = v * h - b * $ + p * q + A * l - y * E + g * R;
        return f ? (t[0] = (s * h - i * $ + c * q) * (f = 1 / f), t[1] = (i * l - u * h - c * E) * f, t[2] = (u * $ - s * l + c * R) * f, t[3] = (e * $ - n * h - o * q) * f, t[4] = (r * h - e * l + o * E) * f, t[5] = (n * l - r * $ - o * R) * f, t[6] = (m * g - d * y + a * A) * f, t[7] = (d * p - M * g - a * b) * f, t[8] = (M * y - m * p + a * v) * f, t) : null;
      }, projection2 = function(t, a, r) {
        return t[0] = 2 / a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
      }, str$62 = function(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
      }, frob$12 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
      }, add$62 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t;
      }, subtract$42 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t;
      }, multiplyScalar$12 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t;
      }, multiplyScalarAndAdd$12 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t;
      }, exactEquals$62 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8];
      }, equals$62 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], t = t[8], l = a[0], $ = a[1], h = a[2], f = a[3], M = a[4], m = a[5], d = a[6], v = a[7], a = a[8];
        return Math.abs(r - l) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - f) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(s - m) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(i - d) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(c - v) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$52 = function() {
        var t = new ARRAY_TYPE(16);
        return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
      }, clone$52 = function(t) {
        var a = new ARRAY_TYPE(16);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;
      }, copy$52 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
      }, fromValues$52 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m) {
        var d = new ARRAY_TYPE(16);
        return d[0] = t, d[1] = a, d[2] = r, d[3] = n, d[4] = e, d[5] = o, d[6] = u, d[7] = s, d[8] = i, d[9] = c, d[10] = l, d[11] = $, d[12] = h, d[13] = f, d[14] = M, d[15] = m, d;
      }, set$52 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m, d) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t[9] = l, t[10] = $, t[11] = h, t[12] = f, t[13] = M, t[14] = m, t[15] = d, t;
      }, identity$22 = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, transpose2 = function(t, a) {
        var r, n, e, o, u, s;
        return t === a ? (r = a[1], n = a[2], e = a[3], o = a[6], u = a[7], s = a[11], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = r, t[6] = a[9], t[7] = a[13], t[8] = n, t[9] = o, t[11] = a[14], t[12] = e, t[13] = u, t[14] = s) : (t[0] = a[0], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = a[1], t[5] = a[5], t[6] = a[9], t[7] = a[13], t[8] = a[2], t[9] = a[6], t[10] = a[10], t[11] = a[14], t[12] = a[3], t[13] = a[7], t[14] = a[11], t[15] = a[15]), t;
      }, invert$22 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, q = l * a - f * M, x = $ * d - h * m, P = $ * a - f * m, L = h * a - f * d, O = v * L - b * P + p * x + A * q - y * E + g * R;
        return O ? (t[0] = (s * L - i * P + c * x) * (O = 1 / O), t[1] = (e * P - n * L - o * x) * O, t[2] = (m * g - d * y + a * A) * O, t[3] = (h * y - $ * g - f * A) * O, t[4] = (i * q - u * L - c * E) * O, t[5] = (r * L - e * q + o * E) * O, t[6] = (d * p - M * g - a * b) * O, t[7] = (l * g - h * p + f * b) * O, t[8] = (u * P - s * q + c * R) * O, t[9] = (n * q - r * P - o * R) * O, t[10] = (M * y - m * p + a * v) * O, t[11] = ($ * p - l * y - f * v) * O, t[12] = (s * E - u * x - i * R) * O, t[13] = (r * x - n * E + e * R) * O, t[14] = (m * b - M * A - d * v) * O, t[15] = (l * A - $ * b + h * v) * O, t) : null;
      }, adjoint2 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, q = l * a - f * M, x = $ * d - h * m, P = $ * a - f * m, L = h * a - f * d;
        return t[0] = s * L - i * P + c * x, t[1] = e * P - n * L - o * x, t[2] = m * g - d * y + a * A, t[3] = h * y - $ * g - f * A, t[4] = i * q - u * L - c * E, t[5] = r * L - e * q + o * E, t[6] = d * p - M * g - a * b, t[7] = l * g - h * p + f * b, t[8] = u * P - s * q + c * R, t[9] = n * q - r * P - o * R, t[10] = M * y - m * p + a * v, t[11] = $ * p - l * y - f * v, t[12] = s * E - u * x - i * R, t[13] = r * x - n * E + e * R, t[14] = m * b - M * A - d * v, t[15] = l * A - $ * b + h * v, t;
      }, determinant2 = function(t) {
        var a = t[0], r = t[1], n = t[2], e = t[4], o = t[5], u = t[6], s = t[8], i = t[9], c = t[10], l = t[12], $ = t[13], h = t[14], f = a * o - r * e, M = a * u - n * e, m = r * u - n * o, d = s * $ - i * l, v = s * h - c * l, b = i * h - c * $;
        return t[7] * (a * b - r * v + n * d) - t[3] * (e * b - o * v + u * d) + t[15] * (s * m - i * M + c * f) - t[11] * (l * m - $ * M + h * f);
      }, multiply$52 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], m = a[12], d = a[13], v = a[14], a = a[15], b = r[0], p = r[1], A = r[2], y = r[3];
        return t[0] = b * n + p * s + A * $ + y * m, t[1] = b * e + p * i + A * h + y * d, t[2] = b * o + p * c + A * f + y * v, t[3] = b * u + p * l + A * M + y * a, t[4] = (b = r[4]) * n + (p = r[5]) * s + (A = r[6]) * $ + (y = r[7]) * m, t[5] = b * e + p * i + A * h + y * d, t[6] = b * o + p * c + A * f + y * v, t[7] = b * u + p * l + A * M + y * a, t[8] = (b = r[8]) * n + (p = r[9]) * s + (A = r[10]) * $ + (y = r[11]) * m, t[9] = b * e + p * i + A * h + y * d, t[10] = b * o + p * c + A * f + y * v, t[11] = b * u + p * l + A * M + y * a, t[12] = (b = r[12]) * n + (p = r[13]) * s + (A = r[14]) * $ + (y = r[15]) * m, t[13] = b * e + p * i + A * h + y * d, t[14] = b * o + p * c + A * f + y * v, t[15] = b * u + p * l + A * M + y * a, t;
      }, translate$12 = function(t, a, r) {
        var n, e, o, u, s, i, c, l, $, h, f, M, m = r[0], d = r[1], r = r[2];
        return a === t ? (t[12] = a[0] * m + a[4] * d + a[8] * r + a[12], t[13] = a[1] * m + a[5] * d + a[9] * r + a[13], t[14] = a[2] * m + a[6] * d + a[10] * r + a[14], t[15] = a[3] * m + a[7] * d + a[11] * r + a[15]) : (n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = c, t[7] = l, t[8] = $, t[9] = h, t[10] = f, t[11] = M, t[12] = n * m + s * d + $ * r + a[12], t[13] = e * m + i * d + h * r + a[13], t[14] = o * m + c * d + f * r + a[14], t[15] = u * m + l * d + M * r + a[15]), t;
      }, scale$52 = function(t, a, r) {
        var n = r[0], e = r[1], r = r[2];
        return t[0] = a[0] * n, t[1] = a[1] * n, t[2] = a[2] * n, t[3] = a[3] * n, t[4] = a[4] * e, t[5] = a[5] * e, t[6] = a[6] * e, t[7] = a[7] * e, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;
      }, rotate$12 = function(t, a, r, n) {
        var e, o, u, s, i, c, l, $, h, f, M, m, d, v, b, p, A, y, g, R, E = n[0], q = n[1], n = n[2], x = Math.hypot(E, q, n);
        return x < EPSILON ? null : (E *= x = 1 / x, q *= x, n *= x, x = Math.sin(r), r = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], l = a[5], $ = a[6], h = a[7], M = a[9], m = a[10], d = a[11], b = E * q * (e = 1 - r) - n * x, p = q * q * e + r, A = n * q * e + E * x, y = E * n * e + q * x, g = q * n * e - E * x, R = n * n * e + r, t[0] = o * (r = E * E * e + r) + (c = a[4]) * (v = q * E * e + n * x) + (f = a[8]) * (n = n * E * e - q * x), t[1] = u * r + l * v + M * n, t[2] = s * r + $ * v + m * n, t[3] = i * r + h * v + d * n, t[4] = o * b + c * p + f * A, t[5] = u * b + l * p + M * A, t[6] = s * b + $ * p + m * A, t[7] = i * b + h * p + d * A, t[8] = o * y + c * g + f * R, t[9] = u * y + l * g + M * R, t[10] = s * y + $ * g + m * R, t[11] = i * y + h * g + d * R, a !== t && (t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t);
      }, rotateX$32 = function(t, a, r) {
        var n = Math.sin(r), r = Math.cos(r), e = a[4], o = a[5], u = a[6], s = a[7], i = a[8], c = a[9], l = a[10], $ = a[11];
        return a !== t && (t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[4] = e * r + i * n, t[5] = o * r + c * n, t[6] = u * r + l * n, t[7] = s * r + $ * n, t[8] = i * r - e * n, t[9] = c * r - o * n, t[10] = l * r - u * n, t[11] = $ * r - s * n, t;
      }, rotateY$32 = function(t, a, r) {
        var n = Math.sin(r), r = Math.cos(r), e = a[0], o = a[1], u = a[2], s = a[3], i = a[8], c = a[9], l = a[10], $ = a[11];
        return a !== t && (t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = e * r - i * n, t[1] = o * r - c * n, t[2] = u * r - l * n, t[3] = s * r - $ * n, t[8] = e * n + i * r, t[9] = o * n + c * r, t[10] = u * n + l * r, t[11] = s * n + $ * r, t;
      }, rotateZ$32 = function(t, a, r) {
        var n = Math.sin(r), r = Math.cos(r), e = a[0], o = a[1], u = a[2], s = a[3], i = a[4], c = a[5], l = a[6], $ = a[7];
        return a !== t && (t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = e * r + i * n, t[1] = o * r + c * n, t[2] = u * r + l * n, t[3] = s * r + $ * n, t[4] = i * r - e * n, t[5] = c * r - o * n, t[6] = l * r - u * n, t[7] = $ * r - s * n, t;
      }, fromTranslation$12 = function(t, a) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t;
      }, fromScaling2 = function(t, a) {
        return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = a[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromRotation$12 = function(t, a, r) {
        var n, e = r[0], o = r[1], r = r[2], u = Math.hypot(e, o, r);
        return u < EPSILON ? null : (e *= u = 1 / u, o *= u, r *= u, u = Math.sin(a), a = Math.cos(a), t[0] = e * e * (n = 1 - a) + a, t[1] = o * e * n + r * u, t[2] = r * e * n - o * u, t[3] = 0, t[4] = e * o * n - r * u, t[5] = o * o * n + a, t[6] = r * o * n + e * u, t[7] = 0, t[8] = e * r * n + o * u, t[9] = o * r * n - e * u, t[10] = r * r * n + a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
      }, fromXRotation2 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromYRotation2 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = a, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromZRotation2 = function(t, a) {
        var r = Math.sin(a), a = Math.cos(a);
        return t[0] = a, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, fromRotationTranslation$12 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = n + n, s = e + e, i = o + o, c = n * u, l = n * s, n = n * i, $ = e * s, e = e * i, o = o * i, u = a * u, s = a * s, a = a * i;
        return t[0] = 1 - ($ + o), t[1] = l + a, t[2] = n - s, t[3] = 0, t[4] = l - a, t[5] = 1 - (c + o), t[6] = e + u, t[7] = 0, t[8] = n + s, t[9] = e - u, t[10] = 1 - (c + $), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
      }, fromQuat22 = function(t, a) {
        var r = new ARRAY_TYPE(3), n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = n * n + e * e + o * o + u * u;
        return 0 < $ ? (r[0] = 2 * (s * u + l * n + i * o - c * e) / $, r[1] = 2 * (i * u + l * e + c * n - s * o) / $, r[2] = 2 * (c * u + l * o + s * e - i * n) / $) : (r[0] = 2 * (s * u + l * n + i * o - c * e), r[1] = 2 * (i * u + l * e + c * n - s * o), r[2] = 2 * (c * u + l * o + s * e - i * n)), fromRotationTranslation$12(t, a, r), t;
      }, getTranslation$12 = function(t, a) {
        return t[0] = a[12], t[1] = a[13], t[2] = a[14], t;
      }, getScaling2 = function(t, a) {
        var r = a[0], n = a[4], e = a[5], o = a[6], u = a[8], s = a[9], i = a[10];
        return t[0] = Math.hypot(r, a[1], a[2]), t[1] = Math.hypot(n, e, o), t[2] = Math.hypot(u, s, i), t;
      }, getRotation2 = function(t, a) {
        var r = new ARRAY_TYPE(3), n = (getScaling2(r, a), 1 / r[0]), e = 1 / r[1], r = 1 / r[2], o = a[0] * n, u = a[1] * e, s = a[2] * r, i = a[4] * n, c = a[5] * e, l = a[6] * r, n = a[8] * n, e = a[9] * e, a = a[10] * r, r = o + c + a, $ = 0;
        return 0 < r ? ($ = 2 * Math.sqrt(1 + r), t[3] = 0.25 * $, t[0] = (l - e) / $, t[1] = (n - s) / $, t[2] = (u - i) / $) : c < o && a < o ? ($ = 2 * Math.sqrt(1 + o - c - a), t[3] = (l - e) / $, t[0] = 0.25 * $, t[1] = (u + i) / $, t[2] = (n + s) / $) : a < c ? ($ = 2 * Math.sqrt(1 + c - o - a), t[3] = (n - s) / $, t[0] = (u + i) / $, t[1] = 0.25 * $, t[2] = (l + e) / $) : ($ = 2 * Math.sqrt(1 + a - o - c), t[3] = (u - i) / $, t[0] = (n + s) / $, t[1] = (l + e) / $, t[2] = 0.25 * $), t;
      }, decompose2 = function(t, a, r, n) {
        a[0] = n[12], a[1] = n[13], a[2] = n[14];
        var a = n[0], e = n[1], o = n[2], u = n[4], s = n[5], i = n[6], c = n[8], l = n[9], n = n[10], $ = (r[0] = Math.hypot(a, e, o), r[1] = Math.hypot(u, s, i), r[2] = Math.hypot(c, l, n), 1 / r[0]), h = 1 / r[1], r = 1 / r[2], a = a * $, e = e * h, o = o * r, u = u * $, s = s * h, i = i * r, c = c * $, $ = l * h, l = n * r, h = a + s + l, n = 0;
        return 0 < h ? (n = 2 * Math.sqrt(1 + h), t[3] = 0.25 * n, t[0] = (i - $) / n, t[1] = (c - o) / n, t[2] = (e - u) / n) : s < a && l < a ? (n = 2 * Math.sqrt(1 + a - s - l), t[3] = (i - $) / n, t[0] = 0.25 * n, t[1] = (e + u) / n, t[2] = (c + o) / n) : l < s ? (n = 2 * Math.sqrt(1 + s - a - l), t[3] = (c - o) / n, t[0] = (e + u) / n, t[1] = 0.25 * n, t[2] = (i + $) / n) : (n = 2 * Math.sqrt(1 + l - a - s), t[3] = (e - u) / n, t[0] = (c + o) / n, t[1] = (i + $) / n, t[2] = 0.25 * n), t;
      }, fromRotationTranslationScale2 = function(t, a, r, n) {
        var e = a[0], o = a[1], u = a[2], a = a[3], s = e + e, i = o + o, c = u + u, l = e * s, $ = e * i, e = e * c, h = o * i, o = o * c, u = u * c, s = a * s, i = a * i, a = a * c, c = n[0], f = n[1], n = n[2];
        return t[0] = (1 - (h + u)) * c, t[1] = ($ + a) * c, t[2] = (e - i) * c, t[3] = 0, t[4] = ($ - a) * f, t[5] = (1 - (l + u)) * f, t[6] = (o + s) * f, t[7] = 0, t[8] = (e + i) * n, t[9] = (o - s) * n, t[10] = (1 - (l + h)) * n, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
      }, fromRotationTranslationScaleOrigin2 = function(t, a, r, n, e) {
        var o = a[0], u = a[1], s = a[2], a = a[3], i = o + o, c = u + u, l = s + s, $ = o * i, h = o * c, o = o * l, f = u * c, u = u * l, s = s * l, i = a * i, c = a * c, a = a * l, l = n[0], M = n[1], n = n[2], m = e[0], d = e[1], e = e[2], v = (1 - (f + s)) * l, b = (h + a) * l, l = (o - c) * l, h = (h - a) * M, a = (1 - ($ + s)) * M, s = (u + i) * M, M = (o + c) * n, o = (u - i) * n, c = (1 - ($ + f)) * n;
        return t[0] = v, t[1] = b, t[2] = l, t[3] = 0, t[4] = h, t[5] = a, t[6] = s, t[7] = 0, t[8] = M, t[9] = o, t[10] = c, t[11] = 0, t[12] = r[0] + m - (v * m + h * d + M * e), t[13] = r[1] + d - (b * m + a * d + o * e), t[14] = r[2] + e - (l * m + s * d + c * e), t[15] = 1, t;
      }, fromQuat3 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = r + r, u = n + n, s = e + e, r = r * o, i = n * o, n = n * u, c = e * o, l = e * u, e = e * s, o = a * o, u = a * u, a = a * s;
        return t[0] = 1 - n - e, t[1] = i + a, t[2] = c - u, t[3] = 0, t[4] = i - a, t[5] = 1 - r - e, t[6] = l + o, t[7] = 0, t[8] = c + u, t[9] = l - o, t[10] = 1 - r - n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
      }, frustum2 = function(t, a, r, n, e, o, u) {
        var s = 1 / (r - a), i = 1 / (e - n), c = 1 / (o - u);
        return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * i, t[6] = 0, t[7] = 0, t[8] = (r + a) * s, t[9] = (e + n) * i, t[10] = (u + o) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * o * 2 * c, t[15] = 0, t;
      }, perspectiveNO2 = function(t, a, r, n, e) {
        a = 1 / Math.tan(a / 2);
        return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0 ? (t[10] = (e + n) * (r = 1 / (n - e)), t[14] = 2 * e * n * r) : (t[10] = -1, t[14] = -2 * n), t;
      }, perspectiveZO2 = function(t, a, r, n, e) {
        a = 1 / Math.tan(a / 2);
        return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0 ? (t[10] = e * (r = 1 / (n - e)), t[14] = e * n * r) : (t[10] = -1, t[14] = -n), t;
      }, perspectiveFromFieldOfView2 = function(t, a, r, n) {
        var e = Math.tan(a.upDegrees * Math.PI / 180), o = Math.tan(a.downDegrees * Math.PI / 180), u = Math.tan(a.leftDegrees * Math.PI / 180), a = Math.tan(a.rightDegrees * Math.PI / 180), s = 2 / (u + a), i = 2 / (e + o);
        return t[0] = s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = i, t[6] = 0, t[7] = 0, t[8] = -(u - a) * s * 0.5, t[9] = (e - o) * i * 0.5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;
      }, orthoNO2 = function(t, a, r, n, e, o, u) {
        var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);
        return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = (u + o) * c, t[15] = 1, t;
      }, orthoZO2 = function(t, a, r, n, e, o, u) {
        var s = 1 / (a - r), i = 1 / (n - e), u = 1 / (o - u);
        return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = o * u, t[15] = 1, t;
      }, lookAt2 = function(t, a, r, n) {
        var e, o, u, s, i = a[0], c = a[1], a = a[2], l = n[0], $ = n[1], n = n[2], h = r[0], f = r[1], r = r[2];
        return Math.abs(i - h) < EPSILON && Math.abs(c - f) < EPSILON && Math.abs(a - r) < EPSILON ? identity$22(t) : (h = i - h, f = c - f, r = a - r, e = $ * (r *= s = 1 / Math.hypot(h, f, r)) - n * (f *= s), n = n * (h *= s) - l * r, l = l * f - $ * h, (s = Math.hypot(e, n, l)) ? (e *= s = 1 / s, n *= s, l *= s) : l = n = e = 0, $ = f * l - r * n, o = r * e - h * l, u = h * n - f * e, (s = Math.hypot($, o, u)) ? ($ *= s = 1 / s, o *= s, u *= s) : u = o = $ = 0, t[0] = e, t[1] = $, t[2] = h, t[3] = 0, t[4] = n, t[5] = o, t[6] = f, t[7] = 0, t[8] = l, t[9] = u, t[10] = r, t[11] = 0, t[12] = -(e * i + n * c + l * a), t[13] = -($ * i + o * c + u * a), t[14] = -(h * i + f * c + r * a), t[15] = 1, t);
      }, targetTo2 = function(t, a, r, n) {
        var e = a[0], o = a[1], a = a[2], u = n[0], s = n[1], n = n[2], i = e - r[0], c = o - r[1], r = a - r[2], l = i * i + c * c + r * r, $ = (0 < l && (i *= l = 1 / Math.sqrt(l), c *= l, r *= l), s * r - n * c), n = n * i - u * r, u = u * c - s * i;
        return 0 < (l = $ * $ + n * n + u * u) && ($ *= l = 1 / Math.sqrt(l), n *= l, u *= l), t[0] = $, t[1] = n, t[2] = u, t[3] = 0, t[4] = c * u - r * n, t[5] = r * $ - i * u, t[6] = i * n - c * $, t[7] = 0, t[8] = i, t[9] = c, t[10] = r, t[11] = 0, t[12] = e, t[13] = o, t[14] = a, t[15] = 1, t;
      }, str$52 = function(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
      }, frob2 = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
      }, add$52 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t[9] = a[9] + r[9], t[10] = a[10] + r[10], t[11] = a[11] + r[11], t[12] = a[12] + r[12], t[13] = a[13] + r[13], t[14] = a[14] + r[14], t[15] = a[15] + r[15], t;
      }, subtract$32 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t[9] = a[9] - r[9], t[10] = a[10] - r[10], t[11] = a[11] - r[11], t[12] = a[12] - r[12], t[13] = a[13] - r[13], t[14] = a[14] - r[14], t[15] = a[15] - r[15], t;
      }, multiplyScalar2 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12] * r, t[13] = a[13] * r, t[14] = a[14] * r, t[15] = a[15] * r, t;
      }, multiplyScalarAndAdd2 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t[9] = a[9] + r[9] * n, t[10] = a[10] + r[10] * n, t[11] = a[11] + r[11] * n, t[12] = a[12] + r[12] * n, t[13] = a[13] + r[13] * n, t[14] = a[14] + r[14] * n, t[15] = a[15] + r[15] * n, t;
      }, exactEquals$52 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8] && t[9] === a[9] && t[10] === a[10] && t[11] === a[11] && t[12] === a[12] && t[13] === a[13] && t[14] === a[14] && t[15] === a[15];
      }, equals$52 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = t[9], h = t[10], f = t[11], M = t[12], m = t[13], d = t[14], t = t[15], v = a[0], b = a[1], p = a[2], A = a[3], y = a[4], g = a[5], R = a[6], E = a[7], q = a[8], x = a[9], P = a[10], L = a[11], O = a[12], S = a[13], Y = a[14], a = a[15];
        return Math.abs(r - v) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(v)) && Math.abs(n - b) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(e - p) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(p)) && Math.abs(o - A) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(A)) && Math.abs(u - y) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(y)) && Math.abs(s - g) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(i - R) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(R)) && Math.abs(c - E) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(E)) && Math.abs(l - q) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(q)) && Math.abs($ - x) <= EPSILON * Math.max(1, Math.abs($), Math.abs(x)) && Math.abs(h - P) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(P)) && Math.abs(f - L) <= EPSILON * Math.max(1, Math.abs(f), Math.abs(L)) && Math.abs(M - O) <= EPSILON * Math.max(1, Math.abs(M), Math.abs(O)) && Math.abs(m - S) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(S)) && Math.abs(d - Y) <= EPSILON * Math.max(1, Math.abs(d), Math.abs(Y)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$42 = function() {
        var t = new ARRAY_TYPE(3);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
      }, clone$42 = function(t) {
        var a = new ARRAY_TYPE(3);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a;
      }, length$42 = function(t) {
        var a = t[0];
        return Math.hypot(a, t[1], t[2]);
      }, fromValues$42 = function(t, a, r) {
        var n = new ARRAY_TYPE(3);
        return n[0] = t, n[1] = a, n[2] = r, n;
      }, copy$42 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;
      }, set$42 = function(t, a, r, n) {
        return t[0] = a, t[1] = r, t[2] = n, t;
      }, add$42 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;
      }, subtract$22 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t;
      }, multiply$42 = function(t, a, r) {
        return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t;
      }, divide$22 = function(t, a, r) {
        return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t;
      }, ceil$22 = function(t, a) {
        return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t;
      }, floor$22 = function(t, a) {
        return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t;
      }, min$22 = function(t, a, r) {
        return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t;
      }, max$22 = function(t, a, r) {
        return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t;
      }, round$22 = function(t, a) {
        return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t;
      }, scale$42 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;
      }, scaleAndAdd$22 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t;
      }, distance$22 = function(t, a) {
        var r = a[0] - t[0];
        return Math.hypot(r, a[1] - t[1], a[2] - t[2]);
      }, squaredDistance$22 = function(t, a) {
        var r = a[0] - t[0], n = a[1] - t[1], a = a[2] - t[2];
        return r * r + n * n + a * a;
      }, squaredLength$42 = function(t) {
        var a = t[0], r = t[1], t = t[2];
        return a * a + r * r + t * t;
      }, negate$22 = function(t, a) {
        return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t;
      }, inverse$22 = function(t, a) {
        return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t;
      }, normalize$42 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], r = r * r + n * n + e * e;
        return 0 < r && (r = 1 / Math.sqrt(r)), t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;
      }, dot$42 = function(t, a) {
        return t[0] * a[0] + t[1] * a[1] + t[2] * a[2];
      }, cross$22 = function(t, a, r) {
        var n = a[0], e = a[1], a = a[2], o = r[0], u = r[1], r = r[2];
        return t[0] = e * r - a * u, t[1] = a * o - n * r, t[2] = n * u - e * o, t;
      }, lerp$42 = function(t, a, r, n) {
        var e = a[0], o = a[1], a = a[2];
        return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = a + n * (r[2] - a), t;
      }, slerp$12 = function(t, a, r, n) {
        var e = Math.acos(Math.min(Math.max(dot$42(a, r), -1), 1)), o = Math.sin(e), u = Math.sin((1 - n) * e) / o, n = Math.sin(n * e) / o;
        return t[0] = u * a[0] + n * r[0], t[1] = u * a[1] + n * r[1], t[2] = u * a[2] + n * r[2], t;
      }, hermite2 = function(t, a, r, n, e, o) {
        var u = o * o, s = u * (2 * o - 3) + 1, i = u * (o - 2) + o, c = u * (o - 1), u = u * (3 - 2 * o);
        return t[0] = a[0] * s + r[0] * i + n[0] * c + e[0] * u, t[1] = a[1] * s + r[1] * i + n[1] * c + e[1] * u, t[2] = a[2] * s + r[2] * i + n[2] * c + e[2] * u, t;
      }, bezier2 = function(t, a, r, n, e, o) {
        var u = 1 - o, s = u * u, i = o * o, c = s * u, s = 3 * o * s, u = 3 * i * u, i = i * o;
        return t[0] = a[0] * c + r[0] * s + n[0] * u + e[0] * i, t[1] = a[1] * c + r[1] * s + n[1] * u + e[1] * i, t[2] = a[2] * c + r[2] * s + n[2] * u + e[2] * i, t;
      }, random$32 = function(t, a) {
        a = a || 1;
        var r = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a;
        return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t[2] = n * a, t;
      }, transformMat4$22 = function(t, a, r) {
        var n = a[0], e = a[1], a = a[2], o = r[3] * n + r[7] * e + r[11] * a + r[15];
        return t[0] = (r[0] * n + r[4] * e + r[8] * a + r[12]) / (o = o || 1), t[1] = (r[1] * n + r[5] * e + r[9] * a + r[13]) / o, t[2] = (r[2] * n + r[6] * e + r[10] * a + r[14]) / o, t;
      }, transformMat3$12 = function(t, a, r) {
        var n = a[0], e = a[1], a = a[2];
        return t[0] = n * r[0] + e * r[3] + a * r[6], t[1] = n * r[1] + e * r[4] + a * r[7], t[2] = n * r[2] + e * r[5] + a * r[8], t;
      }, transformQuat$12 = function(t, a, r) {
        var n = r[0], e = r[1], o = r[2], u = a[0], s = a[1], a = a[2], i = e * a - o * s, c = o * u - n * a, l = n * s - e * u, $ = e * l - o * c, o = o * i - n * l, n = n * c - e * i, e = 2 * r[3];
        return c *= e, l *= e, o *= 2, n *= 2, t[0] = u + (i *= e) + ($ *= 2), t[1] = s + c + o, t[2] = a + l + n, t;
      }, rotateX$22 = function(t, a, r, n) {
        var e = [], o = [];
        return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0], o[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
      }, rotateY$22 = function(t, a, r, n) {
        var e = [], o = [];
        return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o[1] = e[1], o[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
      }, rotateZ$22 = function(t, a, r, n) {
        var e = [], o = [];
        return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o[2] = e[2], t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;
      }, angle$12 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2], r = Math.sqrt((r * r + n * n + e * e) * (o * o + u * u + s * s)), n = r && dot$42(t, a) / r;
        return Math.acos(Math.min(Math.max(n, -1), 1));
      }, zero$22 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t;
      }, str$42 = function(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
      }, exactEquals$42 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2];
      }, equals$42 = function(t, a) {
        var r = t[0], n = t[1], t = t[2], e = a[0], o = a[1], a = a[2];
        return Math.abs(r - e) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) && Math.abs(n - o) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$32 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
      }, clone$32 = function(t) {
        var a = new ARRAY_TYPE(4);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;
      }, fromValues$32 = function(t, a, r, n) {
        var e = new ARRAY_TYPE(4);
        return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;
      }, copy$32 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;
      }, set$32 = function(t, a, r, n, e) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;
      }, add$32 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;
      }, subtract$12 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;
      }, multiply$32 = function(t, a, r) {
        return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t[3] = a[3] * r[3], t;
      }, divide$12 = function(t, a, r) {
        return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t[3] = a[3] / r[3], t;
      }, ceil$12 = function(t, a) {
        return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t[3] = Math.ceil(a[3]), t;
      }, floor$12 = function(t, a) {
        return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t[3] = Math.floor(a[3]), t;
      }, min$12 = function(t, a, r) {
        return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t[3] = Math.min(a[3], r[3]), t;
      }, max$12 = function(t, a, r) {
        return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t[3] = Math.max(a[3], r[3]), t;
      }, round$12 = function(t, a) {
        return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t[3] = Math.round(a[3]), t;
      }, scale$32 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;
      }, scaleAndAdd$12 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;
      }, distance$12 = function(t, a) {
        var r = a[0] - t[0];
        return Math.hypot(r, a[1] - t[1], a[2] - t[2], a[3] - t[3]);
      }, squaredDistance$12 = function(t, a) {
        var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], a = a[3] - t[3];
        return r * r + n * n + e * e + a * a;
      }, length$32 = function(t) {
        var a = t[0];
        return Math.hypot(a, t[1], t[2], t[3]);
      }, squaredLength$32 = function(t) {
        var a = t[0], r = t[1], n = t[2], t = t[3];
        return a * a + r * r + n * n + t * t;
      }, negate$12 = function(t, a) {
        return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = -a[3], t;
      }, inverse$12 = function(t, a) {
        return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t[3] = 1 / a[3], t;
      }, normalize$32 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = r * r + n * n + e * e + a * a;
        return 0 < o && (o = 1 / Math.sqrt(o)), t[0] = r * o, t[1] = n * o, t[2] = e * o, t[3] = a * o, t;
      }, dot$32 = function(t, a) {
        return t[0] * a[0] + t[1] * a[1] + t[2] * a[2] + t[3] * a[3];
      }, cross$12 = function(t, a, r, n) {
        var e = r[0] * n[1] - r[1] * n[0], o = r[0] * n[2] - r[2] * n[0], u = r[0] * n[3] - r[3] * n[0], s = r[1] * n[2] - r[2] * n[1], i = r[1] * n[3] - r[3] * n[1], r = r[2] * n[3] - r[3] * n[2], n = a[0], c = a[1], l = a[2], a = a[3];
        return t[0] = c * r - l * i + a * s, t[1] = -n * r + l * u - a * o, t[2] = n * i - c * u + a * e, t[3] = -n * s + c * o - l * e, t;
      }, lerp$32 = function(t, a, r, n) {
        var e = a[0], o = a[1], u = a[2], a = a[3];
        return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t[3] = a + n * (r[3] - a), t;
      }, random$22 = function(t, a) {
        var r, n, e, o, u, s;
        for (a = a || 1; 1 <= (u = (r = 2 * RANDOM() - 1) * r + (n = 2 * RANDOM() - 1) * n); ) ;
        for (; 1 <= (s = (e = 2 * RANDOM() - 1) * e + (o = 2 * RANDOM() - 1) * o); ) ;
        var i = Math.sqrt((1 - u) / s);
        return t[0] = a * r, t[1] = a * n, t[2] = a * e * i, t[3] = a * o * i, t;
      }, transformMat4$12 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3];
        return t[0] = r[0] * n + r[4] * e + r[8] * o + r[12] * a, t[1] = r[1] * n + r[5] * e + r[9] * o + r[13] * a, t[2] = r[2] * n + r[6] * e + r[10] * o + r[14] * a, t[3] = r[3] * n + r[7] * e + r[11] * o + r[15] * a, t;
      }, transformQuat2 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2], r = r[3], c = r * n + s * o - i * e, l = r * e + i * n - u * o, $ = r * o + u * e - s * n, n = -u * n - s * e - i * o;
        return t[0] = c * r + n * -u + l * -i - $ * -s, t[1] = l * r + n * -s + $ * -u - c * -i, t[2] = $ * r + n * -i + c * -s - l * -u, t[3] = a[3], t;
      }, zero$12 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
      }, str$32 = function(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, exactEquals$32 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];
      }, equals$32 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], t = t[3], o = a[0], u = a[1], s = a[2], a = a[3];
        return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create$22 = function() {
        var t = new ARRAY_TYPE(4);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
      }, identity$12 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
      }, setAxisAngle2 = function(t, a, r) {
        r *= 0.5;
        var n = Math.sin(r);
        return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = Math.cos(r), t;
      }, getAxisAngle2 = function(t, a) {
        var r = 2 * Math.acos(a[3]), n = Math.sin(r / 2);
        return EPSILON < n ? (t[0] = a[0] / n, t[1] = a[1] / n, t[2] = a[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r;
      }, getAngle2 = function(t, a) {
        t = dot$2(t, a);
        return Math.acos(2 * t * t - 1);
      }, multiply$22 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], r = r[3];
        return t[0] = n * r + a * u + e * i - o * s, t[1] = e * r + a * s + o * u - n * i, t[2] = o * r + a * i + n * s - e * u, t[3] = a * r - n * u - e * s - o * i, t;
      }, rotateX$12 = function(t, a, r) {
        r *= 0.5;
        var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);
        return t[0] = n * r + a * u, t[1] = e * r + o * u, t[2] = o * r - e * u, t[3] = a * r - n * u, t;
      }, rotateY$12 = function(t, a, r) {
        r *= 0.5;
        var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);
        return t[0] = n * r - o * u, t[1] = e * r + a * u, t[2] = o * r + n * u, t[3] = a * r - e * u, t;
      }, rotateZ$12 = function(t, a, r) {
        r *= 0.5;
        var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);
        return t[0] = n * r + e * u, t[1] = e * r - n * u, t[2] = o * r + a * u, t[3] = a * r - o * u, t;
      }, calculateW2 = function(t, a) {
        var r = a[0], n = a[1], a = a[2];
        return t[0] = r, t[1] = n, t[2] = a, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - a * a)), t;
      }, exp2 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = Math.sqrt(r * r + n * n + e * e), a = Math.exp(a), u = 0 < o ? a * Math.sin(o) / o : 0;
        return t[0] = r * u, t[1] = n * u, t[2] = e * u, t[3] = a * Math.cos(o), t;
      }, ln2 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = Math.sqrt(r * r + n * n + e * e), o = 0 < o ? Math.atan2(o, a) / o : 0;
        return t[0] = r * o, t[1] = n * o, t[2] = e * o, t[3] = 0.5 * Math.log(r * r + n * n + e * e + a * a), t;
      }, pow2 = function(t, a, r) {
        return ln2(t, a), scale$2(t, t, r), exp2(t, t), t;
      }, slerp2 = function(t, a, r, n) {
        var e, o, u = a[0], s = a[1], i = a[2], a = a[3], c = r[0], l = r[1], $ = r[2], r = r[3], h = u * c + s * l + i * $ + a * r;
        return h < 0 && (h = -h, c = -c, l = -l, $ = -$, r = -r), h = EPSILON < 1 - h ? (h = Math.acos(h), e = Math.sin(h), o = Math.sin((1 - n) * h) / e, Math.sin(n * h) / e) : (o = 1 - n, n), t[0] = o * u + h * c, t[1] = o * s + h * l, t[2] = o * i + h * $, t[3] = o * a + h * r, t;
      }, random$12 = function(t) {
        var a = RANDOM(), r = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a), a = Math.sqrt(a);
        return t[0] = e * Math.sin(2 * Math.PI * r), t[1] = e * Math.cos(2 * Math.PI * r), t[2] = a * Math.sin(2 * Math.PI * n), t[3] = a * Math.cos(2 * Math.PI * n), t;
      }, invert$12 = function(t, a) {
        var r = a[0], n = a[1], e = a[2], a = a[3], o = r * r + n * n + e * e + a * a, o = o ? 1 / o : 0;
        return t[0] = -r * o, t[1] = -n * o, t[2] = -e * o, t[3] = a * o, t;
      }, conjugate$12 = function(t, a) {
        return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t;
      }, fromMat32 = function(t, a) {
        var r, n, e, o = a[0] + a[4] + a[8];
        return 0 < o ? (e = Math.sqrt(o + 1), t[3] = 0.5 * e, t[0] = (a[5] - a[7]) * (e = 0.5 / e), t[1] = (a[6] - a[2]) * e, t[2] = (a[1] - a[3]) * e) : (r = ((o = a[3 * (o = a[4] > a[o = 0] ? 1 : o) + o] < a[8] ? 2 : o) + 1) % 3, n = (o + 2) % 3, e = Math.sqrt(a[3 * o + o] - a[3 * r + r] - a[3 * n + n] + 1), t[o] = 0.5 * e, t[3] = (a[3 * r + n] - a[3 * n + r]) * (e = 0.5 / e), t[r] = (a[3 * r + o] + a[3 * o + r]) * e, t[n] = (a[3 * n + o] + a[3 * o + n]) * e), t;
      }, fromEuler2 = function(t, a, r, n) {
        var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o = Math.PI / 360, u = (n *= o, r *= o, Math.sin(a *= o)), s = Math.cos(a), i = Math.sin(r), c = Math.cos(r), l = Math.sin(n), $ = Math.cos(n);
        switch (e) {
          case "xyz":
            t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;
            break;
          case "xzy":
            t[0] = u * c * $ - s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ + u * i * l;
            break;
          case "yxz":
            t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;
            break;
          case "yzx":
            t[0] = u * c * $ + s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ - u * i * l;
            break;
          case "zxy":
            t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;
            break;
          case "zyx":
            t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;
            break;
          default:
            throw new Error("Unknown angle order " + e);
        }
        return t;
      }, str$22 = function(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
      }, equals$22 = function(t, a) {
        return Math.abs(dot$32(t, a)) >= 1 - EPSILON;
      }, create$12 = function() {
        var t = new ARRAY_TYPE(8);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;
      }, clone$12 = function(t) {
        var a = new ARRAY_TYPE(8);
        return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a;
      }, fromValues$12 = function(t, a, r, n, e, o, u, s) {
        var i = new ARRAY_TYPE(8);
        return i[0] = t, i[1] = a, i[2] = r, i[3] = n, i[4] = e, i[5] = o, i[6] = u, i[7] = s, i;
      }, fromRotationTranslationValues2 = function(t, a, r, n, e, o, u) {
        var s = new ARRAY_TYPE(8), e = (s[0] = t, s[1] = a, s[2] = r, s[3] = n, 0.5 * e), o = 0.5 * o, u = 0.5 * u;
        return s[4] = e * n + o * r - u * a, s[5] = o * n + u * t - e * r, s[6] = u * n + e * a - o * t, s[7] = -e * t - o * a - u * r, s;
      }, fromRotationTranslation2 = function(t, a, r) {
        var n = 0.5 * r[0], e = 0.5 * r[1], r = 0.5 * r[2], o = a[0], u = a[1], s = a[2], a = a[3];
        return t[0] = o, t[1] = u, t[2] = s, t[3] = a, t[4] = n * a + e * s - r * u, t[5] = e * a + r * o - n * s, t[6] = r * a + n * u - e * o, t[7] = -n * o - e * u - r * s, t;
      }, fromTranslation2 = function(t, a) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0.5 * a[0], t[5] = 0.5 * a[1], t[6] = 0.5 * a[2], t[7] = 0, t;
      }, fromRotation2 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
      }, fromMat42 = function(t, a) {
        var r = create$22(), n = (getRotation2(r, a), new ARRAY_TYPE(3));
        return getTranslation$12(n, a), fromRotationTranslation2(t, r, n), t;
      }, copy$12 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t;
      }, identity2 = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
      }, set$12 = function(t, a, r, n, e, o, u, s, i) {
        return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t;
      }, getDual2 = function(t, a) {
        return t[0] = a[4], t[1] = a[5], t[2] = a[6], t[3] = a[7], t;
      }, setDual2 = function(t, a) {
        return t[4] = a[0], t[5] = a[1], t[6] = a[2], t[7] = a[3], t;
      }, getTranslation2 = function(t, a) {
        var r = a[4], n = a[5], e = a[6], o = a[7], u = -a[0], s = -a[1], i = -a[2], a = a[3];
        return t[0] = 2 * (r * a + o * u + n * i - e * s), t[1] = 2 * (n * a + o * s + e * u - r * i), t[2] = 2 * (e * a + o * i + r * s - n * u), t;
      }, translate2 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = 0.5 * r[0], i = 0.5 * r[1], r = 0.5 * r[2], c = a[4], l = a[5], $ = a[6], a = a[7];
        return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = u * s + e * r - o * i + c, t[5] = u * i + o * s - n * r + l, t[6] = u * r + n * i - e * s + $, t[7] = -n * s - e * i - o * r + a, t;
      }, rotateX2 = function(t, a, r) {
        var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;
        return rotateX$12(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;
      }, rotateY2 = function(t, a, r) {
        var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;
        return rotateY$12(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;
      }, rotateZ2 = function(t, a, r) {
        var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;
        return rotateZ$12(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;
      }, rotateByQuatAppend2 = function(t, a, r) {
        var n = r[0], e = r[1], o = r[2], r = r[3], u = a[0], s = a[1], i = a[2], c = a[3];
        return t[0] = u * r + c * n + s * o - i * e, t[1] = s * r + c * e + i * n - u * o, t[2] = i * r + c * o + u * e - s * n, t[3] = c * r - u * n - s * e - i * o, t[4] = (u = a[4]) * r + (c = a[7]) * n + (s = a[5]) * o - (i = a[6]) * e, t[5] = s * r + c * e + i * n - u * o, t[6] = i * r + c * o + u * e - s * n, t[7] = c * r - u * n - s * e - i * o, t;
      }, rotateByQuatPrepend2 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], c = r[3];
        return t[0] = n * c + a * u + e * i - o * s, t[1] = e * c + a * s + o * u - n * i, t[2] = o * c + a * i + n * s - e * u, t[3] = a * c - n * u - e * s - o * i, t[4] = n * (c = r[7]) + a * (u = r[4]) + e * (i = r[6]) - o * (s = r[5]), t[5] = e * c + a * s + o * u - n * i, t[6] = o * c + a * i + n * s - e * u, t[7] = a * c - n * u - e * s - o * i, t;
      }, rotateAroundAxis2 = function(t, a, r, n) {
        var e, o, u, s, i, c;
        return Math.abs(n) < EPSILON ? copy$12(t, a) : (c = Math.hypot(r[0], r[1], r[2]), n *= 0.5, e = (u = Math.sin(n)) * r[0] / c, o = u * r[1] / c, u = u * r[2] / c, r = Math.cos(n), c = a[0], t[0] = c * r + (n = a[3]) * e + (s = a[1]) * u - (i = a[2]) * o, t[1] = s * r + n * o + i * e - c * u, t[2] = i * r + n * u + c * o - s * e, t[3] = n * r - c * e - s * o - i * u, t[4] = (n = a[4]) * r + (c = a[7]) * e + (s = a[5]) * u - (i = a[6]) * o, t[5] = s * r + c * o + i * e - n * u, t[6] = i * r + c * u + n * o - s * e, t[7] = c * r - n * e - s * o - i * u, t);
      }, add$12 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t;
      }, multiply$12 = function(t, a, r) {
        var n = a[0], e = a[1], o = a[2], u = a[3], s = r[4], i = r[5], c = r[6], l = r[7], $ = a[4], h = a[5], f = a[6], a = a[7], M = r[0], m = r[1], d = r[2], r = r[3];
        return t[0] = n * r + u * M + e * d - o * m, t[1] = e * r + u * m + o * M - n * d, t[2] = o * r + u * d + n * m - e * M, t[3] = u * r - n * M - e * m - o * d, t[4] = n * l + u * s + e * c - o * i + $ * r + a * M + h * d - f * m, t[5] = e * l + u * i + o * s - n * c + h * r + a * m + f * M - $ * d, t[6] = o * l + u * c + n * i - e * s + f * r + a * d + $ * m - h * M, t[7] = u * l - n * s - e * i - o * c + a * r - $ * M - h * m - f * d, t;
      }, scale$12 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t;
      }, lerp$12 = function(t, a, r, n) {
        var e = 1 - n;
        return dot$1(a, r) < 0 && (n = -n), t[0] = a[0] * e + r[0] * n, t[1] = a[1] * e + r[1] * n, t[2] = a[2] * e + r[2] * n, t[3] = a[3] * e + r[3] * n, t[4] = a[4] * e + r[4] * n, t[5] = a[5] * e + r[5] * n, t[6] = a[6] * e + r[6] * n, t[7] = a[7] * e + r[7] * n, t;
      }, invert2 = function(t, a) {
        var r = squaredLength$1(a);
        return t[0] = -a[0] / r, t[1] = -a[1] / r, t[2] = -a[2] / r, t[3] = a[3] / r, t[4] = -a[4] / r, t[5] = -a[5] / r, t[6] = -a[6] / r, t[7] = a[7] / r, t;
      }, conjugate2 = function(t, a) {
        return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t[4] = -a[4], t[5] = -a[5], t[6] = -a[6], t[7] = a[7], t;
      }, normalize$12 = function(t, a) {
        var r, n, e, o, u, s, i, c, l = squaredLength$1(a);
        return 0 < l && (l = Math.sqrt(l), c = (r = a[0] / l) * (u = a[4]) + (n = a[1] / l) * (s = a[5]) + (e = a[2] / l) * (i = a[6]) + (o = a[3] / l) * (a = a[7]), t[0] = r, t[1] = n, t[2] = e, t[3] = o, t[4] = (u - r * c) / l, t[5] = (s - n * c) / l, t[6] = (i - e * c) / l, t[7] = (a - o * c) / l), t;
      }, str$12 = function(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
      }, exactEquals$12 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7];
      }, equals$12 = function(t, a) {
        var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], t = t[7], c = a[0], l = a[1], $ = a[2], h = a[3], f = a[4], M = a[5], m = a[6], a = a[7];
        return Math.abs(r - c) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - l) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(e - $) <= EPSILON * Math.max(1, Math.abs(e), Math.abs($)) && Math.abs(o - h) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(u - f) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(f)) && Math.abs(s - M) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(M)) && Math.abs(i - m) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(m)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      }, create2 = function() {
        var t = new ARRAY_TYPE(2);
        return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
      }, clone2 = function(t) {
        var a = new ARRAY_TYPE(2);
        return a[0] = t[0], a[1] = t[1], a;
      }, fromValues2 = function(t, a) {
        var r = new ARRAY_TYPE(2);
        return r[0] = t, r[1] = a, r;
      }, copy2 = function(t, a) {
        return t[0] = a[0], t[1] = a[1], t;
      }, set2 = function(t, a, r) {
        return t[0] = a, t[1] = r, t;
      }, add2 = function(t, a, r) {
        return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t;
      }, subtract2 = function(t, a, r) {
        return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t;
      }, multiply2 = function(t, a, r) {
        return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t;
      }, divide2 = function(t, a, r) {
        return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t;
      }, ceil2 = function(t, a) {
        return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t;
      }, floor2 = function(t, a) {
        return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t;
      }, min2 = function(t, a, r) {
        return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t;
      }, max2 = function(t, a, r) {
        return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t;
      }, round2 = function(t, a) {
        return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t;
      }, scale2 = function(t, a, r) {
        return t[0] = a[0] * r, t[1] = a[1] * r, t;
      }, scaleAndAdd2 = function(t, a, r, n) {
        return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t;
      }, distance2 = function(t, a) {
        var r = a[0] - t[0];
        return Math.hypot(r, a[1] - t[1]);
      }, squaredDistance2 = function(t, a) {
        var r = a[0] - t[0], a = a[1] - t[1];
        return r * r + a * a;
      }, length2 = function(t) {
        var a = t[0];
        return Math.hypot(a, t[1]);
      }, squaredLength2 = function(t) {
        var a = t[0], t = t[1];
        return a * a + t * t;
      }, negate2 = function(t, a) {
        return t[0] = -a[0], t[1] = -a[1], t;
      }, inverse2 = function(t, a) {
        return t[0] = 1 / a[0], t[1] = 1 / a[1], t;
      }, normalize2 = function(t, a) {
        var r = a[0], n = a[1], r = r * r + n * n;
        return 0 < r && (r = 1 / Math.sqrt(r)), t[0] = a[0] * r, t[1] = a[1] * r, t;
      }, dot2 = function(t, a) {
        return t[0] * a[0] + t[1] * a[1];
      }, cross2 = function(t, a, r) {
        a = a[0] * r[1] - a[1] * r[0];
        return t[0] = t[1] = 0, t[2] = a, t;
      }, lerp2 = function(t, a, r, n) {
        var e = a[0], a = a[1];
        return t[0] = e + n * (r[0] - e), t[1] = a + n * (r[1] - a), t;
      }, random2 = function(t, a) {
        a = a || 1;
        var r = 2 * RANDOM() * Math.PI;
        return t[0] = Math.cos(r) * a, t[1] = Math.sin(r) * a, t;
      }, transformMat22 = function(t, a, r) {
        var n = a[0], a = a[1];
        return t[0] = r[0] * n + r[2] * a, t[1] = r[1] * n + r[3] * a, t;
      }, transformMat2d2 = function(t, a, r) {
        var n = a[0], a = a[1];
        return t[0] = r[0] * n + r[2] * a + r[4], t[1] = r[1] * n + r[3] * a + r[5], t;
      }, transformMat32 = function(t, a, r) {
        var n = a[0], a = a[1];
        return t[0] = r[0] * n + r[3] * a + r[6], t[1] = r[1] * n + r[4] * a + r[7], t;
      }, transformMat42 = function(t, a, r) {
        var n = a[0], a = a[1];
        return t[0] = r[0] * n + r[4] * a + r[12], t[1] = r[1] * n + r[5] * a + r[13], t;
      }, rotate2 = function(t, a, r, n) {
        var e = a[0] - r[0], a = a[1] - r[1], o = Math.sin(n), n = Math.cos(n);
        return t[0] = e * n - a * o + r[0], t[1] = e * o + a * n + r[1], t;
      }, angle2 = function(t, a) {
        var r = t[0], t = t[1], n = a[0], a = a[1], e = Math.sqrt((r * r + t * t) * (n * n + a * a));
        return Math.acos(Math.min(Math.max(e && (r * n + t * a) / e, -1), 1));
      }, zero2 = function(t) {
        return t[0] = 0, t[1] = 0, t;
      }, str2 = function(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")";
      }, exactEquals2 = function(t, a) {
        return t[0] === a[0] && t[1] === a[1];
      }, equals2 = function(t, a) {
        var r = t[0], t = t[1], n = a[0], a = a[1];
        return Math.abs(r - n) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));
      };
      setMatrixArrayType = setMatrixArrayType2, toRadian = toRadian2, equals$9 = equals$92, create$8 = create$82, clone$8 = clone$82, copy$8 = copy$82, identity$5 = identity$52, fromValues$8 = fromValues$82, set$8 = set$82, transpose$2 = transpose$22, invert$5 = invert$52, adjoint$2 = adjoint$22, determinant$3 = determinant$32, multiply$8 = multiply$82, rotate$4 = rotate$42, scale$8 = scale$82, fromRotation$4 = fromRotation$42, fromScaling$3 = fromScaling$32, str$8 = str$82, frob$3 = frob$32, LDU = LDU2, add$8 = add$82, subtract$6 = subtract$62, exactEquals$8 = exactEquals$82, equals$8 = equals$82, multiplyScalar$3 = multiplyScalar$32, multiplyScalarAndAdd$3 = multiplyScalarAndAdd$32, create$7 = create$72, clone$7 = clone$72, copy$7 = copy$72, identity$4 = identity$42, fromValues$7 = fromValues$72, set$7 = set$72, invert$4 = invert$42, determinant$2 = determinant$22, multiply$7 = multiply$72, rotate$3 = rotate$32, scale$7 = scale$72, translate$3 = translate$32, fromRotation$3 = fromRotation$32, fromScaling$2 = fromScaling$22, fromTranslation$3 = fromTranslation$32, str$7 = str$72, frob$2 = frob$22, add$7 = add$72, subtract$5 = subtract$52, multiplyScalar$2 = multiplyScalar$22, multiplyScalarAndAdd$2 = multiplyScalarAndAdd$22, exactEquals$7 = exactEquals$72, equals$7 = equals$72, create$6 = create$62, fromMat4$1 = fromMat4$12, clone$6 = clone$62, copy$6 = copy$62, fromValues$6 = fromValues$62, set$6 = set$62, identity$3 = identity$32, transpose$1 = transpose$12, invert$3 = invert$32, adjoint$1 = adjoint$12, determinant$1 = determinant$12, multiply$6 = multiply$62, translate$2 = translate$22, rotate$2 = rotate$22, scale$6 = scale$62, fromTranslation$2 = fromTranslation$22, fromRotation$2 = fromRotation$22, fromScaling$1 = fromScaling$12, fromMat2d = fromMat2d2, fromQuat$1 = fromQuat$12, normalFromMat4 = normalFromMat42, projection = projection2, str$6 = str$62, frob$1 = frob$12, add$6 = add$62, subtract$4 = subtract$42, multiplyScalar$1 = multiplyScalar$12, multiplyScalarAndAdd$1 = multiplyScalarAndAdd$12, exactEquals$6 = exactEquals$62, equals$6 = equals$62, create$5 = create$52, clone$5 = clone$52, copy$5 = copy$52, fromValues$5 = fromValues$52, set$5 = set$52, identity$2 = identity$22, transpose = transpose2, invert$2 = invert$22, adjoint = adjoint2, determinant = determinant2, multiply$5 = multiply$52, translate$1 = translate$12, scale$5 = scale$52, rotate$1 = rotate$12, rotateX$3 = rotateX$32, rotateY$3 = rotateY$32, rotateZ$3 = rotateZ$32, fromTranslation$1 = fromTranslation$12, fromScaling = fromScaling2, fromRotation$1 = fromRotation$12, fromXRotation = fromXRotation2, fromYRotation = fromYRotation2, fromZRotation = fromZRotation2, fromRotationTranslation$1 = fromRotationTranslation$12, fromQuat2 = fromQuat22, getTranslation$1 = getTranslation$12, getScaling = getScaling2, getRotation = getRotation2, decompose = decompose2, fromRotationTranslationScale = fromRotationTranslationScale2, fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin2, fromQuat = fromQuat3, frustum = frustum2, perspectiveNO = perspectiveNO2, perspectiveZO = perspectiveZO2, perspectiveFromFieldOfView = perspectiveFromFieldOfView2, orthoNO = orthoNO2, orthoZO = orthoZO2, lookAt = lookAt2, targetTo = targetTo2, str$5 = str$52, frob = frob2, add$5 = add$52, subtract$3 = subtract$32, multiplyScalar = multiplyScalar2, multiplyScalarAndAdd = multiplyScalarAndAdd2, exactEquals$5 = exactEquals$52, equals$5 = equals$52, create$4 = create$42, clone$4 = clone$42, length$4 = length$42, fromValues$4 = fromValues$42, copy$4 = copy$42, set$4 = set$42, add$4 = add$42, subtract$2 = subtract$22, multiply$4 = multiply$42, divide$2 = divide$22, ceil$2 = ceil$22, floor$2 = floor$22, min$2 = min$22, max$2 = max$22, round$2 = round$22, scale$4 = scale$42, scaleAndAdd$2 = scaleAndAdd$22, distance$2 = distance$22, squaredDistance$2 = squaredDistance$22, squaredLength$4 = squaredLength$42, negate$2 = negate$22, inverse$2 = inverse$22, normalize$4 = normalize$42, dot$4 = dot$42, cross$2 = cross$22, lerp$4 = lerp$42, slerp$1 = slerp$12, hermite = hermite2, bezier = bezier2, random$3 = random$32, transformMat4$2 = transformMat4$22, transformMat3$1 = transformMat3$12, transformQuat$1 = transformQuat$12, rotateX$2 = rotateX$22, rotateY$2 = rotateY$22, rotateZ$2 = rotateZ$22, angle$1 = angle$12, zero$2 = zero$22, str$4 = str$42, exactEquals$4 = exactEquals$42, equals$4 = equals$42, create$3 = create$32, clone$3 = clone$32, fromValues$3 = fromValues$32, copy$3 = copy$32, set$3 = set$32, add$3 = add$32, subtract$1 = subtract$12, multiply$3 = multiply$32, divide$1 = divide$12, ceil$1 = ceil$12, floor$1 = floor$12, min$1 = min$12, max$1 = max$12, round$1 = round$12, scale$3 = scale$32, scaleAndAdd$1 = scaleAndAdd$12, distance$1 = distance$12, squaredDistance$1 = squaredDistance$12, length$3 = length$32, squaredLength$3 = squaredLength$32, negate$1 = negate$12, inverse$1 = inverse$12, normalize$3 = normalize$32, dot$3 = dot$32, cross$1 = cross$12, lerp$3 = lerp$32, random$2 = random$22, transformMat4$1 = transformMat4$12, transformQuat = transformQuat2, zero$1 = zero$12, str$3 = str$32, exactEquals$3 = exactEquals$32, equals$3 = equals$32, create$2 = create$22, identity$1 = identity$12, setAxisAngle = setAxisAngle2, getAxisAngle = getAxisAngle2, getAngle = getAngle2, multiply$2 = multiply$22, rotateX$1 = rotateX$12, rotateY$1 = rotateY$12, rotateZ$1 = rotateZ$12, calculateW = calculateW2, exp = exp2, ln = ln2, pow = pow2, slerp = slerp2, random$1 = random$12, invert$1 = invert$12, conjugate$1 = conjugate$12, fromMat3 = fromMat32, fromEuler = fromEuler2, str$2 = str$22, equals$2 = equals$22, create$1 = create$12, clone$1 = clone$12, fromValues$1 = fromValues$12, fromRotationTranslationValues = fromRotationTranslationValues2, fromRotationTranslation = fromRotationTranslation2, fromTranslation = fromTranslation2, fromRotation = fromRotation2, fromMat4 = fromMat42, copy$1 = copy$12, identity = identity2, set$1 = set$12, getDual = getDual2, setDual = setDual2, getTranslation = getTranslation2, translate = translate2, rotateX = rotateX2, rotateY = rotateY2, rotateZ = rotateZ2, rotateByQuatAppend = rotateByQuatAppend2, rotateByQuatPrepend = rotateByQuatPrepend2, rotateAroundAxis = rotateAroundAxis2, add$1 = add$12, multiply$1 = multiply$12, scale$1 = scale$12, lerp$1 = lerp$12, invert = invert2, conjugate = conjugate2, normalize$1 = normalize$12, str$1 = str$12, exactEquals$1 = exactEquals$12, equals$1 = equals$12, create = create2, clone = clone2, fromValues = fromValues2, copy = copy2, set = set2, add = add2, subtract = subtract2, multiply = multiply2, divide = divide2, ceil = ceil2, floor = floor2, min = min2, max = max2, round = round2, scale = scale2, scaleAndAdd = scaleAndAdd2, distance = distance2, squaredDistance = squaredDistance2, length = length2, squaredLength = squaredLength2, negate = negate2, inverse = inverse2, normalize = normalize2, dot = dot2, cross = cross2, lerp = lerp2, random = random2, transformMat2 = transformMat22, transformMat2d = transformMat2d2, transformMat3 = transformMat32, transformMat4 = transformMat42, rotate = rotate2, angle = angle2, zero = zero2, str = str2, exactEquals = exactEquals2, equals = equals2;
      EPSILON = 1e-6, ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = "zyx";
      degree = Math.PI / 180;
      Math.hypot || (Math.hypot = function() {
        for (var t = 0, a = arguments.length; a--; ) t += arguments[a] * arguments[a];
        return Math.sqrt(t);
      });
      common = { __proto__: null, EPSILON, get ARRAY_TYPE() {
        return ARRAY_TYPE;
      }, RANDOM, ANGLE_ORDER, setMatrixArrayType: setMatrixArrayType2, toRadian: toRadian2, equals: equals$92 };
      mul$8 = multiply$82, sub$6 = subtract$62, mat2 = Object.freeze({ __proto__: null, create: create$82, clone: clone$82, copy: copy$82, identity: identity$52, fromValues: fromValues$82, set: set$82, transpose: transpose$22, invert: invert$52, adjoint: adjoint$22, determinant: determinant$32, multiply: multiply$82, rotate: rotate$42, scale: scale$82, fromRotation: fromRotation$42, fromScaling: fromScaling$32, str: str$82, frob: frob$32, LDU: LDU2, add: add$82, subtract: subtract$62, exactEquals: exactEquals$82, equals: equals$82, multiplyScalar: multiplyScalar$32, multiplyScalarAndAdd: multiplyScalarAndAdd$32, mul: mul$8, sub: sub$6 });
      mul$7 = multiply$72, sub$5 = subtract$52, mat2d = Object.freeze({ __proto__: null, create: create$72, clone: clone$72, copy: copy$72, identity: identity$42, fromValues: fromValues$72, set: set$72, invert: invert$42, determinant: determinant$22, multiply: multiply$72, rotate: rotate$32, scale: scale$72, translate: translate$32, fromRotation: fromRotation$32, fromScaling: fromScaling$22, fromTranslation: fromTranslation$32, str: str$72, frob: frob$22, add: add$72, subtract: subtract$52, multiplyScalar: multiplyScalar$22, multiplyScalarAndAdd: multiplyScalarAndAdd$22, exactEquals: exactEquals$72, equals: equals$72, mul: mul$7, sub: sub$5 });
      mul$6 = multiply$62, sub$4 = subtract$42, mat3 = Object.freeze({ __proto__: null, create: create$62, fromMat4: fromMat4$12, clone: clone$62, copy: copy$62, fromValues: fromValues$62, set: set$62, identity: identity$32, transpose: transpose$12, invert: invert$32, adjoint: adjoint$12, determinant: determinant$12, multiply: multiply$62, translate: translate$22, rotate: rotate$22, scale: scale$62, fromTranslation: fromTranslation$22, fromRotation: fromRotation$22, fromScaling: fromScaling$12, fromMat2d: fromMat2d2, fromQuat: fromQuat$12, normalFromMat4: normalFromMat42, projection: projection2, str: str$62, frob: frob$12, add: add$62, subtract: subtract$42, multiplyScalar: multiplyScalar$12, multiplyScalarAndAdd: multiplyScalarAndAdd$12, exactEquals: exactEquals$62, equals: equals$62, mul: mul$6, sub: sub$4 });
      perspective = perspectiveNO2;
      ortho = orthoNO2;
      mul$5 = multiply$52, sub$3 = subtract$32, mat4 = Object.freeze({ __proto__: null, create: create$52, clone: clone$52, copy: copy$52, fromValues: fromValues$52, set: set$52, identity: identity$22, transpose: transpose2, invert: invert$22, adjoint: adjoint2, determinant: determinant2, multiply: multiply$52, translate: translate$12, scale: scale$52, rotate: rotate$12, rotateX: rotateX$32, rotateY: rotateY$32, rotateZ: rotateZ$32, fromTranslation: fromTranslation$12, fromScaling: fromScaling2, fromRotation: fromRotation$12, fromXRotation: fromXRotation2, fromYRotation: fromYRotation2, fromZRotation: fromZRotation2, fromRotationTranslation: fromRotationTranslation$12, fromQuat2: fromQuat22, getTranslation: getTranslation$12, getScaling: getScaling2, getRotation: getRotation2, decompose: decompose2, fromRotationTranslationScale: fromRotationTranslationScale2, fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin2, fromQuat: fromQuat3, frustum: frustum2, perspectiveNO: perspectiveNO2, perspective, perspectiveZO: perspectiveZO2, perspectiveFromFieldOfView: perspectiveFromFieldOfView2, orthoNO: orthoNO2, ortho, orthoZO: orthoZO2, lookAt: lookAt2, targetTo: targetTo2, str: str$52, frob: frob2, add: add$52, subtract: subtract$32, multiplyScalar: multiplyScalar2, multiplyScalarAndAdd: multiplyScalarAndAdd2, exactEquals: exactEquals$52, equals: equals$52, mul: mul$5, sub: sub$3 });
      sub$2 = subtract$22, mul$4 = multiply$42, div$2 = divide$22, dist$2 = distance$22, sqrDist$2 = squaredDistance$22, len$4 = length$42, sqrLen$4 = squaredLength$42, forEach$2 = function() {
        var i = create$42();
        return function(t, a, r, n, e, o) {
          var u, s;
          for (a = a || 3, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], i[2] = t[u + 2], e(i, i, o), t[u] = i[0], t[u + 1] = i[1], t[u + 2] = i[2];
          return t;
        };
      }(), vec3 = Object.freeze({ __proto__: null, create: create$42, clone: clone$42, length: length$42, fromValues: fromValues$42, copy: copy$42, set: set$42, add: add$42, subtract: subtract$22, multiply: multiply$42, divide: divide$22, ceil: ceil$22, floor: floor$22, min: min$22, max: max$22, round: round$22, scale: scale$42, scaleAndAdd: scaleAndAdd$22, distance: distance$22, squaredDistance: squaredDistance$22, squaredLength: squaredLength$42, negate: negate$22, inverse: inverse$22, normalize: normalize$42, dot: dot$42, cross: cross$22, lerp: lerp$42, slerp: slerp$12, hermite: hermite2, bezier: bezier2, random: random$32, transformMat4: transformMat4$22, transformMat3: transformMat3$12, transformQuat: transformQuat$12, rotateX: rotateX$22, rotateY: rotateY$22, rotateZ: rotateZ$22, angle: angle$12, zero: zero$22, str: str$42, exactEquals: exactEquals$42, equals: equals$42, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });
      sub$1 = subtract$12, mul$3 = multiply$32, div$1 = divide$12, dist$1 = distance$12, sqrDist$1 = squaredDistance$12, len$3 = length$32, sqrLen$3 = squaredLength$32, forEach$1 = function() {
        var i = create$32();
        return function(t, a, r, n, e, o) {
          var u, s;
          for (a = a || 4, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], i[2] = t[u + 2], i[3] = t[u + 3], e(i, i, o), t[u] = i[0], t[u + 1] = i[1], t[u + 2] = i[2], t[u + 3] = i[3];
          return t;
        };
      }(), vec4 = Object.freeze({ __proto__: null, create: create$32, clone: clone$32, fromValues: fromValues$32, copy: copy$32, set: set$32, add: add$32, subtract: subtract$12, multiply: multiply$32, divide: divide$12, ceil: ceil$12, floor: floor$12, min: min$12, max: max$12, round: round$12, scale: scale$32, scaleAndAdd: scaleAndAdd$12, distance: distance$12, squaredDistance: squaredDistance$12, length: length$32, squaredLength: squaredLength$32, negate: negate$12, inverse: inverse$12, normalize: normalize$32, dot: dot$32, cross: cross$12, lerp: lerp$32, random: random$22, transformMat4: transformMat4$12, transformQuat: transformQuat2, zero: zero$12, str: str$32, exactEquals: exactEquals$32, equals: equals$32, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });
      clone$2 = clone$32, fromValues$2 = fromValues$32, copy$2 = copy$32, set$2 = set$32, add$2 = add$32, mul$2 = multiply$22, scale$2 = scale$32, dot$2 = dot$32, lerp$2 = lerp$32, length$2 = length$32, len$2 = length$2, squaredLength$2 = squaredLength$32, sqrLen$2 = squaredLength$2, normalize$2 = normalize$32, exactEquals$2 = exactEquals$32;
      rotationTo = function() {
        var e = create$42(), o = fromValues$42(1, 0, 0), u = fromValues$42(0, 1, 0);
        return function(t, a, r) {
          var n = dot$42(a, r);
          return n < -0.999999 ? (cross$22(e, o, a), len$4(e) < 1e-6 && cross$22(e, u, a), normalize$42(e, e), setAxisAngle2(t, e, Math.PI), t) : 0.999999 < n ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (cross$22(e, a, r), t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = 1 + n, normalize$2(t, t));
        };
      }(), sqlerp = function() {
        var u = create$22(), s = create$22();
        return function(t, a, r, n, e, o) {
          return slerp2(u, a, e, o), slerp2(s, r, n, o), slerp2(t, u, s, 2 * o * (1 - o)), t;
        };
      }(), setAxes = function() {
        var e = create$62();
        return function(t, a, r, n) {
          return e[0] = r[0], e[3] = r[1], e[6] = r[2], e[1] = n[0], e[4] = n[1], e[7] = n[2], e[2] = -a[0], e[5] = -a[1], e[8] = -a[2], normalize$2(t, fromMat32(t, e));
        };
      }(), quat = Object.freeze({ __proto__: null, create: create$22, identity: identity$12, setAxisAngle: setAxisAngle2, getAxisAngle: getAxisAngle2, getAngle: getAngle2, multiply: multiply$22, rotateX: rotateX$12, rotateY: rotateY$12, rotateZ: rotateZ$12, calculateW: calculateW2, exp: exp2, ln: ln2, pow: pow2, slerp: slerp2, random: random$12, invert: invert$12, conjugate: conjugate$12, fromMat3: fromMat32, fromEuler: fromEuler2, str: str$22, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$22, rotationTo, sqlerp, setAxes });
      getReal = copy$2;
      setReal = copy$2;
      mul$1 = multiply$12;
      dot$1 = dot$2;
      length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;
      quat2 = Object.freeze({ __proto__: null, create: create$12, clone: clone$12, fromValues: fromValues$12, fromRotationTranslationValues: fromRotationTranslationValues2, fromRotationTranslation: fromRotationTranslation2, fromTranslation: fromTranslation2, fromRotation: fromRotation2, fromMat4: fromMat42, copy: copy$12, identity: identity2, set: set$12, getReal, getDual: getDual2, setReal, setDual: setDual2, getTranslation: getTranslation2, translate: translate2, rotateX: rotateX2, rotateY: rotateY2, rotateZ: rotateZ2, rotateByQuatAppend: rotateByQuatAppend2, rotateByQuatPrepend: rotateByQuatPrepend2, rotateAroundAxis: rotateAroundAxis2, add: add$12, multiply: multiply$12, mul: mul$1, scale: scale$12, dot: dot$1, lerp: lerp$12, invert: invert2, conjugate: conjugate2, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$12, str: str$12, exactEquals: exactEquals$12, equals: equals$12 });
      len = length2, sub = subtract2, mul = multiply2, div = divide2, dist = distance2, sqrDist = squaredDistance2, sqrLen = squaredLength2, forEach = function() {
        var i = create2();
        return function(t, a, r, n, e, o) {
          var u, s;
          for (a = a || 2, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], e(i, i, o), t[u] = i[0], t[u + 1] = i[1];
          return t;
        };
      }(), vec2 = Object.freeze({ __proto__: null, create: create2, clone: clone2, fromValues: fromValues2, copy: copy2, set: set2, add: add2, subtract: subtract2, multiply: multiply2, divide: divide2, ceil: ceil2, floor: floor2, min: min2, max: max2, round: round2, scale: scale2, scaleAndAdd: scaleAndAdd2, distance: distance2, squaredDistance: squaredDistance2, length: length2, squaredLength: squaredLength2, negate: negate2, inverse: inverse2, normalize: normalize2, dot: dot2, cross: cross2, lerp: lerp2, random: random2, transformMat2: transformMat22, transformMat2d: transformMat2d2, transformMat3: transformMat32, transformMat4: transformMat42, rotate: rotate2, angle: angle2, zero: zero2, str: str2, exactEquals: exactEquals2, equals: equals2, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });
      globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;
    }
    var EPSILON;
    var ARRAY_TYPE;
    var RANDOM;
    var ANGLE_ORDER;
    var degree;
    var common;
    var mul$8;
    var sub$6;
    var mat2;
    var mul$7;
    var sub$5;
    var mat2d;
    var mul$6;
    var sub$4;
    var mat3;
    var perspective;
    var ortho;
    var mul$5;
    var sub$3;
    var mat4;
    var sub$2;
    var mul$4;
    var div$2;
    var dist$2;
    var sqrDist$2;
    var len$4;
    var sqrLen$4;
    var forEach$2;
    var vec3;
    var sub$1;
    var mul$3;
    var div$1;
    var dist$1;
    var sqrDist$1;
    var len$3;
    var sqrLen$3;
    var forEach$1;
    var vec4;
    var clone$2;
    var fromValues$2;
    var copy$2;
    var set$2;
    var add$2;
    var mul$2;
    var scale$2;
    var dot$2;
    var lerp$2;
    var length$2;
    var len$2;
    var squaredLength$2;
    var sqrLen$2;
    var normalize$2;
    var exactEquals$2;
    var rotationTo;
    var sqlerp;
    var setAxes;
    var quat;
    var getReal;
    var setReal;
    var mul$1;
    var dot$1;
    var length$1;
    var len$1;
    var squaredLength$1;
    var sqrLen$1;
    var quat2;
    var len;
    var sub;
    var mul;
    var div;
    var dist;
    var sqrDist;
    var sqrLen;
    var forEach;
    var vec2;
    var setMatrixArrayType;
    var toRadian;
    var equals$9;
    var create$8;
    var clone$8;
    var copy$8;
    var identity$5;
    var fromValues$8;
    var set$8;
    var transpose$2;
    var invert$5;
    var adjoint$2;
    var determinant$3;
    var multiply$8;
    var rotate$4;
    var scale$8;
    var fromRotation$4;
    var fromScaling$3;
    var str$8;
    var frob$3;
    var LDU;
    var add$8;
    var subtract$6;
    var exactEquals$8;
    var equals$8;
    var multiplyScalar$3;
    var multiplyScalarAndAdd$3;
    var create$7;
    var clone$7;
    var copy$7;
    var identity$4;
    var fromValues$7;
    var set$7;
    var invert$4;
    var determinant$2;
    var multiply$7;
    var rotate$3;
    var scale$7;
    var translate$3;
    var fromRotation$3;
    var fromScaling$2;
    var fromTranslation$3;
    var str$7;
    var frob$2;
    var add$7;
    var subtract$5;
    var multiplyScalar$2;
    var multiplyScalarAndAdd$2;
    var exactEquals$7;
    var equals$7;
    var create$6;
    var fromMat4$1;
    var clone$6;
    var copy$6;
    var fromValues$6;
    var set$6;
    var identity$3;
    var transpose$1;
    var invert$3;
    var adjoint$1;
    var determinant$1;
    var multiply$6;
    var translate$2;
    var rotate$2;
    var scale$6;
    var fromTranslation$2;
    var fromRotation$2;
    var fromScaling$1;
    var fromMat2d;
    var fromQuat$1;
    var normalFromMat4;
    var projection;
    var str$6;
    var frob$1;
    var add$6;
    var subtract$4;
    var multiplyScalar$1;
    var multiplyScalarAndAdd$1;
    var exactEquals$6;
    var equals$6;
    var create$5;
    var clone$5;
    var copy$5;
    var fromValues$5;
    var set$5;
    var identity$2;
    var transpose;
    var invert$2;
    var adjoint;
    var determinant;
    var multiply$5;
    var translate$1;
    var scale$5;
    var rotate$1;
    var rotateX$3;
    var rotateY$3;
    var rotateZ$3;
    var fromTranslation$1;
    var fromScaling;
    var fromRotation$1;
    var fromXRotation;
    var fromYRotation;
    var fromZRotation;
    var fromRotationTranslation$1;
    var fromQuat2;
    var getTranslation$1;
    var getScaling;
    var getRotation;
    var decompose;
    var fromRotationTranslationScale;
    var fromRotationTranslationScaleOrigin;
    var fromQuat;
    var frustum;
    var perspectiveNO;
    var perspectiveZO;
    var perspectiveFromFieldOfView;
    var orthoNO;
    var orthoZO;
    var lookAt;
    var targetTo;
    var str$5;
    var frob;
    var add$5;
    var subtract$3;
    var multiplyScalar;
    var multiplyScalarAndAdd;
    var exactEquals$5;
    var equals$5;
    var create$4;
    var clone$4;
    var length$4;
    var fromValues$4;
    var copy$4;
    var set$4;
    var add$4;
    var subtract$2;
    var multiply$4;
    var divide$2;
    var ceil$2;
    var floor$2;
    var min$2;
    var max$2;
    var round$2;
    var scale$4;
    var scaleAndAdd$2;
    var distance$2;
    var squaredDistance$2;
    var squaredLength$4;
    var negate$2;
    var inverse$2;
    var normalize$4;
    var dot$4;
    var cross$2;
    var lerp$4;
    var slerp$1;
    var hermite;
    var bezier;
    var random$3;
    var transformMat4$2;
    var transformMat3$1;
    var transformQuat$1;
    var rotateX$2;
    var rotateY$2;
    var rotateZ$2;
    var angle$1;
    var zero$2;
    var str$4;
    var exactEquals$4;
    var equals$4;
    var create$3;
    var clone$3;
    var fromValues$3;
    var copy$3;
    var set$3;
    var add$3;
    var subtract$1;
    var multiply$3;
    var divide$1;
    var ceil$1;
    var floor$1;
    var min$1;
    var max$1;
    var round$1;
    var scale$3;
    var scaleAndAdd$1;
    var distance$1;
    var squaredDistance$1;
    var length$3;
    var squaredLength$3;
    var negate$1;
    var inverse$1;
    var normalize$3;
    var dot$3;
    var cross$1;
    var lerp$3;
    var random$2;
    var transformMat4$1;
    var transformQuat;
    var zero$1;
    var str$3;
    var exactEquals$3;
    var equals$3;
    var create$2;
    var identity$1;
    var setAxisAngle;
    var getAxisAngle;
    var getAngle;
    var multiply$2;
    var rotateX$1;
    var rotateY$1;
    var rotateZ$1;
    var calculateW;
    var exp;
    var ln;
    var pow;
    var slerp;
    var random$1;
    var invert$1;
    var conjugate$1;
    var fromMat3;
    var fromEuler;
    var str$2;
    var equals$2;
    var create$1;
    var clone$1;
    var fromValues$1;
    var fromRotationTranslationValues;
    var fromRotationTranslation;
    var fromTranslation;
    var fromRotation;
    var fromMat4;
    var copy$1;
    var identity;
    var set$1;
    var getDual;
    var setDual;
    var getTranslation;
    var translate;
    var rotateX;
    var rotateY;
    var rotateZ;
    var rotateByQuatAppend;
    var rotateByQuatPrepend;
    var rotateAroundAxis;
    var add$1;
    var multiply$1;
    var scale$1;
    var lerp$1;
    var invert;
    var conjugate;
    var normalize$1;
    var str$1;
    var exactEquals$1;
    var equals$1;
    var create;
    var clone;
    var fromValues;
    var copy;
    var set;
    var add;
    var subtract;
    var multiply;
    var divide;
    var ceil;
    var floor;
    var min;
    var max;
    var round;
    var scale;
    var scaleAndAdd;
    var distance;
    var squaredDistance;
    var length;
    var squaredLength;
    var negate;
    var inverse;
    var normalize;
    var dot;
    var cross;
    var lerp;
    var random;
    var transformMat2;
    var transformMat2d;
    var transformMat3;
    var transformMat4;
    var rotate;
    var angle;
    var zero;
    var str;
    var exactEquals;
    var equals;
    {
      let lineInt2 = function(o, n, t) {
        var e = [0, 0], l = o[1][1] - o[0][1], p = o[0][0] - o[1][0], o = l * o[0][0] + p * o[0][1], g = n[1][1] - n[0][1], r = n[0][0] - n[1][0], n = g * n[0][0] + r * n[0][1], i = l * r - g * p;
        return scalar_eq2(i, 0, t = t || 0) || (e[0] = (r * o - p * n) / i, e[1] = (l * n - g * o) / i), e;
      }, lineSegmentsIntersect2 = function(o, n, t, e) {
        var l, p = n[0] - o[0], n = n[1] - o[1], g = e[0] - t[0], e = e[1] - t[1];
        return g * n - e * p != 0 && (l = (g * (o[1] - t[1]) + e * (t[0] - o[0])) / (e * p - g * n), 0 <= (o = (p * (t[1] - o[1]) + n * (o[0] - t[0])) / (g * n - e * p))) && o <= 1 && 0 <= l && l <= 1;
      }, triangleArea2 = function(o, n, t) {
        return (n[0] - o[0]) * (t[1] - o[1]) - (t[0] - o[0]) * (n[1] - o[1]);
      }, isLeft2 = function(o, n, t) {
        return 0 < triangleArea2(o, n, t);
      }, isLeftOn2 = function(o, n, t) {
        return 0 <= triangleArea2(o, n, t);
      }, isRight2 = function(o, n, t) {
        return triangleArea2(o, n, t) < 0;
      }, isRightOn2 = function(o, n, t) {
        return triangleArea2(o, n, t) <= 0;
      }, collinear2 = function(o, n, t, e) {
        var l, p, g;
        return e ? (g = tmpPoint2, (p = tmpPoint1)[0] = n[0] - o[0], p[1] = n[1] - o[1], g[0] = t[0] - n[0], g[1] = t[1] - n[1], l = p[0] * g[0] + p[1] * g[1], p = Math.sqrt(p[0] * p[0] + p[1] * p[1]), g = Math.sqrt(g[0] * g[0] + g[1] * g[1]), Math.acos(l / (p * g)) < e) : 0 === triangleArea2(o, n, t);
      }, sqdist2 = function(o, n) {
        var t = n[0] - o[0], n = n[1] - o[1];
        return t * t + n * n;
      }, polygonAt2 = function(o, n) {
        var t = o.length;
        return o[n < 0 ? n % t + t : n % t];
      }, polygonClear2 = function(o) {
        o.length = 0;
      }, polygonAppend2 = function(o, n, t, e) {
        for (var l = t; l < e; l++) o.push(n[l]);
      }, polygonMakeCCW2 = function(o) {
        for (var n = 0, t = o, e = 1; e < o.length; ++e) (t[e][1] < t[n][1] || t[e][1] === t[n][1] && t[e][0] > t[n][0]) && (n = e);
        return !isLeft2(polygonAt2(o, n - 1), polygonAt2(o, n), polygonAt2(o, n + 1)) && (polygonReverse2(o), true);
      }, polygonReverse2 = function(o) {
        for (var n = [], t = o.length, e = 0; e !== t; e++) n.push(o.pop());
        for (e = 0; e !== t; e++) o[e] = n[e];
      }, polygonIsReflex2 = function(o, n) {
        return isRight2(polygonAt2(o, n - 1), polygonAt2(o, n), polygonAt2(o, n + 1));
      }, polygonCanSee3 = function(o, n, t) {
        var e, l = tmpLine1, p = tmpLine2;
        if (isLeftOn2(polygonAt2(o, n + 1), polygonAt2(o, n), polygonAt2(o, t)) && isRightOn2(polygonAt2(o, n - 1), polygonAt2(o, n), polygonAt2(o, t))) return false;
        for (var g = sqdist2(polygonAt2(o, n), polygonAt2(o, t)), r = 0; r !== o.length; ++r) if ((r + 1) % o.length !== n && r !== n && isLeftOn2(polygonAt2(o, n), polygonAt2(o, t), polygonAt2(o, r + 1)) && isRightOn2(polygonAt2(o, n), polygonAt2(o, t), polygonAt2(o, r)) && (l[0] = polygonAt2(o, n), l[1] = polygonAt2(o, t), p[0] = polygonAt2(o, r), p[1] = polygonAt2(o, r + 1), e = lineInt2(l, p), sqdist2(polygonAt2(o, n), e) < g)) return false;
        return true;
      }, polygonCanSee22 = function(o, n, t) {
        for (var e = 0; e !== o.length; ++e) if (e !== n && e !== t && (e + 1) % o.length !== n && (e + 1) % o.length !== t && lineSegmentsIntersect2(polygonAt2(o, n), polygonAt2(o, t), polygonAt2(o, e), polygonAt2(o, e + 1))) return false;
        return true;
      }, polygonCopy2 = function(o, n, t, e) {
        var l = e || [];
        if (polygonClear2(l), n < t) for (var p = n; p <= t; p++) l.push(o[p]);
        else {
          for (p = 0; p <= t; p++) l.push(o[p]);
          for (p = n; p < o.length; p++) l.push(o[p]);
        }
        return l;
      }, polygonGetCutEdges2 = function(o) {
        for (var n = [], t = [], e = [], l = Number.MAX_VALUE, p = 0; p < o.length; ++p) if (polygonIsReflex2(o, p)) {
          for (var g = 0; g < o.length; ++g) if (polygonCanSee3(o, p, g)) {
            for (var t = polygonGetCutEdges2(polygonCopy2(o, p, g, e)), r = polygonGetCutEdges2(polygonCopy2(o, g, p, e)), i = 0; i < r.length; i++) t.push(r[i]);
            t.length < l && (l = (n = t).length, n.push([polygonAt2(o, p), polygonAt2(o, g)]));
          }
        }
        return n;
      }, polygonDecomp2 = function(o) {
        var n = polygonGetCutEdges2(o);
        return 0 < n.length ? polygonSlice2(o, n) : [o];
      }, polygonSlice2 = function(o, n) {
        if (0 === n.length) return [o];
        if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {
          for (var t = [o], e = 0; e < n.length; e++) for (var l = n[e], p = 0; p < t.length; p++) {
            var g = polygonSlice2(t[p], l);
            if (g) {
              t.splice(p, 1), t.push(g[0], g[1]);
              break;
            }
          }
          return t;
        }
        return e = o.indexOf((l = n)[0]), p = o.indexOf(l[1]), -1 !== e && -1 !== p && [polygonCopy2(o, e, p), polygonCopy2(o, p, e)];
      }, polygonIsSimple2 = function(o) {
        for (var n = o, t = 0; t < n.length - 1; t++) for (var e = 0; e < t - 1; e++) if (lineSegmentsIntersect2(n[t], n[t + 1], n[e], n[e + 1])) return false;
        for (t = 1; t < n.length - 2; t++) if (lineSegmentsIntersect2(n[0], n[n.length - 1], n[t], n[t + 1])) return false;
        return true;
      }, getIntersectionPoint2 = function(o, n, t, e, l) {
        var p = n[1] - o[1], n = o[0] - n[0], o = p * o[0] + n * o[1], g = e[1] - t[1], e = t[0] - e[0], t = g * t[0] + e * t[1], r = p * e - g * n;
        return scalar_eq2(r, 0, l = l || 0) ? [0, 0] : [(e * o - n * t) / r, (p * t - g * o) / r];
      }, polygonQuickDecomp2 = function(o, n, t, e, l, p, g) {
        p = p || 100, g = g || 0, l = l || 25, n = void 0 !== n ? n : [], t = t || [], e = e || [];
        var r = [0, 0], i = [0, 0], y = [0, 0], s = 0, A = 0, u = 0, a = 0, f = 0, c = 0, h = 0, v = [], m = [], d = o, C = o;
        if (!(C.length < 3)) if (p < ++g) console.warn("quickDecomp: max level (" + p + ") reached.");
        else {
          for (var R = 0; R < o.length; ++R) if (polygonIsReflex2(d, R)) {
            t.push(d[R]);
            for (var s = A = Number.MAX_VALUE, q = 0; q < o.length; ++q) isLeft2(polygonAt2(d, R - 1), polygonAt2(d, R), polygonAt2(d, q)) && isRightOn2(polygonAt2(d, R - 1), polygonAt2(d, R), polygonAt2(d, q - 1)) && (y = getIntersectionPoint2(polygonAt2(d, R - 1), polygonAt2(d, R), polygonAt2(d, q), polygonAt2(d, q - 1)), isRight2(polygonAt2(d, R + 1), polygonAt2(d, R), y)) && (u = sqdist2(d[R], y)) < A && (A = u, i = y, c = q), isLeft2(polygonAt2(d, R + 1), polygonAt2(d, R), polygonAt2(d, q + 1)) && isRightOn2(polygonAt2(d, R + 1), polygonAt2(d, R), polygonAt2(d, q)) && (y = getIntersectionPoint2(polygonAt2(d, R + 1), polygonAt2(d, R), polygonAt2(d, q), polygonAt2(d, q + 1)), isLeft2(polygonAt2(d, R - 1), polygonAt2(d, R), y)) && (u = sqdist2(d[R], y)) < s && (s = u, r = y, f = q);
            if (c === (f + 1) % o.length) y[0] = (i[0] + r[0]) / 2, y[1] = (i[1] + r[1]) / 2, e.push(y), R < f ? (polygonAppend2(v, d, R, f + 1), v.push(y), m.push(y), 0 !== c && polygonAppend2(m, d, c, d.length), polygonAppend2(m, d, 0, R + 1)) : (0 !== R && polygonAppend2(v, d, R, d.length), polygonAppend2(v, d, 0, f + 1), v.push(y), m.push(y), polygonAppend2(m, d, c, R + 1));
            else {
              if (f < c && (f += o.length), a = Number.MAX_VALUE, f < c) return n;
              for (q = c; q <= f; ++q) isLeftOn2(polygonAt2(d, R - 1), polygonAt2(d, R), polygonAt2(d, q)) && isRightOn2(polygonAt2(d, R + 1), polygonAt2(d, R), polygonAt2(d, q)) && (u = sqdist2(polygonAt2(d, R), polygonAt2(d, q))) < a && polygonCanSee22(d, R, q) && (a = u, h = q % o.length);
              R < h ? (polygonAppend2(v, d, R, h + 1), 0 !== h && polygonAppend2(m, d, h, C.length), polygonAppend2(m, d, 0, R + 1)) : (0 !== R && polygonAppend2(v, d, R, C.length), polygonAppend2(v, d, 0, h + 1), polygonAppend2(m, d, h, R + 1));
            }
            return v.length < m.length ? (polygonQuickDecomp2(v, n, t, e, l, p, g), polygonQuickDecomp2(m, n, t, e, l, p, g)) : (polygonQuickDecomp2(m, n, t, e, l, p, g), polygonQuickDecomp2(v, n, t, e, l, p, g)), n;
          }
          n.push(o);
        }
        return n;
      }, polygonRemoveCollinearPoints2 = function(o, n) {
        for (var t = 0, e = o.length - 1; 3 < o.length && 0 <= e; --e) collinear2(polygonAt2(o, e - 1), polygonAt2(o, e), polygonAt2(o, e + 1), n) && (o.splice(e % o.length, 1), t++);
        return t;
      }, polygonRemoveDuplicatePoints2 = function(o, n) {
        for (var t = o.length - 1; 1 <= t; --t) for (var e = o[t], l = t - 1; 0 <= l; --l) points_eq2(e, o[l], n) && o.splice(t, 1);
      }, scalar_eq2 = function(o, n, t) {
        return t = t || 0, Math.abs(o - n) <= t;
      }, points_eq2 = function(o, n, t) {
        return scalar_eq2(o[0], n[0], t) && scalar_eq2(o[1], n[1], t);
      };
      lineInt = lineInt2, lineSegmentsIntersect = lineSegmentsIntersect2, triangleArea = triangleArea2, isLeft = isLeft2, isLeftOn = isLeftOn2, isRight = isRight2, isRightOn = isRightOn2, collinear = collinear2, sqdist = sqdist2, polygonAt = polygonAt2, polygonClear = polygonClear2, polygonAppend = polygonAppend2, polygonMakeCCW = polygonMakeCCW2, polygonReverse = polygonReverse2, polygonIsReflex = polygonIsReflex2, polygonCanSee = polygonCanSee3, polygonCanSee2 = polygonCanSee22, polygonCopy = polygonCopy2, polygonGetCutEdges = polygonGetCutEdges2, polygonDecomp = polygonDecomp2, polygonSlice = polygonSlice2, polygonIsSimple = polygonIsSimple2, getIntersectionPoint = getIntersectionPoint2, polygonQuickDecomp = polygonQuickDecomp2, polygonRemoveCollinearPoints = polygonRemoveCollinearPoints2, polygonRemoveDuplicatePoints = polygonRemoveDuplicatePoints2, scalar_eq = scalar_eq2, points_eq = points_eq2;
      tmpPoint1 = [], tmpPoint2 = [];
      tmpLine1 = [], tmpLine2 = [];
      self.polyDecomp = { decomp: polygonDecomp2, quickDecomp: polygonQuickDecomp2, isSimple: polygonIsSimple2, removeCollinearPoints: polygonRemoveCollinearPoints2, removeDuplicatePoints: polygonRemoveDuplicatePoints2, makeCCW: polygonMakeCCW2 };
    }
    var tmpPoint1;
    var tmpPoint2;
    var tmpLine1;
    var tmpLine2;
    var lineInt;
    var lineSegmentsIntersect;
    var triangleArea;
    var isLeft;
    var isLeftOn;
    var isRight;
    var isRightOn;
    var collinear;
    var sqdist;
    var polygonAt;
    var polygonClear;
    var polygonAppend;
    var polygonMakeCCW;
    var polygonReverse;
    var polygonIsReflex;
    var polygonCanSee;
    var polygonCanSee2;
    var polygonCopy;
    var polygonGetCutEdges;
    var polygonDecomp;
    var polygonSlice;
    var polygonIsSimple;
    var getIntersectionPoint;
    var polygonQuickDecomp;
    var polygonRemoveCollinearPoints;
    var polygonRemoveDuplicatePoints;
    var scalar_eq;
    var points_eq;
    {
      let isReady = false, hasAppStarted = false, buildMode = "dev";
      const internalApiToken = Symbol("Construct internal API token");
      let internalApiTokenAccessesRemaining = 14;
      const C33 = self.C3 = class {
        constructor() {
          throw TypeError("static class can't be instantiated");
        }
        static _GetInternalAPIToken() {
          if (internalApiTokenAccessesRemaining <= 0) throw new Error("cannot obtain internal API token");
          return --internalApiTokenAccessesRemaining, internalApiToken;
        }
        static SetReady() {
          isReady = true;
        }
        static IsReady() {
          return isReady;
        }
        static SetAppStarted() {
          hasAppStarted = true;
        }
        static HasAppStarted() {
          return hasAppStarted;
        }
        static SetBuildMode(e) {
          buildMode = e;
        }
        static GetBuildMode() {
          return buildMode;
        }
        static IsReleaseBuild() {
          return "final" === buildMode;
        }
      };
      C33.isDebug = false, C33.isDebugDefend = false, C33.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};
    }
    {
      const C33 = self.C3;
      C33.QueryParser = class {
        constructor(e) {
          this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();
        }
        _Parse() {
          let e = this._queryString;
          const r = (e = e.startsWith("?") || e.startsWith("#") ? e.substr(1) : e).split("&");
          for (const t of r) this._ParseParameter(t);
        }
        _ParseParameter(e) {
          if (e) if (e.includes("=")) {
            const r = e.indexOf("="), t = decodeURIComponent(e.substring(0, r)), s = decodeURIComponent(e.substring(r + 1));
            this._parameters.set(t, s);
          } else this._parameters.set(e, null);
        }
        LogAll() {
          for (const e of this._parameters) console.log("[QueryParser] Parameter '" + e[0] + "' = " + (null === e[1] ? "null" : "'" + e[1] + "'"));
        }
        Has(e) {
          return this._parameters.has(e);
        }
        Get(e) {
          const r = this._parameters.get(e);
          return void 0 === r ? null : r;
        }
        ClearHash() {
          history.replaceState("", document.title, location.pathname + location.search);
        }
        Reparse(e) {
          this._queryString = e, this._parameters.clear(), this._Parse();
        }
      }, C33.QueryString = new C33.QueryParser(location.search), C33.LocationHashString = new C33.QueryParser(location.hash), C33.QueryString.Has("perf") && (C33.isPerformanceProfiling = true), "dev" !== C33.QueryString.Get("mode") && C33.SetBuildMode("final");
    }
    {
      let GetWindowsNTVersionName2 = function(r) {
        const o = parseFloat(r), e = windowsNTVerMap.get(o);
        return e || (13 <= o ? "11" : "NT " + r);
      };
      GetWindowsNTVersionName = GetWindowsNTVersionName2;
      const C33 = self.C3, UNKNOWN = "(unknown)", windowsNTVerMap = (C33.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: "browser", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {
      } }, /* @__PURE__ */ new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]));
      const uaStr = navigator.userAgent, uaData = navigator["userAgentData"];
      if (uaData && 0 < uaData["brands"].length) {
        let ReadBrandList2 = function(r) {
          let o2 = "", t = "", a = "", s = "";
          for (const i of r) {
            const n = d.get(i["brand"]), m = (!o2 && n && (o2 = n, t = i["version"]), e.get(i["brand"]));
            !a && m && (a = m, s = i["version"]);
          }
          o2 || "Chromium" !== a || (C33.Platform.Browser = "Chromium", C33.Platform.BrowserVersion = s), C33.Platform.Browser = o2 || UNKNOWN, C33.Platform.BrowserVersion = t || UNKNOWN, C33.Platform.BrowserEngine = a || UNKNOWN;
        };
        ReadBrandList = ReadBrandList2;
        C33.Platform.OS = uaData["platform"], C33.Platform.IsMobile = uaData["mobile"], C33.Platform.IsDesktop = !C33.Platform.IsMobile;
        const d = /* @__PURE__ */ new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]), e = /* @__PURE__ */ new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
        ReadBrandList2(uaData["brands"]);
        let o = false;
        C33.Platform.GetDetailedInfo = async () => {
          if (!o) try {
            const r = await navigator["userAgentData"]["getHighEntropyValues"](["platformVersion", "fullVersionList"]);
            ReadBrandList2(r["fullVersionList"]), "Windows" === C33.Platform.OS ? C33.Platform.OSVersion = GetWindowsNTVersionName2(r["platformVersion"]) : C33.Platform.OSVersion = r["platformVersion"], o = true;
          } catch (r) {
            console.warn("Failed to get detailed user agent information: ", r);
          }
        };
      } else {
        let RunTest2 = function(r2, o) {
          const e = Array.isArray(r2) ? r2 : [r2];
          for (const t2 of e) {
            const a = t2.exec(uaStr);
            if (a) {
              o(a);
              break;
            }
          }
        };
        RunTest = RunTest2;
        RunTest2(/windows\s+nt\s+([\d\.]+)/i, (r2) => {
          C33.Platform.OS = "Windows";
          const o = r2[1];
          C33.Platform.OSVersion = GetWindowsNTVersionName2(o);
        }), RunTest2(/mac\s+os\s+x\s+([\d\._]+)/i, (r2) => {
          C33.Platform.OS = "macOS", C33.Platform.OSVersion = r2[1].replace(/_/g, ".");
        }), RunTest2(/CrOS/, () => {
          C33.Platform.OS = "Chrome OS";
        }), RunTest2(/linux|openbsd|freebsd|netbsd/i, () => {
          C33.Platform.OS = "Linux";
        }), RunTest2(/android/i, () => {
          C33.Platform.OS = "Android";
        }), RunTest2(/android\s+([\d\.]+)/i, (r2) => {
          C33.Platform.OS = "Android", C33.Platform.OSVersion = r2[1];
        }), C33.Platform.OS === UNKNOWN && (RunTest2(/(iphone|ipod|ipad)/i, (r2) => {
          C33.Platform.OS = "iOS";
        }), RunTest2([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], (r2) => {
          C33.Platform.OS = "iOS", C33.Platform.OSVersion = r2[1].replace(/_/g, ".");
        }));
        const q = /chrome\//i.test(uaStr), r = /chromium\//i.test(uaStr), s = /edg\//i.test(uaStr), t = /OPR\//.test(uaStr), u = /nwjs/i.test(uaStr), v = /safari\//i.test(uaStr), w = /webkit/i.test(uaStr), x = (s || t || RunTest2(/chrome\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chrome", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/edg\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Edge", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/OPR\/([\d\.]+)/, (r2) => {
          C33.Platform.Browser = "Opera", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/chromium\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chromium", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium";
        }), RunTest2(/nwjs\/[0-9.]+/i, (r2) => {
          C33.Platform.Browser = "NW.js", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Chromium", C33.Platform.Context = "nwjs";
        }), RunTest2(/firefox\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Firefox", C33.Platform.BrowserVersion = r2[1], C33.Platform.BrowserEngine = "Gecko";
        }), !v || q || r || s || t || u || (C33.Platform.Browser = "Safari", C33.Platform.BrowserEngine = "WebKit", RunTest2(/version\/([\d\.]+)/i, (r2) => {
          C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/crios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Chrome for iOS", C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/fxios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Firefox for iOS", C33.Platform.BrowserVersion = r2[1];
        }), RunTest2(/edgios\/([\d\.]+)/i, (r2) => {
          C33.Platform.Browser = "Edge for iOS", C33.Platform.BrowserVersion = r2[1];
        })), C33.Platform.BrowserEngine === UNKNOWN && w && (C33.Platform.BrowserEngine = "WebKit"), "Android" === C33.Platform.OS && "Safari" === C33.Platform.Browser && (C33.Platform.Browser = "Stock"), /* @__PURE__ */ new Set(["Windows", "macOS", "Linux", "Chrome OS"])), y = x.has(C33.Platform.OS) || "nwjs" === C33.Platform.Context;
        C33.Platform.IsDesktop = y, C33.Platform.IsMobile = !y;
      }
      "Chrome" === C33.Platform.Browser && "browser" === C33.Platform.Context && /wv\)/.test(uaStr) && (C33.Platform.Context = "webview"), "nwjs" !== C33.Platform.Context && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator["standalone"]) && (C33.Platform.Context = "webapp"), C33.Platform.BrowserVersionNumber = parseFloat(C33.Platform.BrowserVersion);
      const looksLikeIPadOS = "macOS" === C33.Platform.OS && navigator["maxTouchPoints"] && 2 < navigator["maxTouchPoints"];
      looksLikeIPadOS && (C33.Platform.OS = "iOS", C33.Platform.OSVersion = C33.Platform.BrowserVersion, C33.Platform.IsDesktop = false, C33.Platform.IsMobile = true, C33.Platform.IsIpadOS = true), C33.Platform.IsAppleOS = "macOS" === C33.Platform.OS || "iOS" === C33.Platform.OS;
    }
    var ReadBrandList;
    var RunTest;
    var GetWindowsNTVersionName;
    {
      "use strict";
      {
        let asyncifyRequest2 = function(n) {
          return new Promise((e2, t) => {
            n.onsuccess = () => e2(n.result), n.onerror = () => t(n.error);
          });
        }, asyncifyTransaction2 = function(n) {
          return new Promise((e2, t) => {
            n.oncomplete = () => e2(), n.onerror = () => t(n.error), n.onabort = () => t(n.error);
          });
        }, openReadOnlyTransaction2 = function(e2, t) {
          return openTransaction(e2, t);
        }, openWriteTransaction2 = function(e2, t) {
          return openTransaction(e2, t, true);
        }, lazyOpenDatabase2 = function(t) {
          RequireString2(t);
          let e2 = c.get(t);
          return e2 instanceof Promise || (e2 = openDatabase(t), c.set(t, e2), e2.catch((e3) => c.delete(t))), e2;
        }, RequireString2 = function(e2) {
          if ("string" != typeof e2) throw new TypeError("expected string");
        }, getEntriesFromCursor2 = function(e2, a2) {
          const t = e2.objectStore(b).openCursor();
          return new Promise((n) => {
            const r = [];
            t.onsuccess = (e3) => {
              const t2 = e3.target.result;
              if (t2) {
                switch (a2) {
                  case "entries":
                    r.push([t2.key, t2.value]);
                    break;
                  case "keys":
                    r.push(t2.key);
                    break;
                  case "values":
                    r.push(t2.value);
                }
                t2.continue();
              } else n(r);
            };
          });
        };
        asyncifyRequest = asyncifyRequest2, asyncifyTransaction = asyncifyTransaction2, openReadOnlyTransaction = openReadOnlyTransaction2, openWriteTransaction = openWriteTransaction2, lazyOpenDatabase = lazyOpenDatabase2, RequireString = RequireString2, getEntriesFromCursor = getEntriesFromCursor2;
        const a = 2, b = "keyvaluepairs", c = /* @__PURE__ */ new Map(), d = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, e = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
        async function openTransaction(t, n, r = false, a2 = true) {
          const e2 = await lazyOpenDatabase2(t);
          try {
            const s = e2.transaction([b], r ? "readwrite" : "readonly");
            return n(s);
          } catch (e3) {
            if (a2 && "InvalidStateError" === e3["name"]) return c.delete(t), openTransaction(t, n, r, false);
            throw e3;
          }
        }
        async function openDatabase(n) {
          RequireString2(n);
          const e2 = indexedDB.open(n, a);
          return e2.addEventListener("upgradeneeded", (e3) => {
            try {
              const t = e3.target.result;
              t.createObjectStore(b);
            } catch (e4) {
              console.error("Failed to create objectstore for database " + n, e4);
            }
          }), asyncifyRequest2(e2);
        }
        class f {
          constructor(e2) {
            RequireString2(e2), this.name = e2;
          }
          async ready() {
            await lazyOpenDatabase2(this.name);
          }
          set(a2, s) {
            return RequireString2(a2), openWriteTransaction2(this.name, async (e2) => {
              const t = e2.objectStore(b).put(s, a2), n = asyncifyRequest2(t), r = asyncifyTransaction2(e2);
              await Promise.all([r, n]);
            });
          }
          get(s) {
            return RequireString2(s), openReadOnlyTransaction2(this.name, async (e2) => {
              const t = e2.objectStore(b).get(s), n = asyncifyRequest2(t), r = asyncifyTransaction2(e2), [, a2] = await Promise.all([r, n]);
              return a2;
            });
          }
          delete(a2) {
            return RequireString2(a2), openWriteTransaction2(this.name, async (e2) => {
              const t = e2.objectStore(b).delete(a2), n = asyncifyRequest2(t), r = asyncifyTransaction2(e2);
              await Promise.all([r, n]);
            });
          }
          clear() {
            return openWriteTransaction2(this.name, async (e2) => {
              const t = e2.objectStore(b).clear(), n = asyncifyRequest2(t), r = asyncifyTransaction2(e2);
              await Promise.all([r, n]);
            });
          }
          keys() {
            return openReadOnlyTransaction2(this.name, async (t) => {
              let n;
              if (e) {
                const s = t.objectStore(b).getAllKeys();
                n = asyncifyRequest2(s);
              } else n = getEntriesFromCursor2(t, "keys");
              const r = asyncifyTransaction2(t), [, a2] = await Promise.all([r, n]);
              return a2;
            });
          }
          values() {
            return openReadOnlyTransaction2(this.name, async (e2) => {
              let t;
              if (d) {
                const a2 = e2.objectStore(b).getAll();
                t = asyncifyRequest2(a2);
              } else t = getEntriesFromCursor2(e2, "values");
              const n = asyncifyTransaction2(e2), [, r] = await Promise.all([n, t]);
              return r;
            });
          }
          entries() {
            return openReadOnlyTransaction2(this.name, async (e2) => {
              const t = getEntriesFromCursor2(e2, "entries"), n = asyncifyTransaction2(e2), [, r] = await Promise.all([n, t]);
              return r;
            });
          }
        }
        self.KVStorageContainer = f;
      }
    }
    var asyncifyRequest;
    var asyncifyTransaction;
    var openReadOnlyTransaction;
    var openWriteTransaction;
    var lazyOpenDatabase;
    var RequireString;
    var getEntriesFromCursor;
    {
      "use strict";
      {
        let NOT_IMPLEMENTED2 = function(e) {
          throw new Error(`"${e}" is not implemented`);
        }, DISALLOW_CALLBACK2 = function(e) {
          if ("function" == typeof e) throw new Error("localforage callback API is not implemented; please use the promise API instead");
        }, StructuredClone2 = function(a2) {
          return "object" == typeof a2 ? new Promise((t) => {
            const { port1: e, port2: r } = new MessageChannel();
            r.onmessage = (e2) => t(e2.data), e.postMessage(a2);
          }) : Promise.resolve(a2);
        };
        NOT_IMPLEMENTED = NOT_IMPLEMENTED2, DISALLOW_CALLBACK = DISALLOW_CALLBACK2, StructuredClone = StructuredClone2;
        const a = self.KVStorageContainer, b = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i], c = /* @__PURE__ */ new WeakMap();
        class d {
          constructor(e) {
            this._inst = e, this._isInMemory = !this._inst, this._isInMemory || "undefined" != typeof indexedDB || (this._isInMemory = true, console.warn("Unable to use local storage because IndexedDB API is not available")), this._memoryStorage = /* @__PURE__ */ new Map();
          }
          _MaybeSwitchToMemoryFallback(e) {
            if (!this._isInMemory) {
              for (const t of b) if (e && t.test(e.message)) {
                console.error("Unable to use local storage, reverting to in-memory store: ", e, e.message), this._isInMemory = true;
                break;
              }
            }
          }
          async _getItemFallback(e) {
            const t = this._memoryStorage.get(e), r = await StructuredClone2(t);
            return void 0 === r ? null : r;
          }
          async _setItemFallback(e, t) {
            t = await StructuredClone2(t), this._memoryStorage.set(e, t);
          }
          _removeItemFallback(e) {
            this._memoryStorage.delete(e);
          }
          _clearFallback() {
            this._memoryStorage.clear();
          }
          _keysFallback() {
            return Array.from(this._memoryStorage.keys());
          }
          IsInMemory() {
            return this._isInMemory;
          }
          GetMemoryStorage() {
            return this._memoryStorage;
          }
          SetMemoryStorage(e) {
            this._memoryStorage = e;
          }
          async getItem(t, e) {
            if (DISALLOW_CALLBACK2(e), this._isInMemory) return this._getItemFallback(t);
            let r;
            try {
              r = await this._inst.get(t);
            } catch (e2) {
              return this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._getItemFallback(t) : (console.error(`Error reading '${t}' from storage, returning null: `, e2), null);
            }
            return void 0 === r ? null : r;
          }
          async setItem(t, r, e) {
            if (DISALLOW_CALLBACK2(e), void 0 === r && (r = null), this._isInMemory) await this._setItemFallback(t, r);
            else try {
              await this._inst.set(t, r);
            } catch (e2) {
              if (this._MaybeSwitchToMemoryFallback(e2), !this._isInMemory) throw e2;
              await this._setItemFallback(t, r);
            }
          }
          async removeItem(t, e) {
            if (DISALLOW_CALLBACK2(e), this._isInMemory) this._removeItemFallback(t);
            else try {
              await this._inst.delete(t);
            } catch (e2) {
              this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._removeItemFallback(t) : console.error(`Error removing '${t}' from storage: `, e2);
            }
          }
          async clear(e) {
            if (DISALLOW_CALLBACK2(e), this._isInMemory) this._clearFallback();
            else try {
              await this._inst.clear();
            } catch (e2) {
              this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", e2);
            }
          }
          async keys(e) {
            if (DISALLOW_CALLBACK2(e), this._isInMemory) return this._keysFallback();
            let t = [];
            try {
              t = await this._inst.keys();
            } catch (e2) {
              if (this._MaybeSwitchToMemoryFallback(e2), this._isInMemory) return this._keysFallback();
              console.error("Error getting storage keys: ", e2);
            }
            return t;
          }
          ready(e) {
            return DISALLOW_CALLBACK2(e), this._isInMemory ? Promise.resolve(true) : this._inst.ready();
          }
          createInstance(e) {
            if (e.forceInMemoryFallback) return new d(null);
            {
              const t = e.name;
              if ("string" != typeof t) throw new TypeError("invalid store name");
              const r = new a(t);
              return new d(r);
            }
          }
          length(e) {
            NOT_IMPLEMENTED2("localforage.length()");
          }
          key(e, t) {
            NOT_IMPLEMENTED2("localforage.key()");
          }
          iterate(e, t) {
            NOT_IMPLEMENTED2("localforage.iterate()");
          }
          setDriver(e) {
            NOT_IMPLEMENTED2("localforage.setDriver()");
          }
          config(e) {
            NOT_IMPLEMENTED2("localforage.config()");
          }
          defineDriver(e) {
            NOT_IMPLEMENTED2("localforage.defineDriver()");
          }
          driver() {
            NOT_IMPLEMENTED2("localforage.driver()");
          }
          supports(e) {
            NOT_IMPLEMENTED2("localforage.supports()");
          }
          dropInstance() {
            NOT_IMPLEMENTED2("localforage.dropInstance()");
          }
        }
        self["localforage"] = new d(new a("localforage"));
      }
    }
    var NOT_IMPLEMENTED;
    var DISALLOW_CALLBACK;
    var StructuredClone;
    {
      const C33 = self.C3;
      if (C33.Supports = {}, C33.Supports.WebAnimations = (() => {
        try {
          if ("undefined" == typeof document) return false;
          const e = document.createElement("div");
          if (void 0 === e.animate) return false;
          const t = e.animate([{ opacity: "0" }, { opacity: "1" }], 1e3);
          return void 0 !== t.reverse;
        } catch (e) {
          return false;
        }
      })(), C33.Supports.DialogElement = "undefined" != typeof HTMLDialogElement, C33.Supports.RequestIdleCallback = !!self.requestIdleCallback, C33.Supports.ImageBitmap = !!self.createImageBitmap, C33.Supports.ImageBitmapOptions = false, C33.Supports.ImageBitmapOptionsResize = false, C33.Supports.ImageBitmap) {
        try {
          self.createImageBitmap(new ImageData(32, 32), { "premultiplyAlpha": "none" }).then(() => {
            C33.Supports.ImageBitmapOptions = true;
          }).catch(() => {
            C33.Supports.ImageBitmapOptions = false;
          });
        } catch (e) {
          C33.Supports.ImageBitmapOptions = false;
        }
        try {
          self.createImageBitmap(new ImageData(32, 32), { "resizeWidth": 10, "resizeHeight": 10 }).then((e) => {
            C33.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;
          }).catch(() => {
            C33.Supports.ImageBitmapOptionsResize = false;
          });
        } catch (e) {
          C33.Supports.ImageBitmapOptionsResize = false;
        }
      }
      if (C33.Supports.ClipboardReadText = !(!navigator["clipboard"] || !navigator["clipboard"]["readText"]), C33.Supports.PermissionsQuery = !(!navigator["permissions"] || !navigator["permissions"]["query"]), C33.Supports.ClipboardPermissionsQuery = false, C33.Supports.PermissionsQuery) {
        const g = { "name": "clipboard-read" };
        navigator["permissions"]["query"](g).then(() => {
          C33.Supports.ClipboardPermissionsQuery = true;
        }).catch(() => {
          C33.Supports.ClipboardPermissionsQuery = false;
        });
      }
      C33.Supports.AsyncClipboardApi = !!(navigator["permissions"] && navigator["clipboard"] && self["ClipboardItem"]), C33.Supports.Proxies = "undefined" != typeof Proxy, C33.Supports.DownloadAttribute = (() => {
        if ("undefined" == typeof document) return false;
        const e = document.createElement("a");
        return void 0 !== e.download;
      })(), C33.Supports.Fetch = "function" == typeof fetch, C33.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C33.Platform.Browser && navigator["storage"] && navigator["storage"]["persist"]), C33.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator["storage"] && navigator["storage"]["estimate"]), C33.Supports.Fullscreen = (() => {
        if ("undefined" == typeof document) return false;
        if ("iOS" === C33.Platform.OS) return false;
        const e = document.documentElement;
        return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);
      })(), C33.Supports.ImageDecoder = void 0 !== self["ImageDecoder"], C33.Supports.WebCodecs = !!self["VideoEncoder"], C33.Supports.NativeFileSystemAPI = !!self["showOpenFilePicker"], C33.Supports.QueryLocalFonts = !!self["queryLocalFonts"], C33.Supports.UserActivation = !!navigator["userActivation"], C33.Supports.CanvasToBlobWebP = false, (async () => {
        let t;
        "undefined" == typeof document ? t = new OffscreenCanvas(32, 32) : ((t = document.createElement("canvas")).width = 32, t.height = 32);
        const e = t.getContext("2d");
        e.fillStyle = "blue", e.fillRect(0, 0, 32, 32);
        let o = null;
        try {
          t["convertToBlob"] ? o = await t["convertToBlob"]({ "type": "image/webp", "quality": 1 }) : t.toBlob && (o = await new Promise((e2) => t.toBlob(e2, "image/webp", 1))), C33.Supports.CanvasToBlobWebP = o && "image/webp" === o.type;
        } catch (e2) {
          C33.Supports.CanvasToBlobWebP = false;
        }
      })();
    }
    {
      let arrayFlat2 = function(t, e) {
        return t.reduce((t2, r) => (0 < e && Array.isArray(r) ? Array.prototype.push.apply(t2, arrayFlat2(r, e - 1)) : t2.push(r), t2), []);
      };
      arrayFlat = arrayFlat2;
      const C33 = self.C3;
      if (!String.prototype.trimStart) {
        const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
          return this.replace(a, "");
        };
      }
      if (!String.prototype.trimEnd) {
        const c = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
          return this.replace(c, "");
        };
      }
      String.prototype.replaceAll || (String.prototype.replaceAll = function(t, r) {
        return this.replace(new RegExp(C33.EscapeRegex(t), "g"), r);
      }), Array.prototype.values || (Array.prototype.values = function* () {
        for (const t of this) yield t;
      }), Array.prototype.flat || (Array.prototype.flat = function(t = 1) {
        return arrayFlat2(this, t);
      }), Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
      }), String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
      }), RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
        if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
        for (const r of this) if (!t.has(r)) return false;
        return true;
      }), navigator["storage"] && !navigator["storage"]["estimate"] && navigator["webkitTemporaryStorage"] && navigator["webkitTemporaryStorage"]["queryUsageAndQuota"] && (navigator["storage"]["estimate"] = function() {
        return new Promise((e, t) => navigator["webkitTemporaryStorage"]["queryUsageAndQuota"]((t2, r) => e({ "usage": t2, "quota": r }), t));
      }), void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol), void 0 === self["globalThis"] && (self["globalThis"] = self);
    }
    var arrayFlat;
    {
      let assertFail2 = function(e) {
        let s = C33.GetCallStack(), t = "Assertion failure: " + e + "\n\nStack trace:\n" + s;
        console.error(t);
      };
      assertFail = assertFail2;
      const C33 = self.C3;
      self.assert = function(e, s) {
        e || assertFail2(s);
      };
    }
    var assertFail;
    {
      const C33 = self.C3, C3X = self.C3X, TypedArray = (C33.IsNumber = function(e) {
        return "number" == typeof e;
      }, C33.IsFiniteNumber = function(e) {
        return C33.IsNumber(e) && isFinite(e);
      }, C33.RequireNumber = function(e) {
        if (!C33.IsNumber(e)) throw new TypeError("expected number");
      }, C33.RequireOptionalNumber = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireNumberInRange = function(e, n, r) {
        if (!C33.IsNumber(e) || isNaN(e) || e < n || r < e) throw new RangeError("number outside of range");
      }, C33.RequireAllNumber = function(...n) {
        for (let e of n) ;
      }, C33.RequireFiniteNumber = function(e) {
        if (!C33.IsFiniteNumber(e)) throw new TypeError("expected finite number");
      }, C33.RequireOptionalFiniteNumber = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllFiniteNumber = function(...n) {
        for (let e of n) ;
      }, C33.IsString = function(e) {
        return "string" == typeof e;
      }, C33.RequireString = function(e) {
        if (!C33.IsString(e)) throw new TypeError("expected string");
      }, C33.RequireOptionalString = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllString = function(...n) {
        for (let e of n) ;
      }, C33.IsSimpleObject = function(e) {
        if ("object" != typeof e || null === e) return false;
        let n = Object.getPrototypeOf(e);
        return n ? n.constructor === Object : null === n;
      }, C33.RequireSimpleObject = function(e) {
        if (!C33.IsSimpleObject(e)) throw new TypeError("expected simple object");
      }, C33.RequireOptionalSimpleObject = function(e) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsSimpleObject(e)) throw new TypeError("expected simple object");
      }, C33.IsObject = function(e) {
        return "object" == typeof e && null !== e && !Array.isArray(e);
      }, C33.RequireObject = function(e) {
        if (!C33.IsObject(e)) throw new TypeError("expected object");
      }, C33.RequireOptionalObject = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllObject = function(...n) {
        for (let e of n) ;
      }, C33.IsFileLike = function(e) {
        return C33.WeakIsInstanceOf(e, Blob) && "string" == typeof e["name"];
      }, C33.RequireFileLike = function(e) {
        if (!C33.IsFileLike(e)) throw new TypeError("expected file");
      }, C33.RequireOptionalFileLike = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsArray = function(e) {
        return Array.isArray(e);
      }, C33.RequireArray = function(e) {
        if (!C33.IsArray(e)) throw new TypeError("expected array");
      }, C33.RequireOptionalArray = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllArray = function(...n) {
        for (let e of n) ;
      }, C33.Is2DArray = function(e) {
        return !(!C33.IsArray(e) || e.length && !C33.IsArray(e[0]));
      }, C33.Require2DArray = function(n) {
        if (!C33.Is2DArray(n)) throw new TypeError("expected 2d array");
        for (let e of n) if (!C33.IsArray(e)) throw new TypeError("expected 2d array");
      }, C33.RequireOptional2DArray = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsFunction = function(e) {
        return "function" == typeof e;
      }, C33.RequireFunction = function(e, n) {
        if (!C33.IsFunction(e)) throw new TypeError("expected function");
        if (!C33.IsNullOrUndefined(n) && e !== n) throw new TypeError("expected same function reference");
      }, C33.RequireOptionalFunction = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllFunction = function(...n) {
        for (let e of n) ;
      }, C33.RequireAnyFunction = function(n, ...r) {
        if (!C33.IsFunction(n)) throw new TypeError("expected function");
        if (!r.length) throw new Error("missing comparison functions");
        for (let e of r) if (!C33.IsNullOrUndefined(e) && n === e) return;
        throw new TypeError("expected same function reference");
      }, C33.RequireOptionalAllFunction = function(...n) {
        if (!C33.IsNullOrUndefined(n)) for (let e of n) ;
      }, C33.IsInstanceOf = function(e, n) {
        return e instanceof n;
      }, C33.IsInstanceOfAny = function(n, ...r) {
        for (let e of r) if (C33.IsInstanceOf(n, e)) return true;
        return false;
      }, C33.RequireInstanceOf = function(e, n) {
        if (!C33.IsInstanceOf(e, n)) throw new TypeError("unexpected type");
      }, C33.RequireOptionalInstanceOf = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllInstanceOf = function(e, ...n) {
        for (let e2 of n) ;
      }, C33.RequireAnyInstanceOf = function(e, ...n) {
        if (!C33.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
      }, C33.RequireAnyOptionalInstanceOf = function(e, ...n) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
      }, C33.IsArrayOf = function(n, r) {
        for (let e of n) if (!C33.IsInstanceOf(e, r)) return false;
        return true;
      }, C33.IsArrayOfFiniteNumbers = function(n) {
        for (let e of n) if (!C33.IsFiniteNumber(e)) return false;
        return true;
      }, C33.RequireArrayOf = function(n, e) {
        for (let e2 of n) ;
      }, C33.RequireOptionalArrayOf = function(n, e) {
        if (!C33.IsNullOrUndefined(n)) for (let e2 of n) ;
      }, C33.RequireOptionalArrayOfFunctions = function(n, e) {
        if (!C33.IsNullOrUndefined(n)) for (let e2 of n) ;
      }, C33.RequireArrayOfAny = function(n) {
        for (let e of n) ;
      }, C33.RequireOptionalArrayOfAny = function(n) {
        if (!C33.IsNullOrUndefined(n)) for (let e of n) ;
      }, C33.IsDOMNode = function(e, n) {
        return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) && (!n || C33.equalsNoCase(e.nodeName, n));
      }, C33.RequireDOMNode = function(e, n) {
        if (C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) throw new TypeError("expected DOM node");
        if (n && !C33.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);
      }, C33.RequireOptionalDOMNode = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.IsHTMLElement = function(e, n) {
        return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) && (!n || C33.equalsNoCase(e.tagName, n));
      }, C33.RequireHTMLElement = function(e, n) {
        if (C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) throw new TypeError("expected HTML element");
        if (n && !C33.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);
      }, C33.RequireOptionalHTMLElement = function(e, n) {
        C33.IsNullOrUndefined(e);
      }, C33.IsDrawable = function(e) {
        return C33.IsHTMLElement(e, "img") || C33.IsHTMLElement(e, "canvas") || C33.IsHTMLElement(e, "video") || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap;
      }, C33.RequireDrawable = function(e) {
        if (!C33.IsDrawable(e)) throw new TypeError("expected drawable");
      }, C33.RequireOptionalDrawable = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.IsDrawableOrImageData = function(e) {
        return e instanceof ImageData || C33.IsDrawable(e);
      }, C33.RequireDrawableOrImageData = function(e) {
        if (!C33.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
      }, C33.RequireOptionalDrawableOrImageData = function(e) {
        if (!C33.IsNullOrUndefined(e) && !C33.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
      }, C33.IsStringLike = function(e) {
        return "string" == typeof e || C33.HtmlString && e instanceof C33.HtmlString || e instanceof C33.BBString;
      }, C33.RequireStringLike = function(e) {
        if (!C33.IsStringLike(e)) throw new TypeError("expected string-like");
      }, C33.RequireOptionalStringLike = function(e) {
        C33.IsNullOrUndefined(e);
      }, C33.RequireAllStringLike = function(...n) {
        for (let e of n) ;
      }, C33.RequireOverride = function() {
        throw new Error("must be overridden");
      }, C33.NotYetImplemented = function() {
        throw new Error("not yet implemented");
      }, C33.IsDefined = function(e, ...n) {
        let r = e;
        if (void 0 === r) return false;
        for (let e2 of n) {
          if (void 0 === r[e2]) return false;
          r = r[e2];
        }
        return true;
      }, C33.IsNullOrUndefined = function(e) {
        return null == e;
      }, C33.AreArrayElementsOfSameType = function(n) {
        let r = n[0].constructor;
        for (let e of n) if (e.constructor !== r) return false;
        return r;
      }, C33.AreArrayElementsOfType = function(n, r) {
        for (let e of n) if (!(e instanceof r)) return false;
        return true;
      }, Object.getPrototypeOf(Uint8Array));
      C33.IsTypedArray = function(e) {
        return C33.IsInstanceOf(e, TypedArray);
      }, C33.RequireTypedArray = function(e) {
      }, C33.WeakRequireTypedArray = function(e) {
        C33.WeakRequireInstanceOf(e, TypedArray);
      }, C33.WeakRequireAnyInstanceOf = function(e, ...n) {
        if (!C33.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError("unexpected type");
      }, C33.WeakIsAnyInstanceOf = function(e, ...n) {
        for (const r of n) if (C33.WeakIsInstanceOf(e, r)) return true;
        return false;
      }, C33.WeakRequireInstanceOf = function(e, n) {
        if (!C33.WeakIsInstanceOf(e, n)) throw new TypeError("unexpected type");
      }, C33.WeakIsInstanceOf = function(e, n) {
        for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;
        return false;
      }, C3X.RequireNumber = C33.RequireNumber, C3X.RequireOptionalNumber = C33.RequireOptionalNumber, C3X.RequireFiniteNumber = C33.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C33.RequireOptionalFiniteNumber, C3X.RequireString = C33.RequireString, C3X.RequireOptionalString = C33.RequireOptionalString, C3X.RequireObject = C33.RequireObject, C3X.RequireOptionalObject = C33.RequireOptionalObject, C3X.RequireArray = C33.RequireArray, C3X.RequireOptionalArray = C33.RequireOptionalArray, C3X.RequireFunction = C33.RequireFunction, C3X.RequireOptionalFunction = C33.RequireOptionalFunction, C3X.RequireInstanceOf = C33.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C33.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C33.IsNullOrUndefined;
    }
    {
      let isValidTypeChange2 = function(e, t) {
        let r = C33.getType(e), n = C33.getType(t);
        return "null" === r || "null" === n || "undefined" !== r && "undefined" !== n && r === n;
      }, logDefendedObjectWarning2 = function(e) {
        console.warn("[Defence] " + e + " @", C33.GetCallStack());
      }, CheckDefendedObjectsUsedCorrectly2 = function() {
        if (checkRafId = -1, 0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {
          let e = new Set([...ctorObjectToProxy.keys()].map((e2) => C33.getName(e2))), t = [...e].join(",");
          console.warn("An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: " + t), ctorObjectToProxy.clear(), ctorProxyToObject.clear();
        }
      }, getObjectPropertySet2 = function(t) {
        let r = /* @__PURE__ */ new Set();
        for (let e in t) r.add(e);
        return r;
      }, VerifyObjectPropertiesConsistent2 = function(e, t) {
        let r = getObjectPropertySet2(t), n = typeProperties.get(e);
        if (n) {
          let t2 = [];
          for (let e2 of n.values()) r.has(e2) ? r.delete(e2) : t2.push(e2);
          C33.appendArray(t2, [...r]), t2.length && console.warn(`[Defence] '${C33.getName(e)}' constructor creates inconsistent properties: ` + t2.join(", "));
        } else typeProperties.set(e, r);
      };
      isValidTypeChange = isValidTypeChange2, logDefendedObjectWarning = logDefendedObjectWarning2, CheckDefendedObjectsUsedCorrectly = CheckDefendedObjectsUsedCorrectly2, getObjectPropertySet = getObjectPropertySet2, VerifyObjectPropertiesConsistent = VerifyObjectPropertiesConsistent2;
      const C33 = self.C3, logRafIds = /* @__PURE__ */ new Map();
      C33.ColorLog = function(e, t) {
        console.log("%c" + e, "font-weight: bold; color:" + t);
      }, C33.RafLog = function(e, ...t) {
        logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {
          console.log("%c" + e, "font-weight: bold", ...t), logRafIds.set(e, -1);
        }));
      };
      let measures;
      C33.StartMeasure = function(e) {
        performance.mark(e), (measures = measures || /* @__PURE__ */ new Map()).has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {
          return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ` + this.calls;
        } });
      }, C33.EndMeasure = function(e) {
        performance.measure("measure-" + e, e);
        const t = performance.getEntriesByName("measure-" + e)[0], r = measures.get(e);
        r.current = t.duration, r.total += r.current, r.average = r.total / r.calls, console.log(r.toString()), r.calls++, performance.clearMarks(e), performance.clearMeasures("measure-" + e);
      }, C33.GetCallStack = function() {
        return new Error().stack;
      }, C33.Debugger = function() {
      }, C33.cast = function(e, t) {
        return e && e instanceof t ? e : null;
      }, C33.getName = function(e) {
        return void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? "<boolean>" : C33.IsNumber(e) ? "<number>" : C33.IsString(e) ? "<string>" : C33.IsArray(e) ? "<array>" : "symbol" == typeof e ? "<" + e.toString() + ">" : C33.IsFunction(e) ? e.name && "Function" !== e.name ? e.name : "<anonymous function>" : "object" == typeof e ? e.constructor && e.constructor.name && "Object" !== e.constructor.name ? e.constructor.name : "<anonymous object>" : "<unknown>";
      }, C33.getType = function(e) {
        return null === e ? "null" : Array.isArray(e) ? "array" : typeof e;
      }, C33.range = function* (t, r) {
        if (!isFinite(Math.abs(t - r))) throw new Error("Invalid parameters");
        if (r < t) for (let e = t - 1; e >= r; e--) yield e;
        else for (let e = t; e < r; e++) yield e;
      };
      let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();
      C33.DefendHandler = {};
      const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set(["then", "splice"]);
      C33.DefendHandler.get = function(e, t) {
        return t in e || "symbol" == typeof t || VALID_GET_MISSING_KEYS.has(t) || logDefendedObjectWarning2(`Accessed missing property '${t}' from defended object '${C33.getName(e)}', returning undefined`), releasedObjects.has(e) && "symbol" != typeof t && !VALID_GET_MISSING_KEYS.has(t) && logDefendedObjectWarning2(`Accessed property '${t}' on a released object '${C33.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t];
      }, C33.DefendHandler.set = function(e, t, r) {
        return t in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning2(`Set non-existent property '${t}' to '${r}' on defended object '${C33.getName(e)}'`), isValidTypeChange2(e[t], r) || ctorObjectToProxy.has(e) || logDefendedObjectWarning2(`Set '${C33.getType(e[t])}' property '${t}' to type '${C33.getType(r)}' on defended object '${C33.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning2(`Set property '${t}' on a released object '${C33.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t] = r, true;
      }, C33.DefendHandler.deleteProperty = function(e, t) {
        throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C33.getName(e)}'`);
      }, C33.DefendHandler.defineProperty = function(e, t, r) {
        throw new ReferenceError(`Cannot define property '${t}' on defended object '${C33.getName(e)}'`);
      }, C33.DefendHandler.enumerate = function(e) {
        throw new ReferenceError(`Cannot enumerate defended object '${C33.getName(e)}'`);
      };
      let checkRafId = -1;
      C33.DefendedBase = class {
        constructor() {
          if (C33.isDebugDefend && C33.Supports.Proxies) {
            let e = Object.create(new.target.prototype), t = new Proxy(e, C33.DefendHandler);
            return ctorObjectToProxy.set(e, t), ctorProxyToObject.set(t, e), proxyToObject.set(t, e), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly2)), t;
          }
        }
      }, C33.debugDefend = function(t) {
        if (C33.isDebugDefend && C33.Supports.Proxies && t instanceof C33.DefendedBase) {
          if (ctorProxyToObject.has(t)) {
            let e = ctorProxyToObject.get(t);
            ctorProxyToObject.delete(t), ctorObjectToProxy.delete(e);
          }
          return t;
        }
        return C33.isDebug ? Object.seal(t) : t;
      }, C33.New = function(e, ...t) {
        let r;
        try {
          r = new e(...t);
        } catch (e2) {
          throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;
        }
        return C33.isDebugDefend && VerifyObjectPropertiesConsistent2(e, r), C33.debugDefend(r);
      }, C33.Release = function(e) {
        let t = proxyToObject.get(e);
        t && releasedObjects.set(t, C33.GetCallStack());
      }, C33.WasReleased = function(e) {
        let t = proxyToObject.get(e);
        return !!t && !!releasedObjects.get(t);
      };
      let typeProperties = /* @__PURE__ */ new Map();
      C33.PerfMark = class {
        constructor(e) {
          this._name = "", e && this.start(e);
        }
        start(e) {
          C33.isPerformanceProfiling && (this._name = e, performance.mark(this._name + "-Start"));
        }
        end() {
          C33.isPerformanceProfiling && (performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End"));
        }
        next(e) {
          C33.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + "-Start"));
        }
      };
    }
    var isValidTypeChange;
    var logDefendedObjectWarning;
    var CheckDefendedObjectsUsedCorrectly;
    var getObjectPropertySet;
    var VerifyObjectPropertiesConsistent;
    {
      let isNegativeZero2 = function(t) {
        return 0 === t && 1 / t < 0;
      };
      isNegativeZero = isNegativeZero2;
      const C33 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI, ALPHAEX_SHIFT = (C33.wrap = function(t, n, e) {
        t = Math.floor(t), n = Math.floor(n);
        const r = (e = Math.floor(e)) - n;
        if (0 == r) return e;
        if (t < n) {
          const a = e - (n - t) % r;
          return a === e ? 0 : a;
        }
        return n + (t - n) % r;
      }, C33.mapToRange = function(t, n, e, r, a) {
        const o = e - n;
        if (0 == o && 0 === r) return t;
        const c = a - r;
        return (t - n) * c / o + r;
      }, C33.normalize = function(t, n, e) {
        return n - e == 0 ? 1 : (t - n) / (e - n);
      }, C33.clamp = function(t, n, e) {
        return t < n ? n : e < t ? e : t;
      }, C33.clampAngle = function(t) {
        return (t %= TWO_PI) < 0 && (t += TWO_PI), t;
      }, C33.toRadians = function(t) {
        return t * D_TO_R;
      }, C33.toDegrees = function(t) {
        return t * R_TO_D;
      }, C33.distanceTo = function(t, n, e, r) {
        return Math.hypot(e - t, r - n);
      }, C33.distanceSquared = function(t, n, e, r) {
        const a = e - t, o = r - n;
        return a * a + o * o;
      }, C33.angleTo = function(t, n, e, r) {
        return Math.atan2(r - n, e - t);
      }, C33.angleDiff = function(t, n) {
        if (t === n) return 0;
        let e = Math.sin(t), r = Math.cos(t), a = Math.sin(n), o = Math.cos(n), c = e * a + r * o;
        return 1 <= c ? 0 : c <= -1 ? Math.PI : Math.acos(c);
      }, C33.angleRotate = function(t, n, e) {
        let r = Math.sin(t), a = Math.cos(t), o = Math.sin(n), c = Math.cos(n);
        return Math.acos(r * o + a * c) > e ? 0 < a * o - r * c ? C33.clampAngle(t + e) : C33.clampAngle(t - e) : C33.clampAngle(n);
      }, C33.angleClockwise = function(t, n) {
        let e = Math.sin(t), r = Math.cos(t), a = Math.sin(n), o = Math.cos(n);
        return r * a - e * o <= 0;
      }, C33.angleLerp = function(t, n, e, r = 0) {
        let a = C33.angleDiff(t, n);
        const o = TWO_PI * r;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a + o) * e) : C33.clampAngle(t - (a + o) * e);
      }, C33.angleLerpClockwise = function(t, n, e, r = 0) {
        const a = C33.angleDiff(t, n), o = TWO_PI * r;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a + o) * e) : C33.clampAngle(t + (TWO_PI - a + o) * e);
      }, C33.angleLerpAntiClockwise = function(t, n, e, r = 0) {
        const a = C33.angleDiff(t, n), o = TWO_PI * r;
        return C33.angleClockwise(n, t) ? C33.clampAngle(t - (-TWO_PI + a - o) * e) : C33.clampAngle(t - (a + o) * e);
      }, C33.angleReflect = function(t, n) {
        const e = C33.angleDiff(t, n);
        return C33.angleClockwise(t, n) ? C33.clampAngle(n - e) : C33.clampAngle(n + e);
      }, C33.lerp = function(t, n, e) {
        return t + e * (n - t);
      }, C33.unlerp = function(t, n, e) {
        return t === n ? 0 : (e - t) / (n - t);
      }, C33.relerp = function(t, n, e, r, a) {
        return C33.lerp(r, a, C33.unlerp(t, n, e));
      }, C33.qarp = function(t, n, e, r) {
        return C33.lerp(C33.lerp(t, n, r), C33.lerp(n, e, r), r);
      }, C33.cubic = function(t, n, e, r, a) {
        return C33.lerp(C33.qarp(t, n, e, a), C33.qarp(n, e, r, a), a);
      }, C33.cosp = function(t, n, e) {
        return (t + n + (t - n) * Math.cos(e * Math.PI)) / 2;
      }, C33.isPOT = function(t) {
        return 0 < t && 0 == (t - 1 & t);
      }, C33.nextHighestPowerOfTwo = function(n) {
        --n;
        for (let t = 1; t < 32; t <<= 1) n |= n >> t;
        return n + 1;
      }, C33.roundToNearestFraction = function(t, n) {
        return Math.round(t * n) / n;
      }, C33.floorToNearestFraction = function(t, n) {
        return Math.floor(t * n) / n;
      }, C33.roundToDp = function(t, n) {
        n = Math.max(Math.floor(n), 0);
        const e = Math.pow(10, n);
        return Math.round(t * e) / e;
      }, C33.countDecimals = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
      }, C33.toFixed = function(t, n) {
        let e = t.toFixed(n), r = e.length - 1;
        for (; 0 <= r && "0" === e.charAt(r); --r) ;
        return 0 <= r && "." === e.charAt(r) && --r, r < 0 ? e : e.substr(0, r + 1);
      }, C33.PackRGB = function(t, n, e) {
        return C33.clamp(t, 0, 255) | C33.clamp(n, 0, 255) << 8 | C33.clamp(e, 0, 255) << 16;
      }, 1024), ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;
      C33.PackRGBAEx = function(t, n, e, r) {
        return t = C33.clamp(Math.floor(1024 * t), RGBEX_MIN, RGBEX_MAX), n = C33.clamp(Math.floor(1024 * n), RGBEX_MIN, RGBEX_MAX), e = C33.clamp(Math.floor(1024 * e), RGBEX_MIN, RGBEX_MAX), r = C33.clamp(Math.floor(r * ALPHAEX_MAX), 0, ALPHAEX_MAX), t < 0 && (t += RGBEX_SHIFT), n < 0 && (n += RGBEX_SHIFT), e < 0 && (e += RGBEX_SHIFT), -(t * RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT + n * RGBEX_SHIFT * ALPHAEX_SHIFT + e * ALPHAEX_SHIFT + r);
      }, C33.PackRGBEx = function(t, n, e) {
        return C33.PackRGBAEx(t, n, e, 1);
      }, C33.GetRValue = function(n) {
        if (0 <= n) return (255 & n) / 255;
        {
          let t = Math.floor(-n / (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT));
          return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
        }
      }, C33.GetGValue = function(n) {
        if (0 <= n) return ((65280 & n) >> 8) / 255;
        {
          let t = Math.floor(-n % (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT) / (RGBEX_SHIFT * ALPHAEX_SHIFT));
          return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
        }
      }, C33.GetBValue = function(n) {
        if (0 <= n) return ((16711680 & n) >> 16) / 255;
        {
          let t = Math.floor(-n % (RGBEX_SHIFT * ALPHAEX_SHIFT) / ALPHAEX_SHIFT);
          return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
        }
      }, C33.GetAValue = function(t) {
        if (isNegativeZero2(t)) return 0;
        if (0 <= t) return 1;
        {
          const n = Math.floor(-t % ALPHAEX_SHIFT);
          return n / ALPHAEX_MAX;
        }
      }, C33.greatestCommonDivisor = function(n, e) {
        for (n = Math.floor(n), e = Math.floor(e); 0 !== e; ) {
          let t = e;
          e = n % e, n = t;
        }
        return n;
      };
      const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]], NO_HIT = (C33.getAspectRatio = function(e, r) {
        if ((e = Math.floor(e)) === (r = Math.floor(r))) return [1, 1];
        for (let n of COMMON_ASPECT_RATIOS) {
          let t2 = e / n[0] * n[1];
          if (Math.abs(r - t2) < 1) return n.slice(0);
          if (t2 = e / n[1] * n[0], Math.abs(r - t2) < 1) return [n[1], n[0]];
        }
        let t = C33.greatestCommonDivisor(e, r);
        return [e / t, r / t];
      }, C33.segmentsIntersect = function(t, n, e, r, a, o, c, u) {
        const i = Math.min(t, e), l = Math.max(t, e), s = Math.min(a, c), C = Math.max(a, c);
        if (l < s || C < i) return false;
        const f = Math.min(n, r), M = Math.max(n, r), h = Math.min(o, u), A = Math.max(o, u);
        if (M < h || A < f) return false;
        const I = a - t + c - e, _ = o - n + u - r, g = e - t, T = r - n, m = c - a, X = u - o, E = Math.abs(T * m - X * g), P = m * _ - X * I;
        if (Math.abs(P) > E) return false;
        const H = g * _ - T * I;
        return Math.abs(H) <= E;
      }, C33.segmentsIntersectPreCalc = function(t, n, e, r, a, o, c, u, i, l, s, C) {
        const f = Math.min(i, s), M = Math.max(i, s);
        if (o < f || M < a) return false;
        const h = Math.min(l, C), A = Math.max(l, C);
        if (u < h || A < c) return false;
        const I = i - t + s - e, _ = l - n + C - r, g = e - t, T = r - n, m = s - i, X = C - l, E = Math.abs(T * m - X * g), P = m * _ - X * I;
        if (Math.abs(P) > E) return false;
        const H = g * _ - T * I;
        return Math.abs(H) <= E;
      }, C33.segmentIntersectsQuad = function(t, n, e, r, a) {
        const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r), l = a.getTlx(), s = a.getTly(), C = a.getTrx(), f = a.getTry(), M = a.getBrx(), h = a.getBry(), A = a.getBlx(), I = a.getBly();
        return C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, l, s, C, f) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, C, f, M, h) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, M, h, A, I) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, A, I, l, s);
      }, C33.segmentIntersectsAnyN = function(n, e, r, a, o) {
        const c = Math.min(n, r), u = Math.max(n, r), i = Math.min(e, a), l = Math.max(e, a);
        let s = 0;
        for (let t = o.length - 4; s <= t; s += 2) if (C33.segmentsIntersectPreCalc(n, e, r, a, c, u, i, l, o[s], o[s + 1], o[s + 2], o[s + 3])) return true;
        return C33.segmentsIntersectPreCalc(n, e, r, a, c, u, i, l, o[s], o[s + 1], o[0], o[1]);
      }, 2), PADDING = 1e-6;
      C33.rayIntersect = function(t, n, e, r, a, o, c, u) {
        const i = e - t, l = r - n, s = c - a, C = u - o, f = i * C - l * s;
        if (0 == f) return NO_HIT;
        const M = ((n - r) * (c - t) + i * (u - n)) / f;
        return 0 < M && M < 1 + PADDING ? (C * (c - t) + (a - c) * (u - n)) / f : NO_HIT;
      }, C33.rayIntersectExtended = function(t, n, e, r, a, o, c, u, i) {
        const l = (c - a) * i, s = (u - o) * i;
        return C33.rayIntersect(t, n, e, r, a - l, o - s, c + l, u + s);
      }, C33.isPointInTriangleInclusive = function(t, n, e, r, a, o, c, u) {
        const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, M = n - r, h = i * i + l * l, A = i * s + l * C, I = i * f + l * M, _ = s * s + C * C, g = s * f + C * M, T = 1 / (h * _ - A * A), m = (_ * I - A * g) * T, X = (h * g - A * I) * T;
        return 0 <= m && 0 <= X && m + X <= 1;
      }, C33.triangleCartesianToBarycentric = function(t, n, e, r, a, o, c, u) {
        const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, M = n - r, h = i * i + l * l, A = i * s + l * C, I = s * s + C * C, _ = f * i + M * l, g = f * s + M * C, T = h * I - A * A, m = (I * _ - A * g) / T, X = (h * g - A * _) / T, E = 1 - m - X;
        return [E, m, X];
      }, C33.triangleBarycentricToCartesian3d = function(t, n, e, r, a, o, c, u, i, l, s, C) {
        return [t * r + n * c + e * l, t * a + n * u + e * s, t * o + n * i + e * C];
      };
    }
    var isNegativeZero;
    {
      const C33 = self.C3;
      let mainDocument = null, baseHref = "";
      if ("undefined" != typeof document) {
        const a = (mainDocument = document).querySelector("base");
        !(baseHref = a && a.hasAttribute("href") ? a.getAttribute("href") : "") || (baseHref = baseHref.startsWith("/") ? baseHref.substr(1) : baseHref).endsWith("/") || (baseHref += "/");
      }
      C33.GetBaseHref = function() {
        return baseHref;
      }, C33.GetBaseURL = function() {
        if (!mainDocument) return "";
        const e = mainDocument.location;
        return C33.GetPathFromURL(e.origin + e.pathname) + baseHref;
      }, C33.GetPathFromURL = function(e) {
        if (!e.length) return e;
        if (e.endsWith("/") || e.endsWith("\\")) return e;
        const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
        return -1 === t ? "" : e.substr(0, t + 1);
      }, C33.GetFilenameFromURL = function(e) {
        if (!e.length) return e;
        if (e.endsWith("/") || e.endsWith("\\")) return "";
        const t = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
        return -1 === t ? e : e.substr(t + 1);
      }, C33.GetFileExtension = function(e) {
        let t = e.lastIndexOf(".");
        return t < 1 ? "" : e.substr(t);
      }, C33.SetFileExtension = function(e, t) {
        const n = e.lastIndexOf(".");
        return -1 === n ? e + "." + t : e.substr(0, n + 1) + t;
      }, C33.GetFileNamePart = function(e) {
        let t = e.lastIndexOf(".");
        return t < 1 ? e : e.substr(0, t);
      }, C33.NormalizeFileSeparator = function(e) {
        return e.replace(/\\/g, "/");
      }, C33.IsFileExtension = function(e, t) {
        const n = e ? C33.GetFileExtension(e).slice(1) : "";
        return t === n;
      }, C33.FileNameEquals = function(e, t) {
        let n, r;
        return C33.IsFileLike(e) && (n = C33.GetFileNamePart(e["name"])), C33.IsString(e) && (n = C33.GetFileNamePart(e)), C33.IsFileLike(t) && (r = C33.GetFileNamePart(t["name"])), C33.IsString(t) && (r = C33.GetFileNamePart(t)), n === r;
      }, C33.ParseFilePath = function(e) {
        e = C33.NormalizeFileSeparator(e);
        let t = /^\w\:\//.exec(e);
        t ? (t = t[0], "/" !== (e = e.slice(3))[0] && (e = "/" + e)) : t = "";
        const n = (e = 1 < (e = e.replace(/\/{2,}/g, "/")).length && "/" === e.slice(-1) ? e.slice(0, -1) : e).lastIndexOf("/") + 1;
        let r = "", a = e, o, s = "";
        0 < n && (r = e.slice(0, n), a = e.slice(n));
        const i = (o = a).lastIndexOf("."), l = (0 < i && (s = a.slice(i), o = a.slice(0, -s.length)), t + r + a);
        return { dir: r, base: a, name: o, root: t, ext: s, full: l };
      }, C33.Wait = function(n, r) {
        return new Promise((e, t) => {
          self.setTimeout(e, n, r);
        });
      }, C33.swallowException = function(e) {
        try {
          e();
        } catch (e2) {
          C33.isDebug && console.warn("Swallowed exception: ", e2);
        }
      }, C33.noop = function() {
      }, C33.equalsNoCase = function(e, t) {
        return "string" == typeof e && "string" == typeof t && (e === t || e.normalize().toLowerCase() === t.normalize().toLowerCase());
      }, C33.equalsCase = function(e, t) {
        return "string" == typeof e && "string" == typeof t && (e === t || e.normalize() === t.normalize());
      }, C33.typedArraySet16 = function(e, t, n) {
        e[n++] = t[0], e[n++] = t[1], e[n++] = t[2], e[n++] = t[3], e[n++] = t[4], e[n++] = t[5], e[n++] = t[6], e[n++] = t[7], e[n++] = t[8], e[n++] = t[9], e[n++] = t[10], e[n++] = t[11], e[n++] = t[12], e[n++] = t[13], e[n++] = t[14], e[n] = t[15];
      }, C33.truncateArray = function(e, t) {
        e.length = t;
      }, C33.clearArray = function(e) {
        e && 0 !== e.length && C33.truncateArray(e, 0);
      }, C33.clear2DArray = function(n) {
        if (n) {
          for (let t = 0; t < n.length; t++) {
            let e = n[t];
            C33.truncateArray(e, 0);
          }
          C33.truncateArray(n, 0);
        }
      }, C33.extendArray = function(t, n, r) {
        n |= 0;
        const a = t.length;
        if (!(n <= a)) for (let e = a; e < n; ++e) t.push(r);
      }, C33.resizeArray = function(e, t, n) {
        const r = e.length;
        (t |= 0) < r ? C33.truncateArray(e, t) : r < t && C33.extendArray(e, t, n);
      }, C33.shallowAssignArray = function(e, t) {
        C33.clearArray(e), C33.appendArray(e, t);
      }, C33.appendArray = function(n, r) {
        if (r.length < 1e4) n.push(...r);
        else for (let e = 0, t = r.length; e < t; ++e) n.push(r[e]);
      }, C33.arrayRemove = function(n, r) {
        if (!((r = Math.floor(r)) < 0 || r >= n.length)) {
          let t = n.length - 1;
          for (let e = r; e < t; ++e) n[e] = n[e + 1];
          C33.truncateArray(n, t);
        }
      }, C33.arrayFindRemove = function(e, t) {
        let n = e.indexOf(t);
        0 <= n && e.splice(n, 1);
      }, C33.arraysEqual = function(t, n) {
        let r = t.length;
        if (n.length !== r) return false;
        for (let e = 0; e < r; ++e) if (t[e] !== n[e]) return false;
        return true;
      }, C33.arrayFilterOut = function(n, r) {
        let a = [], o = 0;
        for (let t = 0, e = n.length; t < e; ++t) {
          let e2 = n[t];
          r(e2) ? a.push(e2) : (n[o] = e2, ++o);
        }
        return C33.truncateArray(n, o), a;
      }, C33.arrayRemoveAllInSet = function(n, r) {
        const e = n.length;
        let a = 0;
        for (let t = 0, e2 = n.length; t < e2; ++t) {
          let e3 = n[t];
          r.has(e3) || (n[a++] = e3);
        }
        return C33.truncateArray(n, a), e - a;
      }, C33.isArrayIndexInBounds = function(e, t) {
        return e === Math.floor(e) && 0 <= e && e < t.length;
      }, C33.validateArrayIndex = function(e, t) {
        if (!C33.isArrayIndexInBounds(e, t)) throw new RangeError("array index out of bounds");
      }, C33.cloneArray = function(e) {
        return e.slice();
      }, C33.deepCloneArray = function(e, n) {
        let r = [];
        for (let t of e) if (C33.IsObject(t)) {
          let e2 = n(t);
          if (!e2) throw new Error("missing clone");
          if (e2.constructor !== t.constructor) throw new Error("object is not a clone");
          r.push(e2);
        } else C33.IsArray(t) ? r.push(C33.deepCloneArray(t, n)) : r.push(t);
        return r;
      }, C33.clone2DArray = function(t) {
        let n = [];
        for (let e of t) n.push(e.slice());
        return n;
      }, C33.splitStringAndNormalize = function(e, t = " ") {
        return e ? e.split(t).map((e2) => e2.trim()).filter((e2) => !!e2) : [];
      }, C33.filterSet = function(e, t, n) {
        const r = /* @__PURE__ */ new Set();
        for (const a of e.values()) t(a) && (n ? r.add(n(a)) : r.add(a));
        return r;
      }, C33.mergeSets = function(e, t) {
        return e["union"] ? e["union"](t) : /* @__PURE__ */ new Set([...e, ...t]);
      }, C33.mergeSetsInPlace = function(e, t) {
        for (const n of t) e.add(n);
        return e;
      }, C33.first = function(t) {
        for (let e of t) return e;
        return null;
      }, C33.xor = function(e, t) {
        return !e != !t;
      }, C33.compare = function(e, t, n) {
        switch (t) {
          case 0:
            return e === n;
          case 1:
            return e !== n;
          case 2:
            return e < n;
          case 3:
            return e <= n;
          case 4:
            return n < e;
          case 5:
            return n <= e;
          default:
            return false;
        }
      }, C33.hasAnyOwnProperty = function(t) {
        for (let e in t) if (t.hasOwnProperty(e)) return true;
        return false;
      }, C33.PromiseAllWithProgress = function(i, l) {
        return i.length ? new Promise((n, r) => {
          const a = [];
          let o = 0, s = false;
          for (let t = 0, e = i.length; t < e; ++t) a.push(void 0), i[t].then((e2) => {
            s || (a[t] = e2, ++o === i.length ? n(a) : l(o, i.length));
          }).catch((e2) => {
            s = true, r(e2);
          });
        }) : Promise.resolve([]);
      };
      let memoryCallbacks = [], nextTaskId = (C33.AddLibraryMemoryCallback = function(e) {
        memoryCallbacks.push(e);
      }, C33.GetEstimatedLibraryMemoryUsage = function() {
        let n = 0;
        for (let t of memoryCallbacks) {
          let e = t();
          n += e;
        }
        return Math.floor(n);
      }, 1);
      const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel(), activeRPAFids = (taskMessageChannel.port2.onmessage = function(e) {
        const t = e.data, n = activeTaskIds.get(t);
        activeTaskIds.delete(t), n && n(performance.now());
      }, C33.RequestUnlimitedAnimationFrame = function(e) {
        const t = nextTaskId++;
        return activeTaskIds.set(t, e), taskMessageChannel.port1.postMessage(t), t;
      }, C33.CancelUnlimitedAnimationFrame = function(e) {
        activeTaskIds.delete(e);
      }, C33.PostTask = C33.RequestUnlimitedAnimationFrame, C33.WaitForNextTask = function() {
        return new Promise((e) => C33.PostTask(e));
      }, /* @__PURE__ */ new Set());
      C33.RequestPostAnimationFrame = function(t) {
        const n = self.requestAnimationFrame(async (e) => {
          await C33.WaitForNextTask(), activeRPAFids.has(n) && (activeRPAFids.delete(n), t(e));
        });
        return activeRPAFids.add(n), n;
      }, C33.CancelPostAnimationFrame = function(e) {
        activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));
      };
    }
    {
      const C33 = self.C3;
      C33.IsAbsoluteURL = function(e) {
        return /^(?:[a-z\-]+:)?\/\//.test(e) || "data:" === e.substr(0, 5) || "blob:" === e.substr(0, 5);
      }, C33.IsRelativeURL = function(e) {
        return !C33.IsAbsoluteURL(e);
      }, C33.ThrowIfNotOk = function(e) {
        if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ` + e.statusText);
      }, C33.FetchOk = function(e, t) {
        return fetch(e, t).then((e2) => (C33.ThrowIfNotOk(e2), e2));
      }, C33.FetchText = function(e) {
        return C33.FetchOk(e).then((e2) => e2.text());
      }, C33.FetchJson = function(e) {
        return C33.FetchOk(e).then((e2) => e2.json());
      }, C33.FetchBlob = function(e) {
        return C33.FetchOk(e).then((e2) => e2.blob());
      }, C33.FetchArrayBuffer = function(e) {
        return C33.FetchOk(e).then((e2) => e2.arrayBuffer());
      }, C33.FetchImage = function(r) {
        return new Promise((e, t) => {
          const n = new Image();
          n.onload = () => e(n), n.onerror = (e2) => t(e2), n.src = r;
        });
      }, C33.BlobToArrayBuffer = function(r) {
        return "function" == typeof r["arrayBuffer"] ? r["arrayBuffer"]() : new Promise((e, t) => {
          const n = new FileReader();
          n.onload = () => e(n.result), n.onerror = () => t(n.error), n.readAsArrayBuffer(r);
        });
      }, C33.BlobToString = function(r) {
        return "function" == typeof r["text"] ? r["text"]() : new Promise((e, t) => {
          const n = new FileReader();
          n.onload = () => e(n.result), n.onerror = () => t(n.error), n.readAsText(r);
        });
      }, C33.BlobToJson = function(e) {
        return C33.BlobToString(e).then((e2) => JSON.parse(e2));
      }, C33.BlobToImage = async function(e, t) {
        let n = URL.createObjectURL(e);
        try {
          const r = await C33.FetchImage(n);
          return URL.revokeObjectURL(n), n = "", t && "function" == typeof r["decode"] && await r["decode"](), r;
        } finally {
          n && URL.revokeObjectURL(n);
        }
      }, C33.CreateCanvas = function(e, t) {
        if ("undefined" == typeof document || "function" != typeof document.createElement) return new OffscreenCanvas(e, t);
        {
          const n = document.createElement("canvas");
          return n.width = e, n.height = t, n;
        }
      }, C33.CanvasToBlob = function(t, n, r) {
        if ("number" != typeof r && (r = 1), n = n || "image/png", r = C33.clamp(r, 0, 1), t["convertToBlob"]) return t["convertToBlob"]({ "type": n, "quality": r });
        if (t.toBlob) return new Promise((e) => t.toBlob(e, n, r));
        throw new Error("could not convert canvas to blob");
      }, C33.DrawableToBlob = function(e, t, n) {
        const r = C33.CreateCanvas(e.width, e.height), o = r.getContext("2d");
        return o.drawImage(e, 0, 0), C33.CanvasToBlob(r, t, n);
      }, C33.ImageDataToBlob = function(e, t, n) {
        if (C33.Supports.ImageBitmapOptions) return createImageBitmap(e, { "premultiplyAlpha": "none" }).then((e2) => C33.DrawableToBlob(e2, t, n));
        if (C33.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C33.DrawableToBlob(e2, t, n));
        {
          const r = C33.CreateCanvas(e.width, e.height), o = r.getContext("2d");
          return o.putImageData(e, 0, 0), C33.CanvasToBlob(r, t, n);
        }
      }, C33.CopySet = function(e, t) {
        e.clear();
        for (const n of t) e.add(n);
      }, C33.MapToObject = function(e) {
        const t = /* @__PURE__ */ Object.create(null);
        for (const [n, r] of e.entries()) t[n] = r;
        return t;
      }, C33.ObjectToMap = function(e, t) {
        t.clear();
        for (const [n, r] of Object.entries(e)) t.set(n, r);
      }, C33.ToSuperJSON = function t(e) {
        if ("object" != typeof e || null === e) return e;
        if (e instanceof Set) return { "_c3type_": "set", "data": [...e].map((e2) => t(e2)) };
        if (e instanceof Map) return { "_c3type_": "map", "data": [...e].map((e2) => [e2[0], t(e2[1])]) };
        {
          const n = /* @__PURE__ */ Object.create(null);
          for (const [r, o] of Object.entries(e)) n[r] = t(o);
          return n;
        }
      }, C33.FromSuperJSON = function t(e) {
        if ("object" == typeof e & null !== e) {
          if ("set" === e["_c3type_"]) return new Set(e["data"].map((e2) => t(e2)));
          if ("map" === e["_c3type_"]) return new Map(e["data"].map((e2) => [e2[0], t(e2[1])]));
          {
            const n = /* @__PURE__ */ Object.create(null);
            for (const [r, o] of Object.entries(e)) n[r] = t(o);
            return n;
          }
        }
        return e;
      }, C33.CSSToCamelCase = function(e) {
        if (e.startsWith("--")) return e;
        let t = "", n = false, r = 0;
        for (const o of e) "-" === o ? 0 < r && (n = true) : n ? (t += o.toUpperCase(), n = false) : t += o, ++r;
        return t;
      }, C33.IsIterator = function(e) {
        return "object" == typeof e && "function" == typeof e.next;
      }, C33.MakeFilledArray = function(t, n) {
        const r = [];
        if ("function" == typeof n) for (let e = 0; e < t; ++e) r.push(n());
        else for (let e = 0; e < t; ++e) r.push(n);
        return r;
      };
    }
    {
      let padTwoDigits2 = function(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
      }, hueToRGB2 = function(t, s, e) {
        return e < 0 && (e += 1), 1 < e && --e, e < 1 / 6 ? t + 6 * (s - t) * e : e < 0.5 ? s : e < 2 / 3 ? t + (s - t) * (2 / 3 - e) * 6 : t;
      };
      padTwoDigits = padTwoDigits2, hueToRGB = hueToRGB2;
      const C33 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
      C33.Color = class {
        constructor(t, s, e, r) {
          this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof C33.Color ? this.set(t) : this.setRgba(t || 0, s || 0, e || 0, r || 0);
        }
        setRgb(t, s, e) {
          return this._r = +t, this._g = +s, this._b = +e, this.clamp(), this;
        }
        setRgba(t, s, e, r) {
          return this._r = +t, this._g = +s, this._b = +e, this._a = +r, this.clamp(), this;
        }
        set(t) {
          return this._r = t._r, this._g = t._g, this._b = t._b, this._a = t._a, this;
        }
        copy(t) {
          return this.set(t);
        }
        add(t) {
          this._r += t._r, this._g += t._g, this._b += t._b, this._a += t._a, this.clamp();
        }
        addRgb(t, s, e, r = 0) {
          this._r += +t, this._g += +s, this._b += +e, this._a += +r, this.clamp();
        }
        diff(t) {
          this.setR(Math.max(this._r, t._r) - Math.min(this._r, t._r)), this.setG(Math.max(this._g, t._g) - Math.min(this._g, t._g)), this.setB(Math.max(this._b, t._b) - Math.min(this._b, t._b)), this.setA(Math.max(this._a, t._a) - Math.min(this._a, t._a)), this.clamp();
        }
        copyRgb(t) {
          this._r = t._r, this._g = t._g, this._b = t._b;
        }
        setR(t) {
          this._r = C33.clamp(+t, 0, 1);
        }
        getR() {
          return this._r;
        }
        setG(t) {
          this._g = C33.clamp(+t, 0, 1);
        }
        getG() {
          return this._g;
        }
        setB(t) {
          this._b = C33.clamp(+t, 0, 1);
        }
        getB() {
          return this._b;
        }
        setA(t) {
          this._a = C33.clamp(+t, 0, 1);
        }
        getA() {
          return this._a;
        }
        clone() {
          return C33.New(C33.Color, this._r, this._g, this._b, this._a);
        }
        toArray() {
          return [this._r, this._g, this._b, this._a];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s) {
          t[s++] = this._r, t[s++] = this._g, t[s++] = this._b, t[s] = this._a;
        }
        writeRGBToTypedArray(t, s) {
          t[s++] = this._r, t[s++] = this._g, t[s] = this._b;
        }
        equals(t) {
          return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a;
        }
        equalsIgnoringAlpha(t) {
          return this._r === t._r && this._g === t._g && this._b === t._b;
        }
        equalsRgb(t, s, e) {
          return this._r === t && this._g === s && this._b === e;
        }
        equalsRgba(t, s, e, r) {
          return this._r === t && this._g === s && this._b === e && this._a === r;
        }
        equalsF32Array(t, s) {
          return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b) && t[s + 3] === Math.fround(this._a);
        }
        equalsRGBF32Array(t, s) {
          return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b);
        }
        multiply(t) {
          this._r *= t._r, this._g *= t._g, this._b *= t._b, this._a *= t._a;
        }
        multiplyAlpha(t) {
          this._r *= t, this._g *= t, this._b *= t, this._a *= t;
        }
        premultiply() {
          return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;
        }
        unpremultiply() {
          return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;
        }
        clamp() {
          return this._r = C33.clamp(this._r, 0, 1), this._g = C33.clamp(this._g, 0, 1), this._b = C33.clamp(this._b, 0, 1), this._a = C33.clamp(this._a, 0, 1), this;
        }
        setFromRgbValue(t) {
          this._r = C33.GetRValue(t), this._g = C33.GetGValue(t), this._b = C33.GetBValue(t), this._a = C33.GetAValue(t);
        }
        getCssRgb(t, s, e) {
          const r = C33.IsFiniteNumber(t) ? t : this.getR(), i = C33.IsFiniteNumber(s) ? s : this.getG(), a = C33.IsFiniteNumber(e) ? e : this.getB();
          return `rgb(${100 * r}%, ${100 * i}%, ${100 * a}%)`;
        }
        getCssRgba(t, s, e, r) {
          const i = C33.IsFiniteNumber(t) ? t : this.getR(), a = C33.IsFiniteNumber(s) ? s : this.getG(), h = C33.IsFiniteNumber(e) ? e : this.getB(), n = C33.IsFiniteNumber(r) ? r : this.getA();
          return `rgba(${100 * i}%, ${100 * a}%, ${100 * h}%, ${n})`;
        }
        toHexString() {
          const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());
          return "#" + padTwoDigits2(t.toString(16)) + padTwoDigits2(s.toString(16)) + padTwoDigits2(e.toString(16));
        }
        parseHexString(t) {
          if ("string" != typeof t) return false;
          let s, e, r;
          if (3 === (t = "#" === (t = t.trim()).charAt(0) ? t.substr(1) : t).length) s = parseInt(t[0], 16) / 15, e = parseInt(t[1], 16) / 15, r = parseInt(t[2], 16) / 15;
          else {
            if (6 !== t.length) return false;
            s = parseInt(t.substr(0, 2), 16) / 255, e = parseInt(t.substr(2, 2), 16) / 255, r = parseInt(t.substr(4, 2), 16) / 255;
          }
          return isFinite(s) && this.setR(s), isFinite(e) && this.setG(e), isFinite(r) && this.setB(r), this.setA(1), true;
        }
        toCommaSeparatedRgb() {
          const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());
          return t + `, ${s}, ` + e;
        }
        toRgbArray() {
          const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());
          return [t, s, e];
        }
        parseCommaSeparatedRgb(t) {
          if ("string" != typeof t) return false;
          const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
          if (s.length < 3) return false;
          const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255;
          return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;
        }
        parseCommaSeparatedPercentageRgb(t) {
          if ("string" != typeof t) return false;
          const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
          if (s.length < 3) return false;
          const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100;
          return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;
        }
        parseCommaSeparatedRgba(t) {
          if ("string" != typeof t) return false;
          const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
          if (s.length < 4) return false;
          const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255, a = parseFloat(s[3].trim());
          return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;
        }
        parseCommaSeparatedPercentageRgba(t) {
          if ("string" != typeof t) return false;
          const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
          if (s.length < 4) return false;
          const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100, a = parseFloat(s[3].trim());
          return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;
        }
        parseString(t) {
          if ("string" != typeof t) return false;
          if ((t = t.replace(/\s+/, "")).includes(",")) {
            if (t.startsWith("rgb(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgb(t) : this.parseCommaSeparatedRgb(t);
            if (t.startsWith("rgba(")) return t.includes("%") ? this.parseCommaSeparatedPercentageRgba(t) : this.parseCommaSeparatedRgba(t);
            if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this.parseHSLString(t);
            {
              const s = t.split(",");
              return t.includes("%") ? 3 === s.length ? this.parseCommaSeparatedPercentageRgb(t) : 4 === s.length && this.parseCommaSeparatedPercentageRgba(t) : 3 === s.length ? this.parseCommaSeparatedRgb(t) : 4 === s.length && this.parseCommaSeparatedRgba(t);
            }
          }
          return this.parseHexString(t);
        }
        toJSON() {
          return [this._r, this._g, this._b, this._a];
        }
        setFromHSLA(t, s, e, r) {
          let i, a, h;
          if (t %= 360, s = C33.clamp(s, 0, 100), e = C33.clamp(e, 0, 100), r = C33.clamp(r, 0, 1), t /= 360, e /= 100, 0 === (s /= 100)) i = a = h = e;
          else {
            const n = e < 0.5 ? e * (1 + s) : e + s - e * s, _ = 2 * e - n;
            i = hueToRGB2(_, n, t + 1 / 3), a = hueToRGB2(_, n, t), h = hueToRGB2(_, n, t - 1 / 3);
          }
          return this.setR(i), this.setG(a), this.setB(h), this.setA(r), this;
        }
        parseHSLString(t) {
          const s = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), e = HSL_TEST.exec(s), r = HSLA_TEST.exec(s);
          return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r || 5 !== r.length || (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), 0));
        }
        toHSLAString() {
          const t = this._r, s = this._g, e = this._b, r = this._a, i = C33.Color.GetHue(t, s, e), a = C33.Color.GetSaturation(t, s, e), h = C33.Color.GetLuminosity(t, s, e);
          return `hsla(${i}, ${a}%, ${h}%, ${r})`;
        }
        toHSLAArray() {
          const t = this._r, s = this._g, e = this._b;
          return [C33.Color.GetHue(t, s, e), C33.Color.GetSaturation(t, s, e), C33.Color.GetLuminosity(t, s, e), this._a];
        }
        setFromJSON(t) {
          !Array.isArray(t) || t.length < 3 || (this._r = t[0], this._g = t[1], this._b = t[2], this._a = 4 <= t.length ? t[3] : 1);
        }
        set r(t) {
          this.setR(t);
        }
        get r() {
          return this.getR();
        }
        set g(t) {
          this.setG(t);
        }
        get g() {
          return this.getG();
        }
        set b(t) {
          this.setB(t);
        }
        get b() {
          return this.getB();
        }
        set a(t) {
          this.setA(t);
        }
        get a() {
          return this.getA();
        }
        setAtIndex(t, s) {
          switch (t) {
            case 0:
              this.setR(s);
              break;
            case 1:
              this.setG(s);
              break;
            case 2:
              this.setB(s);
              break;
            case 3:
              this.setA(s);
              break;
            default:
              throw new RangeError("invalid color index");
          }
        }
        getAtIndex(t) {
          switch (t) {
            case 0:
              return this.getR();
            case 1:
              return this.getG();
            case 2:
              return this.getB();
            case 3:
              return this.getA();
            default:
              throw new RangeError("invalid color index");
          }
        }
        static Equals(t, s) {
          let e, r;
          if (Array.isArray(t)) (e = new C33.Color()).setFromJSON(t);
          else {
            if (!(t instanceof C33.Color)) throw new Error("unexpected type");
            e = t;
          }
          if (Array.isArray(s)) (r = new C33.Color()).setFromJSON(s);
          else {
            if (!(s instanceof C33.Color)) throw new Error("unexpected type");
            r = s;
          }
          return e.equals(r);
        }
        static DiffChannel(t, s) {
          return C33.clamp(Math.max(t, s) - Math.min(t, s), 0, 1);
        }
        static Diff(t, s) {
          const e = new C33.Color();
          return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e.setA(Math.max(t._a, s._a) - Math.min(t._a, s._a)), e;
        }
        static DiffNoAlpha(t, s) {
          const e = new C33.Color(0, 0, 0, 1);
          return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e;
        }
        static GetHue(t, s, e) {
          const r = Math.max(t, s, e), i = Math.min(t, s, e);
          if (r === i) return 0;
          let a = 0;
          switch (r) {
            case t:
              a = (s - e) / (r - i) + (s < e ? 6 : 0);
              break;
            case s:
              a = (e - t) / (r - i) + 2;
              break;
            case e:
              a = (t - s) / (r - i) + 4;
          }
          return Math.round(a / 6 * 360);
        }
        static GetSaturation(t, s, e) {
          const r = Math.max(t, s, e), i = Math.min(t, s, e);
          if (r === i) return 0;
          const a = (r + i) / 2, h = r - i, n = 0.5 < a ? h / (2 - r - i) : h / (r + i);
          return Math.round(100 * n);
        }
        static GetLuminosity(t, s, e) {
          const r = Math.max(t, s, e), i = Math.min(t, s, e), a = (r + i) / 2;
          return r ? Math.round(100 * a) : 0;
        }
      }, C33.Color.White = Object.freeze(C33.New(C33.Color, 1, 1, 1, 1)), C33.Color.Black = Object.freeze(C33.New(C33.Color, 0, 0, 0, 1)), C33.Color.TransparentBlack = Object.freeze(C33.New(C33.Color, 0, 0, 0, 0));
    }
    var padTwoDigits;
    var hueToRGB;
    {
      const C33 = self.C3;
      C33.Vector2 = class {
        constructor(t, s) {
          this._x = 0, this._y = 0, t instanceof C33.Vector2 ? this.copy(t) : this.set(t || 0, s || 0);
        }
        set(t, s) {
          this._x = +t, this._y = +s;
        }
        copy(t) {
          this._x = t._x, this._y = t._y;
        }
        equals(t) {
          return this._x === t._x && this._y === t._y;
        }
        equalsValues(t, s) {
          return this._x === t && this._y === s;
        }
        equalsF32Array(t, s) {
          return t[s] === Math.fround(this._x) && t[s + 1] === Math.fround(this._y);
        }
        setX(t) {
          this._x = +t;
        }
        getX() {
          return this._x;
        }
        setY(t) {
          this._y = +t;
        }
        getY() {
          return this._y;
        }
        toArray() {
          return [this._x, this._y];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s) {
          t[s++] = this._x, t[s] = this._y;
        }
        offset(t, s) {
          this._x += +t, this._y += +s;
        }
        scale(t, s) {
          this._x *= t, this._y *= s;
        }
        divide(t, s) {
          this._x /= t, this._y /= s;
        }
        round() {
          this._x = Math.round(this._x), this._y = Math.round(this._y);
        }
        floor() {
          this._x = Math.floor(this._x), this._y = Math.floor(this._y);
        }
        ceil() {
          this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);
        }
        angle() {
          return C33.angleTo(0, 0, this._x, this._y);
        }
        lengthSquared() {
          return this._x * this._x + this._y * this._y;
        }
        length() {
          return Math.hypot(this._x, this._y);
        }
        rotatePrecalc(t, s) {
          const h = this._x * s - this._y * t;
          this._y = this._y * s + this._x * t, this._x = h;
        }
        rotate(t) {
          0 !== t && this.rotatePrecalc(Math.sin(t), Math.cos(t));
        }
        rotateAbout(t, s, h) {
          0 === t || s === this._x && h === this._y || (this._x -= s, this._y -= h, this.rotatePrecalc(Math.sin(t), Math.cos(t)), this._x += +s, this._y += +h);
        }
        move(t, s) {
          0 !== s && (this._x += Math.cos(t) * s, this._y += Math.sin(t) * s);
        }
        normalize() {
          const t = this.length();
          0 !== t && 1 !== t && (this._x /= t, this._y /= t);
        }
        clamp(t, s) {
          this._x = C33.clamp(this._x, t, s), this._y = C33.clamp(this._y, t, s);
        }
        dot(t) {
          return this._x * t._x + this._y * t._y;
        }
        reverse() {
          this._x = -this._x, this._y = -this._y;
        }
        perp() {
          let t = this._x;
          return this._x = this._y, this._y = -t, this;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Rect = class {
        constructor(t, h, i, o) {
          this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof C33.Rect ? this.copy(t) : this.set(t || 0, h || 0, i || 0, o || 0);
        }
        set(t, h, i, o) {
          this._left = +t, this._top = +h, this._right = +i, this._bottom = +o;
        }
        setWH(t, h, i, o) {
          h = +h, this._left = t = +t, this._top = h, this._right = t + +i, this._bottom = h + +o;
        }
        copy(t) {
          this._left = +t._left, this._top = +t._top, this._right = +t._right, this._bottom = +t._bottom;
        }
        clone() {
          return new C33.Rect(this._left, this._top, this._right, this._bottom);
        }
        static Merge(t, h) {
          const i = new C33.Rect();
          return i.setLeft(Math.min(t._left, h._left)), i.setTop(Math.min(t._top, h._top)), i.setRight(Math.max(t._right, h._right)), i.setBottom(Math.max(t._bottom, h._bottom)), i;
        }
        static FromObject(t) {
          return new C33.Rect(t.left, t.top, t.right, t.bottom);
        }
        equals(t) {
          return this._left === t._left && this._top === t._top && this._right === t._right && this._bottom === t._bottom;
        }
        equalsWH(t, h, i, o) {
          return this._left === t && this._top === h && this.width() === i && this.height() === o;
        }
        equalsF32Array(t, h) {
          return t[h] === Math.fround(this._left) && t[h + 1] === Math.fround(this._top) && t[h + 2] === Math.fround(this._right) && t[h + 3] === Math.fround(this._bottom);
        }
        setLeft(t) {
          this._left = +t;
        }
        getLeft() {
          return this._left;
        }
        setTop(t) {
          this._top = +t;
        }
        getTop() {
          return this._top;
        }
        setRight(t) {
          this._right = +t;
        }
        getRight() {
          return this._right;
        }
        setBottom(t) {
          this._bottom = +t;
        }
        getBottom() {
          return this._bottom;
        }
        toArray() {
          return [this._left, this._top, this._right, this._bottom];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        toDOMRect() {
          return new DOMRect(this._left, this._top, this.width(), this.height());
        }
        static fromDOMRect(t) {
          return C33.New(C33.Rect, t.left, t.top, t.right, t.bottom);
        }
        writeToTypedArray(t, h) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h] = this._bottom;
        }
        writeAsQuadToTypedArray(t, h) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h++] = this._top, t[h++] = this._right, t[h++] = this._bottom, t[h++] = this._left, t[h] = this._bottom;
        }
        writeAsQuadToTypedArray3D(t, h, i) {
          t[h++] = this._left, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._bottom, t[h++] = i, t[h++] = this._left, t[h++] = this._bottom, t[h] = i;
        }
        width() {
          return this._right - this._left;
        }
        height() {
          return this._bottom - this._top;
        }
        midX() {
          return (this._left + this._right) / 2;
        }
        midY() {
          return (this._top + this._bottom) / 2;
        }
        offset(t, h) {
          h = +h, this._left += t = +t, this._top += h, this._right += t, this._bottom += h;
        }
        offsetLeft(t) {
          this._left += +t;
        }
        offsetTop(t) {
          this._top += +t;
        }
        offsetRight(t) {
          this._right += +t;
        }
        offsetBottom(t) {
          this._bottom += +t;
        }
        toSquare(t) {
          if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
          this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();
        }
        inflate(t, h) {
          h = +h, this._left -= t = +t, this._top -= h, this._right += t, this._bottom += h;
        }
        deflate(t, h) {
          h = +h, this._left += t = +t, this._top += h, this._right -= t, this._bottom -= h;
        }
        multiply(t, h) {
          this._left *= t, this._top *= h, this._right *= t, this._bottom *= h;
        }
        divide(t, h) {
          this._left /= t, this._top /= h, this._right /= t, this._bottom /= h;
        }
        mirrorAround(t) {
          this._left = +t - this._left, this._right = +t - this._right;
        }
        flipAround(t) {
          this._top = +t - this._top, this._bottom = +t - this._bottom;
        }
        rotate90DegreesAround(t, h) {
          const i = this.width(), o = this.height(), s = this.getLeft() + i * t, _ = this.getTop() + o * h;
          this.setWH(s - o * h, _ - i * t, o, i);
        }
        swapLeftRight() {
          const t = this._left;
          this._left = this._right, this._right = t;
        }
        swapTopBottom() {
          const t = this._top;
          this._top = this._bottom, this._bottom = t;
        }
        shuntY(t) {
          const h = this._top;
          this._top = +t - this._bottom, this._bottom = +t - h;
        }
        round() {
          this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);
        }
        roundInner() {
          this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
        }
        roundOuter() {
          this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
        }
        floor() {
          this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
        }
        ceil() {
          this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
        }
        clamp(t, h, i, o) {
          this._left = Math.max(this._left, +t), this._top = Math.max(this._top, +h), this._right = Math.min(this._right, +i), this._bottom = Math.min(this._bottom, +o);
        }
        clampBoth(t, h, i, o) {
          t = +t, h = +h, i = +i, o = +o, this._left = C33.clamp(this._left, t, i), this._top = C33.clamp(this._top, h, o), this._right = C33.clamp(this._right, t, i), this._bottom = C33.clamp(this._bottom, h, o);
        }
        normalize() {
          this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();
        }
        intersectsRect(t) {
          return !(t._right < this._left || t._bottom < this._top || t._left > this._right || t._top > this._bottom);
        }
        intersectsRectOffset(t, h, i) {
          return !(t._right + h < this._left || t._bottom + i < this._top || t._left + h > this._right || t._top + i > this._bottom);
        }
        containsPoint(t, h) {
          return t >= this._left && t <= this._right && h >= this._top && h <= this._bottom;
        }
        containsRect(t) {
          return t._left >= this._left && t._top >= this._top && t._right <= this._right && t._bottom <= this._bottom;
        }
        expandToContain(t) {
          t._left < this._left && (this._left = +t._left), t._top < this._top && (this._top = +t._top), t._right > this._right && (this._right = +t._right), t._bottom > this._bottom && (this._bottom = +t._bottom);
        }
        lerpInto(t) {
          this._left = C33.lerp(t._left, t._right, this._left), this._top = C33.lerp(t._top, t._bottom, this._top), this._right = C33.lerp(t._left, t._right, this._right), this._bottom = C33.lerp(t._top, t._bottom, this._bottom);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Quad = class {
        constructor(t, s, i, h, _, r, l, e) {
          this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof C33.Quad ? this.copy(t) : this.set(t || 0, s || 0, i || 0, h || 0, _ || 0, r || 0, l || 0, e || 0);
        }
        set(t, s, i, h, _, r, l, e) {
          this._tlx = +t, this._tly = +s, this._trx = +i, this._try = +h, this._brx = +_, this._bry = +r, this._blx = +l, this._bly = +e;
        }
        setRect(t, s, i, h) {
          this.set(t, s, i, s, i, h, t, h);
        }
        copy(t) {
          this._tlx = t._tlx, this._tly = t._tly, this._trx = t._trx, this._try = t._try, this._brx = t._brx, this._bry = t._bry, this._blx = t._blx, this._bly = t._bly;
        }
        equals(t) {
          return this._tlx === t._tlx && this._tly === t._tly && this._trx === t._trx && this._try === t._try && this._brx === t._brx && this._bry === t._bry && this._blx === t._blx && this._bly === t._bly;
        }
        setTlx(t) {
          this._tlx = +t;
        }
        getTlx() {
          return this._tlx;
        }
        setTly(t) {
          this._tly = +t;
        }
        getTly() {
          return this._tly;
        }
        setTrx(t) {
          this._trx = +t;
        }
        getTrx() {
          return this._trx;
        }
        setTry(t) {
          this._try = +t;
        }
        getTry() {
          return this._try;
        }
        setBrx(t) {
          this._brx = +t;
        }
        getBrx() {
          return this._brx;
        }
        setBry(t) {
          this._bry = +t;
        }
        getBry() {
          return this._bry;
        }
        setBlx(t) {
          this._blx = +t;
        }
        getBlx() {
          return this._blx;
        }
        setBly(t) {
          this._bly = +t;
        }
        getBly() {
          return this._bly;
        }
        toDOMQuad() {
          return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));
        }
        static fromDOMQuad(t) {
          return C33.New(C33.Quad, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
        }
        toArray() {
          return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];
        }
        toTypedArray() {
          return new Float64Array(this.toArray());
        }
        writeToTypedArray(t, s) {
          t[s++] = this._tlx, t[s++] = this._tly, t[s++] = this._trx, t[s++] = this._try, t[s++] = this._brx, t[s++] = this._bry, t[s++] = this._blx, t[s] = this._bly;
        }
        writeToTypedArray3D(t, s, i) {
          t[s++] = this._tlx, t[s++] = this._tly, t[s++] = i, t[s++] = this._trx, t[s++] = this._try, t[s++] = i, t[s++] = this._brx, t[s++] = this._bry, t[s++] = i, t[s++] = this._blx, t[s++] = this._bly, t[s] = i;
        }
        offset(t, s) {
          s = +s, this._tlx += t = +t, this._tly += s, this._trx += t, this._try += s, this._brx += t, this._bry += s, this._blx += t, this._bly += s;
        }
        round() {
          this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);
        }
        floor() {
          this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);
        }
        ceil() {
          this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);
        }
        setFromRect(t) {
          this._tlx = t._left, this._tly = t._top, this._trx = t._right, this._try = t._top, this._brx = t._right, this._bry = t._bottom, this._blx = t._left, this._bly = t._bottom;
        }
        setFromRotatedRect(t, s) {
          0 === s ? this.setFromRect(t) : this.setFromRotatedRectPrecalc(t, Math.sin(s), Math.cos(s));
        }
        setFromRotatedRectPrecalc(t, s, i) {
          const h = t._left * s, _ = t._top * s, r = t._right * s, l = t._bottom * s, e = t._left * i, x = t._top * i, y = t._right * i, b = t._bottom * i;
          this._tlx = e - _, this._tly = x + h, this._trx = y - _, this._try = x + r, this._brx = y - l, this._bry = b + r, this._blx = e - l, this._bly = b + h;
        }
        getBoundingBox(t) {
          t.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));
        }
        containsPoint(t, s) {
          let i = this._trx - this._tlx, h = this._try - this._tly;
          const _ = this._brx - this._tlx, r = this._bry - this._tly, l = t - this._tlx, e = s - this._tly;
          let x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e;
          const a = _ * _ + r * r, n = _ * l + r * e;
          let o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o;
          return 0 <= c && 0 < u && c + u < 1 || (u = ((x = (i = this._blx - this._tlx) * i + (h = this._bly - this._tly) * h) * n - (y = i * _ + h * r) * (b = i * l + h * e)) * (o = 1 / (x * a - y * y)), 0 <= (c = (a * b - y * n) * o) && 0 < u && c + u < 1);
        }
        midX() {
          return (this._tlx + this._trx + this._brx + this._blx) / 4;
        }
        midY() {
          return (this._tly + this._try + this._bry + this._bly) / 4;
        }
        intersectsSegment(t, s, i, h) {
          return !(!this.containsPoint(t, s) && !this.containsPoint(i, h)) || C33.segmentIntersectsQuad(t, s, i, h, this);
        }
        intersectsQuad(t) {
          let s = t.midX(), i = t.midY();
          if (this.containsPoint(s, i)) return true;
          if (s = this.midX(), i = this.midY(), t.containsPoint(s, i)) return true;
          const h = this._tlx, _ = this._tly, r = this._trx, l = this._try, e = this._brx, x = this._bry, y = this._blx, b = this._bly;
          return C33.segmentIntersectsQuad(h, _, r, l, t) || C33.segmentIntersectsQuad(r, l, e, x, t) || C33.segmentIntersectsQuad(e, x, y, b, t) || C33.segmentIntersectsQuad(y, b, h, _, t);
        }
        rotatePointsAnticlockwise() {
          const t = this._tlx, s = this._tly;
          this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t, this._bly = s;
        }
        mirror() {
          this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);
        }
        flip() {
          this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);
        }
        diag() {
          this._swap(2, 6), this._swap(3, 7);
        }
        _swap(t, s) {
          const i = this._getAtIndex(t);
          this._setAtIndex(t, this._getAtIndex(s)), this._setAtIndex(s, i);
        }
        _getAtIndex(t) {
          switch (t) {
            case 0:
              return this._tlx;
            case 1:
              return this._tly;
            case 2:
              return this._trx;
            case 3:
              return this._try;
            case 4:
              return this._brx;
            case 5:
              return this._bry;
            case 6:
              return this._blx;
            case 7:
              return this._bly;
            default:
              throw new RangeError("invalid quad point index");
          }
        }
        _setAtIndex(t, s) {
          switch (s = +s, t) {
            case 0:
              this._tlx = s;
              break;
            case 1:
              this._tly = s;
              break;
            case 2:
              this._trx = s;
              break;
            case 3:
              this._try = s;
              break;
            case 4:
              this._brx = s;
              break;
            case 5:
              this._bry = s;
              break;
            case 6:
              this._blx = s;
              break;
            case 7:
              this._bly = s;
              break;
            default:
              throw new RangeError("invalid quad point index");
          }
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C33.New(C33.Quad);
      C33.CollisionPoly = class extends C33.DefendedBase {
        constructor(t, s = true) {
          super(), t = t || DEFAULT_POLY_POINTS, this._ptsArr = Float64Array.from(t), this._bbox = new C33.Rect(), this._isBboxChanged = true, this._enabled = s;
        }
        Release() {
        }
        pointsArr() {
          return this._ptsArr;
        }
        pointCount() {
          return this._ptsArr.length / 2;
        }
        setPoints(t) {
          this._ptsArr.length === t.length ? this._ptsArr.set(t) : this._ptsArr = Float64Array.from(t), this._isBboxChanged = true;
        }
        setDefaultPoints() {
          this.setPoints(DEFAULT_POLY_POINTS);
        }
        copy(t) {
          this.setPoints(t._ptsArr);
        }
        setBboxChanged() {
          this._isBboxChanged = true;
        }
        _updateBbox() {
          if (this._isBboxChanged) {
            const i = this._ptsArr;
            let e = i[0], r = i[1], n = e, o = r;
            for (let t = 0, s = i.length; t < s; t += 2) {
              const h = i[t], l = i[t + 1];
              h < e && (e = h), h > n && (n = h), l < r && (r = l), l > o && (o = l);
            }
            this._bbox.set(e, r, n, o), this._isBboxChanged = false;
          }
        }
        setFromRect(t, s, e) {
          let r = this._ptsArr;
          8 !== r.length && (r = new Float64Array(8), this._ptsArr = r), r[0] = t.getLeft() - s, r[1] = t.getTop() - e, r[2] = t.getRight() - s, r[3] = t.getTop() - e, r[4] = t.getRight() - s, r[5] = t.getBottom() - e, r[6] = t.getLeft() - s, r[7] = t.getBottom() - e, this._bbox.copy(t), 0 === s && 0 === e || this._bbox.offset(-s, -e), this._isBboxChanged = false;
        }
        setFromQuad(t, s, e) {
          tempQuad.copy(t), tempQuad.offset(s, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;
        }
        transform(t, s, e) {
          let r = 0, n = 1;
          0 !== e && (r = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t, s, r, n);
        }
        transformPrecalc(e, r, n, o) {
          const i = this._ptsArr;
          for (let t = 0, s = i.length; t < s; t += 2) {
            const h = t + 1, l = i[t] * e, a = i[h] * r;
            i[t] = l * o - a * n, i[h] = a * o + l * n;
          }
          this._isBboxChanged = true;
        }
        offset(e, r) {
          const n = this._ptsArr;
          for (let t = 0, s = n.length; t < s; t += 2) n[t] += e, n[t + 1] += r;
        }
        containsPoint(e, r) {
          const n = this._ptsArr;
          if (e === n[0] && r === n[1]) return true;
          this._updateBbox();
          const t = this._bbox, o = t.getLeft() - 110, i = t.getTop() - 101, h = t.getRight() + 131, l = t.getBottom() + 120;
          let a = 0, c = 0, g = 0, _ = 0, p = 0, f = 0, u = 0, C = 0, A = (g = o < e ? (a = o, e) : (a = e, o), _ = i < r ? (c = i, r) : (c = r, i), u = h < e ? (p = h, e) : (p = e, h), C = l < r ? (f = l, r) : (f = r, l), 0), d = 0;
          for (let t2 = 0, s = n.length; t2 < s; t2 += 2) {
            const b = (t2 + 2) % s, P = n[t2], m = n[t2 + 1], x = n[b], B = n[1 + b];
            C33.segmentsIntersectPreCalc(o, i, e, r, a, g, c, _, P, m, x, B) && ++A, C33.segmentsIntersectPreCalc(h, l, e, r, p, u, f, C, P, m, x, B) && ++d;
          }
          return A % 2 == 1 || d % 2 == 1;
        }
        intersectsPoly(t, i, h) {
          const l = t._ptsArr, a = this._ptsArr;
          if (this.containsPoint(l[0] + i, l[1] + h)) return true;
          if (t.containsPoint(a[0] - i, a[1] - h)) return true;
          for (let t2 = 0, s = a.length; t2 < s; t2 += 2) {
            const c = (t2 + 2) % s, g = a[t2], _ = a[t2 + 1], p = a[c], f = a[1 + c];
            let e = 0, r = 0, n = 0, o = 0;
            n = g < p ? (e = g, p) : (e = p, g), o = _ < f ? (r = _, f) : (r = f, _);
            for (let t3 = 0, s2 = l.length; t3 < s2; t3 += 2) {
              const u = (t3 + 2) % s2, C = l[t3] + i, A = l[t3 + 1] + h, d = l[u] + i, b = l[1 + u] + h;
              if (C33.segmentsIntersectPreCalc(g, _, p, f, e, n, r, o, C, A, d, b)) return true;
            }
          }
          return false;
        }
        intersectsSegment(e, r, n, o, i, h) {
          if (this.containsPoint(n - e, o - r)) return true;
          if (this.containsPoint(i - e, h - r)) return true;
          let l = 0, a = 0, c = 0, g = 0;
          c = n < i ? (l = n, i) : (l = i, n), g = o < h ? (a = o, h) : (a = h, o);
          const _ = this._ptsArr;
          for (let t = 0, s = _.length; t < s; t += 2) {
            const p = (t + 2) % s, f = _[t] + e, u = _[t + 1] + r, C = _[p] + e, A = _[1 + p] + r;
            if (C33.segmentsIntersectPreCalc(n, o, i, h, l, c, a, g, f, u, C, A)) return true;
          }
          return false;
        }
        mirror(e) {
          const r = this._ptsArr;
          for (let t = 0, s = r.length; t < s; t += 2) r[t] = 2 * e - r[t];
          this._isBboxChanged = true;
        }
        flip(e) {
          const r = this._ptsArr;
          for (let t = 0, s = r.length; t < s; t += 2) {
            const n = t + 1;
            r[n] = 2 * e - r[n];
          }
          this._isBboxChanged = true;
        }
        diag() {
          const e = this._ptsArr;
          for (let t = 0, s = e.length; t < s; t += 2) {
            const r = t + 1, n = e[t];
            e[t] = e[r], e[r] = n;
          }
          this._isBboxChanged = true;
        }
        GetMidX() {
          const e = this._ptsArr;
          let r = 0;
          for (let t = 0, s = e.length; t < s; t += 2) r += e[t];
          return r / this.pointCount();
        }
        GetMidY() {
          const e = this._ptsArr;
          let r = 0;
          for (let t = 0, s = e.length; t < s; t += 2) r += e[t + 1];
          return r / this.pointCount();
        }
        GetPointsArray() {
          return this._ptsArr;
        }
        GetPointCount() {
          return this.pointCount();
        }
        IsEnabled() {
          return this._enabled;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PairMap = class extends C33.DefendedBase {
        constructor(e) {
          if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t, s, r] of e) this.Set(t, s, r);
        }
        Release() {
          this.Clear(), this._firstMap = null;
        }
        IsEmpty() {
          return 0 === this._firstMap.size;
        }
        Clear() {
          const e = this._firstMap;
          for (const t of e.values()) t.clear();
          e.clear();
        }
        Set(e, t, s) {
          const r = this._firstMap;
          let i = r.get(e);
          i || (i = /* @__PURE__ */ new Map(), r.set(e, i)), i.set(t, s);
        }
        Get(e, t) {
          const s = this._firstMap.get(e);
          return s && s.get(t);
        }
        Has(e, t) {
          const s = this._firstMap.get(e);
          return !!s && s.has(t);
        }
        Delete(e, t) {
          const s = this._firstMap, r = s.get(e);
          if (!r) return false;
          const i = r.delete(t);
          return i && 0 === r.size && s.delete(e), i;
        }
        DeleteEither(e) {
          const t = this._firstMap, s = t.get(e);
          s && (s.clear(), t.delete(e));
          for (const [r, s2] of t.entries()) s2.delete(e) && 0 === s2.size && t.delete(r);
        }
        GetSize() {
          let e = 0;
          for (const t of this._firstMap.values()) e += t.size;
          return e;
        }
        *values() {
          for (const e of this._firstMap.values()) yield* e.values();
        }
        *keyPairs() {
          for (const [e, t] of this._firstMap.entries()) for (const s of t.keys()) yield [e, s];
        }
        *entries() {
          for (const [e, t] of this._firstMap.entries()) for (const [s, r] of t.entries()) yield [e, s, r];
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ArraySet = class extends C33.DefendedBase {
        constructor() {
          super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;
        }
        Release() {
          this.Clear();
        }
        Clear() {
          this._set.clear(), C33.clearArray(this._arr), this._needToRebuildArray = false;
        }
        Add(e) {
          this._set.has(e) || (this._set.add(e), this._needToRebuildArray) || this._arr.push(e);
        }
        Has(e) {
          return this._set.has(e);
        }
        Delete(e) {
          this._set.delete(e) && (this._needToRebuildArray = true);
        }
        GetSize() {
          return this._set.size;
        }
        IsEmpty() {
          return 0 === this._set.size;
        }
        GetArray() {
          return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;
        }
        _RebuildArray() {
          const e = this._arr;
          C33.clearArray(e);
          for (const r of this._set) e.push(r);
        }
      };
    }
    {
      const C33 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map(), EASE_TRANSLATION_KEYS = (ALIAS_MAP.set("linear", "noease"), ALIAS_MAP.set("default", "noease"), ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"]), SHORT_EASE_TRANSLATION_KEYS = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]), SAMPLE_COUNT = (self.Ease = class d {
        constructor() {
        }
        static InheritEase() {
          return "default";
        }
        static DefaultEase() {
          return "noease";
        }
        static ToInternal(e) {
          return EASE_API2INTERNAL_NAMES.get(e);
        }
        static GetEditorEaseNames(a2, ...s) {
          this._CreateEaseMap();
          let e, t;
          const i = (t = a2 ? (CUSTOM_EASE_EDITOR_MAP.has(a2) || CUSTOM_EASE_EDITOR_MAP.set(a2, /* @__PURE__ */ new Map()), [...(e = CUSTOM_EASE_EDITOR_MAP.get(a2)).keys()].filter((e2) => !d.GetEditorEaseData(e2, a2) || d.GetEditorEaseData(e2, a2).transition.IsForAnyPurpose())) : [...(e = CUSTOM_EASE_RUNTIME_MAP).keys()]).sort();
          return [...PREDEFINED_EASE_MAP.keys()].concat(i).filter((e2) => !s.includes(e2));
        }
        static GetRuntimeEaseNames() {
          this._CreateEaseMap();
          const e = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
          return e.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e);
        }
        static GetCustomRuntimeEaseNames() {
          this._CreateEaseMap();
          const e = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
          return e.sort(), e;
        }
        static IsPredefinedTranslatedName(e) {
          for (const a2 of EASE_TRANSLATION_KEYS) {
            const s = self.lang("ui.bars.timeline.eases." + a2);
            if (s === e) return true;
          }
          for (const t of SHORT_EASE_TRANSLATION_KEYS) {
            const i = self.lang("ui.bars.timeline.short-eases." + t);
            if (i === e) return true;
          }
        }
        static IsNamePredefined(e) {
          return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e);
        }
        static _GetEase(e) {
          const a2 = ALIAS_MAP.get(e);
          return a2 ? EASE_MAP.get(a2) : d.IsNamePredefined(e) ? EASE_MAP.get(e) : PRIVATE_EASE_MAP.has(e) ? PRIVATE_EASE_MAP.get(e) : void 0;
        }
        static GetBuiltInTransition(e) {
          return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e);
        }
        static GetEditorEase(e, a2) {
          this._CreateEaseMap();
          const s = d._GetEase(e);
          if (s) return s;
          if (a2) return CUSTOM_EASE_EDITOR_MAP.get(a2).get(e);
          throw new Error("missing ease function");
        }
        static GetEditorEaseData(e, a2) {
          this._CreateEaseMap();
          const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);
          if (s) return s.get(e);
        }
        static HasEditorEase(e, a2) {
          this._CreateEaseMap();
          const s = d._GetEase(e);
          return !!s || !!CUSTOM_EASE_EDITOR_MAP.get(a2).get(e);
        }
        static GetRuntimeEase(e) {
          this._CreateEaseMap();
          const a2 = d._GetEase(e);
          return a2 || CUSTOM_EASE_RUNTIME_MAP.get(e);
        }
        static GetRuntimeEaseData(e) {
          return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e);
        }
        static GetEaseFromIndex(e) {
          this._CreateEaseMap();
          const a2 = this.GetRuntimeEaseNames();
          return a2[e];
        }
        static GetIndexForEase(e, a2) {
          this._CreateEaseMap();
          const s = this.GetEditorEaseNames(a2);
          return s.indexOf(e);
        }
        static GetIndexForEaseAtRuntime(e) {
          return this.GetIndexForEase(e);
        }
        static _CreateEaseMap() {
          0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {
          }), this._AddPredifinedEase("noease", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }], true), this._AddPredifinedEase("easeinsine", [{ "x": 0, "y": 0, "sax": 0.485, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutsine", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.485, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutsine", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinelastic", [{ "x": 0, "y": 0, "sax": 0.018, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.116, "y": 2e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.266, "y": -5e-3, "sax": 0.024, "say": 0, "eax": -0.021, "eay": 0, "se": true, "ee": true }, { "x": 0.416, "y": 0.016, "sax": 0.024, "say": 0, "eax": -0.026, "eay": 0, "se": true, "ee": true }, { "x": 0.566, "y": -0.045, "sax": 0.061, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.716, "y": 0.132, "sax": 0.072, "say": -4e-3, "eax": -0.045, "eay": 0, "se": true, "ee": true }, { "x": 0.866, "y": -0.373, "sax": 0.06, "say": 0, "eax": -0.049, "eay": -2e-3, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": -0.263, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutelastic", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0.263, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.136, "y": 1.373, "sax": 0.049, "say": 2e-3, "eax": -0.06, "eay": 0, "se": true, "ee": true }, { "x": 0.286, "y": 0.868, "sax": 0.045, "say": 0, "eax": -0.072, "eay": 4e-3, "se": true, "ee": true }, { "x": 0.436, "y": 1.045, "sax": 0.025, "say": 0, "eax": -0.061, "eay": 0, "se": true, "ee": true }, { "x": 0.586, "y": 0.984, "sax": 0.026, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.736, "y": 1.005, "sax": 0.021, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.886, "y": 0.998, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.018, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutelastic", [{ "x": 0, "y": 0, "sax": 0.025, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.067, "y": 1e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.18, "y": -5e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.292, "y": 0.025, "sax": 0.053, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.405, "y": -0.118, "sax": 0.069, "say": 0, "eax": -0.027, "eay": 0, "se": true, "ee": true }, { "x": 0.597, "y": 1.118, "sax": 0.027, "say": 0, "eax": -0.069, "eay": 0, "se": true, "ee": true }, { "x": 0.71, "y": 0.975, "sax": 0.025, "say": 0, "eax": -0.053, "eay": 0, "se": true, "ee": true }, { "x": 0.822, "y": 1.005, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.935, "y": 0.999, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.025, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinback", [{ "x": 0, "y": 0, "sax": 0.35, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.34, "eay": -1.579, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutback", [{ "x": 0, "y": 0, "sax": 0.34, "say": 1.579, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.35, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutback", [{ "x": 0, "y": 0, "sax": 0.035, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.242, "y": -0.1, "sax": 0.258, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.76, "y": 1.1, "sax": 0.025, "say": 0, "eax": -0.26, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.035, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinbounce", [{ "x": 0, "y": 0, "sax": 0.033, "say": 0.025, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.092, "y": 0, "sax": 0.026, "say": 0.078, "eax": -0.033, "eay": 0.025, "se": true, "ee": true }, { "x": 0.274, "y": 0, "sax": 0.097, "say": 0.319, "eax": -0.026, "eay": 0.078, "se": true, "ee": true }, { "x": 0.637, "y": 0, "sax": 0.105, "say": 0.625, "eax": -0.097, "eay": 0.319, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": -4e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutbounce", [{ "x": 0, "y": 0, "sax": 0.125, "say": 4e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.365, "y": 1, "sax": 0.097, "say": -0.319, "eax": -0.105, "eay": -0.625, "se": true, "ee": true }, { "x": 0.728, "y": 1, "sax": 0.026, "say": -0.078, "eax": -0.097, "eay": -0.319, "se": true, "ee": true }, { "x": 0.91, "y": 1, "sax": 0.033, "say": -0.025, "eax": -0.026, "eay": -0.078, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.033, "eay": -0.025, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutbounce", [{ "x": 0, "y": 0, "sax": 0.01, "say": 6e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.046, "y": 0, "sax": 0.021, "say": 0.038, "eax": -0.01, "eay": 6e-3, "se": true, "ee": true }, { "x": 0.137, "y": 0, "sax": 0.059, "say": 0.158, "eax": -0.021, "eay": 0.038, "se": true, "ee": true }, { "x": 0.319, "y": 0, "sax": 0.117, "say": 0.744, "eax": -0.059, "eay": 0.158, "se": true, "ee": true }, { "x": 0.683, "y": 1, "sax": 0.059, "say": -0.158, "eax": -0.117, "eay": -0.744, "se": true, "ee": true }, { "x": 0.865, "y": 1, "sax": 0.021, "say": -0.038, "eax": -0.059, "eay": -0.158, "se": true, "ee": true }, { "x": 0.956, "y": 1, "sax": 0.01, "say": -6e-3, "eax": -0.021, "eay": -0.038, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.01, "eay": -6e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeincubic", [{ "x": 0, "y": 0, "sax": 0.75, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.138, "eay": -0.321, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcubic", [{ "x": 0, "y": 0, "sax": 0.138, "say": 0.321, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.75, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcubic", [{ "x": 0, "y": 0, "sax": 0.285, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.081, "say": 0.272, "eax": -0.081, "eay": -0.272, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.285, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquad", [{ "x": 0, "y": 0, "sax": 0.4, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.178, "eay": -0.392, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquad", [{ "x": 0, "y": 0, "sax": 0.178, "say": 0.392, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.4, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquad", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.03, "say": 0.065, "eax": -0.03, "eay": -0.065, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquart", [{ "x": 0, "y": 0, "sax": 0.25, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.5, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquart", [{ "x": 0, "y": 0, "sax": 0.5, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquart", [{ "x": 0, "y": 0, "sax": 0.765, "say": 0.03, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.765, "eay": -0.03, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquint", [{ "x": 0, "y": 0, "sax": 0.6, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.2, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquint", [{ "x": 0, "y": 0, "sax": 0.2, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.6, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquint", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.84, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.84, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPredifinedEase("easeincirc", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.024, "eay": -0.808, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcirc", [{ "x": 0, "y": 0, "sax": 0.024, "say": 0.808, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcirc", [{ "x": 0, "y": 0, "sax": 0.125, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.02, "say": 0.428, "eax": -0.02, "eay": -0.428, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinexpo", [{ "x": 0, "y": 0, "sax": 0.66, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.14, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutexpo", [{ "x": 0, "y": 0, "sax": 0.14, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.66, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutexpo", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.345, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.06, "eay": -0.5, "ee": true, "sax": 0.06, "say": 0.5, "se": true, "x": 0.5, "y": 0.5 }, { "eax": -0.335, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline));
        }
        static _AddPredifinedEase(e, a2, s = false) {
          if ("function" == typeof a2) d._AddEase(e, a2, "predefined");
          else {
            if (!C33.IsArray(a2)) throw new Error("unexpected arguments");
            if (self.BuiltInTransition) {
              const i = C33.New(self.BuiltInTransition, e, s);
              i.SetFromJson(a2), d._AddEase(e, (e2, a3, s2, t) => i.Interpolate(e2, a3, s2, t), "predefined"), BUILT_IN_TRANSITION_MAP.set(e, i);
            } else {
              const x = C33.New(C33.Transition, [e, a2.map((e2) => [e2["x"], e2["y"], e2["sax"], e2["say"], e2["eax"], e2["eay"], e2["se"], e2["ee"]])], false);
              x.MakeLinear(s), d._AddEase(e, (e2, a3, s2, t) => x.Interpolate(e2, a3, s2, t), "predefined");
            }
          }
        }
        static _AddPrivateCustomEase(e, a2) {
          d._AddEase(e, a2, "private");
        }
        static AddCustomEase(e, a2, s, t) {
          this._CreateEaseMap(), d._AddEase(e, a2, "custom", s, t);
        }
        static RemoveCustomEase(e, a2) {
          if (!this.IsNamePredefined(e) && ![...PRIVATE_EASE_MAP.keys()].includes(e)) {
            const s = CUSTOM_EASE_EDITOR_MAP.get(a2), t = (s && s.delete(e), CUSTOM_EASE_DATA_EDITOR_MAP.get(a2));
            t && t.delete(e);
          }
        }
        static _AddEase(e, a2, s, t, i) {
          switch (s) {
            case "predefined":
              EASE_MAP.set(e, a2), PREDEFINED_EASE_MAP.set(e, a2);
              break;
            case "custom":
              if (t) {
                CUSTOM_EASE_EDITOR_MAP.has(t) || CUSTOM_EASE_EDITOR_MAP.set(t, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t, /* @__PURE__ */ new Map());
                const x = CUSTOM_EASE_EDITOR_MAP.get(t), y = (x.set(e, a2), CUSTOM_EASE_DATA_EDITOR_MAP.get(t));
                y.set(e, i);
              } else CUSTOM_EASE_RUNTIME_MAP.set(e, a2), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e, i);
              break;
            case "private":
              EASE_MAP.set(e, a2), PRIVATE_EASE_MAP.set(e, a2);
              break;
            default:
              throw new Error("unexpected ease mode");
          }
        }
        static NoEase(e, a2, s, t) {
          return 0 === t ? a2 : s * e / t + a2;
        }
        static EaseCubicBezier(e, a2, s, t, i) {
          const x = a2, y = 3 * e * (s - a2), n = 3 * e ** 2 * (a2 + t - 2 * s), E = e ** 3 * (i - a2 + 3 * s - 3 * t);
          return x + y + n + E;
        }
        static EaseSpline(e, s, t, i, x, y, n, E, _, r) {
          if (i === x && y === n) return e;
          const u = get_t_for_x(e, s, i, y, E, r), d2 = a(t, x, n, _), A = b(t, x, n, _), o = c(t, x, n, _);
          return calc_bezier(u, d2, A, o);
        }
        static GetBezierSamples(e, s, t, i) {
          const x = [], y = a(e, s, t, i), n = b(e, s, t, i), E = c(e, s, t, i);
          for (let e2 = 0; e2 < SAMPLE_COUNT; ++e2) {
            const _ = calc_bezier(e2 * SAMPLE_STEP, y, n, E);
            x.push(_);
          }
          return x;
        }
      }, 11), SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a = (e, a2, s, t) => t - 3 * s + 3 * a2 - e, b = (e, a2, s, t) => 3 * s - 6 * a2 + 3 * e, c = (e, a2, s, t) => 3 * (a2 - e), calc_bezier = (e, a2, s, t) => ((a2 * e + s) * e + t) * e, get_slope = (e, a2, s, t) => 3 * a2 * e * e + 2 * s * e + t, get_t_for_x = (y, e, s, t, i, x) => {
        if (1 == y) return 1;
        let n = 0, E = 1, _ = x[E], r = SAMPLE_COUNT - 1;
        SAMPLE_COUNT;
        for (; E != r && _ <= y; ) E++, _ = x[E], n += SAMPLE_STEP;
        E--;
        const u = (y - (_ = x[E])) / (x[E + 1] - _);
        let d = n + u * SAMPLE_STEP;
        const A = a(e, s, t, i), o = b(e, s, t, i), S = c(e, s, t, i), M = get_slope(d, A, o, S);
        if (0 === M) return d;
        if (M >= NEWTON_RAPHSON_MIN_SLOPE) {
          for (let e2 = 0; e2 < NEWTON_RAPHSON_ITERATIONS; ++e2) {
            const P = calc_bezier(d, A, o, S) - y, T = get_slope(d, A, o, S);
            d -= P / T;
          }
          return d;
        }
        {
          let a2 = n, s2 = n + SAMPLE_STEP, t2 = 0, i2, x2;
          do {
            d = a2 + (s2 - a2) / 2;
            let e2 = calc_bezier(d, A, o, S) - y;
            0 < e2 ? s2 = d : a2 = d, i2 = Math.abs(e2) > SUBDIVISION_PRECISION, x2 = ++t2 < SUBDIVISION_MAX_ITERATIONS;
          } while (i2 && x2);
          return d;
        }
      };
    }
    {
      let RequireStringOrNumber2 = function(t) {
        C33.IsString(t);
      };
      RequireStringOrNumber = RequireStringOrNumber2;
      const C33 = self.C3;
      C33.ProbabilityTable = class {
        constructor(t) {
          this._items = [], this._name = t || "", this._totalWeight = 0;
        }
        Release() {
          this.Clear(), this._items = null;
        }
        GetName() {
          return this._name;
        }
        Clear() {
          C33.clear2DArray(this._items), this._totalWeight = 0;
        }
        GetTotalWeight() {
          return this._totalWeight;
        }
        Sample(t = Math.random() * this.GetTotalWeight()) {
          let e = 0;
          for (const [i, s] of this._items) if (t < (e += i)) return s;
          return 0;
        }
        AddItem(t, e) {
          RequireStringOrNumber2(e), this._totalWeight += t, this._items.push([t, e]);
        }
        RemoveItem(e, i) {
          RequireStringOrNumber2(i);
          const s = 0 === e;
          for (let t = 0; t < this._items.length; t++) {
            const r = this._items[t], h = s || r[0] === e, a = r[1] === i;
            if (h && a) {
              this._items.splice(t, 1), this._totalWeight -= r[0];
              break;
            }
          }
        }
        asJSON() {
          return JSON.stringify(this._items);
        }
        static fromJSON(t, e) {
          const i = new C33.ProbabilityTable(e), s = JSON.parse(t);
          for (const r of s) {
            const h = r[0], a = r[1];
            i.AddItem(h, a);
          }
          return i;
        }
      };
    }
    var RequireStringOrNumber;
    {
      const C33 = self.C3;
      let nextId = 0;
      C33.ScreenReaderText = class {
        constructor(t, e) {
          this._runtime = t, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "create", "id": this._id, "text": this._text });
        }
        Release() {
          this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "release", "id": this._id }), this._runtime = null, this._text = "", this._id = -1;
        }
        SetText(t) {
          this._text !== t && (this._text = t, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "update", "id": this._id, "text": this._text }));
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Event = class {
        constructor(t, e) {
          this.type = t, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;
        }
        preventDefault() {
          if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
          this.defaultPrevented = true;
        }
        stopPropagation() {
          if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
          if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);
          this.propagationStopped = true;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert;
      C33.Event.Handler = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];
        }
        Release() {
          0 < this._fireDepth || (C33.clearArray(this._captureListeners), this._captureListenersSet.clear(), C33.clearArray(this._listeners), this._listenersSet.clear(), C33.clearArray(this._queueModifyListeners), C33.Release(this));
        }
        _AddListener(e, t) {
          this._IsFiring() ? this._queueModifyListeners.push({ op: "add", func: e, capture: t }) : t ? this._captureListenersSet.has(e) || (this._captureListeners.push(e), this._captureListenersSet.add(e)) : this._listenersSet.has(e) || (this._listeners.push(e), this._listenersSet.add(e));
        }
        _RemoveListener(e, t) {
          this._IsFiring() ? this._queueModifyListeners.push({ op: "remove", func: e, capture: t }) : t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C33.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C33.arrayFindRemove(this._listeners, e));
        }
        _IsEmpty() {
          return !this._captureListeners.length && !this._listeners.length;
        }
        _IsFiring() {
          return 0 < this._fireDepth;
        }
        _ProcessQueuedListeners() {
          const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
          for (const s of this._queueModifyListeners) if ("add" === s.op) this._AddListener(s.func, s.capture), (s.capture ? t : e).delete(s.func);
          else {
            if ("remove" !== s.op) throw new Error("invalid op");
            (s.capture ? (this._captureListenersSet.delete(s.func), t) : (this._listenersSet.delete(s.func), e)).add(s.func);
          }
          C33.arrayRemoveAllInSet(this._listeners, e), C33.arrayRemoveAllInSet(this._captureListeners, t), C33.clearArray(this._queueModifyListeners);
        }
        _FireCancellable(s) {
          this._IncreaseFireDepth();
          let r = false;
          for (let e = 0, t = this._captureListeners.length; e < t; ++e) if (this._captureListeners[e](s), s.propagationStopped) {
            r = true;
            break;
          }
          if (!r) for (let e = 0, t = this._listeners.length; e < t && (this._listeners[e](s), !s.propagationStopped); ++e) ;
          return this._DecreaseFireDepth(), !s.defaultPrevented;
        }
        _FireNonCancellable(s) {
          this._IncreaseFireDepth();
          for (let e = 0, t = this._captureListeners.length; e < t; ++e) this._captureListeners[e](s);
          for (let e = 0, t = this._listeners.length; e < t; ++e) this._listeners[e](s);
          return this._DecreaseFireDepth(), true;
        }
        _IncreaseFireDepth() {
          this._fireDepth++;
        }
        _DecreaseFireDepth() {
          this._fireDepth--, 0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners();
        }
        SetDelayRemoveEventsEnabled(e) {
          e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();
        }
        _FireAsync(s) {
          let r = [];
          for (let t = 0, e = this._captureListeners.length; t < e; ++t) {
            let e2 = this._captureListeners[t];
            r.push(C33.Asyncify(() => e2(s)));
          }
          for (let t = 0, e = this._listeners.length; t < e; ++t) {
            let e2 = this._listeners[t];
            r.push(C33.Asyncify(() => e2(s)));
          }
          return Promise.all(r).then(() => !s.defaultPrevented);
        }
        _FireAndWait_AsyncOptional(s) {
          const r = [];
          this._IncreaseFireDepth();
          for (let e = 0, t = this._captureListeners.length; e < t; ++e) {
            const i = this._captureListeners[e](s);
            i instanceof Promise && r.push(i);
          }
          for (let e = 0, t = this._listeners.length; e < t; ++e) {
            const n = this._listeners[e](s);
            n instanceof Promise && r.push(n);
          }
          return this._DecreaseFireDepth(), r.length ? Promise.all(r).then(() => !s.defaultPrevented) : !s.defaultPrevented;
        }
        async _FireAndWaitAsync(e) {
          return this._FireAndWait_AsyncOptional(e);
        }
        async _FireAndWaitAsyncSequential(s) {
          this._IncreaseFireDepth();
          for (let e = 0, t = this._captureListeners.length; e < t; ++e) {
            const r = this._captureListeners[e](s);
            r instanceof Promise && await r;
          }
          for (let e = 0, t = this._listeners.length; e < t; ++e) {
            const i = this._listeners[e](s);
            i instanceof Promise && await i;
          }
          return this._DecreaseFireDepth(), !s.defaultPrevented;
        }
        *_FireAsGenerator(s) {
          this._IncreaseFireDepth();
          for (let e = 0, t = this._captureListeners.length; e < t; ++e) {
            const r = this._captureListeners[e](s);
            C33.IsIterator(r) && (yield* r);
          }
          for (let e = 0, t = this._listeners.length; e < t; ++e) {
            const i = this._listeners[e](s);
            C33.IsIterator(i) && (yield* i);
          }
          this._DecreaseFireDepth();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Event.Dispatcher = class extends C33.DefendedBase {
        constructor() {
          super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;
        }
        Release() {
          if (this._dispatcherWasReleased) throw new Error("already released");
          this.ClearEvents(), this._dispatcherWasReleased = true, C33.Release(this);
        }
        WasReleased() {
          return this._dispatcherWasReleased;
        }
        ClearEvents() {
          if (this._eventHandlers) {
            for (let e of this._eventHandlers.values()) e.Release();
            this._eventHandlers.clear();
          }
        }
        _GetHandlerByType(e, t) {
          let n = this._eventHandlers.get(e);
          return n || (t ? (n = C33.New(C33.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);
        }
        HasAnyHandlerFor(e) {
          return this._eventHandlers.has(e);
        }
        addEventListener(e, t, n) {
          let s = this._GetHandlerByType(e, true);
          s._AddListener(t, !!n);
        }
        removeEventListener(e, t, n) {
          let s = this._GetHandlerByType(e, false);
          s && (s._RemoveListener(t, !!n), s._IsEmpty()) && this._eventHandlers.delete(e);
        }
        dispatchEvent(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e));
        }
        dispatchEventAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          return t ? (e.isAsync = true, t._FireAsync(e)) : Promise.resolve(true);
        }
        async dispatchEventAndClearAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          if (!t) return true;
          this._eventHandlers.delete(e.type), e.isAsync = true;
          const n = await t._FireAsync(e);
          return t.Release(), n;
        }
        async dispatchEventAndWaitAsync(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || t._FireAndWaitAsync(e);
        }
        dispatchEventAndWait_AsyncOptional(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || t._FireAndWait_AsyncOptional(e);
        }
        async dispatchEventAndWaitAsyncSequential(e) {
          const t = this._GetHandlerByType(e.type, false);
          return !t || t._FireAndWaitAsyncSequential(e);
        }
        dispatchGeneratorEvent(e) {
          const t = this._GetHandlerByType(e.type, false);
          if (!t) return null;
          if (e.cancelable) throw new Error("not supported");
          return t._FireAsGenerator(e);
        }
        SetDelayRemoveEventsEnabled(e) {
          for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e);
        }
      };
    }
    {
      let SetNewCallback2 = function(e) {
        callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork2, { timeout: IDLECALLBACK_TIMEOUT }) : setTimeout(DoAsyncifiedWork2, 0 < highThroughputMode ? 1 : e);
      }, DoAsyncifiedWork2 = function(n) {
        if (callbackId = -1, workQueue.length) {
          let i = performance.now(), t = i, e = 0, o;
          for (; DoNextAsyncifiedJob2(workQueue.shift()), t = performance.now(), ++e, o = (t - i) / e * 1.1, workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== n ? o < n["timeRemaining"]() : t - i + o < SETTIMEOUT_WORK_DURATION); ) ;
          if (-1 === callbackId && workQueue.length) {
            let e2 = t - i, o2 = Math.max(SETTIMEOUT_INTERVAL - e2, 4);
            SetNewCallback2(o2);
          }
        }
      }, DoNextAsyncifiedJob2 = function(o) {
        let e;
        try {
          e = o.func();
        } catch (e2) {
          return void o.reject(e2);
        }
        o.resolve(e);
      };
      SetNewCallback = SetNewCallback2, DoAsyncifiedWork = DoAsyncifiedWork2, DoNextAsyncifiedJob = DoNextAsyncifiedJob2;
      const C33 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = "undefined" != typeof requestIdleCallback;
      let workQueue = [], callbackId = -1, highThroughputMode = 0;
      let asyncifyDisabled = C33.QueryString.Has("disable-asyncify");
      asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), C33.Asyncify = function(i) {
        let t = null;
        return C33.isDebug && (t = C33.GetCallStack()), new Promise((e, o) => {
          workQueue.push({ func: i, resolve: e, reject: o, stack: t }), asyncifyDisabled ? DoNextAsyncifiedJob2(workQueue.pop()) : -1 === callbackId && SetNewCallback2(SETTIMEOUT_INTERVAL);
        });
      }, C33.Asyncify.SetHighThroughputMode = function(e) {
        if (e) ++highThroughputMode;
        else if (--highThroughputMode < 0) throw new Error("already turned off high throughput mode");
      };
    }
    var SetNewCallback;
    var DoAsyncifiedWork;
    var DoNextAsyncifiedJob;
    {
      let ClearTimeCache2 = function() {
        cachedNowTime = -1;
      }, CheckActiveIdleTimeouts2 = function() {
        timerId = -1, nextDeadline = -1;
        let i = Date.now();
        for (let t of activeIdleTimeouts) if (t._CheckTimeout(i)) {
          let e = t._GetDeadline();
          (-1 === nextDeadline || e < nextDeadline) && (nextDeadline = e);
        } else activeIdleTimeouts.delete(t);
        if (-1 !== nextDeadline) {
          let e = Math.max(nextDeadline - i + IDLE_CHECK_TIMER_OVERSHOOT, IDLE_CHECK_MIN_INTERVAL);
          timerId = self.setTimeout(CheckActiveIdleTimeouts2, e);
        }
      };
      ClearTimeCache = ClearTimeCache2, CheckActiveIdleTimeouts = CheckActiveIdleTimeouts2;
      const C33 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;
      let cachedNowTime = -1;
      C33.FastGetDateNow = function() {
        return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache2, 16)), cachedNowTime;
      };
      let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();
      C33.IdleTimeout = class {
        constructor(e, t) {
          this._callback = e, this._timeout = 1e3 * t, this._deadline = 0, this._isActive = false;
        }
        Reset() {
          let e = C33.FastGetDateNow();
          this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT)) : this._deadline < nextDeadline && nextDeadline > e + IDLE_CHECK_MIN_INTERVAL && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT));
        }
        _CheckTimeout(e) {
          return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : this._isActive = false);
        }
        _GetDeadline() {
          return this._deadline;
        }
        Cancel() {
          this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size) && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1);
        }
        Release() {
          this.Cancel(), this._callback = null;
        }
      };
    }
    var ClearTimeCache;
    var CheckActiveIdleTimeouts;
    {
      const C33 = self.C3;
      C33.Disposable = class a {
        constructor(s) {
          this._disposed = false, this._disposeAction = s;
        }
        Dispose() {
          this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));
        }
        IsDisposed() {
          return this._disposed;
        }
        Release() {
          this.Dispose();
        }
        static Release(s) {
          return new a(() => s.Release());
        }
        static From(e, i, o, t, s) {
          if (null == t) t = false;
          else if ("boolean" != typeof t && "object" != typeof t) throw new TypeError("invalid event listener options");
          if (s && (o = o.bind(s)), i.includes(" ")) {
            i = i.split(" ");
            const d = new C33.CompositeDisposable();
            for (let s2 of i) e.addEventListener(s2, o, t), d.Add(C33.New(C33.Disposable, () => e.removeEventListener(s2, o, t)));
            return d;
          }
          return e.addEventListener(i, o, t), C33.New(C33.Disposable, () => e.removeEventListener(i, o, t));
        }
      }, C33.StubDisposable = class extends C33.Disposable {
        SetAction(s) {
          this._disposeAction = s;
        }
      }, C33.CompositeDisposable = class extends C33.Disposable {
        constructor(...e) {
          super(), this._disposables = /* @__PURE__ */ new Set();
          for (let s of e) this.Add(s);
        }
        Add(...e) {
          if (this._disposed) throw new Error("already disposed");
          for (let s of e) this._disposables.add(s);
        }
        Remove(s) {
          if (this._disposed) throw new Error("already disposed");
          this._disposables.delete(s);
        }
        RemoveAll() {
          if (this._disposed) throw new Error("already disposed");
          if (this._disposables) {
            for (let s of this._disposables) s.Dispose();
            this._disposables.clear();
          }
        }
        IsDisposed() {
          return this._disposed;
        }
        Dispose() {
          if (this._disposed) throw new Error("already disposed");
          this._disposed = true;
          for (let s of this._disposables) s.Dispose();
          this._disposables.clear(), this._disposables = null;
        }
        Release() {
          this.Dispose();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.KahanSum = class extends C33.DefendedBase {
        constructor() {
          super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
        }
        Add(s) {
          this._y = (s = +s) - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;
        }
        Subtract(s) {
          this._sum -= +s;
        }
        Get() {
          return this._sum;
        }
        Reset() {
          this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
        }
        Set(s) {
          this._c = 0, this._y = 0, this._t = 0, this._sum = +s;
        }
        Copy(s) {
          this._c = s._c, this._y = s._y, this._t = s._t, this._sum = s._sum;
        }
        Release() {
        }
      };
    }
    {
      const C33 = self.C3, js_cols = {}, RED = true, BLACK = false;
      js_cols.RBnode = function(t) {
        this.tree = t, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;
      }, js_cols.RedBlackSet = function(t) {
        this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = BLACK, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t || this.default_compare;
      }, js_cols.RedBlackSet.prototype.default_compare = function(t, e) {
        return t < e ? -1 : e < t ? 1 : 0;
      }, js_cols.RedBlackSet.prototype.clone = function() {
        var t = new js_cols.RedBlackSet(this.compare);
        return t.insertAll(this), t;
      }, js_cols.RedBlackSet.prototype.clear = function() {
        this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = BLACK, this.root = this.sentinel, this.root.parent = this.sentinel;
      }, js_cols.RedBlackSet.prototype.leftRotate = function(t) {
        var e = t.right;
        t.right = e.left, e.left != this.sentinel && (e.left.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, (e.left = t).parent = e;
      }, js_cols.RedBlackSet.prototype.rightRotate = function(t) {
        var e = t.left;
        t.left = e.right, e.right != this.sentinel && (e.right.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, (e.right = t).parent = e;
      }, js_cols.RedBlackSet.prototype.insert = function(t) {
        if (this.contains(t)) this.get_(t).key = t;
        else {
          for (var e = new js_cols.RBnode(this), s = (e.key = t, this.sentinel), r = this.root; r != this.sentinel; ) s = r, r = this.compare(e.key, r.key) < 0 ? r.left : r.right;
          (e.parent = s) == this.sentinel ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;
        }
      }, js_cols.RedBlackSet.prototype.insertFixup = function(t) {
        for (; t != this.sentinel && t != this.root && t.parent.color == RED; ) {
          var e;
          t.parent == t.parent.parent.left ? (e = t.parent.parent.right).color == RED ? (t.parent.color = BLACK, e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = BLACK, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.rightRotate(t.parent.parent)) : (e = t.parent.parent.left).color == RED ? (t.parent.color = BLACK, e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = BLACK, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.leftRotate(t.parent.parent));
        }
        this.root.color = BLACK;
      }, js_cols.RedBlackSet.prototype.delete_ = function(t) {
        var e = t.left == this.sentinel || t.right == this.sentinel ? t : this.successor_(t), s = e.left != this.sentinel ? e.left : e.right;
        s.parent = e.parent, e.parent == this.sentinel ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, e != t && (t.key = e.key), e.color == BLACK && this.deleteFixup(s), this.size--;
      }, js_cols.RedBlackSet.prototype.deleteFixup = function(t) {
        for (; t != this.root && t.color == BLACK; ) {
          var e;
          t = t == t.parent.left ? ((e = t.parent.right).color == RED && (e.color = BLACK, t.parent.color = RED, this.leftRotate(t.parent), e = t.parent.right), e.left.color == BLACK && e.right.color == BLACK ? (e.color = RED, t.parent) : (e.right.color == BLACK && (e.left.color = BLACK, e.color = RED, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = BLACK, e.right.color = BLACK, this.leftRotate(t.parent), this.root)) : ((e = t.parent.left).color == RED && (e.color = BLACK, t.parent.color = RED, this.rightRotate(t.parent), e = t.parent.left), e.right.color == BLACK && e.left.color == BLACK ? (e.color = RED, t.parent) : (e.left.color == BLACK && (e.right.color = BLACK, e.color = RED, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = BLACK, e.left.color = BLACK, this.rightRotate(t.parent), this.root));
        }
        t.color = BLACK;
      }, js_cols.RedBlackSet.prototype.remove = function(t) {
        var e, t = this.get_(t);
        return t != this.sentinel ? (e = t.key, this.delete_(t), e) : null;
      }, js_cols.RedBlackSet.prototype.removeSwapped = function(t, e) {
        this.remove(e);
      }, js_cols.RedBlackSet.prototype.min = function(t) {
        for (; t.left != this.sentinel; ) t = t.left;
        return t;
      }, js_cols.RedBlackSet.prototype.max = function(t) {
        for (; t.right != this.sentinel; ) t = t.right;
        return t;
      }, js_cols.RedBlackSet.prototype.successor_ = function(t) {
        if (t.right != this.sentinel) return this.min(t.right);
        for (var e = t.parent; e != this.sentinel && t == e.right; ) e = (t = e).parent;
        return e;
      }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t) {
        if (t.left != this.sentinel) return this.max(t.left);
        for (var e = t.parent; e != this.sentinel && t == e.left; ) e = (t = e).parent;
        return e;
      }, js_cols.RedBlackSet.prototype.successor = function(t) {
        if (0 < this.size) {
          var e = this.get_(t);
          if (e == this.sentinel) return null;
          if (e.right != this.sentinel) return this.min(e.right).key;
          for (var s = e.parent; s != this.sentinel && e == s.right; ) s = (e = s).parent;
          return s != this.sentinel ? s.key : null;
        }
        return null;
      }, js_cols.RedBlackSet.prototype.predecessor = function(t) {
        if (0 < this.size) {
          var e = this.get_(t);
          if (e == this.sentinel) return null;
          if (e.left != this.sentinel) return this.max(e.left).key;
          for (var s = e.parent; s != this.sentinel && e == s.left; ) s = (e = s).parent;
          return s != this.sentinel ? s.key : null;
        }
        return null;
      }, js_cols.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key;
      }, js_cols.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key;
      }, js_cols.RedBlackSet.prototype.get_ = function(t) {
        for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;
        return e;
      }, js_cols.RedBlackSet.prototype.contains = function(t) {
        return null != this.get_(t).key;
      }, js_cols.RedBlackSet.prototype.getValues = function() {
        var e = [];
        return this.forEach(function(t) {
          e.push(t);
        }), e;
      }, js_cols.RedBlackSet.prototype.insertAll = function(t) {
        if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.insert(t[e]);
        else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.insert, this);
        else if ("function" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this.insert(s[e]);
        else if ("object" == js_cols.typeOf(t)) for (var r in t) this.insert(t[r]);
      }, js_cols.RedBlackSet.prototype.removeAll = function(t) {
        if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]);
        else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this.removeSwapped, this);
        else if ("function" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this.remove(s[e]);
        else if ("object" == js_cols.typeOf(t)) for (var r in t) this.remove(t[r]);
      }, js_cols.RedBlackSet.prototype.containsAll = function(t) {
        if ("array" == js_cols.typeOf(t)) {
          for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return false;
          return true;
        }
        if ("function" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);
        if ("function" == js_cols.typeOf(t.getValues)) {
          for (var s = t.getValues(), e = 0; e < s.length; e++) if (!this.contains(s[e])) return false;
          return true;
        }
        if ("object" == js_cols.typeOf(t)) {
          for (var r in t) if (!this.contains(t[r])) return false;
          return true;
        }
      }, js_cols.RedBlackSet.prototype.range = function(t, e) {
        var s = [];
        return this.traverseFromTo(function(t2) {
          s.push(t2);
        }, t, e), s;
      }, js_cols.RedBlackSet.prototype.traverse = function(t, e) {
        if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; ) {
          if (t.call(e, s.key, this)) return;
          s = this.successor_(s);
        }
      }, js_cols.RedBlackSet.prototype.traverseFrom = function(t, e, s) {
        if (!this.isEmpty()) for (var r = this.get_(e); r != this.sentinel; ) {
          if (t.call(s, r.key, this)) return;
          r = this.successor_(r);
        }
      }, js_cols.RedBlackSet.prototype.traverseTo = function(t, e, s) {
        if (!this.isEmpty()) for (var r = this.min(this.root), i = this.get_(e); r != i; ) {
          if (t.call(s, r.key, this)) return;
          r = this.successor_(r);
        }
      }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t, e, s, r) {
        if (!this.isEmpty()) for (var i = this.get_(e), o = this.get_(s); i != o; ) {
          if (t.call(r, i.key, this)) return;
          i = this.successor_(i);
        }
      }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t, e) {
        if (!this.isEmpty()) for (var s = this.max(this.root); s != this.sentinel; ) {
          if (t.call(e, s.key, this)) return;
          s = this.predeccessor_(s);
        }
      }, js_cols.RedBlackSet.prototype.forEach = function(t, e) {
        if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.call(e, s.key, s.key, this);
      }, js_cols.RedBlackSet.prototype.some = function(t, e) {
        if (!this.isEmpty()) {
          for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (t.call(e, s.key, s.key, this)) return true;
        }
        return false;
      }, js_cols.RedBlackSet.prototype.every = function(t, e) {
        if (this.isEmpty()) return false;
        for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (!t.call(e, s.key, s.key, this)) return false;
        return true;
      }, js_cols.RedBlackSet.prototype.map = function(t, e) {
        var s = [];
        if (!this.isEmpty()) for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) s.push(t.call(e, r.key, r.key, this));
        return s;
      }, js_cols.RedBlackSet.prototype.filter = function(t, e) {
        var s = [];
        if (!this.isEmpty()) for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) t.call(e, r.key, r.key, this) && s.push(r.key);
        return s;
      }, js_cols.RedBlackSet.prototype.getCount = function() {
        return this.size;
      }, js_cols.RedBlackSet.prototype.isEmpty = function() {
        return 0 == this.size;
      }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t) {
        var e = js_cols.getCount(t);
        if (this.getCount() > e) return false;
        var s = 0;
        if (this.isEmpty()) return true;
        for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) js_cols.contains.call(t, t, r.key) && s++;
        return s == this.getCount();
      }, js_cols.RedBlackSet.prototype.intersection = function(t) {
        var e = new js_cols.RedBlackSet(this.compare);
        if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.contains.call(t, s.key, s.key, this) && e.insert(s.key);
        return e;
      }, C33.RedBlackSet = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._rbSet = new js_cols.RedBlackSet(t), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();
        }
        Add(t) {
          this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.delete(t) : this._queueInsert.add(t) : this._rbSet.insert(t);
        }
        Remove(t) {
          this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.add(t) : this._queueInsert.delete(t) : this._rbSet.remove(t);
        }
        Has(t) {
          return this._enableQueue ? !!this._queueInsert.has(t) || !this._queueRemove.has(t) && this._rbSet.contains(t) : this._rbSet.contains(t);
        }
        Clear() {
          this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();
        }
        toArray() {
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          return this._rbSet.getValues();
        }
        GetSize() {
          return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;
        }
        IsEmpty() {
          return 0 === this.GetSize();
        }
        Front() {
          if (this.IsEmpty()) throw new Error("empty set");
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          const t = this._rbSet, e = t.min(t.root);
          return e.key;
        }
        Shift() {
          if (this.IsEmpty()) throw new Error("empty set");
          if (this._enableQueue) throw new Error("cannot be used in queueing mode");
          const t = this.Front();
          return this.Remove(t), t;
        }
        SetQueueingEnabled(t) {
          if (this._enableQueue !== (t = !!t) && !(this._enableQueue = t)) {
            for (const e of this._queueRemove) this._rbSet.remove(e);
            this._queueRemove.clear();
            for (const s of this._queueInsert) this._rbSet.insert(s);
            this._queueInsert.clear();
          }
        }
        ForEach(t) {
          this._rbSet.forEach(t);
        }
        *values() {
          if (!this.IsEmpty()) {
            const e = this._rbSet;
            for (let t = e.min(e.root); t != e.sentinel; t = e.successor_(t)) yield t.key;
          }
        }
        [Symbol.iterator]() {
          return this.values();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PromiseThrottle = class {
        constructor(e = C33.hardwareConcurrency) {
          this._maxParallel = e, this._queue = [], this._activeCount = 0;
        }
        Add(s) {
          return new Promise((e, t) => {
            this._queue.push({ func: s, resolve: e, reject: t }), this._MaybeStartNext();
          });
        }
        _FindInQueue(s) {
          for (let e = 0, t = this._queue.length; e < t; ++e) if (this._queue[e].func === s) return e;
          return -1;
        }
        RemoveAndResolve(e, t) {
          const s = this._FindInQueue(e);
          if (-1 === s) throw new Error("cannot find promise to resolve");
          this._queue[s].resolve(t), this._queue.splice(s, 1);
        }
        RemoveAndReject(e, t) {
          const s = this._FindInQueue(e);
          if (-1 === s) throw new Error("cannot find promise to reject");
          this._queue[s].reject(t), this._queue.splice(s, 1);
        }
        async _MaybeStartNext() {
          if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
            this._activeCount++;
            const t = this._queue.shift();
            try {
              const e = await t.func();
              t.resolve(e);
            } catch (e) {
              t.reject(e);
            }
            this._activeCount--, this._MaybeStartNext();
          }
        }
        static async Batch(e, t) {
          const s = [];
          let r = false;
          const i = [];
          for (; e--; ) i.push((async () => {
            let e2;
            for (; e2 = t.pop(); ) {
              if (r) return;
              try {
                s.push(await e2());
              } catch (e3) {
                throw r = true, e3;
              }
            }
          })());
          return await Promise.all(i), s;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.RateLimiter = class {
        constructor(t, e, i) {
          this._callback = t, this._interval = e, this._intervalOnBattery = i || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;
        }
        SetCanRunImmediate(t) {
          this._canRunImmediate = !!t;
        }
        _GetInterval() {
          return void 0 !== C33.Battery && C33.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;
        }
        Call(...l) {
          if (-1 === this._timerId) {
            this._callbackArguments = l;
            let t = C33.FastGetDateNow(), e = t - this._lastCallTime, i = this._GetInterval();
            i <= e && this._canRunImmediate ? (this._lastCallTime = t, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(i - e, 4));
          }
        }
        _RunCallback() {
          this._ignoreReset = true;
          const t = this._callbackArguments;
          this._callbackArguments = null, t ? this._callback(...t) : this._callback(), this._ignoreReset = false;
        }
        Reset() {
          this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C33.FastGetDateNow());
        }
        _OnTimer() {
          this._timerId = -1, this._lastCallTime = C33.FastGetDateNow(), this._RunCallback();
        }
        _CancelTimer() {
          -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);
        }
        Release() {
          this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SVGRasterManager = class {
        constructor() {
          this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;
        }
        SetNpotSurfaceAllowed(e) {
          this._allowNpotSurfaces = !!e;
        }
        IsNpotSurfaceAllowed() {
          return this._allowNpotSurfaces;
        }
        SetGetBaseSizeCallback(e) {
          this._getBaseSizeCallback = e;
        }
        GetBaseSize(e) {
          if (this._getBaseSizeCallback) return this._getBaseSizeCallback(e);
          throw new Error("no get base size callback set");
        }
        SetRasterAtSizeCallback(e) {
          this._rasterAtSizeCallback = e;
        }
        RasterAtSize(e, a, t, l, s, r) {
          if (this._rasterAtSizeCallback) return this._rasterAtSizeCallback(e, a, t, l, s, r);
          throw new Error("no raster at size callback set");
        }
        SetReleaseResultCallback(e) {
          this._releaseResultCallback = e;
        }
        ReleaseResult(e) {
          if (!this._releaseResultCallback) throw new Error("no release result callback set");
          this._releaseResultCallback(e);
        }
        SetRedrawCallback(e) {
          this._redrawCallback = e;
        }
        Redraw() {
          if (!this._redrawCallback) throw new Error("no redraw callback set");
          this._redrawCallback();
        }
        AddImage(e) {
          let a = this._images.get(e);
          return a || (a = C33.New(C33.SVGRasterImage, this, e), this._images.set(e, a)), a.IncReference(), a;
        }
        _RemoveImage(e) {
          this._images.delete(e.GetDataSource());
        }
        OnTexturesChanged() {
          for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();
        }
      };
    }
    {
      const C33 = self.C3, MAX_SURFACE_SIZE = 4096;
      C33.SVGRasterImage = class {
        constructor(e, t) {
          this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then((e2) => {
            this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());
          }).catch((e2) => {
            console.error("[SVG] Error loading SVG: ", e2), this._hadError = true, this._manager && this._manager.Redraw();
          }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;
        }
        Release() {
          if (this._refCount <= 0) throw new Error("already released");
          this._refCount--, 0 === this._refCount && this._Release();
        }
        ReleaseRasterizedResult() {
          this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);
        }
        _Release() {
          this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;
        }
        GetDataSource() {
          return this._dataSource;
        }
        IncReference() {
          this._refCount++;
        }
        HasReferences() {
          return 0 < this._refCount;
        }
        GetRasterizedResult() {
          return this._rasterizedResult;
        }
        ForceRasterAgain() {
          this._forceRaster = true;
        }
        async StartRasterForSize(s, r, a) {
          if (0 !== r && 0 !== a && !this._hadError && !this._isRasterizing) {
            let e = C33.nextHighestPowerOfTwo(Math.ceil(r)), t = C33.nextHighestPowerOfTwo(Math.ceil(a));
            const i = Math.max(e, t);
            if (i > MAX_SURFACE_SIZE) {
              const h = MAX_SURFACE_SIZE / i;
              r *= h, a *= h, e = Math.min(Math.ceil(e * h), MAX_SURFACE_SIZE), t = Math.min(Math.ceil(t * h), MAX_SURFACE_SIZE);
            }
            if (r < e && a < t) {
              const _ = r / a, n = e / t;
              a = _ < n ? (r = t * _, t) : (r = e) / _;
            }
            if (this._manager.IsNpotSurfaceAllowed() && (e = Math.ceil(r), t = Math.ceil(a)), !(e <= this._rasterSurfaceWidth && t <= this._rasterSurfaceHeight) || this._forceRaster) {
              this._isRasterizing = true, this._rasterSurfaceWidth = e, this._rasterSurfaceHeight = t;
              const R = await this._manager.RasterAtSize(this._dataSource, s, this._rasterSurfaceWidth, this._rasterSurfaceHeight, r, a);
              this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = R, this._rasterImageWidth = r, this._rasterImageHeight = a, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());
            }
          }
        }
        WhenBaseSizeReady() {
          return this._getBaseSizePromise;
        }
        GetBaseWidth() {
          return this._baseWidth;
        }
        GetBaseHeight() {
          return this._baseHeight;
        }
        GetRasterWidth() {
          return this._rasterImageWidth;
        }
        GetRasterHeight() {
          return this._rasterImageHeight;
        }
        HadError() {
          return this._hadError;
        }
      };
    }
    {
      let lookupHtmlEntity2 = function(t) {
        return HTML_ENTITY_MAP.get(t);
      };
      lookupHtmlEntity = lookupHtmlEntity2;
      const C33 = self.C3, NUMERIC_CHARS = (C33.UTF8_BOM = "\uFEFF", new Set("0123456789")), WHITESPACE_CHARS = (C33.IsNumericChar = function(t) {
        return NUMERIC_CHARS.has(t);
      }, new Set(" 	\n\r\xA0\x85\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000"));
      C33.IsWhitespaceChar = function(t) {
        return WHITESPACE_CHARS.has(t);
      }, C33.FilterWhitespace = function(t) {
        return [...t].filter((t2) => !C33.IsWhitespaceChar(t2)).join("");
      }, C33.IsStringAllWhitespace = function(t) {
        for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;
        return true;
      }, C33.IsCharArrayAllWhitespace = function(t) {
        for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;
        return true;
      }, C33.IsUnprintableChar = function(t) {
        return 1 === t.length && t.charCodeAt(0) < 32;
      }, C33.FilterUnprintableChars = function(t) {
        return [...t].filter((t2) => !C33.IsUnprintableChar(t2)).join("");
      };
      let cjkPunctuationRegex = null;
      try {
        cjkPunctuationRegex = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
      } catch (t) {
        console.warn("Unable to detect CJK punctuation: ", t);
      }
      C33.IsCJKPunctuationChar = function(t) {
        return !C33.IsWhitespaceChar(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);
      };
      const NUMERIC_STRING_CHARS = new Set("0123456789.+-e"), HTML_ENTITY_MAP = (C33.IsStringNumber = function(e) {
        if (!(e = e.trim()).length) return false;
        let t = e.charAt(0);
        if ("-" !== t && !NUMERIC_CHARS.has(t)) return false;
        for (let t2 of e) if (!NUMERIC_STRING_CHARS.has(t2)) return false;
        return true;
      }, C33.RemoveTrailingDigits = function(e) {
        let n = e.length;
        for (; 0 < n; ) {
          let t = e.charAt(n - 1);
          if (!C33.IsNumericChar(t)) break;
          --n;
        }
        return e.substr(0, n);
      }, C33.IncrementNumberAtEndOf = function(t) {
        let e = C33.RemoveTrailingDigits(t), n = t.substr(e.length);
        return e + (n = n ? (parseInt(n, 10) + 1).toString() : "2");
      }, /* @__PURE__ */ new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]));
      const HTML_ENTITY_REGEX = /[&<>"']/g, ESCAPE_REGEX = (C33.EscapeHTML = function(t) {
        return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity2);
      }, C33.EscapeJS = function(t) {
        let e = C33.ReplaceAll(t, "\\", "\\\\");
        return e = C33.ReplaceAll(e, '"', '\\"'), e = C33.ReplaceAll(e, "	", "\\t"), e = C33.ReplaceAll(e, "\r", ""), C33.ReplaceAll(e, "\n", "\\n");
      }, C33.EscapeXML = function(t) {
        let e = C33.ReplaceAll(t, "&", "&amp;");
        return e = C33.ReplaceAll(e, "<", "&lt;"), e = C33.ReplaceAll(e, ">", "&gt;"), C33.ReplaceAll(e, '"', "&quot;");
      }, /[-[\]{}()*+?.,\\^$|#\s]/g), intlSegmenter = (C33.EscapeRegex = function(t) {
        return t.replace(ESCAPE_REGEX, "\\$&");
      }, C33.CountCharsInString = function(t, e) {
        let n = 0;
        for (const r of t) r === e && ++n;
        return n;
      }, C33.FindAll = function(t, e, n = false) {
        if (!e) return [];
        n || (t = t.toLowerCase(), e = e.toLowerCase());
        const r = e.length;
        let o = 0, i, l = [];
        for (; -1 < (i = t.indexOf(e, o)); ) l.push(i), o = i + r;
        return l;
      }, C33.ReplaceAll = function(t, e, n) {
        return t.replaceAll(e, () => n);
      }, C33.ReplaceAllCaseInsensitive = function(t, e, n) {
        return t.replace(new RegExp(C33.EscapeRegex(e), "gi"), () => n);
      }, C33.SetElementContent = function(t, e) {
        "string" == typeof e ? t.textContent = e : e.isPlainText() ? t.textContent = e.toString() : (t.innerHTML = e.toHTML(), e instanceof C33.BBString && e.attachLinkHandlers(t));
      }, C33.StringLikeEquals = function(t, e) {
        return t instanceof C33.HtmlString || t instanceof C33.BBString ? t.equals(e) : e instanceof C33.HtmlString || e instanceof C33.BBString ? e.equals(t) : t === e;
      }, C33.StringSubstitute = function(n, ...r) {
        let o = n;
        for (let t = 0, e = r.length; t < e; ++t) {
          const i = `{${t}}`;
          if (!n.includes(i)) throw new Error(`missing placeholder '${i}' in string substitution`);
          o = o.replace(i, r[t].toString());
        }
        return o;
      }, C33.StringSubstituteAllowMissing = function(n, ...r) {
        let o = n, i = -1, l = -1;
        for (let t = 0, e = r.length; t < e; ++t) {
          const s = `{${t}}`;
          n.includes(s) ? (l = t, o = o.replace(s, r[t].toString())) : -1 === i && (i = t);
        }
        if (0 <= i && 0 <= l && i < l) throw new Error(`missing placeholder '${i}' in string substitution`);
        return o;
      }, C33.StringSubstituteMap = function(t, n) {
        let r = t;
        for (let [t2, e] of Object.entries(n)) r = r.replaceAll(t2, e.toString());
        return r;
      }, C33.SortAZ = function(t, e) {
        return e < t ? 1 : t < e ? -1 : 0;
      }, C33.SortAZCaseInsensitive = function(t, e) {
        let n = t.toLowerCase(), r = e.toLowerCase();
        return r < n ? 1 : n < r ? -1 : 0;
      }, new self["Intl"]["Segmenter"]()), KILOBYTE = (C33.SplitGraphemes = function(t) {
        const e = [];
        for (const n of intlSegmenter["segment"](t)) e.push(n["segment"]);
        return e;
      }, C33.IterateGraphemes = function* (t) {
        for (const e of intlSegmenter["segment"](t)) yield e["segment"];
      }, C33.CountGraphemes = function(t) {
        let e = 0;
        for (const n of intlSegmenter["segment"](t)) ++e;
        return e;
      }, 1024), MEGABYTE = 1024 * KILOBYTE, GIGABYTE = 1024 * MEGABYTE, TERABYTE = 1024 * GIGABYTE, DEFAULT_FORMATTIME_OPTS = { approximate: !(C33.FormatDataSize = function(e, t) {
        let n = "common." + (t ? "dataRates" : "dataSizes") + ".";
        const r = self.langSub;
        if (e < KILOBYTE) return r(n + "bytes", e);
        if (e < MEGABYTE) {
          let t2 = e / KILOBYTE;
          return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + "kilobytes", t2);
        }
        if (e < GIGABYTE) {
          let t2 = e / MEGABYTE;
          return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + "megabytes", t2);
        }
        if (e < TERABYTE) {
          let t2 = e / GIGABYTE;
          return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + "gigabytes", t2);
        }
        {
          let t2 = e / TERABYTE;
          return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + "terabytes", t2);
        }
      }), days: true, hours: true, minutes: true, seconds: true };
      C33.FormatTime = function(t, e) {
        e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C33.Lang.PushContext("common.time");
        const n = [], r = self.lang, o = self.langPluralSub;
        if (e.days) {
          const l = Math.floor(t / 86400);
          0 < l && (t -= 24 * l * 3600, n.push(o(".days", null, l)));
        }
        if (e.hours) {
          const s = Math.floor(t / 3600);
          (0 < s || n.length) && (t -= 3600 * s, n.push(o(".hours", null, s)));
        }
        if (e.minutes) {
          const a = Math.floor(t / 60);
          (0 < a || n.length || !e.seconds) && (t -= 60 * a, n.push(o(".minutes", null, a)));
        }
        if (e.seconds) {
          const u = Math.floor(t % 60);
          n.push(o(".seconds", null, u));
        }
        const i = (e.approximate ? r(".approx-prefix") : "") + n.join(r(".separator"));
        return C33.Lang.PopContext(), i;
      }, C33.ZeroPad = function(t, e) {
        let n = t < 0 ? "-" : "", r = (t = Math.abs(t)).toString(), o = e - r.length;
        for (let t2 = 0; t2 < o; ++t2) n += "0";
        return n + r;
      }, C33.StringToTitleCase = function(t) {
        return t.toLowerCase().replace(/\b\w/g, (t2) => t2.toUpperCase());
      }, C33.CompareVersionStrings = function(t, e) {
        let n = t.split(".").map((t2) => t2.trim()), r = e.split(".").map((t2) => t2.trim());
        C33.resizeArray(n, 4, "0"), C33.resizeArray(r, 4, "0"), n = n.map((t2) => parseInt(t2, 10)), r = r.map((t2) => parseInt(t2, 10));
        for (let t2 = 0; t2 < 4; ++t2) {
          const o = n[t2] - r[t2];
          if (0 != o) return o < 0 ? -1 : 1;
        }
        return 0;
      }, C33.CreateGUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
          const e = Math.floor(16 * Math.random()), n = "x" === t ? e : 3 & e | 8;
          return n.toString(16);
        });
      }, C33.StringHammingDistance = function(n, r) {
        if (n.length !== r.length) throw new Error("strings must be same length");
        let o = 0;
        for (let t = 0, e = n.length; t < e; ++t) n.charAt(t) !== r.charAt(t) && ++o;
        return o;
      }, C33.StringLevenshteinDistance = function(t, e) {
        if (0 === t.length) return e.length;
        if (0 === e.length) return t.length;
        let n, r, o, i, l, s;
        for (e.length < t.length && (n = t, t = e, e = n), s = Array(t.length + 1), r = 0; r <= t.length; r++) s[r] = r;
        for (r = 1; r <= e.length; r++) {
          for (i = r, o = 1; o <= t.length; o++) l = e[r - 1] === t[o - 1] ? s[o - 1] : Math.min(s[o - 1] + 1, Math.min(i + 1, s[o] + 1)), s[o - 1] = i, i = l;
          s[t.length] = i;
        }
        return s[t.length];
      };
    }
    var lookupHtmlEntity;
    {
      let bbToHtmlReplacerFunc2 = function(t, i, s) {
        const n = BB_CODE_MAP.get(s);
        if (!n) return "class" === s ? i ? "</span>" : `<span class="bbclass${classIndex++}">` : t;
        if ("string" == typeof n) {
          if ("a" === n && 0 === linkActions.length || "abbr" === n && 0 === tipList.length) return t;
          if ("a" !== n || i) {
            if ("abbr" !== n || i) return "<" + i + n + ">";
            {
              const e = parseInt(s.substring(3), 10) - 1;
              if (e < 0 || e >= tipList.length) throw new Error("invalid bbcode tip substitution");
              const r = tipList[e];
              let t2 = "";
              if ("string" == typeof r ? t2 = r : "function" == typeof r && (t2 = r()), "string" != typeof t2) throw new TypeError("invalid bbcode tip");
              return `<abbr title="${C33.ReplaceAll(t2, '"', "&quot;")}">`;
            }
          }
          {
            const a = parseInt(s.substring(1), 10) - 1;
            if (a < 0 || a >= linkActions.length) throw new Error("invalid bbcode link substitution");
            const o = linkActions[a];
            if ("string" == typeof o) return `<a href="${linkActions[a]}">`;
            if ("function" == typeof o) return `<a class="bblink${a}">`;
            throw new TypeError("invalid bbcode link action");
          }
        }
        if (Array.isArray(n)) {
          let t2 = n[0], s2 = n[1];
          return i ? "</" + t2 + ">" : `<${t2} class="${s2}">`;
        }
      };
      bbToHtmlReplacerFunc = bbToHtmlReplacerFunc2;
      const C33 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set(["icon"]), BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g, CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
      let linkActions = null, tipList = null, classIndex = 0;
      const LINEBREAK_REGEX = /\n/g;
      C33.BBString = class {
        constructor(t, s) {
          if (this._bbstr = s && s.noEscape ? t : C33.EscapeHTML(t), this._htmlstr = "", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s) {
            if (this._convertLineBreaks = !!s.convertLineBreaks, s.links) {
              if (9 < s.links.length) throw new Error("too many links");
              this._linkActions = s.links;
            }
            if (s.tips) {
              if (9 < s.tips.length) throw new Error("too many tips");
              this._tipList = s.tips;
            }
          }
          this._hasAnyBBtags = this._bbstr.includes("["), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&"), this._hasParsedFragments = false, this._fragments = [];
        }
        toString() {
          return this._bbstr;
        }
        valueOf() {
          return this._bbstr;
        }
        isPlainText() {
          return this._isPlain;
        }
        toPlainText() {
          return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr;
        }
        toHTML() {
          if (this._isPlain) return this._bbstr;
          if (!this._htmlstr && this._bbstr) {
            let t = this._bbstr;
            this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t = t.replace(BBREGEX, bbToHtmlReplacerFunc2), linkActions = null, tipList = null), this._needsLineBreakConversion && (t = t.replace(LINEBREAK_REGEX, "<br>")), this._htmlstr = t;
          }
          return this._htmlstr;
        }
        attachLinkHandlers(i) {
          if (this._linkActions.length) for (let t = 0, s = this._linkActions.length; t < s; ++t) {
            const n = this._linkActions[t];
            if ("function" == typeof n) {
              const e = i.querySelector(".bblink" + t);
              if (!e) throw new Error("unable to attach BBString link handler");
              e.onclick = n;
            }
          }
        }
        equals(t) {
          return t instanceof C33.HtmlString ? this.toHTML() === t.toHTML() : t instanceof C33.BBString ? this._bbstr === t._bbstr : this._bbstr === t;
        }
        toFragmentList() {
          if (!this._hasParsedFragments) {
            const i = [], n = this._bbstr, e = [];
            let t = CUSTOM_BBREGEX.lastIndex = 0, s;
            for (; null !== (s = CUSTOM_BBREGEX.exec(n)); ) {
              const r = s.index;
              if (!(0 < r && "\\" === n.charAt(r - 1))) {
                const a = s[0], o = s[1], l = s[2], b = n.substring(t, r);
                if (t = r + a.length, b && i.push({ text: b, styles: e.slice(0) }), l) if (o) {
                  const c = l.toLowerCase();
                  for (let t2 = e.length - 1; 0 <= t2; --t2) if (e[t2].tag === c) {
                    e.splice(t2, 1);
                    break;
                  }
                } else {
                  let t2 = l, s2 = null;
                  const h = l.indexOf("=");
                  if (-1 !== h ? (t2 = l.substring(0, h).toLowerCase(), s2 = l.substring(h + 1)) : t2 = t2.toLowerCase(), SELF_CLOSING_TAGS.has(t2)) {
                    if ("icon" !== t2) throw new Error("unknown self-closing tag " + t2);
                    i.push({ icon: s2, styles: e.slice(0) });
                  } else e.push({ tag: t2, param: s2 });
                }
              }
            }
            t < n.length && i.push({ text: n.substring(t), styles: e.slice(0) });
            for (const p of i) p.text && (p.text = this._ProcessBBCodeEscapeSequences(p.text));
            this._fragments = i.map((t2) => t2.icon ? C33.New(C33.IconFragment, { icon: t2.icon, styles: t2.styles }) : C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t2.text), styles: t2.styles })), this._hasParsedFragments = true;
          }
          return this._fragments;
        }
        _ProcessBBCodeEscapeSequences(t) {
          return t = C33.ReplaceAll(t, "\\[", "["), C33.ReplaceAll(t, "\\\\", "\\");
        }
        static StripTags(t) {
          return C33.New(C33.BBString, t, { noEscape: true }).toPlainText();
        }
        static StripAnyTags(t) {
          return t.replace(CUSTOM_BBREGEX, "");
        }
      };
    }
    var bbToHtmlReplacerFunc;
    {
      let IsWordBreakWhiteSpace2 = function(e) {
        return "\xA0" !== e && "\u202F" !== e && C33.IsWhitespaceChar(e);
      }, IsOpeningCJKPunctiationChar2 = function(e) {
        return CJK_OPEN_PUNCTUATION.has(e);
      }, IsContinuingCJKPunctuationChar2 = function(e) {
        return C33.IsCJKPunctuationChar(e) && !IsOpeningCJKPunctiationChar2(e);
      }, WordBreakTrimEnd2 = function(e) {
        for (; 0 < e.length && IsWordBreakWhiteSpace2(e.at(-1)); ) e.pop();
      }, IsNewline2 = function(e) {
        return "\n" === e || "\r\n" === e;
      };
      IsWordBreakWhiteSpace = IsWordBreakWhiteSpace2, IsOpeningCJKPunctiationChar = IsOpeningCJKPunctiationChar2, IsContinuingCJKPunctuationChar = IsContinuingCJKPunctuationChar2, WordBreakTrimEnd = WordBreakTrimEnd2, IsNewline = IsNewline2;
      const C33 = self.C3;
      const CJK_OPEN_PUNCTUATION = new Set("\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D");
      C33.WordWrap = class {
        constructor() {
          this._lines = [], this._iconSet = null;
        }
        GetLines() {
          return this._lines;
        }
        GetLineCount() {
          return this._lines.length;
        }
        SetIconSet(e) {
          this._iconSet = e;
        }
        _MeasureLine(e, t) {
          let n = 0, s = 0, i = 0, o = 0, r = 0;
          for (const h of e) {
            if (-1 === h.GetWidth()) {
              const a = t(h);
              h.SetHeight(a.height), h.SetFontBoundingBoxAscent(a.fontBoundingBoxAscent || 0), h.SetFontBoundingBoxDescent(a.fontBoundingBoxDescent || 0), h.SetTopToAlphabeticDistance(a.topToAlphabeticDistance || 0), h.IsText() ? h.SetWidth(a.width) : h.IsIcon() && h.CalculateWidthFromHeight(this._iconSet);
            }
            n += h.GetWidth(), s = Math.max(s, h.GetHeight()), i = Math.max(i, h.GetFontBoundingBoxAscent()), o = Math.max(o, h.GetFontBoundingBoxDescent()), r = Math.max(r, h.GetTopToAlphabeticDistance());
          }
          return { width: n, height: s, fontBoundingBoxAscent: i, fontBoundingBoxDescent: o, topToAlphabeticDistance: r };
        }
        _AddLine(e, t, n, s, i, o) {
          this._lines.push(C33.New(C33.WordWrap.Line, { fragments: e, width: t, height: n, fontBoundingBoxAscent: s, fontBoundingBoxDescent: i, topToAlphabeticDistance: o }));
        }
        WordWrap(t, o, r, n, h) {
          if ("string" == typeof t && (t = [C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t) })]), C33.clearArray(this._lines), !(!t.length || 1 === t.length && t[0].IsText() && t[0].IsEmpty() || r < 2)) {
            if (1 === t.length) {
              const a = t[0];
              if (a.IsText() && a.GetLength() <= 100 && !a.HasNewLine()) {
                let { width: e2, height: t2, fontBoundingBoxAscent: n2, fontBoundingBoxDescent: s, topToAlphabeticDistance: i } = o(a);
                if (e2 += h, a.SetWidth(e2), a.SetHeight(t2), a.SetFontBoundingBoxAscent(n2 || 0), a.SetFontBoundingBoxDescent(s || 0), a.SetTopToAlphabeticDistance(i || 0), e2 <= r) return void this._AddLine([a], e2, t2, n2, s, i);
              }
            }
            let e;
            e = "word" === n ? this._TokeniseByWord(t) : "cjk" === n ? this._TokeniseByCJK(t) : this._TokeniseByChar(t), this._WrapText(e, o, r, h);
          }
        }
        _TokeniseByWord(e) {
          const t = [];
          let n = [], s = false;
          for (const i of e) {
            const o = i.GetStyles();
            if (i.IsIcon()) 0 < n.length && t.push(n), t.push([i]), n = [];
            else for (const r of i.GetCharacterArray()) if (IsNewline2(r)) 0 < n.length && t.push(n), t.push([C33.New(C33.TextFragment, { chArr: ["\n"], styles: o })]), n = [];
            else if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [r], styles: o })), s = IsWordBreakWhiteSpace2(r);
            else {
              const h = IsWordBreakWhiteSpace2(r);
              if (h === s) {
                const a = n.at(-1);
                a.GetStyles() === o ? a._AppendChar(r) : n.push(C33.New(C33.TextFragment, { chArr: [r], styles: o }));
              } else t.push(n), n = [C33.New(C33.TextFragment, { chArr: [r], styles: o })], s = h;
            }
          }
          return 0 < n.length && t.push(n), t;
        }
        _TokeniseByCJK(e) {
          const t = [];
          let n = [], s = false;
          for (const i of e) {
            const o = i.GetStyles();
            if (i.IsIcon()) 0 < n.length && t.push(n), t.push([i]), n = [];
            else for (const r of i.GetCharacterArray()) if (IsNewline2(r)) 0 < n.length && t.push(n), t.push([C33.New(C33.TextFragment, { chArr: ["\n"], styles: o })]), n = [];
            else {
              if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [r], styles: o }));
              else if (s || IsContinuingCJKPunctuationChar2(r)) {
                const h = n.at(-1);
                h.GetStyles() === o ? h._AppendChar(r) : n.push(C33.New(C33.TextFragment, { chArr: [r], styles: o }));
              } else t.push(n), n = [C33.New(C33.TextFragment, { chArr: [r], styles: o })];
              s = IsOpeningCJKPunctiationChar2(r);
            }
          }
          return 0 < n.length && t.push(n), t;
        }
        _TokeniseByChar(e) {
          const t = [];
          for (const n of e) if (n.IsText()) {
            const s = n.GetCharacterArray();
            C33.appendArray(t, s.map((e2) => [C33.New(C33.TextFragment, { chArr: [e2], styles: n.GetStyles() })]));
          } else t.push([n]);
          return t;
        }
        _CopyLine(e) {
          return e.map((e2) => e2._Clone());
        }
        _AddWordToLine(t, n) {
          const e = t.length ? t.at(-1) : null;
          let s = 0;
          e && e.IsText() && n[0].IsText() && n[0].GetStyles() === e.GetStyles() && (e._Append(n[0].GetCharacterArray()), s = 1);
          for (let e2 = n.length; s < e2; ++s) {
            const i = n[s];
            t.push(i._Clone());
          }
        }
        _WrapText(e, t, n, s) {
          let i = [], o = 0, r = 0, h = 0, a = 0, c = 0;
          for (const l of e) if (1 === l.length && l[0].IsText() && 1 === l[0].GetLength() && IsNewline2(l[0].GetCharacterArray()[0])) {
            if (0 === r) {
              const d = C33.New(C33.TextFragment, { chArr: [" "], styles: l[0].GetStyles() }), g = t(d);
              r = g.height, h = g.fontBoundingBoxAscent || 0, a = g.fontBoundingBoxDescent || 0, c = g.topToAlphabeticDistance || 0;
            }
            this._AddLine(i, o, r, h, a, c), i = [], o = 0, r = 0, h = 0, a = 0, c = 0;
          } else {
            const u = this._CopyLine(i), p = (this._AddWordToLine(u, l), this._MeasureLine(u, t)), C = p.width;
            if (n <= C) if (0 < i.length && this._AddLine(i, o, r, h, a, c), i = [], l[0].IsText() && C33.IsCharArrayAllWhitespace(l[0].GetCharacterArray())) o = 0, r = 0, h = 0, a = 0, c = 0;
            else {
              this._AddWordToLine(i, l);
              const f = this._MeasureLine(i, t);
              o = f.width, r = f.height, h = f.fontBoundingBoxAscent, a = f.fontBoundingBoxDescent, c = f.topToAlphabeticDistance;
            }
            else i = u, o = C, r = p.height, h = p.fontBoundingBoxAscent, a = p.fontBoundingBoxDescent, c = p.topToAlphabeticDistance;
          }
          0 < i.length && this._AddLine(i, o, r, h, a, c), this._TrimLinesTrailingWhitespace(t, s);
        }
        _TrimLinesTrailingWhitespace(t, n) {
          for (const s of this._lines) {
            const i = s._GetFragmentsArray();
            if (i.length) {
              let e = i.at(-1);
              if (e.IsText()) {
                const o = e.GetCharacterArray(), r = o.slice(0);
                if (WordBreakTrimEnd2(r), 0 === r.length) s.OffsetWidth(-e.GetWidth()), i.pop();
                else if (r.length < o.length) {
                  e.SetCharacterArray(r);
                  const h = t(e).width, a = e.GetWidth() - h;
                  e.SetWidth(h), s.OffsetWidth(-a);
                }
                0 !== n && 0 < i.length && ((e = i.at(-1)).OffsetWidth(n), s.OffsetWidth(n));
              }
            }
          }
        }
        Clear() {
          C33.clearArray(this._lines);
        }
        GetMaxLineWidth() {
          return this._lines.reduce((e, t) => Math.max(e, t.GetWidth()), 0);
        }
        GetTotalLineHeight() {
          return this._lines.reduce((e, t) => e + t.GetHeight(), 0);
        }
      };
    }
    var IsWordBreakWhiteSpace;
    var IsOpeningCJKPunctiationChar;
    var IsContinuingCJKPunctuationChar;
    var WordBreakTrimEnd;
    var IsNewline;
    {
      const C33 = self.C3;
      C33.WordWrap.Line = class {
        constructor(t) {
          this._fragments = t.fragments || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
        }
        fragments() {
          return this._fragments.values();
        }
        *fragmentsReverse() {
          const e = this._fragments;
          for (let t = e.length - 1; 0 <= t; --t) yield e[t];
        }
        _GetFragmentsArray() {
          return this._fragments;
        }
        OffsetWidth(t) {
          this._width += t;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetFoundBoundingBoxAscent() {
          return this._fontBoundingBoxAscent;
        }
        GetFontBoundingBoxDescent() {
          return this._fontBoundingBoxDescent;
        }
        GetTopToAlphabeticDistance() {
          return this._topToAlphabeticDistance;
        }
        SetPosX(t) {
          this._posX = t;
        }
        GetPosX() {
          return this._posX;
        }
        SetPosY(t) {
          this._posY = t;
        }
        GetPosY() {
          return this._posY;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FragmentBase = class {
        constructor(t) {
          this._styles = t.styles || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
        }
        IsText() {
          return false;
        }
        IsIcon() {
          return false;
        }
        GetStyles() {
          return this._styles;
        }
        GetStyleTag(e) {
          const s = this._styles;
          for (let t = s.length - 1; 0 <= t; --t) {
            const n = s[t];
            if (n.tag === e) return n;
          }
          return null;
        }
        HasStyleTag(t) {
          return !!this.GetStyleTag(t);
        }
        GetStyleMap() {
          const t = /* @__PURE__ */ new Map();
          for (const e of this._styles) t.set(e.tag, e.param);
          return t;
        }
        OffsetWidth(t) {
          this._width += t;
        }
        SetWidth(t) {
          this._width = t;
        }
        GetWidth() {
          return this._width;
        }
        SetHeight(t) {
          this._height = t;
        }
        GetHeight() {
          return this._height;
        }
        SetFontBoundingBoxAscent(t) {
          this._fontBoundingBoxAscent = t;
        }
        GetFontBoundingBoxAscent() {
          return this._fontBoundingBoxAscent;
        }
        SetFontBoundingBoxDescent(t) {
          this._fontBoundingBoxDescent = t;
        }
        GetFontBoundingBoxDescent() {
          return this._fontBoundingBoxDescent;
        }
        SetTopToAlphabeticDistance(t) {
          this._topToAlphabeticDistance = t;
        }
        GetTopToAlphabeticDistance() {
          return this._topToAlphabeticDistance;
        }
        SetPosX(t) {
          this._posX = t;
        }
        GetPosX() {
          return this._posX;
        }
        SetPosY(t) {
          this._posY = t;
        }
        GetPosY() {
          return this._posY;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextFragment = class extends C33.FragmentBase {
        constructor(t) {
          super(t), this._chArr = t.chArr;
        }
        IsText() {
          return true;
        }
        _Append(t) {
          C33.appendArray(this._chArr, t), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;
        }
        _AppendChar(t) {
          this._chArr.push(t);
        }
        _Clone() {
          return C33.New(C33.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
        }
        GetCharacterArray() {
          return this._chArr;
        }
        SetCharacterArray(t) {
          this._chArr = t;
        }
        GetLength() {
          return this._chArr.length;
        }
        IsEmpty() {
          return 0 === this._chArr.length;
        }
        HasNewLine() {
          return this._chArr.includes("\n");
        }
      };
    }
    {
      const C33 = self.C3;
      C33.IconFragment = class extends C33.FragmentBase {
        constructor(t) {
          super(t), this._icon = t.icon;
        }
        IsIcon() {
          return true;
        }
        GetIconParameter() {
          return this._icon;
        }
        _Clone() {
          return C33.New(C33.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
        }
        GetTextIcon(t) {
          if (!t) return null;
          let e = Number(this._icon);
          return String(e) === this._icon ? (e = Math.floor(e), t.GetTextIconByIndex(e)) : t.GetTextIconByTag(this._icon);
        }
        CalculateWidthFromHeight(t) {
          const e = this.GetTextIcon(t);
          this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;
        }
        GetDrawable(t) {
          const e = this.GetTextIcon(t);
          return e ? e.GetDrawable() : null;
        }
        GetLength() {
          return 1;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIconManager = class {
        constructor(t) {
          this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t.getIconSetMeta, this._getIconSetContentCallback = t.getIconSetContent;
        }
        Release() {
          for (const t of this._iconSets.values()) t.Release();
          this._iconSets.clear();
        }
        GetIconSet(t) {
          let e = this._iconSets.get(t);
          if (!e) {
            const n = this._getIconSetMetaCallback(t);
            e = C33.New(C33.TextIconSet, this, { source: t, iconMeta: n }), this._iconSets.set(t, e);
          }
          return e;
        }
        HasIconSet(t) {
          return this._iconSets.has(t);
        }
        DeleteIconSet(t) {
          const e = this._iconSets.get(t);
          e && e.Release(), this._iconSets.delete(t);
        }
        async _GetIconSetContent(t) {
          return this._getIconSetContentCallback(t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIconSet = class {
        constructor(t, s) {
          this._textIconManager = t, this._source = s.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;
          const o = s.iconMeta.icons;
          for (let t2 = 0, s2 = o.length; t2 < s2; ++t2) {
            const e = o[t2], a = C33.New(C33.TextIcon, this, { index: t2, tag: e.tag, source: e.source, width: e.width, height: e.height });
            this._iconsArray.push(a), e.tag && this._iconsByTag.set(e.tag.toLowerCase(), a);
          }
        }
        Release() {
          for (const t of this._iconsArray) t.Release();
          C33.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;
        }
        HasLoaded() {
          return this._hasStartedLoad;
        }
        IsLoading() {
          return this._isLoading;
        }
        LoadContent() {
          return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;
        }
        async _DoLoadContent() {
          if (!this._hasStartedLoad) {
            this._hasStartedLoad = true, this._isLoading = true;
            const t = await this._textIconManager._GetIconSetContent(this._source);
            if (this._textIconManager) {
              const o = t.icons;
              for (let t2 = 0, s = Math.min(o.length, this._iconsArray.length); t2 < s; ++t2) {
                const e = o[t2].drawable;
                this._iconsArray[t2]._SetDrawable(e);
              }
              this._isLoading = false;
            }
          }
        }
        GetTextIconByIndex(t) {
          return (t = Math.floor(t)) < 0 || t >= this._iconsArray.length ? null : this._iconsArray[t];
        }
        GetTextIconByTag(t) {
          return this._iconsByTag.get(t.toLowerCase()) || null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TextIcon = class {
        constructor(t, e) {
          this._textIconSet = t, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;
        }
        Release() {
          this._width = 0, this._height = 0, this._textIconSet = null;
        }
        GetSource() {
          return this._source;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        _SetDrawable(t) {
          this._drawable = t;
        }
        GetDrawable() {
          return this._drawable;
        }
      };
    }
    {
      let PlaneFromPoints2 = function(t, e, r, n) {
        const a = tempVec3c;
        vec32.subtract(tempVec3a, r, e), vec32.subtract(tempVec3b, t, e), vec32.cross(a, tempVec3a, tempVec3b), vec32.normalize(a, a), n.set(a[0], a[1], a[2], vec32.dot(t, a));
      }, IsInFrontOfPlane2 = function(t, e, r, n, a, c, s) {
        const o = s.x, i = s.y, l = s.z, f = s.w, P = s.xF, h = s.yF, m = s.zF, p = 1 - P, v = 1 - h, u = 1 - m, b = o * t * P + o * n * p + i * e * h + i * a * v + l * r * m + l * c * u;
        if (f <= b) return true;
        const F = o * n * P + o * t * p + i * a * h + i * e * v + l * c * m + l * r * u;
        return f < F;
      }, IsPointInFrontOfPlane2 = function(t, e, r, n) {
        const a = n.x, c = n.y, s = n.z, o = n.w, i = a * t + c * e + s * r;
        return o <= i;
      };
      PlaneFromPoints = PlaneFromPoints2, IsInFrontOfPlane = IsInFrontOfPlane2, IsPointInFrontOfPlane = IsPointInFrontOfPlane2;
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempVec3a = vec32.create(), tempVec3b = vec32.create(), tempVec3c = vec32.create(), tempVec4 = vec42.create(), tempMat4 = mat42.create(), neartl = vec32.create(), neartr = vec32.create(), nearbl = vec32.create(), nearbr = vec32.create(), fartl = vec32.create(), fartr = vec32.create(), farbl = vec32.create(), farbr = vec32.create(), unitViewport = vec42.fromValues(0, 0, 1, 1);
      C33.Gfx = { Project(t, e, r, n, a, c, s) {
        const o = n[0] * t + n[4] * e + n[8] * r + n[12], i = n[1] * t + n[5] * e + n[9] * r + n[13], l = n[2] * t + n[6] * e + n[10] * r + n[14], f = n[3] * t + n[7] * e + n[11] * r + n[15];
        let P = a[0] * o + a[4] * i + a[8] * l + a[12] * f, h = a[1] * o + a[5] * i + a[9] * l + a[13] * f, m = a[2] * o + a[6] * i + a[10] * l + a[14] * f, p = a[3] * o + a[7] * i + a[11] * l + a[15] * f;
        return 0 != p && (h *= p = 1 / p, m *= p, s[0] = (0.5 * (P *= p) + 0.5) * c[2] + c[0], s[1] = (0.5 * h + 0.5) * c[3] + c[1], s[2] = 0.5 * (1 + m), true);
      }, Unproject(t, e, r, n, a, c, s) {
        const o = tempMat4, i = tempVec4;
        return mat42.multiply(o, a, n), null !== mat42.invert(o, o) && (i[0] = (t - c[0]) / c[2] * 2 - 1, i[1] = (e - c[1]) / c[3] * 2 - 1, i[2] = 2 * r - 1, i[3] = 1, vec42.transformMat4(i, i, o), 0 !== i[3]) && (i[3] = 1 / i[3], s[0] = i[0] * i[3], s[1] = i[1] * i[3], s[2] = i[2] * i[3], true);
      }, UnprojectScreenToWorldZ(t, e, r, n, a, c, s) {
        const o = tempVec3a, i = tempVec3b;
        if (!C33.Gfx.Unproject(t, e, 0, n, a, c, o)) return false;
        if (!C33.Gfx.Unproject(t, e, 1, n, a, c, i)) return false;
        const l = tempVec3b, f = (vec32.subtract(l, i, o), tempVec3c), P = (vec32.set(f, 0, 0, 1), -r), h = vec32.dot(f, l);
        let m = 0;
        if (0 === h) {
          const p = vec32.dot(f, o) + P;
          if (0 !== p) return false;
        } else if ((m = -(vec32.dot(o, f) + P) / h) < 0) return false;
        return vec32.scaleAndAdd(s, o, l, m), true;
      } };
      class Plane {
        constructor() {
          this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;
        }
        set(t, e, r, n) {
          this.x = t, this.y = e, this.z = r, this.w = n, this.xF = 0 < t ? 1 : 0, this.yF = 0 < e ? 1 : 0, this.zF = 0 < r ? 1 : 0;
        }
      }
      C33.Gfx.ViewFrustum = class {
        constructor() {
          this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();
        }
        CalculatePlanes(t, e) {
          const r = unitViewport;
          C33.Gfx.Unproject(0, 1, 0, t, e, r, neartl), C33.Gfx.Unproject(1, 1, 0, t, e, r, neartr), C33.Gfx.Unproject(0, 0, 0, t, e, r, nearbl), C33.Gfx.Unproject(1, 0, 0, t, e, r, nearbr), C33.Gfx.Unproject(0, 1, 1, t, e, r, fartl), C33.Gfx.Unproject(1, 1, 1, t, e, r, fartr), C33.Gfx.Unproject(0, 0, 1, t, e, r, farbl), C33.Gfx.Unproject(1, 0, 1, t, e, r, farbr), PlaneFromPoints2(nearbl, neartl, fartl, this._leftP), PlaneFromPoints2(neartl, neartr, fartr, this._topP), PlaneFromPoints2(neartr, nearbr, farbr, this._rightP), PlaneFromPoints2(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints2(farbl, fartl, fartr, this._farP), PlaneFromPoints2(nearbr, neartr, neartl, this._nearP);
        }
        ContainsAABB(t, e, r, n, a, c) {
          return IsInFrontOfPlane2(t, e, r, n, a, c, this._leftP) && IsInFrontOfPlane2(t, e, r, n, a, c, this._topP) && IsInFrontOfPlane2(t, e, r, n, a, c, this._rightP) && IsInFrontOfPlane2(t, e, r, n, a, c, this._bottomP) && IsInFrontOfPlane2(t, e, r, n, a, c, this._nearP) && IsInFrontOfPlane2(t, e, r, n, a, c, this._farP);
        }
        IsBehindNearPlane(t, e, r) {
          return !IsPointInFrontOfPlane2(t, e, r, this._nearP);
        }
      };
    }
    var PlaneFromPoints;
    var IsInFrontOfPlane;
    var IsPointInFrontOfPlane;
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempMat4 = mat42.create(), tmpVec3a = vec32.fromValues(0, 0, 0), tmpVec3b = vec32.fromValues(0, 0, 0), tmpVec3c = vec32.fromValues(0, 0, 0), defaultUpVector = vec32.fromValues(0, 1, 0), tmpVec4 = vec42.fromValues(0, 0, 0, 0), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect(), defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat42.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
      C33.Gfx.RendererBase = class {
        constructor(e) {
          e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C33.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat42.create(), this._matMV = mat42.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;
        }
        FillIndexBufferData(e) {
          let t = 0, i = e.length, a = 0;
          for (; t < i; ) e[t++] = a, e[t++] = a + 1, e[t++] = a + 2, e[t++] = a, e[t++] = a + 2, e[t++] = a + 3, a += 4;
        }
        _ClearState() {
          this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();
        }
        InitState() {
          this._ClearState(), this._currentStateGroup = null;
        }
        OnDeviceOrContextLost() {
          for (const e of this._allShaderPrograms) e.Release();
          this._ClearState();
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetDefaultCameraZ(e) {
          return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());
        }
        GetZAxisScaleFactor(e) {
          if (this.IsZAxisScaleNormalized()) {
            const t = e / (2 * this._GetTanFovYDiv2());
            return t / this.GetDefaultCameraZ(e);
          }
          return 1;
        }
        SetNearZ(e) {
          this._nearZ = e;
        }
        GetNearZ() {
          return this._nearZ;
        }
        SetFarZ(e) {
          this._farZ = e;
        }
        GetFarZ() {
          return this._farZ;
        }
        SetFovY(e) {
          this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);
        }
        GetFovY() {
          return this._fovY;
        }
        _GetTanFovYDiv2() {
          return this._tan_fovY_2;
        }
        SetZAxisScaleNormalized() {
          this._zAxisScale = false;
        }
        SetZAxisScaleRegular() {
          this._zAxisScale = true;
        }
        IsZAxisScaleNormalized() {
          return !this._zAxisScale;
        }
        IsZAxisScaleRegular() {
          return this._zAxisScale;
        }
        CalculatePerspectiveMatrix(e, t, i = 0.5, a = 0.5) {
          const s = this.GetNearZ(), r = this.GetFarZ(), l = this.GetFovY();
          if (0.5 === i && 0.5 === a) this.IsWebGPU() ? mat42.perspectiveZO(e, l, t, s, r) : mat42.perspective(e, l, t, s, r);
          else {
            const n = 2 * (i = 1 - i) - 2, h = 2 * i, o = 2 * a - 2, p = 2 * a, _ = this._GetTanFovYDiv2() * s, c = _ * t;
            mat42.frustum(e, n * c, h * c, o * _, p * _, s, r), this.IsWebGPU() && mat42.mul(e, matWebGLtoWebGPU, e);
          }
        }
        CalculateOrthographicMatrix(e, t, i, a = 1) {
          const s = self.devicePixelRatio, r = 2 * this.GetDefaultCameraZ(i) * s * this._GetTanFovYDiv2() / i, l = t * r / (2 * s * a), n = i * r / (2 * s * a), h = -l, o = l, p = -n, _ = n;
          this.IsWebGPU() ? mat42.orthoZO(e, h, o, p, _, this.GetNearZ(), this.GetFarZ()) : mat42.ortho(e, h, o, p, _, this.GetNearZ(), this.GetFarZ());
        }
        CalculateLookAtModelView(e, t, i, a, s, r = 1) {
          let l = 1;
          this.IsZAxisScaleNormalized() && (l = 200 * this._GetTanFovYDiv2() / s);
          const n = tmpVec3c, h = (vec32.set(n, l, -l, 1), tmpVec3a), o = tmpVec3b;
          vec32.multiply(h, t, n), vec32.multiply(o, i, n), mat42.lookAt(e, h, o, a || defaultUpVector), n[2] = r, mat42.scale(e, e, n);
        }
        CalculateLookAtModelView2(e, t, i, a, s, r, l, n) {
          return vec32.set(tmpVec3a, e, t, i), vec32.set(tmpVec3b, a, s, r), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l, n), tempMat4;
        }
        _AddShaderProgram(e) {
          this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);
        }
        _RemoveShaderProgram(e) {
          const t = this._allShaderPrograms.indexOf(e);
          -1 !== t && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName());
        }
        _ClearAllShaderPrograms() {
          C33.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();
        }
        GetShaderProgramByName(e) {
          return this._shaderProgramsByName.get(e) || null;
        }
        GetTextureFillShaderProgram() {
          return this._spTextureFill;
        }
        SetTextureFillMode() {
          this.SetProgram(this._spTextureFill);
        }
        GetPointsRenderingProgram() {
          return this._spPoints;
        }
        SetPointsRenderingProgram() {
          this.SetProgram(this._spPoints);
        }
        SetTilemapFillMode() {
          this.SetProgram(this._spTilemapFill);
        }
        SetTileRandomizationMode() {
          this.SetProgram(this._spTileRandomization);
        }
        SetColorFillMode() {
          this.SetProgram(this._spColorFill);
        }
        SetLinearGradientFillMode() {
          this.SetProgram(this._spLinearGradientFill);
        }
        SetPenumbraFillMode() {
          this.SetProgram(this._spPenumbraFill);
        }
        SetHardEllipseFillMode() {
          this.SetProgram(this._spHardEllipseFill);
        }
        SetHardEllipseOutlineMode() {
          this.SetProgram(this._spHardEllipseOutline);
        }
        SetSmoothEllipseFillMode() {
          this.SetProgram(this._spSmoothEllipseFill);
        }
        SetSmoothEllipseOutlineMode() {
          this.SetProgram(this._spSmoothEllipseOutline);
        }
        SetSmoothLineFillMode() {
          this.SetProgram(this._spSmoothLineFill);
        }
        _SetCurrentStateGroup(e) {
          this._currentStateGroup = e;
        }
        GetCurrentStateGroup() {
          return this._currentStateGroup;
        }
        AcquireStateGroup(e, t, i, a) {
          const s = C33.Gfx.StateGroup.MakeKey(e, t, i, a);
          let r = this._stateGroups.get(s);
          return r || (r = C33.New(C33.Gfx.StateGroup, this, e, t, i, a), this._stateGroups.set(s, r)), r.AddRef(), r;
        }
        ReleaseStateGroup(e) {
          e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());
        }
        _InitBlendModeData(e) {
          C33.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();
          let t = 0;
          for (const i of e) {
            const a = i[0], s = i[1], r = i[2];
            this._blendModeTable.push([s, r]), this._namedBlendModeMap.set(a, { number: t, srcBlend: s, destBlend: r }), t++;
          }
        }
        _GetBlendByIndex(e) {
          return this._blendModeTable[e];
        }
        GetSrcBlendByIndex(e) {
          return this._GetBlendByIndex(e)[0];
        }
        GetDestBlendByIndex(e) {
          return this._GetBlendByIndex(e)[1];
        }
        GetNamedBlend(e) {
          const t = this._namedBlendModeMap.get(e);
          if (void 0 === t) throw new Error("invalid blend name");
          return t;
        }
        NamedBlendToNumber(e) {
          const t = this._namedBlendModeMap.get(e);
          if (void 0 === t) throw new Error("invalid blend name");
          return t.number;
        }
        SetBaseZ(e) {
          this._baseZ = e;
        }
        GetBaseZ() {
          return this._baseZ;
        }
        SetCurrentZ(e) {
          this._currentZ = e, this._currentStateGroup = null;
        }
        GetCurrentZ() {
          return this._currentZ;
        }
        Line(e, t, i, a) {
          const s = C33.angleTo(e, t, i, a), r = Math.sin(s), l = Math.cos(s), n = 0.5 * this._lineWidth, h = r * n, o = l * n, p = this._lineCap;
          2 === p ? this.LinePreCalc_LineCap2(e, t, 0, i, a, 0, h, o) : 1 === p ? this.LinePreCalc_LineCap1(e, t, 0, i, a, 0, h, o) : this.LinePreCalc_LineCap0(e, t, 0, i, a, 0, h, o);
        }
        Line3D(e, t, i, a, s, r) {
          const l = C33.angleTo(e, t, a, s), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;
          2 === c ? this.LinePreCalc_LineCap2(e, t, i, a, s, r, p, _) : 1 === c ? this.LinePreCalc_LineCap1(e, t, i, a, s, r, p, _) : this.LinePreCalc_LineCap0(e, t, i, a, s, r, p, _);
        }
        LinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = 2 * n, d = 2 * l, C = o + l, m = p - n, L = o - l + u, f = p + n + d, g = _ + l, S = c - n, P = _ - l - u, G = c + n - d;
          this.Quad3D2(C, m, i, g, S, r, P, G, r, L, f, i, defaultTexCoordsQuad);
        }
        LinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;
          this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);
        }
        LinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h, p = t + h, _ = a + h, c = s + h, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;
          this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);
        }
        TexturedLine(e, t, i, a, s, r) {
          const l = C33.angleTo(e, t, i, a), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;
          2 === c ? this.TexturedLinePreCalc_LineCap2(e, t, i, a, p, _, s, r) : 1 === c ? this.TexturedLinePreCalc_LineCap1(e, t, i, a, p, _, s, r) : this.TexturedLinePreCalc_LineCap0(e, t, i, a, p, _, s, r);
        }
        TexturedLinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = 2 * r, d = 2 * s, C = o + s, m = p - r, L = o - s + u, f = p + r + d, g = _ + s, S = c - r, P = _ - s - u, G = c + r - d;
          tmpQuad.set(C, m, g, S, P, G, L, f), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        TexturedLinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;
          tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        TexturedLinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {
          const h = this._lineOffset, o = e + h, p = t + h, _ = i + h, c = a + h, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;
          tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
        }
        LineRect(e, t, i, a) {
          const s = 0.5 * this._lineWidth, r = this._lineCap;
          2 === r ? this._LineRectPreCalc_LineCap2(e, t, i, a, s) : 1 === r ? this._LineRectPreCalc_LineCap1(e, t, i, a, s) : this._LineRectPreCalc_LineCap0(e, t, i, a, s);
        }
        _LineRectPreCalc_LineCap2(e, t, i, a, s) {
          this.LinePreCalc_LineCap2(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap2(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap2(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap2(e, a, 0, e, t, 0, -s, 0);
        }
        _LineRectPreCalc_LineCap1(e, t, i, a, s) {
          this.LinePreCalc_LineCap1(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap1(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap1(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap1(e, a, 0, e, t, 0, -s, 0);
        }
        _LineRectPreCalc_LineCap0(e, t, i, a, s) {
          this.LinePreCalc_LineCap0(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap0(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap0(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap0(e, a, 0, e, t, 0, -s, 0);
        }
        LineRect2(e) {
          this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
        }
        LineQuad(e) {
          const t = C33.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i = Math.sin(t), a = Math.cos(t), s = 0.5 * this._lineWidth, r = i * s, l = a * s, n = this._lineCap;
          2 === n ? this._LineQuadPreCalc_LineCap2(e, r, l) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r, l) : this._LineQuadPreCalc_LineCap0(e, r, l);
        }
        _LineQuadPreCalc_LineCap2(e, t, i) {
          this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
        }
        _LineQuadPreCalc_LineCap1(e, t, i) {
          this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
        }
        _LineQuadPreCalc_LineCap0(e, t, i) {
          this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);
        }
        SetLineWidth(e) {
          this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;
        }
        GetLineWidth() {
          return this._lineWidth;
        }
        PushLineWidth(e) {
          if (100 <= this._lineWidthStack.length) throw new Error("pushed too many line widths - check push/pop pairs");
          this._lineWidthStack.push(e), this._lineWidth = e;
        }
        PopLineWidth() {
          if (this._lineWidthStack.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
          this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);
        }
        SetLineCapButt() {
          this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        SetLineCapSquare() {
          this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        SetLineCapZag() {
          this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;
        }
        PushLineCap(e) {
          if ("butt" === e) this.PushLineCapButt();
          else if ("square" === e) this.PushLineCapSquare();
          else {
            if ("zag" !== e) throw new Error("invalid line cap");
            this.PushLineCapZag();
          }
        }
        PushLineCapButt() {
          if (100 <= this._lineCapStack.length) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(0), this._lineCap = 0;
        }
        PushLineCapSquare() {
          if (100 <= this._lineCapStack.length) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(1), this._lineCap = 1;
        }
        PushLineCapZag() {
          if (100 <= this._lineCapStack.length) throw new Error("pushed too many line caps - check push/pop pairs");
          this._lineCapStack.push(2), this._lineCap = 2;
        }
        PopLineCap() {
          if (this._lineCapStack.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
          this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);
        }
        SetLineOffset(e) {
          this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;
        }
        GetLineOffset() {
          return this._lineOffset;
        }
        PushLineOffset(e) {
          if (100 <= this._lineOffsetStack.length) throw new Error("pushed too many line offsets - check push/pop pairs");
          this._lineOffsetStack.push(e), this._lineOffset = e;
        }
        PopLineOffset() {
          if (this._lineOffsetStack.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
          this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);
        }
        ConvexPoly(t) {
          const e = t.length / 2;
          if (e < 3) throw new Error("need at least 3 points");
          const i = e - 2, a = i - 1, s = t[0], r = t[1];
          for (let e2 = 0; e2 < i; e2 += 2) {
            const l = 2 * e2, n = t[2 + l], h = t[3 + l], o = t[4 + l], p = t[5 + l];
            if (e2 === a) this.Quad2(s, r, n, h, o, p, o, p);
            else {
              const _ = t[6 + l], c = t[7 + l];
              this.Quad2(s, r, n, h, o, p, _, c);
            }
          }
        }
        GetNumVertexComponents() {
          return 3;
        }
        Finish() {
          this.EndBatch(true), this._frameNumber++;
        }
        GetFrameNumber() {
          return this._frameNumber;
        }
        IncrementFrameNumber() {
          this._frameNumber++;
        }
        SetMipmapsEnabled(e) {
          this._enableMipmaps = !!e;
        }
        AreMipmapsEnabled() {
          return this._enableMipmaps;
        }
        SetHasMajorPerformanceCaveat(e) {
          this._hasMajorPerformanceCaveat = !!e;
        }
        HasMajorPerformanceCaveat() {
          return this._hasMajorPerformanceCaveat;
        }
        IsWebGL() {
          return false;
        }
        IsWebGPU() {
          return false;
        }
        GetEstimatedBackBufferMemoryUsage() {
        }
        GetEstimatedRenderBufferMemoryUsage() {
        }
        GetEstimatedTextureMemoryUsage() {
        }
        GetEstimatedTotalMemoryUsage() {
          return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();
        }
        CreateRendererText() {
          return C33.New(C33.Gfx.RendererText, this);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.ShaderProgramBase = class {
        constructor(e, t) {
          this._name = t.name, this._renderer = e, this._extendBoxHorizontal = t.extendBoxHorizontal || 0, this._extendBoxVertical = t.extendBoxVertical || 0, this._crossSampling = !!t.crossSampling, this._mustPreDraw = !!t.mustPreDraw, this._preservesOpaqueness = !!t.preservesOpaqueness, this._supports3dDirectRendering = !!t.supports3dDirectRendering, this._animated = !!t.animated, this._blendsBackground = !!t.blendsBackground, this._usesDepth = !!t.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
        }
        Release() {
          this._renderer = null;
        }
        GetRenderer() {
          return this._renderer;
        }
        GetName() {
          return this._name;
        }
        ExtendsBox() {
          return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
        }
        GetBoxExtendHorizontal() {
          return this._extendBoxHorizontal;
        }
        GetBoxExtendVertical() {
          return this._extendBoxVertical;
        }
        UsesCrossSampling() {
          return this._crossSampling;
        }
        MustPreDraw() {
          return this._mustPreDraw;
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        Supports3DDirectRendering() {
          return this._supports3dDirectRendering;
        }
        IsAnimated() {
          return this._animated;
        }
        BlendsBackground() {
          return this._blendsBackground;
        }
        UsesDepth() {
          return this._usesDepth;
        }
        UsesAnySrcRectOrPixelSize() {
          return this._usesAnySrcRectOrPixelSize;
        }
        NeedsPostDrawOrExtendsBox() {
          return this._needsPostDrawOrExtendBox;
        }
        UsesIsSrcTexRotated() {
          return false;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.StateGroup = class {
        constructor(e, r, t, s, o) {
          this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = "", this._blendMode = t, this._color = C33.New(C33.Color), this._color.set(s), this._zElevation = o, "string" == typeof r ? this._shaderProgramName = r : (this._shaderProgram = r, this._shaderProgramName = this._shaderProgram.GetName());
        }
        Release() {
          if (0 < this._refCount) throw new Error("releasing state group still in use");
          this._renderer = null, this._shaderProgram = null, this._shaderProgramName = "";
        }
        Apply() {
          const e = this._renderer;
          e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e._SetCurrentStateGroup(this);
        }
        GetKey() {
          return C33.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation);
        }
        AddRef() {
          ++this._refCount;
        }
        DecRef() {
          --this._refCount;
        }
        _GetRefCount() {
          return this._refCount;
        }
        OnContextLost() {
          this._shaderProgram = null;
        }
        OnContextRestored(e) {
          if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error("failed to restore shader program");
        }
        static MakeKey(e, r, t, s) {
          const o = "string" == typeof e ? e : e.GetName();
          return o + "," + r + "," + t.getR() + "," + t.getG() + "," + t.getB() + "," + t.getA() + "," + s;
        }
      };
    }
    {
      let interpolateQuad2 = function(t, e, s) {
        const i = s.getTlx(), n = s.getTly(), o = s.getTrx() - i, h = s.getTry() - n, r = s.getBlx() - i, a = s.getBly() - n, l = o * t, _ = h * t, G = r * e, u = a * e;
        return [i + l + G, n + _ + u];
      };
      interpolateQuad = interpolateQuad2;
      const C33 = self.C3, tempQuadTex = C33.New(C33.Quad);
      C33.Gfx.MeshPoint = class {
        constructor(t, e, s) {
          this._mesh = t, this._col = e, this._row = s, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;
        }
        _Init(t, e, s, i) {
          this._x = t, this._y = e, this._u = s, this._v = i;
        }
        GetX() {
          return this._x;
        }
        SetX(t) {
          this._x !== t && (this._x = t, this._mesh._SetPointsChanged());
        }
        GetY() {
          return this._y;
        }
        SetY(t) {
          this._y !== t && (this._y = t, this._mesh._SetPointsChanged());
        }
        GetZElevation() {
          return this._zElevation;
        }
        SetZElevation(t) {
          this._zElevation !== t && (this._zElevation = Math.max(t, 0), this._mesh._SetPointsChanged());
        }
        GetU() {
          return this._u;
        }
        SetU(t) {
          this._u = t;
        }
        GetV() {
          return this._v;
        }
        SetV(t) {
          this._v = t;
        }
        _Interpolate_TexRect(t, e, s) {
          [this._x, this._y] = interpolateQuad2(t._x, t._y, e), this._zElevation = t._zElevation, this._u = C33.lerp(s.getLeft(), s.getRight(), t._u), this._v = C33.lerp(s.getTop(), s.getBottom(), t._v);
        }
        _Interpolate_TexQuad(t, e, s) {
          [this._x, this._y] = interpolateQuad2(t._x, t._y, e), this._zElevation = t._zElevation, [this._u, this._v] = interpolateQuad2(t._u, t._v, s);
        }
        SaveToJson() {
          return { "x": this.GetX(), "y": this.GetY(), "z": this.GetZElevation(), "u": this.GetU(), "v": this.GetV() };
        }
        LoadFromJson(t) {
          this.SetX(t["x"]), this.SetY(t["y"]), t.hasOwnProperty("z") && this.SetZElevation(t["z"]), this.SetU(t["u"]), this.SetV(t["v"]);
        }
        GetMesh() {
          return this._mesh;
        }
        GetColumn() {
          return this._col;
        }
        GetRow() {
          return this._row;
        }
      }, C33.Gfx.Mesh = class {
        constructor(s, t, e) {
          if (s < 2 || t < 2) throw new Error("invalid mesh size");
          this._hsize = s, this._vsize = t, this._owner = e || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._pointsChanged = false;
          const i = s - 1, n = t - 1;
          for (let e2 = 0; e2 < t; ++e2) {
            const o = [];
            for (let t2 = 0; t2 < s; ++t2) {
              const h = C33.New(C33.Gfx.MeshPoint, this, t2, e2), r = t2 / i, a = e2 / n;
              h._Init(r, a, r, a), o.push(h);
            }
            this._pts.push(o);
          }
        }
        Release() {
          C33.clearArray(this._pts);
        }
        GetHSize() {
          return this._hsize;
        }
        GetVSize() {
          return this._vsize;
        }
        GetOwner() {
          return this._owner;
        }
        _GetPoints() {
          return this._pts;
        }
        _SetPointsChanged() {
          this._pointsChanged = true;
        }
        _MaybeComputeBounds() {
          if (this._pointsChanged) {
            let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, n = 0;
            for (const o of this._pts) for (const h of o) {
              const r = h.GetX(), a = h.GetY();
              t = Math.min(t, r), e = Math.min(e, a), s = Math.max(s, r), i = Math.max(i, a), n = Math.max(n, h.GetZElevation());
            }
            this._minX = t, this._minY = e, this._maxX = s, this._maxY = i, this._maxZ = n, this._pointsChanged = false;
          }
        }
        GetMinX() {
          return this._MaybeComputeBounds(), this._minX;
        }
        GetMinY() {
          return this._MaybeComputeBounds(), this._minY;
        }
        GetMaxX() {
          return this._MaybeComputeBounds(), this._maxX;
        }
        GetMaxY() {
          return this._MaybeComputeBounds(), this._maxY;
        }
        GetMaxZ() {
          return this._MaybeComputeBounds(), this._maxZ;
        }
        HasAnyZElevation() {
          return 0 < this.GetMaxZ();
        }
        GetMeshPointAt(t, e) {
          return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t];
        }
        CalculateTransformedMesh(t, s, i) {
          const n = i instanceof C33.Rect;
          if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error("source mesh wrong size");
          const o = t._pts, h = this._pts;
          for (let t2 = 0, e = h.length; t2 < e; ++t2) {
            const r = o[t2], a = h[t2];
            for (let t3 = 0, e2 = a.length; t3 < e2; ++t3) {
              const l = r[t3], _ = a[t3];
              n ? _._Interpolate_TexRect(l, s, i) : _._Interpolate_TexQuad(l, s, i);
            }
          }
        }
        Draw(n) {
          const o = this._pts;
          let h = o[0];
          for (let t = 1, e = o.length; t < e; ++t) {
            const r = o[t];
            let s = h[0], i = r[0];
            for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {
              const a = h[t2], l = r[t2];
              tempQuadTex.set(s.GetU(), s.GetV(), a.GetU(), a.GetV(), l.GetU(), l.GetV(), i.GetU(), i.GetV()), n.Quad3D2(s.GetX(), s.GetY(), s.GetZElevation(), a.GetX(), a.GetY(), a.GetZElevation(), l.GetX(), l.GetY(), l.GetZElevation(), i.GetX(), i.GetY(), i.GetZElevation(), tempQuadTex), s = a, i = l;
            }
            h = r;
          }
        }
        Outline(h, r) {
          r = r || ((t2, e, s) => [t2, e, s]);
          const t = this._pts;
          let a = t[0];
          for (let n = 1, o = t.length; n < o; ++n) {
            const l = t[n];
            let s = a[0], i = l[0];
            for (let t2 = 1, e = l.length; t2 < e; ++t2) {
              const _ = a[t2], G = l[t2], [u, c, m] = r(s.GetX(), s.GetY(), s.GetZElevation()), [p, C, f] = r(_.GetX(), _.GetY(), _.GetZElevation()), [x, v, M] = r(G.GetX(), G.GetY(), G.GetZElevation()), [g, y, d] = r(i.GetX(), i.GetY(), i.GetZElevation());
              h.Line3D(u, c, m, p, C, f), h.Line3D(u, c, m, x, v, M), h.Line3D(u, c, m, g, y, d), t2 === e - 1 && h.Line3D(p, C, f, x, v, M), n === o - 1 && h.Line3D(g, y, d, x, v, M), s = _, i = G;
            }
            a = l;
          }
        }
        InsertPolyMeshVertices(t) {
          const s = 1e-3, i = 0.99999999, n = t.pointsArr(), o = [], h = this.GetHSize() - 1, r = this.GetVSize() - 1, a = 1 / h, l = 1 / r, _ = h - 1, G = r - 1;
          let u = n[0], c = n[1], m = C33.clamp(Math.floor(u * h), 0, _), p = C33.clamp(Math.floor(c * r), 0, G), C = true, f = 0, x = 0, v = 0;
          let M = -1;
          const g = () => {
            u = C33.clamp(C33.lerp(u, f, v), 0, 1), c = C33.clamp(C33.lerp(c, x, v), 0, 1), o.push(u, c);
          };
          for (let t2 = 0, e = n.length; t2 < e; t2 += 2) {
            u = n[t2], c = n[t2 + 1], o.push(u, c), m = C33.clamp(Math.floor(u * h), 0, _), p = C33.clamp(Math.floor(c * r), 0, G);
            const y = (t2 + 2) % e;
            for (f = n[y], x = n[1 + y], M = -1; ; ) {
              if (1e6 < o.length) throw new Error("Too many mesh poly points");
              const d = m * a, z = p * l, E = (m + 1) * a, S = (p + 1) * l;
              if (C = C33.isPointInTriangleInclusive(u, c, d, z, E, z, E, S), 0 !== M && 0 <= (v = C33.rayIntersectExtended(u, c, f, x, d, z, E, S, -s)) && v <= i) g(), C = !C, M = 0;
              else if (0 < p && 2 !== M && 0 <= (v = C33.rayIntersectExtended(u, c, f, x, d, z, E, z, s)) && v <= i) g(), p--, C = false, M = 4;
              else if (m < _ && 3 !== M && 0 <= (v = C33.rayIntersectExtended(u, c, f, x, E, z, E, S, s)) && v <= i) g(), m++, C = false, M = 1;
              else if (0 < m && 1 !== M && 0 <= (v = C33.rayIntersectExtended(u, c, f, x, d, z, d, S, s)) && v <= i) g(), m--, C = true, M = 3;
              else {
                if (!(p < G && 4 !== M && 0 <= (v = C33.rayIntersectExtended(u, c, f, x, d, S, E, S, s)) && v <= i)) break;
                g(), p++, C = true, M = 2;
              }
            }
          }
          return C33.New(C33.CollisionPoly, o);
        }
        TransformCollisionPoly(t, e) {
          const s = this._TransformPolyPoints(t);
          this._SimplifyPoly(s), e.setPoints(s);
        }
        _TransformPolyPoints(t) {
          const s = [], i = t.pointsArr();
          for (let t2 = 0, e = i.length; t2 < e; t2 += 2) {
            const n = i[t2], o = i[t2 + 1], [h, r] = this.TransformPoint(n, o);
            s.push(h, r);
          }
          return s;
        }
        TransformPoint(t, e) {
          const s = this.GetHSize() - 1, i = this.GetVSize() - 1, n = 1 / s, o = 1 / i, h = C33.clamp(Math.floor(t * s), 0, s - 1), r = C33.clamp(Math.floor(e * i), 0, i - 1), a = h * n, l = r * o, _ = (h + 1) * n, G = (r + 1) * o, u = this.GetMeshPointAt(h, r), c = this.GetMeshPointAt(h + 1, r + 1), m = C33.isPointInTriangleInclusive(t, e, a, l, _, l, _, G), p = m ? a + n : a, C = m ? l : l + o, f = this.GetMeshPointAt(h + (m ? 1 : 0), r + (m ? 0 : 1)), [x, v, M] = C33.triangleCartesianToBarycentric(t, e, a, l, p, C, _, G);
          return C33.triangleBarycentricToCartesian3d(x, v, M, u.GetX(), u.GetY(), u.GetZElevation(), f.GetX(), f.GetY(), f.GetZElevation(), c.GetX(), c.GetY(), c.GetZElevation());
        }
        _SimplifyPoly(s) {
          const i = [];
          let n = s[0], o = s[1], h = n - s.at(-2), r = o - s.at(-1);
          for (let t = 0, e = s.length; t < e; t += 2) {
            const a = (t + 2) % e, l = s[a], _ = s[1 + a], G = l - n, u = _ - o, c = Math.abs(G) < 1e-7 && Math.abs(h) < 1e-7 && Math.sign(u) === Math.sign(r), m = Math.abs(u) < 1e-7 && Math.abs(r) < 1e-7 && Math.sign(G) === Math.sign(h);
            (!c && !m && 1e-3 < Math.abs(G / h - u / r) || 0 == G && 0 == u) && i.push(n, o), n = l, o = _, h = G, r = u;
          }
          6 <= i.length && i.length < s.length && C33.shallowAssignArray(s, i);
        }
        SaveToJson() {
          return { "cols": this.GetHSize(), "rows": this.GetVSize(), "points": this._pts.map((t) => t.map((t2) => t2.SaveToJson())) };
        }
        LoadFromJson(t) {
          const s = this.GetHSize(), i = this.GetVSize();
          if (t["cols"] !== s || t["rows"] !== i) throw new Error("mesh data wrong size");
          const n = t["points"];
          for (let e = 0; e < i; ++e) {
            const o = n[e];
            for (let t2 = 0; t2 < s; ++t2) {
              const h = this.GetMeshPointAt(t2, e);
              h.LoadFromJson(o[t2]);
            }
          }
        }
      };
    }
    var interpolateQuad;
    {
      let GetFormatSpecifiers2 = function(e, t) {
        let i, r, a, s;
        switch (e) {
          case "rgba8":
            i = t.RGBA8, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_BYTE;
            break;
          case "rgb8":
            i = t.RGB8, r = t.RGB, a = t.RGB, s = t.UNSIGNED_BYTE;
            break;
          case "rgba4":
            i = t.RGBA4, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_4_4_4_4;
            break;
          case "rgb5_a1":
            i = t.RGB5_A1, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_5_5_5_1;
            break;
          case "rgb565":
            i = t.RGB565, r = t.RGB, a = t.RGB, s = t.UNSIGNED_SHORT_5_6_5;
            break;
          default:
            throw new Error("invalid pixel format");
        }
        return { sizedinternalformat: i, internalformat: r, format: a, type: s };
      };
      GetFormatSpecifiers = GetFormatSpecifiers2;
      const C33 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set(["default", "low", "high"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
      const CREATEFROM_DEFAULT_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, pixelFormat: "rgba8", mipMap: true, mipMapQuality: "default", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();
      C33.Gfx.WebGLRendererTexture = class {
        constructor(e) {
          this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._pixelFormat = "rgba8", this._isMipMapped = false, this._mipMapQuality = "default", this._refCount = 0;
        }
        _CreateStatic(t, e) {
          if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData || t instanceof ArrayBuffer || null === t)) throw new Error("invalid texture source");
          if (e = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, e), this._texture) throw new Error("already created texture");
          if (this._wrapX = e.wrapX, this._wrapY = e.wrapY, this._sampling = e.sampling, this._anisotropy = e.anisotropy, this._pixelFormat = e.pixelFormat, this._isMipMapped = !!e.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = e.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
          if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
          if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
          if (this._isStatic = true, t instanceof ArrayBuffer || null === t || e.isSvg) {
            if (this._width = e.width, this._height = e.height, t instanceof ArrayBuffer && t.byteLength !== this._width * this._height * 4) throw new Error("ArrayBuffer wrong size");
          } else this._width = t.width, this._height = t.height;
          if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture data size");
          if (e.isSvg) {
            const n = C33.CreateCanvas(this._width, this._height), _ = n.getContext("2d");
            _.drawImage(t, 0, 0, this._width, this._height), t = n;
          }
          const i = C33.isPOT(this._width) && C33.isPOT(this._height), r = this._renderer.GetMaxTextureSize();
          if (this._width > r || this._height > r) throw new Error("texture data exceeds maximum texture size");
          const a = this._renderer.GetContext(), s = this._renderer.GetWebGLVersionNumber(), h = (this._texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this._texture), a.pixelStorei(a["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], e.premultiplyAlpha), a.pixelStorei(a["UNPACK_FLIP_Y_WEBGL"], false), GetFormatSpecifiers2(this._pixelFormat, a));
          if (this._renderer.SupportsNPOTTextures() || i || !this._IsTiled()) if (2 <= s) {
            let e2;
            e2 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a.texStorage2D(a.TEXTURE_2D, e2, h.sizedinternalformat, this._width, this._height), t instanceof ArrayBuffer ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this._width, this._height, h.format, h.type, new Uint8Array(t)) : null !== t && a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, h.format, h.type, t);
          } else t instanceof ArrayBuffer ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, new Uint8Array(t)) : null === t ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, null) : a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, t);
          else {
            if (null === t) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
            if ((t = t instanceof ArrayBuffer ? new ImageData(new Uint8ClampedArray(t), this._width, this._height) : t) instanceof ImageData) {
              const l = C33.CreateCanvas(this._width, this._height), T = l.getContext("2d");
              T.putImageData(t, 0, 0), t = l;
            }
            const o = C33.CreateCanvas(C33.nextHighestPowerOfTwo(this._width), C33.nextHighestPowerOfTwo(this._height)), p = o.getContext("2d");
            p.imageSmoothingEnabled = "nearest" !== this._sampling, p.drawImage(t, 0, 0, this._width, this._height, 0, 0, o.width, o.height), a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, o);
          }
          null !== t && this._SetTextureParameters(a), a.bindTexture(a.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
        }
        _CreateDynamic(e, t, i) {
          if (i = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i), this._texture) throw new Error("already created texture");
          if (this._wrapX = i.wrapX, this._wrapY = i.wrapY, this._sampling = i.sampling, this._pixelFormat = i.pixelFormat, this._isMipMapped = !!i.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
          if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
          if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
          this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t);
          const r = C33.isPOT(this._width) && C33.isPOT(this._height), a = this._renderer.GetMaxTextureSize();
          if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
          if (this._width > a || this._height > a) throw new Error("texture exceeds maximum texture size");
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r) throw new Error("non-power-of-two tiled textures not supported");
          const s = this._renderer.GetContext(), h = this._renderer.GetWebGLVersionNumber(), n = (this._texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], i.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], false), GetFormatSpecifiers2(this._pixelFormat, s)), _ = 2 <= h ? n.sizedinternalformat : n.internalformat;
          s.texImage2D(s.TEXTURE_2D, 0, _, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s), s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
        }
        _GetMipMapHint(e) {
          if ("default" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;
          if ("low" === this._mipMapQuality) return e.FASTEST;
          if ("high" === this._mipMapQuality) return e.NICEST;
          throw new Error("invalid mipmap quality");
        }
        _IsTiled() {
          return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY;
        }
        _GetTextureWrapMode(e, t) {
          if ("clamp-to-edge" === t) return e.CLAMP_TO_EDGE;
          if ("repeat" === t) return e.REPEAT;
          if ("mirror-repeat" === t) return e.MIRRORED_REPEAT;
          throw new Error("invalid wrap mode");
        }
        _SetTextureParameters(e) {
          const t = C33.isPOT(this._width) && C33.isPOT(this._height);
          if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), "nearest" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;
          else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
            e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);
            const r = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, r ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);
          } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;
          const i = this._renderer._GetAnisotropicExtension();
          i && 0 < this._anisotropy && "nearest" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i["TEXTURE_MAX_ANISOTROPY_EXT"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));
        }
        _Update(e, t) {
          if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error("invalid texture source");
          if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
          if (this._isStatic) throw new Error("cannot update static texture");
          t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t);
          const i = e.width || e.videoWidth, r = e.height || e.videoHeight, a = this._renderer.GetWebGLVersionNumber(), s = this._renderer.GetContext(), h = (s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], !!t.flipY), GetFormatSpecifiers2(this._pixelFormat, s)), n = 2 <= a ? h.sizedinternalformat : h.internalformat;
          try {
            if (this._width === i && this._height === r) {
              const _ = C33.isPOT(this._width) && C33.isPOT(this._height);
              s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, h.format, h.type, e), (_ || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
            } else {
              this._width = i, this._height = r;
              const o = C33.isPOT(this._width) && C33.isPOT(this._height);
              if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !o) throw new Error("non-power-of-two tiled textures not supported");
              s.texImage2D(s.TEXTURE_2D, 0, n, h.format, h.type, e), (o || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
            }
          } catch (e2) {
            console.error("Error updating WebGL texture: ", e2);
          }
          s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture();
        }
        _Delete() {
          if (0 < this._refCount) throw new Error("texture still has references");
          if (!this._texture) throw new Error("already deleted texture");
          allTextures.delete(this);
          const e = this._renderer.GetContext();
          e.deleteTexture(this._texture), this._texture = null;
        }
        IsValid() {
          return !!this._texture;
        }
        _GetTexture() {
          return this._texture;
        }
        GetRenderer() {
          return this._renderer;
        }
        AddReference() {
          this._refCount++;
        }
        SubtractReference() {
          if (this._refCount <= 0) throw new Error("no more references");
          this._refCount--;
        }
        GetReferenceCount() {
          return this._refCount;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        IsStatic() {
          return this._isStatic;
        }
        GetEstimatedMemoryUsage() {
          let e = this._width * this._height;
          switch (this._pixelFormat) {
            case "rgba8":
              e *= 4;
              break;
            case "rgb8":
              e *= 3;
              break;
            case "rgba4":
            case "rgb5_a1":
            case "rgb565":
              e *= 2;
          }
          return this._isMipMapped && (e += Math.floor(e / 3)), e;
        }
        static OnContextLost() {
          allTextures.clear();
        }
        static allTextures() {
          return allTextures.values();
        }
      };
    }
    var GetFormatSpecifiers;
    {
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, mat42 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
      C33.Gfx.WebGLRenderTarget = class {
        constructor(e) {
          this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = "trilinear", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat42.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;
        }
        _Create(e, t, r) {
          r = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r);
          const i = this._renderer.GetWebGLVersionNumber();
          if (this._texture || this._renderBuffer) throw new Error("already created render target");
          if (this._sampling = r.sampling, this._alpha = !!r.alpha, this._depth = !!r.depth, this._isSampled = !!r.isSampled, this._isDefaultSize = !!r.isDefaultSize, this._multisampling = r.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
          if (0 < this._multisampling && (i < 2 || this._isSampled)) throw new Error("invalid use of multisampling");
          if (i < 2 && (this._isSampled = true), this._width = e, this._height = t, this._width <= 0 || this._height <= 0) throw new Error("invalid render target size");
          this._CalculateProjection();
          const s = this._renderer.GetContext();
          if (this._frameBuffer = s.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s.createFramebuffer()), this._isSampled) {
            this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? "rgba8" : "rgb8", mipMap: false });
            const a = this._texture._GetTexture();
            s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, a, 0), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, a, 0));
          } else {
            this._renderBuffer = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._renderBuffer);
            const f = this._alpha ? s.RGBA8 : s.RGB8;
            if (0 < this._multisampling) {
              const n = s.getInternalformatParameter(s.RENDERBUFFER, f, s.SAMPLES);
              if (n && n[0]) {
                const _ = n[0];
                this._multisampling > _ && (this._multisampling = _);
              } else this._multisampling = 0;
            }
            0 === this._multisampling ? s.renderbufferStorage(s.RENDERBUFFER, f, this._width, this._height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, this._multisampling, f, this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer)), s.bindRenderbuffer(s.RENDERBUFFER, null);
          }
          const h = this._renderer._GetDepthBuffer();
          this._depth && h && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, h, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, h)), s.bindFramebuffer(s.FRAMEBUFFER, null), allRenderTargets.add(this);
        }
        _Resize(e, t) {
          if (this._width !== e || this._height !== t) {
            this._width = e, this._height = t, this._CalculateProjection();
            const r = this._renderer.GetContext(), i = (r.bindFramebuffer(r.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r.bindRenderbuffer(r.RENDERBUFFER, this._renderBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._alpha ? r.RGBA8 : r.RGB8, this._width, this._height), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._renderer._GetDepthBuffer());
            this._depth && i && (this._renderer._CanSampleDepth() ? r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, i, 0) : r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i)), r.bindFramebuffer(r.FRAMEBUFFER, null);
          }
        }
        _Delete() {
          if (!this._texture && !this._renderBuffer) throw new Error("already deleted render target");
          allRenderTargets.delete(this);
          const e = this._renderer.GetContext(), t = (this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), 2 <= this._renderer.GetWebGLVersionNumber() && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth), this._renderer.GetBatchState());
          t.currentFramebuffer = null, this._frameBuffer = t.currentFramebufferNoDepth = null;
        }
        _CalculateProjection() {
          this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
        }
        _GetFramebuffer() {
          return this._frameBuffer;
        }
        _GetFramebufferNoDepth() {
          return this._frameBufferNoDepth;
        }
        GetRenderer() {
          return this._renderer;
        }
        GetTexture() {
          return this._texture;
        }
        GetProjectionMatrix() {
          return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
        }
        IsLinearSampling() {
          return "nearest" !== this._sampling;
        }
        HasAlpha() {
          return this._alpha;
        }
        IsSampled() {
          return this._isSampled;
        }
        HasDepthBuffer() {
          return this._depth;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        IsDefaultSize() {
          return this._isDefaultSize;
        }
        GetMultisampling() {
          return this._multisampling;
        }
        GetOptions() {
          const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };
          return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;
        }
        IsCompatibleWithOptions(e) {
          return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && !!e.alpha === this.HasAlpha() && !!e.depth === this.HasDepthBuffer() && !(2 <= this._renderer.GetWebGLVersionNumber() && !!e.isSampled !== this.IsSampled()) && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize());
        }
        _GetWebGLTexture() {
          return this._texture ? this._texture._GetTexture() : null;
        }
        GetEstimatedMemoryUsage() {
          return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);
        }
        static async DebugReadPixelsToBlob(e, t) {
          const r = await e.ReadBackRenderTargetToImageData(t, true);
          return C33.ImageDataToBlob(r);
        }
        static OnContextLost() {
          allRenderTargets.clear();
        }
        static allRenderTargets() {
          return allRenderTargets.values();
        }
        static ResizeAll(e, t) {
          for (const r of allRenderTargets) r.IsDefaultSize() && r._Resize(e, t);
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, mat42 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set(["aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]);
      C33.Gfx.WebGLShaderProgram = class extends C33.Gfx.ShaderProgramBase {
        static async Compile(e, t) {
          const i = e.GetContext(), r = t.src, o = t.vertexSrc, n = t.name, a = i.createShader(i.FRAGMENT_SHADER), l = (i.shaderSource(a, r), i.compileShader(a), i.createShader(i.VERTEX_SHADER)), s = (i.shaderSource(l, o), i.compileShader(l), i.createProgram()), d = (i.attachShader(s, a), i.attachShader(s, l), i.bindAttribLocation(s, 0, "aPos"), i.bindAttribLocation(s, 1, "aTex"), i.bindAttribLocation(s, 2, "aPoints"), i.linkProgram(s), e._GetParallelShaderCompileExtension());
          if (d ? await e._WaitForObjectReady(() => i.getProgramParameter(s, d["COMPLETION_STATUS_KHR"])) : await C33.Wait(5), !i.getShaderParameter(a, i.COMPILE_STATUS)) {
            const m = i.getShaderInfoLog(a);
            throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling fragment shader: " + m);
          }
          if (!i.getShaderParameter(l, i.COMPILE_STATUS)) {
            const h = i.getShaderInfoLog(l);
            throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling vertex shader: " + h);
          }
          if (!i.getProgramParameter(s, i.LINK_STATUS)) {
            const u = i.getProgramInfoLog(s);
            throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error("Error linking shader program: " + u);
          }
          const c = C33.FilterUnprintableChars(i.getProgramInfoLog(s) || "").trim();
          return c && !C33.IsStringAllWhitespace(c) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c), i.deleteShader(a), i.deleteShader(l), s;
        }
        static async Create(e, t) {
          const i = await C33.Gfx.WebGLShaderProgram.Compile(e, t);
          return new C33.Gfx.WebGLShaderProgram(e, i, t);
        }
        constructor(e, t, i) {
          super(e, i);
          const r = e.GetContext(), o = e.GetBatchState(), n = (e.EndBatch(), r.useProgram(t), this._gl = r, this._shaderProgram = t, this._isDeviceTransform = "<default-device-transform>" === i.name, r.getAttribLocation(t, "aPos")), a = r.getAttribLocation(t, "aTex"), l = (this._locAPoints = r.getAttribLocation(t, "aPoints"), -1 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e._vertexBuffer), r.vertexAttribPointer(n, e.GetNumVertexComponents(), r.FLOAT, false, 0, 0), r.enableVertexAttribArray(n)), -1 !== a && (r.bindBuffer(r.ARRAY_BUFFER, e._texcoordBuffer), r.vertexAttribPointer(a, 2, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(a)), -1 !== this._locAPoints && (r.bindBuffer(r.ARRAY_BUFFER, e._pointBuffer), r.vertexAttribPointer(this._locAPoints, 4, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(this._locAPoints)), r.bindBuffer(r.ARRAY_BUFFER, null), this._uMatP = new C33.Gfx.WebGLShaderUniform(this, "matP", "mat4"), this._uMatMV = new C33.Gfx.WebGLShaderUniform(this, "matMV", "mat4"), this._uColor = new C33.Gfx.WebGLShaderUniform(this, "color", "vec4"), this._uSamplerFront = new C33.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler"), this._uPointTexStart = new C33.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2"), this._uPointTexEnd = new C33.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2"), this._uZElevation = new C33.Gfx.WebGLShaderUniform(this, "zElevation", "float"), this._uTileSize = new C33.Gfx.WebGLShaderUniform(this, "tileSize", "vec2"), this._uTileSpacing = new C33.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2"), this._uColor2 = new C33.Gfx.WebGLShaderUniform(this, "color2_", "vec4"), this._uOutlineThickness = new C33.Gfx.WebGLShaderUniform(this, "outlineThickness", "float"), this._uSamplerBack = new C33.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler"), this._uSamplerDepth = new C33.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler"), this._uDestStart = new C33.Gfx.WebGLShaderUniform(this, "destStart", "vec2"), this._uDestEnd = new C33.Gfx.WebGLShaderUniform(this, "destEnd", "vec2"), this._uSrcStart = new C33.Gfx.WebGLShaderUniform(this, "srcStart", "vec2"), this._uSrcEnd = new C33.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2"), this._uSrcOriginStart = new C33.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2"), this._uSrcOriginEnd = new C33.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2"), this._uPixelSize = new C33.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2"), this._uSeconds = new C33.Gfx.WebGLShaderUniform(this, "seconds", "float"), this._uDevicePixelRatio = new C33.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float"), this._uLayerScale = new C33.Gfx.WebGLShaderUniform(this, "layerScale", "float"), this._uLayerAngle = new C33.Gfx.WebGLShaderUniform(this, "layerAngle", "float"), this._uLayoutStart = new C33.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2"), this._uLayoutEnd = new C33.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2"), this._uZNear = new C33.Gfx.WebGLShaderUniform(this, "zNear", "float"), this._uZFar = new C33.Gfx.WebGLShaderUniform(this, "zFar", "float"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed()), i.parameters || []);
          this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);
          for (const d of l) {
            const c = d[0], m = d[2], h = new C33.Gfx.WebGLShaderUniform(this, c, m);
            "color" === m ? h.Init3f(0, 0, 0) : h.Init1f(0), this._uCustomParameters.push(h);
          }
          this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o.currentMatP) : (this.UpdateMatP(o.currentMatP, true), this.UpdateMatMV(o.currentMV, true));
          const s = o.currentShader;
          r.useProgram(s ? s._shaderProgram : null);
        }
        Release() {
          this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();
        }
        GetWebGLContext() {
          return this._gl;
        }
        GetShaderProgram() {
          return this._shaderProgram;
        }
        GetParameterCount() {
          return this._uCustomParameters.length;
        }
        GetParameterType(e) {
          return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();
        }
        AreCustomParametersAlreadySetInBatch(i) {
          for (let e = 0, t = i.length; e < t; ++e) if (!this._uCustomParameters[e].IsSetToCustomInBatch(i[e])) return false;
          return true;
        }
        SetCustomParametersInBatch(i) {
          for (let e = 0, t = i.length; e < t; ++e) this._uCustomParameters[e].SetBatchValueCustom(i[e]);
        }
        AreOptionalUniformsAlreadySetInBatch(e, t, i, r, o, n, a, l, s, d) {
          return !this._uSamplerBack.IsUsed() && !(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o, n) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i.getLeft(), i.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i.getRight(), i.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r.getLeft(), r.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r.getTop(), r.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(d));
        }
        SetOptionalUniformsInBatch(e, t, i, r, o, n, a, l, s, d) {
          this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i.getLeft(), i.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i.getRight(), i.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r.getLeft(), r.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r.getTop(), r.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(d));
        }
        UpdateMatP(e, t) {
          this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);
        }
        SetMatPStale() {
          this._hasCurrentMatP = false;
        }
        UpdateMatMV(e, t) {
          this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);
        }
        SetMatMVStale() {
          this._hasCurrentMatMV = false;
        }
        _UpdateDeviceTransformUniforms(e) {
          if (!this._isDeviceTransform) throw new Error("not device transform shader");
          this._uMatP.UpdateMatrix4fv(e);
          const t = this._renderer, i = t.GetWidth() / 2, r = t.GetHeight() / 2, o = t.CalculateLookAtModelView2(i, r, t.GetDefaultCameraZ(t.GetHeight()), i, r, 0, t.GetHeight());
          this._uMatMV.UpdateMatrix4fv(o);
        }
        UpdateColor(e) {
          this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);
        }
        static GetReservedUniformNames() {
          return RESERVED_UNIFORM_NAMES;
        }
        static GetDefaultVertexShaderSource(e) {
          const t = e ? "highmedp" : "mediump";
          return ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "attribute highp vec3 aPos;", `attribute ${t} vec2 aTex;`, `varying ${t} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}"].join("\n");
        }
        static GetDefaultVertexShaderSource_WebGL2(e) {
          const t = e ? "highp" : "mediump";
          return ["#version 300 es", "in highp vec3 aPos;", `in ${t} vec2 aTex;`, `out ${t} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * color;", "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * color;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTextureFillFragmentShaderSource_WebGL2() {
          return ["#version 300 es", "in mediump vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	outColor = texture(samplerFront, vTex) * color;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "	highmedp vec2 tile = floor(vTex);", "	highmedp vec2 tex = fract(vTex);", "	highmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "	highmedp vec2 tile = floor(vTex);", "	highmedp vec2 tex = fract(vTex);", "	highmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTilemapFragmentShaderSource_WebGL2() {
          return ["#version 300 es", "in highp vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	outColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetTileRandomizationFragmentShaderSource(e, t, i) {
          let r = "";
          return 2 <= e ? r = "#version 300 es\n" : (t && (r = "#extension GL_EXT_frag_depth : enable\n"), i && (r += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n")), r + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${2 <= e ? "in" : "varying"} vec2 vTex;
${2 <= e ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${2 <= e ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && i ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && !i ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${e < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${2 <= e || i ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${2 <= e || i ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= color;
	${e < 2 ? "gl_FragColor = outColor;" : ""}
	${2 <= e ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${e < 2 && t ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
        }
        static GetPointVertexShaderSource_WebGL1() {
          return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
        }
        static GetPointVertexShaderSource_WebGL2() {
          return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
          return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
          return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetPointFragmentShaderSource_WebGL2() {
          return ["#version 300 es", "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	outColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
        }
        static GetColorFillFragmentShaderSource() {
          return ["uniform lowp vec4 color;", "void main(void) {", "	gl_FragColor = color;", "}"].join("\n");
        }
        static GetLinearGradientFillFragmentShaderSource() {
          return ["precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "	bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "	vec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "	vec3 lower = linearRGB * vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "	bvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "	vec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "	vec3 lower = sRGB/vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "	vec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "	float a = mix(color.a, color2_.a, vTex.x);", "	gl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n");
        }
        static GetPenumbraFillFragmentShaderSource() {
          return ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "precision lowp float;", "varying highmedp vec2 vTex;", "uniform vec4 color;", "void main(void) {", `	highmedp float grad = vTex.x / (1.0 - vTex.y);`, `	gl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);`, "}"].join("\n");
        }
        static GetSmoothLineFillFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "	lowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "	gl_FragColor = color * f;", "}"].join("\n");
        }
        static GetHardEllipseFillFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float f = step(diffSq.x + diffSq.y, 0.25);", "	gl_FragColor = color * f;", "}"].join("\n");
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float distSq = diffSq.x + diffSq.y;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump float innerF = step(distSq, 0.25);", "	mediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "	mediump vec2 innerEdgeSq = innerEdge * innerEdge;", "	mediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "	gl_FragColor = color * innerF * outerF;", "}"].join("\n");
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump vec2 halfNormSq = halfNorm * halfNorm;", "	mediump vec2 innerEdge = halfNorm - pixelSize * norm;", "	mediump vec2 innerEdgeSq = innerEdge * innerEdge;", "	mediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "	gl_FragColor = color * f;", "}"].join("\n");
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
          return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float distSq = diffSq.x + diffSq.y;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump vec2 halfNormSq = halfNorm * halfNorm;", "	mediump vec2 pxNorm = pixelSize * norm;", "	mediump vec2 innerEdge1 = halfNorm - pxNorm;", "	mediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "	mediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "	mediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "	mediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "	mediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "	mediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "	mediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "	gl_FragColor = color * innerF * outerF;", "}"].join("\n");
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, mat42 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
      C33.Gfx.WebGLShaderUniform = class {
        constructor(t, s, a) {
          if (!TYPE_SIZES.has(a)) throw new Error("invalid uniform type");
          this._owner = t, this._gl = this._owner.GetWebGLContext(), this._name = s, this._type = a, this._isColorType = "color" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s), this._isUsed = !!this._location;
          const i = TYPE_SIZES.get(a);
          this._lastValue = new Float32Array(i), this._lastBatchValue = new Float32Array(i);
        }
        Release() {
          this._owner = null, this._gl = null, this._location = null;
        }
        IsUsed() {
          return this._isUsed;
        }
        GetType() {
          return this._type;
        }
        IsColorType() {
          return this._isColorType;
        }
        Init1f(t) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t));
        }
        Init1i(t) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t));
        }
        Init2f(t, s) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t, s));
        }
        Init3f(t, s, a) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t, s, a));
        }
        Init4f(t, s, a, i) {
          this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastValue[3] = i, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t, s, a, i));
        }
        Update1f(t) {
          t = Math.fround(t);
          const s = this._lastValue;
          s[0] !== t && (s[0] = t, this._gl.uniform1f(this._location, t));
        }
        Update1i(t) {
          const s = this._lastValue;
          s[0] !== t && this._gl.uniform1i(this._location, s[0] = t);
        }
        Update2f(t, s) {
          t = Math.fround(t), s = Math.fround(s);
          const a = this._lastValue;
          a[0] === t && a[1] === s || (a[0] = t, a[1] = s, this._gl.uniform2f(this._location, t, s));
        }
        Update3f(t, s, a) {
          t = Math.fround(t), s = Math.fround(s), a = Math.fround(a);
          const i = this._lastValue;
          i[0] === t && i[1] === s && i[2] === a || (i[0] = t, i[1] = s, i[2] = a, this._gl.uniform3f(this._location, t, s, a));
        }
        Update4f(t, s, a, i) {
          t = Math.fround(t), s = Math.fround(s), a = Math.fround(a), i = Math.fround(i);
          const l = this._lastValue;
          l[0] === t && l[1] === s && l[2] === a && l[3] === i || (l[0] = t, l[1] = s, l[2] = a, l[3] = i, this._gl.uniform4f(this._location, t, s, a, i));
        }
        UpdateMatrix4fv(t) {
          const s = this._lastValue;
          mat42.exactEquals(s, t) || (C33.typedArraySet16(s, t, 0), this._gl.uniformMatrix4fv(this._location, false, t));
        }
        IsSetToCustomInBatch(t) {
          const s = this._lastBatchValue;
          return this.IsColorType() ? s[0] === Math.fround(t.getR()) && s[1] === Math.fround(t.getG()) && s[2] === Math.fround(t.getB()) : s[0] === Math.fround(t);
        }
        SetBatchValueCustom(t) {
          const s = this._lastBatchValue;
          this.IsColorType() ? (s[0] = t.getR(), s[1] = t.getG(), s[2] = t.getB()) : s[0] = t;
        }
        IsSetTo1InBatch(t) {
          return this._lastBatchValue[0] === Math.fround(t);
        }
        IsSetTo2InBatch(t, s) {
          const a = this._lastBatchValue;
          return a[0] === Math.fround(t) && a[1] === Math.fround(s);
        }
        SetBatch1(t) {
          this._lastBatchValue[0] = t;
        }
        SetBatch2(t, s) {
          const a = this._lastBatchValue;
          a[0] = t, a[1] = s;
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, BATCH_NULL = 0, BATCH_QUAD = 1, BATCH_SETTEXTURE = 2, BATCH_SETCOLOR = 3, BATCH_SETBLEND = 4, BATCH_SETVIEWPORT = 5, BATCH_SETPROJECTION = 6, BATCH_SETMODELVIEW = 7, BATCH_SETRENDERTARGET = 8, BATCH_CLEARSURFACE = 9, BATCH_POINTS = 10, BATCH_SETPROGRAM = 11, BATCH_SETPROGRAMPARAMETERS = 12, BATCH_SETPROGRAMCUSTOMPARAMETERS = 13, BATCH_INVALIDATEFRAMEBUFFER = 14, BATCH_SETPOINTTEXCOORDS = 15, BATCH_SETTILEMAPINFO = 16, BATCH_BLITFRAMEBUFFER = 17, BATCH_STARTQUERY = 18, BATCH_ENDQUERY = 19, BATCH_SETELLIPSEPARAMS = 20, BATCH_SETGRADIENTCOLOR = 21, BATCH_CLEARDEPTH = 22, BATCH_SETDEPTHENABLED = 23, BATCH_SETDEPTHSAMPLINGENABLED = 24, BATCH_COPLANAR_STARTSTENCILPASS = 25, BATCH_COPLANAR_STARTCOLORPASS = 26, BATCH_COPLANAR_RESTORE = 27, BATCH_SET_SCISSOR = 28, BATCH_SETTILERANDOMIZATIONINFO = 29;
      C33.Gfx.BatchState = class {
        constructor(t) {
          this.renderer = t, this.currentMV = mat42.create(), this.currentMatP = mat42.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentColor = vec42.fromValues(1, 1, 1, 1), this.currentShader = null, this.pointTexCoords = new C33.Rect(), this.clearColor = C33.New(C33.Color, 0, 0, 0, 0);
        }
      }, C33.Gfx.WebGLBatchJob = class {
        constructor(t) {
          const e = new ArrayBuffer(96);
          this._type = 0, this._batchState = t, this._gl = t.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];
        }
        InitQuad(t, e) {
          this._type = BATCH_QUAD, this._startIndex = t, this._indexCount = e;
        }
        DoQuad() {
          const t = this._gl;
          t.drawElements(t.TRIANGLES, this._indexCount, t.UNSIGNED_SHORT, this._startIndex);
        }
        InitSetTexture(t) {
          this._type = BATCH_SETTEXTURE, this._texParam = t;
        }
        DoSetTexture() {
          const t = this._gl, e = this._texParam;
          t.bindTexture(t.TEXTURE_2D, e ? e._GetTexture() : null);
        }
        InitSetColor(t) {
          this._type = BATCH_SETCOLOR, t.writeToTypedArray(this._colorParam, 0);
        }
        DoSetColor() {
          const t = this._colorParam, e = this._batchState;
          vec42.copy(e.currentColor, t), e.currentShader.UpdateColor(t);
        }
        InitSetGradientColor(t) {
          this._type = BATCH_SETGRADIENTCOLOR, t.writeToTypedArray(this._colorParam, 0);
        }
        DoSetGradientColor() {
          const t = this._colorParam, e = this._batchState.currentShader;
          e._uColor2.IsUsed() && e._uColor2.Update4f(t[0], t[1], t[2], t[3]);
        }
        InitSetBlend(t, e) {
          this._type = BATCH_SETBLEND, this._startIndex = t, this._indexCount = e;
        }
        DoSetBlend() {
          this._gl.blendFunc(this._startIndex, this._indexCount);
        }
        InitSetViewport(t, e, r, a) {
          this._type = BATCH_SETVIEWPORT;
          const s = this._colorParam;
          s[0] = t, s[1] = e, s[2] = r, s[3] = a;
        }
        DoSetViewport() {
          const t = this._colorParam;
          this._gl.viewport(t[0], t[1], t[2], t[3]);
        }
        InitSetProjection(t) {
          this._type = BATCH_SETPROJECTION, mat42.copy(this._mat4param, t);
        }
        DoSetProjection() {
          const t = this._batchState, r = t.renderer._allShaderPrograms, a = t.currentShader, s = this._mat4param;
          for (let t2 = 0, e = r.length; t2 < e; ++t2) {
            const i = r[t2];
            i === a ? i.UpdateMatP(s, true) : i.SetMatPStale();
          }
          mat42.copy(t.currentMatP, s);
        }
        InitSetModelView(t) {
          this._type = BATCH_SETMODELVIEW, mat42.copy(this._mat4param, t);
        }
        DoSetModelView() {
          const t = this._batchState, r = t.renderer._allShaderPrograms, a = t.currentShader, s = this._mat4param;
          for (let t2 = 0, e = r.length; t2 < e; ++t2) {
            const i = r[t2];
            i === a ? i.UpdateMatMV(s, true) : i.SetMatMVStale();
          }
          mat42.copy(t.currentMV, s);
        }
        InitSetRenderTarget(t) {
          this._type = BATCH_SETRENDERTARGET, this._texParam = t;
        }
        DoSetRenderTarget() {
          const t = this._gl, e = this._texParam, r = this._batchState;
          e ? (r.currentFramebuffer = e._GetFramebuffer(), r.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r.isDepthSamplingEnabled && r.currentFramebufferNoDepth ? t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebufferNoDepth) : t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebuffer)) : (r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
        }
        InitClearSurface(t) {
          this._type = BATCH_CLEARSURFACE, t.writeToTypedArray(this._mat4param, 0);
        }
        InitClearSurface2(t, e, r, a) {
          this._type = BATCH_CLEARSURFACE;
          const s = this._mat4param;
          s[0] = t, s[1] = e, s[2] = r, s[3] = a;
        }
        DoClearSurface() {
          const t = this._gl, e = this._mat4param, r = this._batchState, a = r.clearColor, s = e[0], i = e[1], n = e[2], o = e[3];
          a.equalsRgba(s, i, n, o) || (t.clearColor(s, i, n, o), a.setRgba(s, i, n, o)), t.clear(t.COLOR_BUFFER_BIT);
        }
        InitSetPointTexCoords(t) {
          this._type = BATCH_SETPOINTTEXCOORDS, t.writeToTypedArray(this._mat4param, 0);
        }
        DoSetPointTextureCoords() {
          const t = this._mat4param;
          this._batchState.pointTexCoords.set(t[0], t[1], t[2], t[3]);
        }
        InitPoints(t, e) {
          this._type = BATCH_POINTS, this._startIndex = t, this._indexCount = 1, this._mat4param[0] = e;
        }
        DoPoints() {
          const t = this._gl, e = this._batchState, r = e.renderer, a = r._spPoints, s = (t.useProgram(a._shaderProgram), a.UpdateMatP(e.currentMatP, false), a.UpdateMatMV(e.currentMV, false), e.pointTexCoords), i = (a._uPointTexStart.IsUsed() && a._uPointTexStart.Update2f(s.getLeft(), s.getTop()), a._uPointTexEnd.IsUsed() && a._uPointTexEnd.Update2f(s.getRight(), s.getBottom()), this._mat4param[0]);
          if (a._uZElevation.IsUsed() && a._uZElevation.Update1f(i), a._uColor.IsUsed()) {
            const n = e.currentColor;
            a._uColor.Update4f(n[0], n[1], n[2], n[3]);
          }
          t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount), t.useProgram(e.currentShader._shaderProgram);
        }
        InitSetProgram(t) {
          this._type = BATCH_SETPROGRAM, this._texParam = t;
        }
        DoSetProgram() {
          const t = this._gl, e = this._batchState, r = this._texParam;
          if (e.currentShader = r, t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false), r._uColor.IsUsed()) {
            const a = e.currentColor;
            r._uColor.Update4f(a[0], a[1], a[2], a[3]);
          }
        }
        InitSetProgramParameters() {
          this._type = BATCH_SETPROGRAMPARAMETERS;
        }
        DoSetProgramParameters() {
          const t = this._batchState.currentShader, e = this._gl, r = this._mat4param, a = this._colorParam, s = this._srcOriginRect;
          if (t._uSamplerBack.IsUsed()) {
            const i = this._batchState.renderer, n = this._texParam;
            i._lastTexture1 !== n && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, n ? n._GetTexture() : null), i._lastTexture1 = n, e.activeTexture(e.TEXTURE0));
          }
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(r[0], r[1]), t._uDestStart.IsUsed() && t._uDestStart.Update2f(r[2], r[3]), t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(r[4], r[5]), t._uDevicePixelRatio.IsUsed() && t._uDevicePixelRatio.Update1f(this._indexCount), t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(r[6]), t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(r[7]), t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(r[12], r[13]), t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(r[14], r[15]), t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(s[0], s[1]), t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(s[2], s[3]), t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(a[0], a[1]), t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(a[2], a[3]), t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex);
        }
        InitSetProgramCustomParameters() {
          this._type = BATCH_SETPROGRAMCUSTOMPARAMETERS;
        }
        DoSetProgramCustomParameters() {
          const t = this._batchState.currentShader, r = t._uCustomParameters, a = this._shaderParams;
          for (let t2 = 0, e = r.length; t2 < e; ++t2) {
            const s = r[t2], i = a[t2];
            s.IsColorType() ? s.Update3f(i.getR(), i.getG(), i.getB()) : s.Update1f(i);
          }
        }
        InitInvalidateFramebuffer(t) {
          this._type = BATCH_INVALIDATEFRAMEBUFFER, this._texParam = t;
        }
        DoInvalidateFramebuffer() {
          const t = this._gl, e = this._texParam, r = this._batchState.currentFramebuffer;
          e !== r && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), e !== r && t.bindFramebuffer(t.FRAMEBUFFER, r);
        }
        InitBlitFramebuffer(t, e, r) {
          this._type = BATCH_BLITFRAMEBUFFER;
          const a = this._mat4param, s = this._batchState.renderer, i = (a[0] = t.GetWidth(), a[1] = t.GetHeight(), a[2] = (e || s).GetWidth(), a[3] = (e || s).GetHeight(), a[4] = t.IsLinearSampling() ? 1 : 0, a[5] = "stretch" === r, this._shaderParams);
          C33.clearArray(i), i.push(t._GetFramebuffer()), i.push(e ? e._GetFramebuffer() : null);
        }
        DoBlitFramebuffer() {
          const t = this._mat4param, e = this._shaderParams, r = this._gl, a = t[0], s = t[1], i = t[2], n = t[3], o = 0 !== t[4], _ = 0 !== t[5], h = e[0], S = e[1];
          if (r.bindFramebuffer(r.READ_FRAMEBUFFER, h), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, S), _) r.blitFramebuffer(0, 0, a, s, 0, 0, i, n, r.COLOR_BUFFER_BIT, o ? r.LINEAR : r.NEAREST);
          else {
            const T = Math.min(a, i), u = Math.min(s, n), d = Math.max(s - n, 0), E = Math.max(n - s, 0);
            r.blitFramebuffer(0, d, T, u + d, 0, E, T, u + E, r.COLOR_BUFFER_BIT, r.NEAREST);
          }
        }
        InitStartQuery(t) {
          this._type = BATCH_STARTQUERY, this._texParam = t;
        }
        DoStartQuery() {
          this._texParam.BeginTimeElapsed(), this._texParam = null;
        }
        InitEndQuery(t) {
          this._type = BATCH_ENDQUERY, this._texParam = t;
        }
        DoEndQuery() {
          this._texParam.EndTimeElapsed(), this._texParam = null;
        }
        InitSetEllipseParams(t, e, r) {
          this._type = BATCH_SETELLIPSEPARAMS;
          const a = this._mat4param;
          a[0] = t, a[1] = e, a[2] = r;
        }
        DoSetEllipseParams() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[2]);
        }
        InitSetTilemapInfo(t, e, r, a, s, i, n) {
          this._type = BATCH_SETTILEMAPINFO;
          const o = this._mat4param;
          t.writeToTypedArray(o, 0), o[4] = 1 / e, o[5] = 1 / r, o[6] = a / e, o[7] = s / r, o[8] = i / e, o[9] = n / r;
        }
        DoSetTilemapInfo() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(e[0], e[1]), t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[4], e[5]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[6], e[7]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[8], e[9]);
        }
        InitSetTileRandomizationInfo(t, e, r, a, s, i, n) {
          this._type = BATCH_SETTILERANDOMIZATIONINFO;
          const o = this._mat4param;
          o[0] = 1 / t, o[1] = 1 / e, o[2] = r, o[3] = a, o[4] = s, o[5] = i, o[6] = n;
        }
        DoSetTileRandomizationInfo() {
          const t = this._batchState.currentShader, e = this._mat4param;
          t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[2], e[3]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[4]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[5], e[6]);
        }
        InitClearDepth(t) {
          this._type = BATCH_CLEARDEPTH, this._startIndex = t ? 1 : 0;
        }
        DoClearDepth() {
          const t = this._gl, e = 0 !== this._startIndex;
          e || t.depthMask(true), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(false);
        }
        InitSetDepthEnabled(t) {
          this._type = BATCH_SETDEPTHENABLED, this._startIndex = t ? 1 : 0;
        }
        DoSetDepthEnabled() {
          const t = this._gl;
          0 === this._startIndex ? (t.disable(t.DEPTH_TEST), t.depthMask(false)) : (t.enable(t.DEPTH_TEST), t.depthMask(true));
        }
        InitSetDepthSamplingEnabled(t) {
          this._type = BATCH_SETDEPTHSAMPLINGENABLED, this._startIndex = t ? 1 : 0;
        }
        DoSetDepthSamplingEnabled() {
          const t = this._gl, e = this._batchState, r = e.renderer, a = 0 !== this._startIndex;
          e.isDepthSamplingEnabled = a, t.activeTexture(t.TEXTURE2), a ? (e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebufferNoDepth), t.bindTexture(t.TEXTURE_2D, r._GetDepthBuffer())) : (t.bindTexture(t.TEXTURE_2D, null), e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebuffer)), t.activeTexture(t.TEXTURE0);
        }
        InitCoplanarStartStencilPass() {
          this._type = BATCH_COPLANAR_STARTSTENCILPASS;
        }
        DoCoplanarStartStencilPass() {
          const t = this._gl;
          t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(false, false, false, false);
        }
        InitCoplanarStartColorPass() {
          this._type = BATCH_COPLANAR_STARTCOLORPASS;
        }
        DoCoplanarStartColorPass() {
          const t = this._gl;
          t.colorMask(true, true, true, true), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
        }
        InitCoplanarRestore() {
          this._type = BATCH_COPLANAR_RESTORE;
        }
        DoCoplanarRestore() {
          const t = this._gl;
          t.disable(t.STENCIL_TEST);
        }
        InitSetScissor(t, e, r, a, s) {
          this._type = BATCH_SET_SCISSOR, this._startIndex = t ? 1 : 0;
          const i = this._mat4param;
          i[0] = e, i[1] = r, i[2] = a, i[3] = s;
        }
        DoSetScissor() {
          const t = this._gl, e = this._mat4param;
          1 === this._startIndex ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);
        }
        Run() {
          switch (this._type) {
            case 1:
              return void this.DoQuad();
            case 2:
              return void this.DoSetTexture();
            case 3:
              return void this.DoSetColor();
            case 4:
              return void this.DoSetBlend();
            case 5:
              return void this.DoSetViewport();
            case 6:
              return void this.DoSetProjection();
            case 7:
              return void this.DoSetModelView();
            case 8:
              return void this.DoSetRenderTarget();
            case 9:
              return void this.DoClearSurface();
            case 10:
              return void this.DoPoints();
            case 11:
              return void this.DoSetProgram();
            case 12:
              return void this.DoSetProgramParameters();
            case 13:
              return void this.DoSetProgramCustomParameters();
            case 14:
              return void this.DoInvalidateFramebuffer();
            case 15:
              return void this.DoSetPointTextureCoords();
            case 16:
              return void this.DoSetTilemapInfo();
            case 17:
              return void this.DoBlitFramebuffer();
            case 18:
              return void this.DoStartQuery();
            case 19:
              return void this.DoEndQuery();
            case 20:
              return void this.DoSetEllipseParams();
            case 21:
              return void this.DoSetGradientColor();
            case 22:
              return void this.DoClearDepth();
            case 23:
              return void this.DoSetDepthEnabled();
            case 24:
              return void this.DoSetDepthSamplingEnabled();
            case 25:
              return void this.DoCoplanarStartStencilPass();
            case 26:
              return void this.DoCoplanarStartColorPass();
            case 27:
              return void this.DoCoplanarRestore();
            case 28:
              return void this.DoSetScissor();
            case 29:
              return void this.DoSetTileRandomizationInfo();
          }
        }
      };
    }
    {
      let fillOrStrokeRect2 = function(t, e, i, s, a, n) {
        e ? t.strokeRect(i, s, a, n) : t.fillRect(i, s, a, n);
      }, ptToPx2 = function(t) {
        return t * (4 / 3);
      }, getOffsetParam2 = function(t, e) {
        t = t.trim();
        const i = parseFloat(t);
        return isFinite(i) ? t.endsWith("%") ? e * i / 100 : i : 0;
      };
      fillOrStrokeRect = fillOrStrokeRect2, ptToPx = ptToPx2, getOffsetParam = getOffsetParam2;
      const C33 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C33.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set(["left", "center", "right"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set(["top", "center", "bottom"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set(["word", "cjk", "character"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set(["ltr", "rtl"]), allRendererTexts = /* @__PURE__ */ new Set();
      C33.FontManager && C33.FontManager.addEventListener("fontload", (t) => {
        const e = t.font.GetName();
        for (const i of allRendererTexts) (i.IsBBCodeEnabled() || C33.equalsNoCase(i.GetFontName(), e)) && i._SetWordWrapChanged();
      });
      let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;
      C33.Gfx.RendererText = class {
        constructor(t, e) {
          e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t, this._fontName = "Arial", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = "black", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = "left", this._verticalAlign = "top", this._text = "", this._bbString = null, this._wrappedText = C33.New(C33.WordWrap), this._wrapMode = "word", this._textDirection = "ltr", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = "", this._lastMeasureCanvasFont = "", this._lastTextCanvasFillStyle = "", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t2) => this._MeasureText(t2), this._texture = null, this._rcTex = new C33.Rect(), this._scaleFactor = 1, this._textureTimeout = new C33.IdleTimeout(() => {
            this.ReleaseTexture(), this._SetTextCanvasSize(8, 8);
          }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);
        }
        Release() {
          this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);
        }
        _SetDrawChanged() {
          this._drawChanged = true;
        }
        _SetTextLayoutChanged() {
          this._SetDrawChanged(), this._textLayoutChanged = true;
        }
        _SetWordWrapChanged() {
          this._SetTextLayoutChanged(), this._wordWrapChanged = true;
        }
        SetBBCodeEnabled(t) {
          if (this._isBBcodeEnabled !== (t = !!t)) {
            this._isBBcodeEnabled = t;
            const e = this._isBBcodeEnabled ? "alphabetic" : "top";
            this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._SetWordWrapChanged();
          }
        }
        IsBBCodeEnabled() {
          return this._isBBcodeEnabled;
        }
        SetIconSet(t) {
          this._iconSet !== t && (this._iconSet = t, this._wrappedText.SetIconSet(t), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());
        }
        SetIconSmoothing(t) {
          this._iconSmoothing !== (t = !!t) && (this._iconSmoothing = t, this._SetDrawChanged());
        }
        SetFontName(t) {
          this._fontName !== (t = t || "serif") && (this._fontName = t, this._SetWordWrapChanged());
        }
        GetFontName() {
          return this._fontName;
        }
        SetFontSize(t) {
          this._fontSize !== (t = t < 0.1 ? 0.1 : t) && (this._fontSize = t, this._SetWordWrapChanged());
        }
        GetFontSize() {
          return this._fontSize;
        }
        SetFontSizeScale(t) {
          this._fontSizeScale !== t && (this._fontSizeScale = t, this._SetWordWrapChanged());
        }
        SetLineHeight(t) {
          this._lineHeight !== t && (this._lineHeight = t, this._SetTextLayoutChanged());
        }
        GetLineHeight() {
          return this._lineHeight;
        }
        SetBold(t) {
          this._isBold !== (t = !!t) && (this._isBold = t, this._SetWordWrapChanged());
        }
        IsBold() {
          return this._isBold;
        }
        SetItalic(t) {
          this._isItalic !== (t = !!t) && (this._isItalic = t, this._SetWordWrapChanged());
        }
        IsItalic() {
          return this._isItalic;
        }
        SetDrawMaxCharacterCount(t) {
          t = Math.floor(t), this._drawMaxCharCount !== t && (this._drawMaxCharCount = t, this._SetDrawChanged());
        }
        GetDrawMaxCharacterCount() {
          return this._drawMaxCharCount;
        }
        _GetFontString(t, e) {
          let i = [];
          (this._isBold || e.HasStyleTag("b")) && i.push("bold"), (this._isItalic || e.HasStyleTag("i")) && i.push("italic");
          const s = e.GetStyleTag("size"), a = (s ? parseFloat(s.param) : this._fontSize) * this._fontSizeScale;
          i.push(t ? a + "pt" : a * this.GetDrawScale() + "pt");
          let n = this._fontName;
          const h = e.GetStyleTag("font");
          return h && h.param && (n = h.param, this.onloadfont) && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n)), n && (GENERIC_FONT_FAMILIES.has(n) ? i.push(n) : i.push('"' + n + '"')), i.join(" ");
        }
        SetColor(t) {
          t instanceof C33.Color && (t = t.getCssRgb()), this._colorStr !== t && (this._colorStr = t, this._SetDrawChanged());
        }
        SetColorRgb(t, e, i) {
          tempColor.setRgb(t, e, i), this.SetColor(tempColor);
        }
        SetHorizontalAlignment(t) {
          if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error("invalid horizontal alignment");
          this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());
        }
        GetHorizontalAlignment() {
          return this._horizontalAlign;
        }
        SetVerticalAlignment(t) {
          if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error("invalid vertical alignment");
          this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());
        }
        GetVerticalAlignment() {
          return this._verticalAlign;
        }
        SetWordWrapMode(t) {
          if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error("invalid word wrap mode");
          this._wrapMode !== t && (this._wrapMode = t, this._SetWordWrapChanged());
        }
        GetWordWrapMode() {
          return this._wrapMode;
        }
        SetTextDirection(t) {
          if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error("invalid text direction");
          this._textDirection !== t && (this._textDirection = t, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._SetWordWrapChanged());
        }
        GetTextDirection() {
          return this._textDirection;
        }
        SetText(t) {
          this._text !== t && (this._text = t, this._SetWordWrapChanged());
        }
        GetText() {
          return this._text;
        }
        GetDrawScale() {
          return this._scaleFactor * this._zoom * self.devicePixelRatio;
        }
        SetSize(e, i, s) {
          if (void 0 === s && (s = 1), !(e <= 0 || this._cssWidth === e && this._cssHeight === i && this._zoom === s)) {
            const a = this._cssWidth, n = (this._cssWidth = e, this._cssHeight = i, this._zoom = s, self.devicePixelRatio), h = (this._width = this._cssWidth * this._zoom * n, this._height = this._cssHeight * this._zoom * n, Math.max(this._width, this._height)), o = Math.min(this._renderer.GetMaxTextureSize(), MAX_TEXTURE_SIZE);
            let t = 1;
            o < h && (t = o / h, this._width = Math.min(this._width * t, o), this._height = Math.min(this._height * t, o)), this._scaleFactor = t, this._cssWidth !== a ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();
          }
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetZoom() {
          return this._zoom;
        }
        GetTextWidth() {
          return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();
        }
        GetTextHeight() {
          return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + EXTRA_LINE_HEIGHT) - this._lineHeight;
        }
        GetLengthInGraphemes() {
          this._UpdateTextMeasurements();
          let t = 0;
          for (const e of this._wrappedText.GetLines()) for (const i of e.fragments()) t += i.GetLength();
          return t;
        }
        GetTexture() {
          return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;
        }
        HitTestFragment(t, e) {
          this._UpdateTextMeasurements();
          const i = this.GetDrawScale(), s = this._wrappedText.GetLines();
          for (const a of s) {
            const n = a.GetFontBoundingBoxDescent() * i;
            if (e >= a.GetPosY() - a.GetHeight() * i + n && e < a.GetPosY() + n) {
              for (const h of a.fragments()) if (t >= h.GetPosX() && t < h.GetPosX() + h.GetWidth() * i) return h;
            }
          }
          return null;
        }
        *fragmentsWithTag(t) {
          this._UpdateTextMeasurements();
          const e = this._wrappedText.GetLines();
          for (const i of e) for (const s of i.fragments()) {
            const a = s.GetStyleTag("tag");
            a && C33.equalsNoCase(a.param, t) && (yield s);
          }
        }
        FindFragmentWithTag(t, e) {
          for (const i of this.fragmentsWithTag(t)) {
            if (0 === e) return i;
            --e;
          }
          return null;
        }
        CountFragmentsWithTag(t) {
          let e = 0;
          for (const i of this.fragmentsWithTag(t)) ++e;
          return e;
        }
        _MaybeUpdate() {
          this._texture && !this._drawChanged && !this._textLayoutChanged && !this._wordWrapChanged || this._wasReleased || this._width <= 0 || this._height <= 0 || (this._drawChanged = false, this._DoUpdate());
        }
        _DoUpdate() {
          this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());
        }
        _SetTextCanvasSize(t, e) {
          this._textCanvas || (this._textCanvas = C33.CreateCanvas(16, 16));
          let i = false;
          this._lastCanvasWidth === t && this._lastCanvasHeight === e || (this._lastCanvasWidth = t, this._lastCanvasHeight = e, this._textCanvas.width = t, this._textCanvas.height = e, i = true), this._textContext || (this._textContext = this._textCanvas.getContext("2d"), i = true), i ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, e);
        }
        _MaybeCreateMeasureContext() {
          this._measureContext || (this._measureContext = C33.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = C33.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);
        }
        _SetMeasureFontString(t) {
          this._lastMeasureCanvasFont !== t && (this._lastMeasureCanvasFont = t, this._measureContext.font = t, this._measureContextTop.font = t);
        }
        _SupportsFontBoundingBoxMeasurements() {
          if (!didCheckFoundBoundingBoxSupport) {
            didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();
            const t = this._measureContext.measureText("test");
            supportsFontBoundingBoxMeasurements = "number" == typeof t["fontBoundingBoxAscent"] && "number" == typeof t["fontBoundingBoxDescent"];
          }
          return supportsFontBoundingBoxMeasurements;
        }
        _UpdateTextMeasurements() {
          this._UpdateWordWrap(), this._UpdateTextLayout();
        }
        _UpdateWordWrap() {
          this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C33.BBString(this._text, { noEscape: true })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);
        }
        _UpdateTextLayout() {
          this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);
        }
        _MeasureText(t) {
          const e = t.IsText() ? t.GetCharacterArray().join("") : " ", i = (this._SetMeasureFontString(this._GetFontString(true, t)), t.GetStyleTag("size")), s = (i ? parseFloat(i.param) : this._fontSize) * this._fontSizeScale, a = this._measureContext.measureText(e);
          let n = 0;
          if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {
            const h = this._measureContextTop.measureText(e);
            n = a["fontBoundingBoxAscent"] - h["fontBoundingBoxAscent"];
          }
          return { width: a.width, height: ptToPx2(s), fontBoundingBoxAscent: a["fontBoundingBoxAscent"] || 0, fontBoundingBoxDescent: a["fontBoundingBoxDescent"] || 0, topToAlphabeticDistance: n };
        }
        _SetDrawFontString(t) {
          this._lastTextCanvasFont !== t && (this._lastTextCanvasFont = t, this._textContext.font = t);
        }
        _SetDrawCanvasColor(t) {
          this._lastTextCanvasFillStyle !== t && (this._lastTextCanvasFillStyle = t, this._textContext.fillStyle = t, this._textContext.strokeStyle = t);
        }
        _SetDrawCanvasOpacity(t) {
          this._lastTextCanvasOpacity !== t && (this._lastTextCanvasOpacity = t, this._textContext.globalAlpha = t);
        }
        _SetDrawCanvasLineWith(t) {
          this._lastTextCanvasLineWidth !== t && (this._lastTextCanvasLineWidth = t, this._textContext.lineWidth = t);
        }
        _LayoutText() {
          const s = this.GetDrawScale(), a = (EXTRA_LINE_HEIGHT + this._lineHeight) * s;
          let n = 0;
          const h = this._wrappedText.GetLines();
          if (0 !== h.length) {
            for (const e of h) {
              e.SetPosX(NaN), e.SetPosY(NaN);
              for (const o of e.fragments()) o.SetPosX(NaN), o.SetPosY(NaN);
            }
            const t = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
            let i = h[0].GetHeight() * s;
            if ("center" === this._verticalAlign) {
              const r = h.reduce((t2, e) => t2 + e.GetHeight() * s + a, 0) - a;
              n = Math.max(this._height / 2 - r / 2, 0), t && (i = h[0].GetTopToAlphabeticDistance() * s);
            } else if ("bottom" === this._verticalAlign) {
              const _ = h.reduce((t2, e) => t2 + e.GetHeight() * s + a, 0) - this._lineHeight * s, l = t ? h.at(-1).GetFontBoundingBoxDescent() * s : 0;
              n = this._height - _ - l - 2;
            }
            for (let t2 = 0, e = h.length; t2 < e; ++t2) {
              const d = h[t2], x = d.GetHeight() * s, C = n;
              if (this._isBBcodeEnabled) {
                if (n += 0 === t2 ? i : x, 0 < t2 && n > this._height - EXTRA_LINE_HEIGHT * s) break;
              } else if (0 < t2 && n >= this._height - x) break;
              0 <= C && this._LayoutTextLine(d, n, s), this._isBBcodeEnabled || (n += x), n += a;
            }
          }
        }
        _LayoutTextLine(t, e, i) {
          let s = 0;
          "center" === this._horizontalAlign ? s = Math.floor((this._width - t.GetWidth() * i) / 2) : "right" === this._horizontalAlign && (s = this._width - t.GetWidth() * i), t.SetPosX(s), t.SetPosY(e);
          for (const a of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._LayoutFragment(a, s, e, i), s += a.GetWidth() * i;
        }
        _LayoutFragment(t, e, i, s) {
          const a = t.GetStyleTag("offsetx"), n = (e += a ? getOffsetParam2(a.param, t.GetHeight()) * s : 0, t.GetStyleTag("offsety"));
          if (i += n ? getOffsetParam2(n.param, t.GetHeight()) * s : 0, t.IsIcon()) {
            const h = t.GetStyleTag("iconoffsety");
            i += h ? getOffsetParam2(h.param, t.GetHeight()) * s : 0.2 * t.GetHeight() * s;
          }
          t.SetPosX(e), t.SetPosY(i);
        }
        _DrawTextToCanvas() {
          this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = "high", this._drawCharCount = 0;
          const t = this.GetDrawScale(), e = this._wrappedText.GetLines();
          for (const i of e) this._DrawTextLine(i, t);
        }
        _DrawTextLine(t, e) {
          const i = t.GetPosX(), s = t.GetPosY();
          if (Number.isFinite(i) && Number.isFinite(s)) for (const a of "ltr" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._DrawFragment(a, e, t.GetHeight());
        }
        _DrawFragment(i, s, a) {
          const n = this._textContext, h = i.GetPosX(), o = i.GetPosY();
          if (Number.isFinite(h) && Number.isFinite(o)) {
            const r = a / 16;
            let t = i.GetWidth() * s;
            const _ = i.GetHeight() * s, l = i.GetHeight() / 16, d = (EXTRA_LINE_HEIGHT + this._lineHeight) * s;
            let e = i.IsText() ? i.GetCharacterArray() : null;
            if (-1 !== this._drawMaxCharCount) {
              if (this._drawCharCount >= this._drawMaxCharCount) return;
              i.IsText() && this._drawCharCount + e.length > this._drawMaxCharCount && (e = e.slice(0, this._drawMaxCharCount - this._drawCharCount), t = this._MeasureText(i).width * s), this._drawCharCount += i.GetLength();
            }
            const x = i.GetStyleTag("background"), C = i.HasStyleTag("u"), u = i.HasStyleTag("s");
            if ((!i.IsText() || !C33.IsCharArrayAllWhitespace(e) || x || C || u) && !i.HasStyleTag("hide")) {
              const c = i.GetStyleTag("color"), g = i.GetStyleTag("opacity"), S = (this._SetDrawCanvasOpacity(g ? parseFloat(g.param) / 100 : 1), x && (this._SetDrawCanvasColor(x.param), n.fillRect(h, o - _, t, _ + d)), i.GetStyleTag("linethickness")), T = S ? parseFloat(S.param) : 1, p = i.HasStyleTag("stroke");
              if (p && this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale()), i.IsText()) {
                const f = e.join("");
                if (this._SetDrawFontString(this._GetFontString(false, i)), !p) {
                  this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale());
                  const m = i.GetStyleTag("outlineback");
                  m && (this._SetDrawCanvasColor(m.param), this._FillOrStrokeText(true, f, h, o, t));
                }
                if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), this._FillOrStrokeText(p, f, h, o, t), !p) {
                  this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale());
                  const w = i.GetStyleTag("outline");
                  w && (this._SetDrawCanvasColor(w.param), this._FillOrStrokeText(true, f, h, o, t));
                }
              } else if (i.IsIcon() && 0 < i.GetWidth()) {
                const G = i.GetDrawable(this._iconSet);
                G && n.drawImage(G, h, o - _, t, _);
              }
              if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), C && fillOrStrokeRect2(n, p, h, o + s * r, t, s * r * T), u) {
                const B = o - _ / 4, W = s * l, D = B + W / 2;
                n.fillRect(h, D - W * T / 2, t, W * T);
              }
            }
          }
        }
        _FillOrStrokeText(t, e, i, s, a) {
          "rtl" === this._textDirection && (i += a), t ? "Gecko" === C33.Platform.BrowserEngine ? this._textContext.strokeText(e, i, s, a) : this._textContext.strokeText(e, i, s) : "Gecko" === C33.Platform.BrowserEngine ? this._textContext.fillText(e, i, s, a) : this._textContext.fillText(e, i, s);
        }
        _UpdateTexture() {
          this._renderer.IsContextLost() || (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: true, mipMapQuality: "high" })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());
        }
        GetTexRect() {
          return this._rcTex;
        }
        ReleaseTexture() {
          this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);
        }
        static OnContextLost() {
          for (const t of allRendererTexts) t.ReleaseTexture();
        }
        static GetAll() {
          return allRendererTexts.values();
        }
      };
    }
    var fillOrStrokeRect;
    var ptToPx;
    var getOffsetParam;
    {
      const C33 = self.C3;
      class WebGLRealTimeElapsedQuery {
        constructor(e) {
          this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt["createQueryEXT"]() : this._query = this._gl["createQuery"]();
        }
        Release() {
          this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;
        }
        _DeleteQueryObject() {
          this._query && (1 === this._version ? this._timerExt["deleteQueryEXT"](this._query) : this._gl["deleteQuery"](this._query), this._query = null);
        }
        BeginTimeElapsed() {
          if (this._isActive) throw new Error("query already active");
          1 === this._version ? this._timerExt["beginQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"], this._query) : this._gl["beginQuery"](this._timerExt["TIME_ELAPSED_EXT"], this._query), this._isActive = true;
        }
        EndTimeElapsed() {
          if (!this._isActive) throw new Error("query not active");
          1 === this._version ? this._timerExt["endQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"]) : this._gl["endQuery"](this._timerExt["TIME_ELAPSED_EXT"]), this._isActive = false;
        }
        CheckForResult() {
          if (this._query && !this._hasResult && !this._isActive) {
            let e = false;
            e = 1 === this._version ? this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_AVAILABLE_EXT"]) : this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT_AVAILABLE"]);
            const t = this._gl.getParameter(this._timerExt["GPU_DISJOINT_EXT"]);
            e && !t && (1 === this._version ? this._result = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_EXT"]) : this._result = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT"]), this._result /= 1e9, this._hasResult = true), (e || t) && this._DeleteQueryObject();
          }
        }
        HasResult() {
          return this._hasResult;
        }
        GetResult() {
          if (this._hasResult) return this._result;
          throw new Error("no result available");
        }
      }
      C33.Gfx.WebGLTimeElapsedQuery = class {
        constructor(e) {
          this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];
        }
        Release() {
          for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();
          C33.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;
        }
        BeginTimeElapsed() {
          if (this._isActive) throw new Error("query already active");
          const e = this._renderer._GetTimeQueryStack();
          0 < e.length ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();
        }
        EndTimeElapsed() {
          if (!this._isActive) throw new Error("query not active");
          const e = this._renderer._GetTimeQueryStack().pop();
          if (e !== this) throw new Error("can only end most nested query");
          this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);
        }
        _StartReal() {
          this._realQuery = C33.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();
        }
        _EndReal() {
          this._realQuery.EndTimeElapsed(), this._realQuery = null;
        }
        CheckForResult() {
          for (const e of this._queries) e.CheckForResult();
        }
        IsNested() {
          return this._isNested;
        }
        HasResult() {
          return this._queries.every((e) => e.HasResult());
        }
        GetResult() {
          return this._queries.reduce((e, t) => e + t.GetResult(), 0);
        }
        GetFrameNumber() {
          return this._frameNumber;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.WebGLQueryResultBuffer = class {
        constructor(e, r = 1e3) {
          this._renderer = e, this._maxQueries = r, this._buffer = [], this._renderer._AddQueryResultBuffer(this);
        }
        Release() {
          this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;
        }
        Clear() {
          for (const e of this._buffer) e.Release();
          C33.clearArray(this._buffer);
        }
        AddTimeElapsedQuery() {
          const e = new C33.Gfx.WebGLTimeElapsedQuery(this._renderer);
          if (this._buffer.push(e), this._buffer.length > this._maxQueries) {
            const r = this._buffer.shift();
            r.Release();
          }
          return e;
        }
        CheckForResults(e) {
          for (const r of this._buffer) {
            if (r.GetFrameNumber() >= e) return;
            if (r.IsNested()) return;
            r.CheckForResult();
          }
        }
        GetFrameRangeResultSum(e, r) {
          if (r <= e) return NaN;
          let t = 0;
          for (const s of this._buffer) {
            if (s.GetFrameNumber() >= r) break;
            if (!(s.GetFrameNumber() < e)) {
              if (!s.HasResult()) return NaN;
              t += s.GetResult();
            }
          }
          return t;
        }
        DeleteAllBeforeFrameNumber(t) {
          for (let e = 0, r = this._buffer.length; e < r; ++e) {
            const s = this._buffer[e];
            if (!(s.GetFrameNumber() < t)) return void (0 < e && this._buffer.splice(0, e));
            s.Release();
          }
        }
      };
    }
    {
      let CheckPendingPolls2 = function() {
        pollRafId = -1;
        for (const t of pendingPolls) t.checkFunc() && (t.resolve(), pendingPolls.delete(t));
        0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2));
      };
      CheckPendingPolls = CheckPendingPolls2;
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: "default", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set(["default", "low-power", "high-performance"]), MAX_VERTICES = 8e3, MAX_INDICES = MAX_VERTICES / 2 * 3, MAX_POINTS = 8e3, LAST_POINT = MAX_POINTS - 4, PARTIAL_TEXTURE_UPLOAD_CHUNK_SIZE = 262144, defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat42.create(), tmpModelView = mat42.create(), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect();
      let loseContextExtension = null;
      C33.isDebug && (self.debug_lose_webgl_context = function() {
        loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported");
      }, self.debug_restore_webgl_context = function() {
        loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported");
      });
      const pendingPolls = /* @__PURE__ */ new Set();
      let pollRafId = -1;
      C33.Gfx.WebGLRenderer = class extends C33.Gfx.RendererBase {
        constructor(t, e) {
          if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error("invalid power preference");
          const r = { "alpha": !!e.alpha, "depth": false, "antialias": false, "powerPreference": e.powerPreference, "failIfMajorPerformanceCaveat": !!e.failIfMajorPerformanceCaveat };
          let i = null, s = 0;
          if (2 <= e.maxWebGLVersion && (i = t.getContext("webgl2", r), s = 2), i || (i = t.getContext("webgl", r), s = 1), !i) throw new Error("renderer-unavailable (could not get WebGL context)");
          this._gl = i, this._attribs = i.getContextAttributes(), this._versionString = i.getParameter(i.VERSION), this._version = s, this._viewport = vec42.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat42.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._vertexData = new Float32Array(MAX_VERTICES * this.GetNumVertexComponents()), this._indexData = new Uint16Array(MAX_INDICES), this._texcoordData = new Float32Array(2 * MAX_VERTICES), this._pointData = new Float32Array(4 * MAX_POINTS), this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._lastVertexPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C33.New(C33.Gfx.BatchState, this), this._lastColor = C33.New(C33.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lastPointTexCoords = new C33.Rect(), this._lastScissorRect = C33.New(C33.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._highpPrecision = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [], this.FillIndexBufferData(this._indexData);
        }
        IsWebGL() {
          return true;
        }
        async InitState() {
          super.InitState();
          const t = this._gl, e = this.GetNumVertexComponents(), r = (this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._pointPtr = 0, this._lastVertexPtr = MAX_VERTICES * e - 4 * e, C33.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0, this._batchState), i = (r.currentShader = null, r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, vec42.set(r.currentColor, 1, 1, 1, 1), r.clearColor.setRgba(0, 0, 0, 0), r.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t.ONE, this._lastDestBlend = t.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t), t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), this._usesDepthBuffer ? (t.enable(t.DEPTH_TEST), t.depthMask(true), t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData, t.STATIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), t.getParameter(t.ALIASED_POINT_SIZE_RANGE)), s = (this._minPointSize = i[0], this._maxPointSize = i[1], t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)), a = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT), h = (this._highpPrecision = s && a ? Math.min(s["precision"], a["precision"]) : 0, 2048 < this._maxPointSize && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions(), t.getExtension("WEBGL_debug_renderer_info"));
          if (h && (this._unmaskedVendor = t.getParameter(h["UNMASKED_VENDOR_WEBGL"]), this._unmaskedRenderer = t.getParameter(h["UNMASKED_RENDERER_WEBGL"])), this._parallelShaderCompileExt = t.getExtension("KHR_parallel_shader_compile"), C33.isDebug && (loseContextExtension = t.getExtension("WEBGL_lose_context")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t.getExtension("EXT_disjoint_timer_query") : this._timerExt = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), this._anisotropicExt = t.getExtension("EXT_texture_filter_anisotropic"), this._anisotropicExt ? this._maxAnisotropy = t.getParameter(this._anisotropicExt["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t.getExtension("WEBGL_depth_texture"), !this._depthTextureExt)) throw new Error("no depth texture support");
          this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t.getExtension("EXT_frag_depth"), this._stdDerivativesExt = t.getExtension("OES_standard_derivatives"), this._textureLodExt = t.getExtension("EXT_shader_texture_lod"));
          const n = C33.Gfx.WebGLShaderProgram, o = n.GetDefaultVertexShaderSource(false);
          let l = n.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), _ = o, u = n.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), d = n.GetPointVertexShaderSource_WebGL1(), c = n.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), f = n.GetDefaultVertexShaderSource(true), p = false;
          this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (l = n.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), u = n.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), c = n.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), p = true) : (_ = n.GetDefaultVertexShaderSource_WebGL2(), l = n.GetTextureFillFragmentShaderSource_WebGL2(), u = n.GetPointFragmentShaderSource_WebGL2(), d = n.GetPointVertexShaderSource_WebGL2(), c = n.GetTilemapFragmentShaderSource_WebGL2(), f = n.GetDefaultVertexShaderSource_WebGL2(true)));
          const x = n.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), p, this._stdDerivativesExt && this._textureLodExt), E = 2 <= this.GetWebGLVersionNumber() ? n.GetDefaultVertexShaderSource_WebGL2() : o, S = [[l, _, "<default>"], [l, _, "<default-device-transform>"], [u, d, "<point>"], [n.GetColorFillFragmentShaderSource(), o, "<fill>"], [n.GetLinearGradientFillFragmentShaderSource(), o, "<lineargradient>"], [n.GetPenumbraFillFragmentShaderSource(), o, "<penumbra>"], [n.GetHardEllipseFillFragmentShaderSource(), o, "<hardellipse>"], [n.GetHardEllipseOutlineFragmentShaderSource(), o, "<hardellipseoutline>"], [n.GetSmoothEllipseFillFragmentShaderSource(), o, "<smoothellipse>"], [n.GetSmoothEllipseOutlineFragmentShaderSource(), o, "<smoothellipseoutline>"], [n.GetSmoothLineFillFragmentShaderSource(), o, "<smoothline>"], [c, f, "<tilemap>"], [x, E, "<tilerandomization>"]], T = await Promise.all(S.map((t2) => this.CreateShaderProgram({ src: t2[0], vertexSrc: t2[1], name: t2[2] })));
          this._spTextureFill = T[0], this._spDeviceTransformTextureFill = T[1], this._spPoints = T[2], this._spColorFill = T[3], this._spLinearGradientFill = T[4], this._spPenumbraFill = T[5], this._spHardEllipseFill = T[6], this._spHardEllipseOutline = T[7], this._spSmoothEllipseFill = T[8], this._spSmoothEllipseOutline = T[9], this._spSmoothLineFill = T[10], this._spTilemapFill = T[11], this._spTileRandomization = T[12], this.SetTextureFillMode();
        }
        async CreateShaderProgram(t) {
          const e = await C33.Gfx.WebGLShaderProgram.Create(this, t);
          return this._AddShaderProgram(e), e;
        }
        ResetLastProgram() {
          this._lastProgram = null;
        }
        SetSize(t, e, r) {
          if (this._width !== t || this._height !== e || r) {
            this.EndBatch();
            const i = this._gl, s = this._batchState;
            this._width = t, this._height = e, this._SetViewport(0, 0, t, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i.bindFramebuffer(i.FRAMEBUFFER, null), this._currentRenderTarget = null, s.currentFramebuffer = null, s.currentFramebufferNoDepth = null;
          }
        }
        _SetDepthBufferSize(t, e) {
          const r = this._gl;
          this._depthBuffer && this._depthBufferWidth === t && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r.deleteTexture(this._depthBuffer), this._depthBuffer = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this._depthBuffer), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), 2 <= this.GetWebGLVersionNumber() ? r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH24_STENCIL8, t, e, 0, r.DEPTH_STENCIL, r.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH_STENCIL, t, e, 0, r.DEPTH_STENCIL, this._depthTextureExt["UNSIGNED_INT_24_8_WEBGL"], null), r.bindTexture(r.TEXTURE_2D, null)) : (this._depthBuffer && r.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._depthBuffer), r.renderbufferStorage(r.RENDERBUFFER, 2 <= this._version ? r.DEPTH24_STENCIL8 : r.DEPTH_STENCIL, t, e), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._depthBufferWidth = t, this._depthBufferHeight = e);
        }
        SetFixedSizeDepthBuffer(t, e) {
          this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t, e));
        }
        SetAutoSizeDepthBuffer() {
          this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));
        }
        _SetViewport(t, e, r, i) {
          const s = this._viewport;
          if (s[0] !== t || s[1] !== e || s[2] !== r || s[3] !== i) {
            const a = this.PushBatch();
            a.InitSetViewport(t, e, r, i), vec42.set(s, t, e, r, i), this._topOfBatch = 0;
          }
        }
        SetFovY(t) {
          super.SetFovY(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetNearZ(t) {
          super.SetNearZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetFarZ(t) {
          super.SetFarZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
        }
        SetProjectionMatrix(t) {
          if (!mat42.exactEquals(this._matP, t)) {
            const e = this.PushBatch();
            e.InitSetProjection(t), mat42.copy(this._matP, t), this._topOfBatch = 0, this._didChangeTransform = true;
          }
        }
        SetDefaultRenderTargetProjectionState() {
          let t, e, r;
          const i = this._currentRenderTarget;
          r = (null === i ? (t = this._bbProjectionMatrix, e = this.GetWidth(), this) : (t = i.GetProjectionMatrix(), e = i.GetWidth(), i)).GetHeight(), this.SetProjectionMatrix(t), this._SetViewport(0, 0, e, r);
        }
        SetModelViewMatrix(t) {
          if (!mat42.exactEquals(this._matMV, t)) {
            const e = this.PushBatch();
            e.InitSetModelView(t), mat42.copy(this._matMV, t), this._topOfBatch = 0, this._didChangeTransform = true;
          }
        }
        ResetDidChangeTransformFlag() {
          this._didChangeTransform = false;
        }
        DidChangeTransform() {
          return this._didChangeTransform;
        }
        GetBatchState() {
          return this._batchState;
        }
        PushBatch() {
          const t = this._batch;
          return this._batchPtr === t.length && t.push(new C33.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++];
        }
        EndBatch() {
          0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._topOfBatch = 0);
        }
        _WriteBuffers() {
          const t = this._gl;
          0 < this._pointPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))), 0 < this._vertexPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)));
        }
        _ExecuteBatch() {
          const r = this._batch;
          for (let t = 0, e = this._batchPtr; t < e; ++t) r[t].Run();
        }
        GetOpacity() {
          return this._lastColor.getA();
        }
        SetColorRgba(t, e, r, i) {
          const s = this._lastColor;
          if (!s.equalsRgba(t, e, r, i)) {
            s.setRgba(t, e, r, i);
            const a = this.PushBatch();
            a.InitSetColor(s), this._topOfBatch = 0, this._currentStateGroup = null;
          }
        }
        SetOpacity(t) {
          const e = this._lastColor;
          if (e.getA() !== t) {
            e.setA(t);
            const r = this.PushBatch();
            r.InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;
          }
        }
        SetColor(t) {
          const e = this._lastColor;
          if (!e.equals(t)) {
            e.set(t);
            const r = this.PushBatch();
            r.InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;
          }
        }
        ResetColor() {
          this.SetColorRgba(1, 1, 1, 1);
        }
        GetColor() {
          return this._lastColor;
        }
        SetTexture(t) {
          if (t !== this._lastTexture0) {
            const e = this.PushBatch();
            e.InitSetTexture(t), this._lastTexture0 = t, this._topOfBatch = 0;
          }
        }
        _ResetLastTexture() {
          this._lastTexture0 = null;
        }
        SetBlendMode(t) {
          const e = this._GetBlendByIndex(t);
          this._SetBlend(e[0], e[1]);
        }
        SetNamedBlendMode(t) {
          const e = this.GetNamedBlend(t);
          this._SetBlend(e.srcBlend, e.destBlend);
        }
        _SetBlend(t, e) {
          if (t !== this._lastSrcBlend || e !== this._lastDestBlend) {
            const r = this.PushBatch();
            r.InitSetBlend(t, e), this._lastSrcBlend = t, this._lastDestBlend = e, this._topOfBatch = 0, this._currentStateGroup = null;
          }
        }
        IsPremultipliedAlphaBlend() {
          return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA;
        }
        SetAlphaBlend() {
          this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
        }
        SetNoPremultiplyAlphaBlend() {
          this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
        }
        SetCopyBlend() {
          this._SetBlend(this._gl.ONE, this._gl.ZERO);
        }
        Rect(t) {
          this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom());
        }
        Rect2(t, e, r, i) {
          this.Quad2(t, e, r, e, r, i, t, i);
        }
        _ExtendQuadBatch() {
          let t = this._vertexPtr;
          if (t >= this._lastVertexPtr && (this.EndBatch(), t = 0), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += 6;
          else {
            const e = this.PushBatch();
            e.InitQuad(t, 6), this._topOfBatch = 1;
          }
        }
        _WriteQuadToVertexBuffer(t) {
          t.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ), this._vertexPtr += 12;
        }
        Quad(t) {
          this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        Quad2(t, e, r, i, s, a, h, n) {
          this._ExtendQuadBatch();
          const o = this._vertexData;
          let l = this._vertexPtr;
          const _ = this._baseZ + this._currentZ;
          o[l++] = t, o[l++] = e, o[l++] = _, o[l++] = r, o[l++] = i, o[l++] = _, o[l++] = s, o[l++] = a, o[l++] = _, o[l++] = h, o[l++] = n, o[l++] = _, this._vertexPtr = l, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        Quad3(t, e) {
          this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        Quad4(t, e) {
          this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        Quad3D(t, e, r, i, s, a, h, n, o, l, _, u, d) {
          this._ExtendQuadBatch();
          const c = this._vertexData;
          let f = this._vertexPtr;
          const p = this._baseZ + this._currentZ;
          c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        Quad3D2(t, e, r, i, s, a, h, n, o, l, _, u, d) {
          this._ExtendQuadBatch();
          const c = this._vertexData;
          let f = this._vertexPtr;
          const p = this._baseZ + this._currentZ;
          c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;
        }
        DrawMesh(i, s, a) {
          const h = this._vertexData, n = this._texcoordData;
          if (a.length % 3 != 0) throw new Error("invalid index buffer length");
          for (let r = 0, t = a.length; r < t; ) {
            const o = a[r++], l = a[r++], _ = a[r++], u = 3 * o, d = 3 * l, c = 3 * _, f = 2 * o, p = 2 * l, x = 2 * _;
            this._ExtendQuadBatch();
            let t2 = this._vertexPtr, e = this._texPtr;
            h[t2++] = i[0 + u], h[t2++] = i[1 + u], h[t2++] = i[2 + u], h[t2++] = i[0 + d], h[t2++] = i[1 + d], h[t2++] = i[2 + d], h[t2++] = i[0 + c], h[t2++] = i[1 + c], h[t2++] = i[2 + c], h[t2++] = i[0 + c], h[t2++] = i[1 + c], h[t2++] = i[2 + c], n[e++] = s[0 + f], n[e++] = s[1 + f], n[e++] = s[0 + p], n[e++] = s[1 + p], n[e++] = s[0 + x], n[e++] = s[1 + x], n[e++] = s[0 + x], n[e++] = s[1 + x], this._vertexPtr = t2, this._texPtr = e;
          }
        }
        FullscreenQuad(t, e) {
          this.SetCurrentZ(0), mat42.copy(tmpProjection, this._matP), mat42.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();
          const [r, i] = this.GetRenderTargetSize(this._currentRenderTarget), s = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i), 0, 0, 0, i);
          if (this.SetModelViewMatrix(s), "crop" === t && this._currentRenderTarget && e) {
            const a = this._width / 2, h = this._height / 2, n = e.GetWidth(), o = e.GetHeight(), l = this._currentRenderTarget.GetWidth(), _ = this._currentRenderTarget.GetHeight(), u = Math.min(l, n), d = Math.min(_, o), c = Math.max(o - _, 0), f = Math.max(_ - o, 0);
            tmpRect.set(-a, h - f, -a + u, h - d - f), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, c, u, d + c), tmpRect.divide(n, o), this.Quad3(tmpQuad, tmpRect);
          } else {
            const p = r / 2, x = i / 2;
            this.Rect2(-p, x, p, -x);
          }
          this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);
        }
        StartRenderingPoints(t) {
          if (!this._lastPointTexCoords.equals(t)) {
            this._lastPointTexCoords.copy(t);
            const e = this.PushBatch();
            e.InitSetPointTexCoords(t), this._topOfBatch = 0;
          }
        }
        FinishRenderingPoints() {
        }
        Point(t, e, r, i) {
          this._pointPtr >= LAST_POINT && this.EndBatch();
          let s = this._pointPtr;
          const a = this._baseZ + this._currentZ;
          if (2 === this._topOfBatch && this._lastPointZ === a) this._batch[this._batchPtr - 1]._indexCount++;
          else {
            const n = this.PushBatch();
            n.InitPoints(s, a), this._topOfBatch = 2, this._lastPointZ = a;
          }
          const h = this._pointData;
          h[s++] = t, h[s++] = e, h[s++] = r, h[s++] = i, this._pointPtr = s;
        }
        SetProgram(t) {
          if (this._lastProgram !== t) {
            const e = this.PushBatch();
            e.InitSetProgram(t), this._lastProgram = t, this._topOfBatch = 0, this._currentStateGroup = null;
          }
        }
        GetProgram() {
          return this._lastProgram;
        }
        SetDeviceTransformTextureFillMode() {
          this.SetProgram(this._spDeviceTransformTextureFill);
        }
        SetGradientColor(t) {
          const e = this.PushBatch();
          e.InitSetGradientColor(t), this._topOfBatch = 0;
        }
        SetEllipseParams(t, e, r = 1) {
          const i = this.PushBatch();
          i.InitSetEllipseParams(t, e, r), this._topOfBatch = 0;
        }
        SetTilemapInfo(t, e, r, i, s, a, h) {
          if (this._lastProgram !== this._spTilemapFill) throw new Error("must set tilemap fill mode first");
          const n = this.PushBatch();
          n.InitSetTilemapInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;
        }
        SetTileRandomizationInfo(t, e, r, i, s, a, h) {
          if (this._lastProgram !== this._spTileRandomization) throw new Error("must set tile randomization mode first");
          const n = this.PushBatch();
          n.InitSetTileRandomizationInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;
        }
        SetProgramParameters(t, e, r, i, s, a, h, n, o, l, _) {
          const u = this._lastProgram;
          if (_ %= 10800, u._hasAnyOptionalUniforms && !u.AreOptionalUniformsAlreadySetInBatch(e, r, i, s, a, h, n, o, l, _)) {
            const d = this.PushBatch(), c = (d.InitSetProgramParameters(), u.SetOptionalUniformsInBatch(e, r, i, s, a, h, n, o, l, _), d._mat4param), f = (c[0] = a, c[1] = h, e.writeToTypedArray(c, 2), c[6] = o, c[7] = l, r.writeToTypedArray(c, 12), d._colorParam), p = (s.writeToTypedArray(f, 0), f[1]);
            f[1] = f[3], f[3] = p, i.writeToTypedArray(d._srcOriginRect, 0), d._startIndex = _, d._indexCount = n, u._uSamplerBack.IsUsed() ? d._texParam = t ? t.GetTexture() : null : d._texParam = null, this._topOfBatch = 0;
          }
        }
        SetProgramCustomParameters(t) {
          const e = this._lastProgram;
          if (0 !== t.length && !e.AreCustomParametersAlreadySetInBatch(t)) {
            const r = this.PushBatch();
            r.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t), C33.shallowAssignArray(r._shaderParams, t), this._topOfBatch = 0;
          }
        }
        ClearRgba(t, e, r, i) {
          const s = this.PushBatch();
          s.InitClearSurface2(t, e, r, i), this._topOfBatch = 0;
        }
        Clear(t) {
          const e = this.PushBatch();
          e.InitClearSurface(t), this._topOfBatch = 0;
        }
        Start() {
        }
        Finish() {
          super.Finish(), this._gl.flush();
        }
        ClearDepth() {
          if (this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer()) {
            const t = this.PushBatch();
            t.InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;
          }
        }
        SetDepthEnabled(t) {
          if (this._isDepthEnabled !== (t = !!t) && this._usesDepthBuffer) {
            this._isDepthEnabled = t;
            const e = this.PushBatch();
            e.InitSetDepthEnabled(t), this._topOfBatch = 0;
          }
        }
        IsDepthEnabled() {
          return this._isDepthEnabled;
        }
        _GetDepthBuffer() {
          return this._depthBuffer;
        }
        _CanSampleDepth() {
          return this._canSampleDepth;
        }
        SetDepthSamplingEnabled(t) {
          if (t = !!t, this._canSampleDepth && this._isDepthSamplingEnabled !== t) {
            if (t && this.IsDepthEnabled()) throw new Error("depth still enabled");
            this._isDepthSamplingEnabled = t;
            const e = this.PushBatch();
            e.InitSetDepthSamplingEnabled(t), this._topOfBatch = 0;
          }
        }
        SetScissorRect(t, e, r, i, s = 0) {
          if (t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), i = Math.floor(i), !this._lastScissorRect.equalsWH(t, e, r, i)) {
            this._lastScissorRect.setWH(t, e, r, i);
            const a = s || this.GetRenderTargetSize(this.GetRenderTarget())[1], h = (e = a - e - i, this.PushBatch());
            h.InitSetScissor(true, t, e, r, i), this._topOfBatch = 0;
          }
        }
        RemoveScissorRect() {
          if (-1 !== this._lastScissorRect.getRight()) {
            this._lastScissorRect.set(0, 0, -1, -1);
            const t = this.PushBatch();
            t.InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;
          }
        }
        CheckForQueryResults() {
          for (const t of this._allQueryResultBuffers) t.CheckForResults(this._frameNumber);
        }
        IsContextLost() {
          return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;
        }
        OnContextLost() {
          super.OnDeviceOrContextLost(), C33.Gfx.WebGLRendererTexture.OnContextLost(), C33.Gfx.WebGLRenderTarget.OnContextLost(), C33.Gfx.RendererText.OnContextLost();
          for (const t of this._allQueryResultBuffers) t.Clear();
          this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;
          for (const e of this._stateGroups.values()) e.OnContextLost();
        }
        async OnContextRestored() {
          this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;
          for (const t of this._stateGroups.values()) t.OnContextRestored(this);
          this.SetSize(this._width, this._height, true);
        }
        CreateStaticTexture(t, e) {
          if (this.IsContextLost()) throw new Error("context lost");
          this.EndBatch();
          const r = C33.New(C33.Gfx.WebGLRendererTexture, this);
          return r._CreateStatic(t, e), r;
        }
        async CreateStaticTextureAsync(e, r) {
          if (this.IsContextLost()) throw new Error("context lost");
          if (r = Object.assign({}, r), C33.Supports.ImageBitmapOptions) {
            let t = await createImageBitmap(e, { "premultiplyAlpha": "premultiply" });
            const i = r.wrapX && "clamp-to-edge" !== r.wrapX || r.wrapY && "clamp-to-edge" !== r.wrapY, s = C33.isPOT(t.width) && C33.isPOT(t.height);
            return this.SupportsNPOTTextures() || s || !i ? r.premultiplyAlpha = false : C33.Supports.ImageBitmapOptionsResize ? (t = await createImageBitmap(e, { "premultiplyAlpha": "premultiply", "resizeWidth": C33.nextHighestPowerOfTwo(t.width), "resizeHeight": C33.nextHighestPowerOfTwo(t.height) }), r.premultiplyAlpha = false) : t = await createImageBitmap(e, { "premultiplyAlpha": "none" }), C33.Asyncify(() => this.CreateStaticTexture(t, r));
          }
          if (e instanceof Blob) {
            if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
            const t = await C33.BlobToImage(e);
            e = t;
          }
          return C33.Asyncify(() => this.CreateStaticTexture(e, r));
        }
        CreateDynamicTexture(t, e, r) {
          this.EndBatch();
          const i = C33.New(C33.Gfx.WebGLRendererTexture, this);
          return i._CreateDynamic(t, e, r), i;
        }
        UpdateTexture(t, e, r) {
          this.EndBatch(), e._Update(t, r);
        }
        DeleteTexture(t) {
          t && (t.SubtractReference(), 0 < t.GetReferenceCount() || (this.EndBatch(), t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete()));
        }
        CreateRenderTarget(t) {
          let e = this._width, r = this._height, i = true;
          if (t && ("number" == typeof t.width && (e = Math.floor(t.width), i = false), "number" == typeof t.height) && (r = Math.floor(t.height), i = false), e <= 0 || r <= 0) throw new Error("invalid size");
          this.EndBatch();
          const s = C33.New(C33.Gfx.WebGLRenderTarget, this);
          return s._Create(e, r, Object.assign({ isDefaultSize: i }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s;
        }
        SetRenderTarget(t, e = true) {
          if (t !== this._currentRenderTarget) {
            t && t.IsDefaultSize() && t._Resize(this._width, this._height);
            const r = this.PushBatch();
            r.InitSetRenderTarget(t), this._currentRenderTarget = t, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();
          }
        }
        GetRenderTarget() {
          return this._currentRenderTarget;
        }
        GetRenderTargetSize(t) {
          return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height];
        }
        CopyRenderTarget(t, e = "stretch") {
          if (this._version < 2 || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling()) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t, e);
          else {
            const r = this.PushBatch();
            r.InitBlitFramebuffer(t, this._currentRenderTarget, e), this._topOfBatch = 0;
          }
        }
        DrawRenderTarget(t, e = "stretch") {
          const r = t.GetTexture();
          if (!r) throw new Error("not a texture-backed render target");
          this.SetTexture(r), this.FullscreenQuad(e, r);
        }
        InvalidateRenderTarget(t) {
          if (!(this._version < 2)) {
            const e = this.PushBatch();
            e.InitInvalidateFramebuffer(t._GetFramebuffer()), this._topOfBatch = 0;
          }
        }
        DeleteRenderTarget(t) {
          this.SetRenderTarget(null), this.EndBatch();
          const e = t.GetTexture();
          e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete();
        }
        async ReadBackRenderTargetToImageData(t, e, r) {
          this.EndBatch();
          const i = this._currentRenderTarget;
          let s, a, h, n = (h = t ? (s = t.GetWidth(), a = t.GetHeight(), t._GetFramebuffer()) : (s = this.GetWidth(), a = this.GetHeight(), null), 0), o = 0, l = s, _ = a;
          if (r) {
            n = C33.clamp(Math.floor(r.getLeft()), 0, s - 1), o = C33.clamp(Math.floor(r.getTop()), 0, a - 1);
            let t2 = r.width(), e2 = (t2 = 0 === t2 ? s - n : C33.clamp(Math.floor(t2), 0, s - n), r.height());
            e2 = 0 === e2 ? a - o : C33.clamp(Math.floor(e2), 0, a - o), l = t2, _ = e2, o = a - (o + _);
          }
          const u = this._gl, d = (u.bindFramebuffer(u.FRAMEBUFFER, h), () => {
            u.bindFramebuffer(u.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i);
          });
          let c;
          if (!e && 2 <= this.GetWebGLVersionNumber()) {
            u.bindFramebuffer(u.READ_FRAMEBUFFER, h);
            const f = u.createBuffer(), p = l * _ * 4, x = u["PIXEL_PACK_BUFFER"], E = (u.bindBuffer(x, f), u.bufferData(x, p, u["STREAM_READ"]), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, 0), u.bindFramebuffer(u.READ_FRAMEBUFFER, null), u.bindBuffer(x, null), d(), u["fenceSync"](u["SYNC_GPU_COMMANDS_COMPLETE"], 0));
            await this._WaitForObjectReady(() => u["getSyncParameter"](E, u["SYNC_STATUS"]) === u["SIGNALED"]), u["deleteSync"](E), c = new ImageData(l, _), u.bindBuffer(x, f), u["getBufferSubData"](x, 0, new Uint8Array(c.data.buffer), 0, p), u.bindBuffer(x, null), u.deleteBuffer(f);
          } else c = new ImageData(l, _), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array(c.data.buffer)), d();
          return c;
        }
        CoplanarStartStencilPass() {
          this.SetDepthEnabled(true);
          const t = this.PushBatch();
          t.InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;
        }
        CoplanarStartColorPass() {
          this.SetDepthEnabled(false);
          const t = this.PushBatch();
          t.InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;
        }
        IsCoplanarColorPass() {
          return 2 === this._coplanarMode;
        }
        CoplanarRestoreStandardRendering() {
          this.SetDepthEnabled(true);
          const t = this.PushBatch();
          t.InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;
        }
        StartQuery(t) {
          if (this.SupportsGPUProfiling()) {
            const e = this.PushBatch();
            e.InitStartQuery(t), this._topOfBatch = 0;
          }
        }
        EndQuery(t) {
          if (this.SupportsGPUProfiling()) {
            const e = this.PushBatch();
            e.InitEndQuery(t), this._topOfBatch = 0;
          }
        }
        _WaitForObjectReady(e) {
          const t = new Promise((t2) => pendingPolls.add({ resolve: t2, checkFunc: e }));
          return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2)), t;
        }
        GetEstimatedBackBufferMemoryUsage() {
          return this._width * this._height * (this._attribs["alpha"] ? 4 : 3);
        }
        GetEstimatedRenderBufferMemoryUsage() {
          let t = 0;
          for (const e of C33.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t += e.GetEstimatedMemoryUsage());
          return t;
        }
        GetEstimatedTextureMemoryUsage() {
          let t = 0;
          for (const e of C33.Gfx.WebGLRendererTexture.allTextures()) t += e.GetEstimatedMemoryUsage();
          return t;
        }
        GetWebGLVersionString() {
          return this._versionString;
        }
        GetWebGLVersionNumber() {
          return this._version;
        }
        GetDisplayName() {
          return "webgl" + this.GetWebGLVersionNumber();
        }
        SupportsNPOTTextures() {
          return 2 <= this.GetWebGLVersionNumber();
        }
        GetMaxTextureSize() {
          return this._maxTextureSize;
        }
        GetMinPointSize() {
          return this._minPointSize;
        }
        GetMaxPointSize() {
          return this._maxPointSize;
        }
        SupportsHighP() {
          return 0 !== this._highpPrecision;
        }
        GetHighPPrecision() {
          return this._highpPrecision;
        }
        GetUnmaskedVendor() {
          return this._unmaskedVendor;
        }
        GetUnmaskedRenderer() {
          return this._unmaskedRenderer;
        }
        GetWebGLExtensionsAnalyticsString() {
          if (2 <= this.GetWebGLVersionNumber()) return "webgl2";
          {
            const t = [];
            return this._fragDepthExt && t.push("EXT_frag_depth"), this._stdDerivativesExt && t.push("OES_standard_derivatives"), this._textureLodExt && t.push("EXT_shader_texture_lod"), 0 < t.length ? "webgl1:" + t.join(",") : "webgl1:none";
          }
        }
        GetExtensions() {
          return this._extensions;
        }
        SupportsGPUProfiling() {
          return !!this._timerExt;
        }
        _GetDisjointTimerQueryExtension() {
          return this._timerExt;
        }
        _GetParallelShaderCompileExtension() {
          return this._parallelShaderCompileExt;
        }
        _GetAnisotropicExtension() {
          return this._anisotropicExt;
        }
        _GetMaxAnisotropy() {
          return this._maxAnisotropy;
        }
        _AddQueryResultBuffer(t) {
          this._allQueryResultBuffers.add(t);
        }
        _RemoveQueryResultBuffer(t) {
          this._allQueryResultBuffers.delete(t);
        }
        _GetTimeQueryStack() {
          return this._timeQueryStack;
        }
        GetContext() {
          return this._gl;
        }
        _InitBlendModes(t) {
          this._InitBlendModeData([["normal", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["additive", t.ONE, t.ONE], ["xor", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["copy", t.ONE, t.ZERO], ["destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE], ["source-in", t.DST_ALPHA, t.ZERO], ["destination-in", t.ZERO, t.SRC_ALPHA], ["source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO], ["destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA], ["source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], ["destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]]);
        }
        CreateWebGLText() {
          return this.CreateRendererText();
        }
      };
    }
    var CheckPendingPolls;
    {
      const C33 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };
      C33.Gfx.EffectChainManager = class {
        constructor(e) {
          e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();
        }
        _AddEffectChain(e) {
          this._allEffectChains.add(e);
        }
        _RemoveEffectChain(e) {
          this._allEffectChains.delete(e);
        }
        OnContextLost() {
          this._webgpuBackTexture = null;
          for (const e of this._allEffectChains) e.OnContextLost();
        }
        GetDrawSize(e) {
          return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];
        }
        GetRenderTarget(e) {
          return this._cbGetRenderTarget(e);
        }
        ReleaseRenderTarget(e, t) {
          this._cbReleaseRenderTarget(e, t);
        }
        GetTime() {
          return this._cbGetTime();
        }
        Redraw(e) {
          this._cbRedraw(e);
        }
        _GetWebGPUBackTexture(e, t, r) {
          return t = Math.floor(t), r = Math.floor(r), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t && this._webgpuBackTexture.GetHeight() === r || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t, height: r, sampling: "nearest", mipMap: false })), this._webgpuBackTexture;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat42 = glMatrix.mat4, tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect), tempRect3 = C33.New(C33.Rect), tempRect4 = C33.New(C33.Rect), tempMat4a = mat42.create(), tempMat4b = mat42.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };
      C33.Gfx.EffectChain = class {
        constructor(e, t) {
          t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._manager = e, this._cbDrawContent = t.drawContent, this._cbGetSourceTextureInfo = t.getSourceTextureInfo, this._cbGetShaderParameters = t.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C33.New(C33.Rect), this._drawSurfaceRect = C33.New(C33.Rect), this._rcTexOriginal = C33.New(C33.Rect), this._rcTexBounce = C33.New(C33.Rect), this._rcTexDest = C33.New(C33.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._updateOwnProjection = false, this._projectionMatrix = mat42.create(), this._modelViewMatrix = mat42.create(), this._manager._AddEffectChain(this);
        }
        Release() {
          this._manager._RemoveEffectChain(this), C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;
        }
        OnContextLost() {
          this._needsRebuild = true, C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices);
        }
        NeedsRebuild() {
          return this._needsRebuild;
        }
        BuildSteps(i, e) {
          if (e = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, e), C33.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!e.isSourceTextureRotated, this._useFullSurface = !!e.useFullSurface, this._needsRebuild = false, C33.shallowAssignArray(this._shaderProgramList, i), 0 !== i.length) {
            if (e.indexMap) {
              if (e.indexMap.length !== i.length) throw new Error("incorrect indexMap length");
              C33.shallowAssignArray(this._shaderProgramIndices, e.indexMap);
            } else {
              C33.clearArray(this._shaderProgramIndices);
              for (let e2 = 0, t = i.length; e2 < t; ++e2) this._shaderProgramIndices.push(e2);
            }
            for (const t of i) this._boxExtendHorizontal += t.GetBoxExtendHorizontal(), this._boxExtendVertical += t.GetBoxExtendVertical(), t.IsAnimated() && (this._isAnyShaderAnimated = true), t.UsesDepth() && (this._isAnyShaderDepthSampling = true), t.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);
            this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(i[0].GetRenderer());
            const a = this._ShouldPreDraw(i[0], e), n = this._ShouldPostDraw(i.at(-1), e);
            if (1 !== i.length || a || n) {
              this._canUseFastPath = false;
              let s = 0;
              a && (this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), s = 1);
              for (let t = 0, r = i.length; t < r; ++t) if (0 !== t || a) {
                let e2 = 1 === s ? 2 : 1;
                t !== r - 1 || n || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C33.New(C33.Gfx.EffectChain.Step.Bounce, this, s, e2, t)), s = e2;
              } else this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t)), s = 1;
              n && this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PostDraw, this, s, 0));
            } else this._canUseFastPath = true;
          }
        }
        _ShouldPreDraw(e, t) {
          return !!(t.forcePreDraw || e.MustPreDraw() || t.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t.isRotatedOrNegativeSizeInstance || t.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t.isRotatedOrNegativeSizeInstance);
        }
        _ShouldPostDraw(e, t) {
          return !!t.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());
        }
        _ShouldUseCopyTextureBackgroundSampling(e) {
          return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;
        }
        Render(e, t, r) {
          e.IsWebGPU() && null === t && (t = e.GetBackbufferRenderTarget()), this._destRenderTarget = t, this._contentObject = r.contentObject || null, this._contextObject = r.contextObject || null, this._blendMode = r.blendMode || 0, this._devicePixelRatio = r.devicePixelRatio || 1, this._layerScale = r.layerScale || 1, this._layerAngle = r.layerAngle || 0, this._time = "number" == typeof r.time ? r.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();
          let s = false;
          if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r), s = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r);
          else if (s || this._CalculateDrawSizeAndRectangles(e, r), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
            e.SetAlphaBlend(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r.drawContentHook || null, this._compositOffX = r.compositOffX || 0, this._compositOffY = r.compositOffY || 0, this._updateOwnProjection = !!r.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t, this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            for (const i of this._steps) {
              const a = this._GetRenderTargetForId(i.GetSrcTargetId()), n = this._GetRenderTargetForId(i.GetDestTargetId());
              e.IsWebGPU() ? i.Run_WebGPU(e, a, n) : i.Run_WebGL(e, a, n);
            }
            e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;
          }
        }
        _CalculateDrawSizeAndRectangles(e, t) {
          const [r, s] = this._manager.GetDrawSize(e);
          this._SetDrawSize(e, r, s), this._CalculateRectangles(t);
        }
        _SetDrawSize(e, t, r) {
          if (t <= 0 || r <= 0) throw new Error("invalid draw size");
          this._drawWidth === t && this._drawHeight === r || this._CalculateDeviceTransformMatrices(e, t, r, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t, this._drawHeight = r;
        }
        _CalculateDeviceTransformMatrices(e, t, r, s, i, a, n) {
          const h = t / 2 + s, c = r / 2 + i, o = (e.CalculatePerspectiveMatrix(a, t / r), e.CalculateLookAtModelView2(h, c, e.GetDefaultCameraZ(r), h, c, 0, r));
          mat42.copy(n, o);
        }
        _CalculateRectangles(e) {
          this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
          const t = this._layerScale * this._devicePixelRatio;
          this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t, this._boxExtendVertical * t), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);
        }
        _OnBeforeStartEffectChain(e) {
          if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);
          else {
            if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {
              const t = this._layerScale * this._devicePixelRatio;
              tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * t, Math.max(this._boxExtendVertical, 1) * t), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);
            } else tempRect.roundOuter();
            e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);
          }
        }
        _OnAfterEffectChainDrawContent(e) {
          e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart && e.CoplanarRestoreStandardRendering(), e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);
        }
        _OnAfterEndEffectChain(e) {
          e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart && e.CoplanarStartColorPass(), e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();
        }
        _ClampRcTexDest() {
          this._rcTexDest.clamp(0, 0, 1, 1);
        }
        _GetRenderTargetForId(e) {
          return e < 0 ? null : this._renderTargets[e];
        }
        _GetRenderTarget() {
          return this._manager.GetRenderTarget(this);
        }
        _GetDestRenderTarget() {
          return this._destRenderTarget;
        }
        _ReleaseRenderTarget(e) {
          this._manager.ReleaseRenderTarget(e, this);
        }
        _GetShaderProgramAt(e) {
          return this._shaderProgramList[e];
        }
        _DrawContent(e) {
          this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);
        }
        _IsRenderTargetSameSizeAndOffset(e) {
          if (this._useFullSurface) return true;
          if (0 !== this._compositOffX || 0 !== this._compositOffY) return false;
          const [t, r] = e.GetRenderTargetSize(e.GetRenderTarget());
          return t === this._drawWidth && r === this._drawHeight;
        }
        _SetDeviceTransform(e, t) {
          let r = this._projectionMatrix, s = this._modelViewMatrix;
          if (t && !this._IsRenderTargetSameSizeAndOffset(e)) {
            r = tempMat4a, s = tempMat4b;
            const [i, a] = e.GetRenderTargetSize(e.GetRenderTarget());
            this._CalculateDeviceTransformMatrices(e, i, a, this._compositOffX, this._compositOffY, r, s), this._useFullSurface || e.RemoveScissorRect();
          }
          e.SetProjectionMatrix(r), e.SetModelViewMatrix(s);
        }
        _Redraw() {
          this._manager.Redraw(this);
        }
        _GetShaderParameters(e, t) {
          return this._cbGetShaderParameters(this._shaderProgramIndices[e], t);
        }
        _SetProgramParameters(e, t) {
          let r = this._rcTexDest, s = this._rcTexBounce, i = this._rcTexOriginal;
          e.IsWebGL() && (tempRect2.copy(r), tempRect2.flipAround(1), r = tempRect2, tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4), this._DoSetProgramParameters(e, t, s, i, r, 1 / this._drawWidth, 1 / this._drawHeight);
        }
        _SetFirstBounceProgramParameters(e, t) {
          let s = this._rcTexBounce, i = this._rcTexOriginal, a = 1 / this._drawWidth, n = 1 / this._drawHeight;
          if (this._cbGetSourceTextureInfo) {
            let { srcTexRect: e2, srcWidth: t2, srcHeight: r2 } = this._cbGetSourceTextureInfo(this._contentObject);
            e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t2 = t2 || this._drawWidth, r2 = r2 || this._drawHeight, s = e2, i = e2, a = 1 / t2, n = 1 / r2;
          } else e.IsWebGL() && (tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4);
          let r = this._rcTexDest;
          e.IsWebGL() && ((r = tempRect2).copy(this._rcTexDest), r.flipAround(1)), this._DoSetProgramParameters(e, t, s, i, r, a, n), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
        }
        _GetBackTex(e) {
          return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;
        }
        _DoSetProgramParameters(e, t, r, s, i, a, n) {
          e.SetProgramParameters(this._GetBackTex(e), i, r, s, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t, e));
        }
        _Render_FastPath(e, t) {
          const r = this._shaderProgramList[0], s = e.IsDepthEnabled(), i = r.UsesDepth();
          i && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget);
          let a = 0, n = 1;
          if (this._rcTexOriginal.set(0, 0, 1, 1), r.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
            const { srcTexRect: h, srcWidth: c, srcHeight: o } = this._cbGetSourceTextureInfo(this._contentObject);
            h && this._rcTexOriginal.copy(h), a = Number.isFinite(c) ? 1 / c : 0, n = Number.isFinite(o) ? 1 / o : 0;
          } else {
            const [d, _] = this._manager.GetDrawSize(e);
            a = 1 / d, n = 1 / _;
          }
          t.layoutRect ? this._layoutRect.copy(t.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s));
        }
        _UseCopyTextureBackgroundSampling() {
          return this._useCopyTextureBackgroundSampling;
        }
        _UseRenderTargetBackgroundSampling() {
          return !this._useCopyTextureBackgroundSampling;
        }
        IsAnyShaderBackgroundBlending() {
          return this._isAnyShaderBackgroundBlending;
        }
        CanSkipCalculatingDrawSurfaceRect() {
          return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();
        }
        UseFullSurface() {
          return this._useFullSurface;
        }
        GetContentObject() {
          return this._contentObject;
        }
        GetContextObject() {
          return this._contextObject;
        }
        _GetBlendMode() {
          return this._blendMode;
        }
        _UpdateOwnProjection() {
          return this._updateOwnProjection;
        }
        DidChangeTransform() {
          return this._didChangeTransform;
        }
        _GetDrawSurfaceRect() {
          return this._drawSurfaceRect;
        }
        _GetRcTexBounce() {
          return this._rcTexBounce;
        }
        _ShouldInvalidateRenderTargets() {
          return this._invalidateRenderTargets;
        }
        async DebugLogRenderTargetContents(e, t, r) {
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step = class {
        constructor(t, e, r, s = -1) {
          this._effectChain = t, this._srcTargetId = e, this._destTargetId = r, this._index = s;
        }
        GetEffectChain() {
          return this._effectChain;
        }
        GetSrcTargetId() {
          return this._srcTargetId;
        }
        GetDestTargetId() {
          return this._destTargetId;
        }
        GetIndex() {
          return this._index;
        }
        GetShaderProgram() {
          return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());
        }
        Run_WebGL(t, e, r) {
        }
        Run_WebGPU(t, e, r) {
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step.PreDraw = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, n, a) {
          super(e, t, n, a);
        }
        Run_WebGL(e, t, n) {
          const a = this.GetEffectChain();
          e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();
        }
        Run_WebGPU(e, t, n) {
          const a = this.GetEffectChain();
          e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, false), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);
      C33.Gfx.EffectChain.Step.PostDraw = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r, a) {
          super(e, t, r, a);
        }
        Run_WebGL(e, t, r) {
          const a = this.GetEffectChain();
          e.SetTextureFillMode(), e.SetRenderTarget(r), a._SetDeviceTransform(e, true), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
        }
        Run_WebGPU(e, t, r) {
          const a = this.GetEffectChain();
          e.SetTextureFillMode(), e.SetRenderTarget(r, false), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Gfx.EffectChain.Step.FirstBounce = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r, a) {
          super(e, t, r, a);
        }
        Run_WebGL(e, t, r) {
          const a = this.GetEffectChain();
          e.SetRenderTarget(r, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();
        }
        Run_WebGPU(e, t, r) {
          const a = this.GetEffectChain();
          e.SetRenderTarget(r, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);
      C33.Gfx.EffectChain.Step.Bounce = class extends C33.Gfx.EffectChain.Step {
        constructor(e, t, r, a) {
          super(e, t, r, a);
        }
        Run_WebGL(e, t, r) {
          const a = this.GetEffectChain(), d = (e.SetRenderTarget(r), 0 === this.GetDestTargetId());
          d ? e.SetBlendMode(a._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a._SetDeviceTransform(e, d), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);
        }
        Run_WebGPU(e, t, r) {
          const a = this.GetEffectChain(), d = (e.SetRenderTarget(r, false), 0 === this.GetDestTargetId());
          d ? (e.SetBlendMode(a._GetBlendMode()), e.SetBackTexture(null), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());
        }
      };
    }
    {
      let SortZOrderList2 = function(e, t) {
        const r = e[0], n = t[0], i = r - n;
        if (0 != i) return i;
        const o = e[1], a = t[1];
        return o - a;
      };
      SortZOrderList = SortZOrderList2;
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      const keysDownByKey = /* @__PURE__ */ new Set();
      const tempZOrderList = [], tempInstances = [];
      let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false;
      const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
      self.IRuntime = class {
        constructor(e) {
          runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, isPixelRoundingEnabled: { value: runtime.IsPixelRoundingEnabled(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener("keydown", (e2) => {
            keysDownByKey.has(e2["key"]) ? e2.stopPropagation() : keysDownByKey.add(e2["key"]);
          }), runtime.UserScriptDispatcher().addEventListener("keyup", (e2) => keysDownByKey.delete(e2["key"])), runtime.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear()), runtime.IsInWorker() && (self["alert"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), this.alert(e2)));
        }
        _InitObjects(e) {
          Object.defineProperties(this.objects, e);
        }
        _InitGlobalVars(e) {
          Object.defineProperties(this.globalVars, e);
        }
        addEventListener(e, t) {
          runtime.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          runtime.UserScriptDispatcher().removeEventListener(e, t);
        }
        callFunction(e, ...t) {
          C3X.RequireString(e);
          const r = runtime.GetEventSheetManager(), n = r.GetFunctionBlockByName(e);
          if (!n) throw new Error(`cannot find function name '${e}'`);
          if (!n.IsEnabled()) return n.GetDefaultReturnValue();
          if (t.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t.length} passed, ${n.GetFunctionParameterCount()} expected)`);
          const i = n.GetEventBlock();
          let o = i.GetSolModifiersIncludingParents();
          const a = r.GetCurrentEvent();
          if (a) {
            o = o.slice(0);
            const u = new Set(o);
            for (const l of a.GetSolModifiersIncludingParents()) u.has(l) || (o.push(l), u.add(l));
            for (const m of r.GetDynamicSolModifiersSet()) u.has(m) || (o.push(m), u.add(m));
          }
          const s = i.RunAsExpressionFunctionCall(o, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t);
          return s;
        }
        setReturnValue(e) {
          const t = runtime.GetEventStack().GetCurrentExpFuncStackFrame();
          if (!t) throw new Error("not in a function which returns a value");
          switch (t.GetFunctionReturnType()) {
            case 1:
              "number" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 2:
              "string" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 3:
              "number" != typeof e && "string" != typeof e || t.SetFunctionReturnValue(e);
          }
        }
        signal(e) {
          C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);
        }
        waitForSignal(e) {
          return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);
        }
        getViewportSize() {
          return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];
        }
        get isSuspended() {
          return runtime.IsSuspended();
        }
        get dt() {
          return runtime.GetDt();
        }
        get dtRaw() {
          return runtime.GetDtRaw();
        }
        get gameTime() {
          return runtime.GetGameTime();
        }
        get wallTime() {
          return runtime.GetWallTime();
        }
        get timeScale() {
          return runtime.GetTimeScale();
        }
        set timeScale(e) {
          C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);
        }
        get fps() {
          return didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();
        }
        get framesPerSecond() {
          return runtime.GetFramesPerSecond();
        }
        get ticksPerSecond() {
          return runtime.GetTicksPerSecond();
        }
        get cpuUtilisation() {
          return runtime.GetMainThreadTime();
        }
        get gpuUtilisation() {
          return runtime.GetGPUUtilisation();
        }
        get framerateMode() {
          return runtime.GetFramerateMode();
        }
        set framerateMode(e) {
          if (!VALID_FRAMERATE_MODES.has(e)) throw new Error("invalid framerate mode");
          runtime._SetFramerateMode(e);
        }
        get minDt() {
          return runtime.GetMinDt();
        }
        set minDt(e) {
          C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);
        }
        get maxDt() {
          return runtime.GetMaxDt();
        }
        set maxDt(e) {
          runtime.SetMaxDt(e);
        }
        random() {
          return runtime.Random();
        }
        get layout() {
          const e = runtime.GetMainRunningLayout();
          if (e) return e.GetILayout();
          throw new Error("no layout is running - make sure a layout is loaded before accessing");
        }
        getLayout(e) {
          const t = runtime.GetLayoutManager();
          let r = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          if (r = t.GetLayout(e)) return r.GetILayout();
          throw new Error("invalid layout");
        }
        getAllLayouts() {
          return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());
        }
        goToLayout(e) {
          const t = runtime.GetLayoutManager();
          let r = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          if (!(r = t.GetLayout(e))) throw new Error("invalid layout");
          t.IsPendingChangeMainLayout() || t.ChangeMainLayout(r);
        }
        get keyboard() {
          const e = runtime._GetCommonScriptInterfaces().keyboard;
          if (e) return e;
          throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
        }
        get mouse() {
          const e = runtime._GetCommonScriptInterfaces().mouse;
          if (e) return e;
          throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
        }
        get touch() {
          const e = runtime._GetCommonScriptInterfaces().touch;
          if (e) return e;
          throw new Error("runtime.touch used but Touch object missing - add it to your project first");
        }
        get timelineController() {
          const e = runtime._GetCommonScriptInterfaces().timelineController;
          if (e) return e;
          throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
        }
        invokeDownload(e, t) {
          C3X.RequireString(e), C3X.RequireString(t), runtime.InvokeDownload(e, t);
        }
        getInstanceByUid(e) {
          C3X.RequireFiniteNumber(e);
          const t = runtime.GetInstanceByUID(e);
          return t ? t.GetInterfaceClass() : null;
        }
        sortZOrder(e, n) {
          C3X.RequireFunction(n);
          const i = runtime.GetCurrentLayout();
          for (const t of e) {
            const r = runtime._UnwrapIWorldInstance(t), o = r.GetWorldInfo();
            tempZOrderList.push([o.GetLayer().GetIndex(), o.GetZIndex()]), tempInstances.push(r);
          }
          if (0 !== tempZOrderList.length) {
            tempZOrderList.sort(SortZOrderList2), tempInstances.sort((e2, t) => n(e2.GetInterfaceClass(), t.GetInterfaceClass()));
            let r = false;
            for (let e2 = 0, t = tempZOrderList.length; e2 < t; ++e2) {
              const a = tempInstances[e2], s = i.GetLayerByIndex(tempZOrderList[e2][0]), u = tempZOrderList[e2][1], l = s._GetInstances();
              l[u] !== a && ((l[u] = a).GetWorldInfo()._SetLayer(s, true), s.SetZIndicesChanged(a), r = true);
            }
            r && runtime.UpdateRender(), C33.clearArray(tempZOrderList), C33.clearArray(tempInstances);
          }
        }
        async createWorker(e, t) {
          const r = new MessageChannel(), n = r.port1, i = r.port2;
          return await runtime.PostComponentMessageToDOMAsync("runtime", "script-create-worker", { "url": e, "opts": t, "port2": i }, [i]), n;
        }
        alert(e) {
          return runtime.PostComponentMessageToDOMAsync("runtime", "alert", { "message": e + (runtime.IsInWorker() ? " [via Web Worker]" : "") });
        }
        getHTMLLayer(e) {
          return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);
        }
        addLoadPromise(e) {
          runtime.AddLoadPromise(e);
        }
      };
    }
    var SortZOrderList;
    {
      const C33 = self.C3, C3X = self.C3X;
      let assetManager = null;
      self.IAssetManager = class {
        constructor(e) {
          assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: assetManager.IsAudioFormatSupported("audio/webm; codecs=opus"), writable: false } });
        }
        loadImageAsset(e) {
          const t = self.IImageInfo._Unwrap(e);
          if (!t) throw new Error("invalid IImageInfo");
          t.LoadAsset(assetManager.GetRuntime());
        }
        fetchText(e) {
          return assetManager.FetchText(e);
        }
        fetchJson(e) {
          return assetManager.FetchJson(e);
        }
        fetchBlob(e) {
          return assetManager.FetchBlob(e);
        }
        fetchArrayBuffer(e) {
          return assetManager.FetchArrayBuffer(e);
        }
        getProjectFileUrl(e) {
          return assetManager.GetProjectFileUrl(e);
        }
        getMediaFileUrl(e) {
          return "flat" === assetManager.GetFileStructure() && C33.IsRelativeURL(e) && (e = e.toLowerCase()), assetManager.GetMediaFileUrl(e);
        }
        get mediaFolder() {
          return assetManager.GetMediaSubfolder();
        }
        async decodeWebMOpus(e, t) {
          if (this.isWebMOpusSupported) throw new Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
          const a = await assetManager.GetRuntime()._WasmDecodeWebMOpus(t), r = new Float32Array(a), s = e["createBuffer"](1, r.length, 48e3), n = s["getChannelData"](0);
          return n.set(r), s;
        }
        loadScripts(...e) {
          return assetManager.LoadScripts(...e);
        }
        compileWebAssembly(e) {
          return assetManager.CompileWebAssembly(e);
        }
        loadStyleSheet(e) {
          return assetManager.LoadStyleSheet(e);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let collisionEngine = null;
      self.ICollisionEngine = class {
        constructor(n) {
          collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });
        }
        testOverlap(n, e) {
          const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n), t = l._UnwrapIWorldInstance(e);
          return collisionEngine.TestOverlap(i, t);
        }
        testOverlapAny(n, e) {
          const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n);
          for (const t of e) {
            const o = l._UnwrapIWorldInstance(t);
            if (collisionEngine.TestOverlap(i, o)) return t;
          }
          return null;
        }
        testOverlapSolid(n) {
          const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l = collisionEngine.TestOverlapSolid(e);
          return l ? l.GetInterfaceClass() : null;
        }
        setCollisionCellSize(n, e) {
          if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error("invalid cell size");
          collisionEngine.SetCollisionCellSize(n, e);
        }
        getCollisionCellSize() {
          return collisionEngine.GetCollisionCellSize();
        }
        getCollisionCandidates(n, e) {
          const l = collisionEngine.GetRuntime();
          let i;
          i = Array.isArray(n) ? n.map((n2) => l._UnwrapIObjectClass(n2)) : [l._UnwrapIObjectClass(n)];
          const t = C33.Rect.FromObject(e), o = [];
          return collisionEngine.GetObjectClassesCollisionCandidates(null, i, t, o), o.map((n2) => n2.GetInterfaceClass());
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      const osMap = /* @__PURE__ */ new Map([["Windows", "windows"], ["macOS", "macos"], ["Linux", "linux"], ["Chrome OS", "chrome-os"], ["Android", "android"], ["iOS", "ios"]]), browserMap = /* @__PURE__ */ new Map([["Chrome", "chrome"], ["Chromium", "chromium"], ["Edge", "edge"], ["Opera", "opera"], ["NW.js", "nwjs"], ["Firefox", "firefox"], ["Safari", "safari"]]), browserEngineMap = /* @__PURE__ */ new Map([["Chromium", "chromium"], ["Gecko", "gecko"], ["WebKit", "webkit"]]);
      self.IPlatformInfo = class {
        constructor(e) {
          runtime = e, Object.defineProperties(this, { isMobile: { value: C33.Platform.IsMobile, writable: false }, os: { value: osMap.get(C33.Platform.OS) || "unknown", writable: false }, osVersion: { value: C33.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C33.Platform.Browser) || "unknown", writable: false }, browserVersion: { value: C33.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C33.Platform.BrowserEngine) || "unknown", writable: false } });
        }
        get exportType() {
          let e = runtime.GetExportType();
          return runtime.IsNWjs() ? e = "nwjs" : runtime.IsWindowsWebView2() ? e = "windows-webview2" : "cordova" === e ? e = "Android" === C33.Platform.OS ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== e && "playable-ad-zip" !== e || (e = "playable-ad"), e;
        }
        get renderer() {
          return runtime.GetCanvasManager().GetRendererString();
        }
        get rendererDetail() {
          return runtime.GetCanvasManager().GetRendererDetailString();
        }
        get canvasCssWidth() {
          return runtime.GetCanvasManager().GetCssWidth();
        }
        get canvasCssHeight() {
          return runtime.GetCanvasManager().GetCssHeight();
        }
        get canvasDeviceWidth() {
          return runtime.GetCanvasManager().GetDeviceWidth();
        }
        get canvasDeviceHeight() {
          return runtime.GetCanvasManager().GetDeviceHeight();
        }
        get devicePixelRatio() {
          return runtime.GetDevicePixelRatio();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IStorage = class {
        constructor(e) {
          this._storage = e._GetProjectStorage();
        }
        getItem(e) {
          return C3X.RequireString(e), this._storage.getItem(e);
        }
        setItem(e, t) {
          return C3X.RequireString(e), this._storage.setItem(e, t);
        }
        removeItem(e) {
          return C3X.RequireString(e), this._storage.removeItem(e);
        }
        clear() {
          return this._storage.clear();
        }
        keys() {
          return this._storage.keys();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IPlugin = class {
        #private;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#private = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } });
        }
        static getByConstructor(e) {
          if (!e) return null;
          const t = C33.AddonManager.GetPluginByConstructorFunction(e);
          return t ? t.GetIPlugin() : null;
        }
        getSingleGlobalObjectType() {
          return this.#private.GetSingleGlobalObjectClass().GetIObjectClass();
        }
        getSingleGlobalInstance() {
          return this.#private.GetSingleGlobalInstance().GetInterfaceClass();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IObjectClass = class {
        #private;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken);
          this.#private = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
        }
        addEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#private.UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), this.#private.UserScriptDispatcher().removeEventListener(e, t);
        }
        getAllInstances() {
          return [...this.instances()];
        }
        getFirstInstance() {
          return C33.first(this.instances());
        }
        getPickedInstances() {
          return [...this.pickedInstances()];
        }
        getFirstPickedInstance() {
          return C33.first(this.pickedInstances());
        }
        getPairedInstance(e) {
          const t = this.#private, n = t.GetRuntime()._UnwrapIInstance(e), s = t.GetPairedInstance(n);
          return s ? s.GetInterfaceClass() : null;
        }
        *instances() {
          for (const e of this.#private.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();
        }
        *pickedInstances() {
          for (const e of this.#private.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();
        }
        setInstanceClass(e) {
          C3X.RequireFunction(e);
          const t = this.#private;
          if (0 < t.GetInstanceCount()) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
          t._SetUserScriptInstanceClass(e);
        }
        createInstance(e, t, n, s, r) {
          if (C3X.RequireNumber(t), C3X.RequireNumber(n), "number" != typeof e && "string" != typeof e) throw new TypeError("invalid layer parameter");
          const i = this.#private, a = i.GetRuntime(), c = a.GetMainRunningLayout().GetLayer(e);
          if (!c) throw new Error("invalid layer");
          const l = a.CreateInstance(i, c, t, n, s, r), u = (s && c.SortAndAddInstancesByZIndex(l), a.GetEventSheetManager());
          return u.BlockFlushingInstances(true), l._TriggerOnCreatedOnSelfAndRelated(), u.BlockFlushingInstances(false), u.IsInEventEngine() || a.GetLayoutManager().IsEndingLayout() || a.FlushPendingInstances(), l.GetInterfaceClass();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
      self.ILayout = class {
        constructor(e) {
          map.set(this, e);
          const t = [], r = e.GetEffectList(), i = r.GetAllEffectTypes().length;
          for (let e2 = 0; e2 < i; ++e2) t.push(new self.IEffectInstance(r, e2));
          Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t, writable: false } });
        }
        addEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().addEventListener(e, t);
        }
        removeEventListener(e, t) {
          C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().removeEventListener(e, t);
        }
        get width() {
          return map.get(this).GetWidth();
        }
        set width(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetWidth(e);
        }
        get height() {
          return map.get(this).GetHeight();
        }
        set height(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetHeight(e);
        }
        setSize(e, t) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t);
          const r = map.get(this);
          r.SetWidth(e), r.SetHeight(t);
        }
        getSize() {
          const e = map.get(this);
          return [e.GetWidth(), e.GetHeight()];
        }
        set scale(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetScale(e);
        }
        get scale() {
          return map.get(this).GetScale();
        }
        set angle(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);
        }
        get angle() {
          return map.get(this).GetAngle();
        }
        set scrollX(e) {
          C3X.RequireNumber(e), map.get(this).SetScrollX(e);
        }
        get scrollX() {
          return map.get(this).GetScrollX();
        }
        set scrollY(e) {
          C3X.RequireNumber(e), map.get(this).SetScrollY(e);
        }
        get scrollY() {
          return map.get(this).GetScrollY();
        }
        scrollTo(e, t) {
          C3X.RequireNumber(e), C3X.RequireNumber(t);
          const r = map.get(this);
          r.SetScrollX(e), r.SetScrollY(t);
        }
        getScrollPosition() {
          const e = map.get(this);
          return [e.GetScrollX(), e.GetScrollY()];
        }
        getLayer(e) {
          const t = map.get(this);
          let r = null;
          if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
          return (r = t.GetLayer(e)) ? r.GetILayer() : null;
        }
        getAllLayers() {
          return map.get(this).GetLayers().map((e) => e.GetILayer());
        }
        *allLayers() {
          for (const e of map.get(this).allLayers()) yield e.GetILayer();
        }
        addLayer(e, t, r) {
          const i = map.get(this), n = self.ILayer, a = (C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t, n), t ? i.GetRuntime()._UnwrapScriptInterface(t) : null), s = VALID_WHERE_STRINGS.indexOf(r);
          if (s < 0) throw new Error("invalid location");
          i.AddLayer(e, a, s);
        }
        moveLayer(e, t, r) {
          const i = map.get(this), n = i.GetRuntime(), a = self.ILayer, s = (C3X.RequireInstanceOf(e, a), n._UnwrapScriptInterface(e));
          if (!s) throw new Error("invalid layer");
          C3X.RequireOptionalInstanceOf(t, a);
          const o = t ? n._UnwrapScriptInterface(t) : null, l = VALID_WHERE_STRINGS.indexOf(r);
          if (l < 0) throw new Error("invalid location");
          i.MoveLayer(s, o, l);
        }
        removeLayer(e) {
          const t = map.get(this), r = self.ILayer, i = (C3X.RequireInstanceOf(e, r), t.GetRuntime()._UnwrapScriptInterface(e));
          if (!i) throw new Error("invalid layer");
          const n = i.GetRuntime();
          t.RemoveLayer(i), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();
        }
        removeAllDynamicLayers() {
          const e = map.get(this), t = e.GetRuntime();
          e.RemoveAllDynamicLayers(), t.GetEventSheetManager().IsInEventEngine() || t.FlushPendingInstances();
        }
        setVanishingPoint(e, t) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t), map.get(this).SetVanishingPointXY(e, t);
        }
        getVanishingPoint() {
          return map.get(this)._GetVanishingPoint();
        }
        set projection(e) {
          C3X.RequireString(e);
          const t = map.get(this);
          if ("perspective" === e) t.SetPerspectiveProjection();
          else {
            if ("orthographic" !== e) throw new Error("invalid projection");
            t.SetOrthographicProjection();
          }
        }
        get projection() {
          return map.get(this).IsOrthographicProjection() ? "orthographic" : "perspective";
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C33.New(C33.Color);
      self.ILayer = class {
        constructor(e) {
          map.set(this, e);
          const t = [], r = e.GetEffectList(), a = r.GetAllEffectTypes().length;
          for (let e2 = 0; e2 < a; ++e2) t.push(new self.IEffectInstance(r, e2));
          Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
        }
        get parentLayer() {
          const e = map.get(this).GetParentLayer();
          return e ? e.GetILayer() : null;
        }
        *parentLayers() {
          for (const e of map.get(this).parentLayers()) yield e.GetILayer();
        }
        *subLayers() {
          for (const e of map.get(this).GetSubLayers()) yield e.GetILayer();
        }
        *allSubLayers() {
          for (const e of map.get(this).GetSubLayers()) for (const t of e.selfAndAllSubLayers()) yield t.GetILayer();
        }
        get index() {
          return map.get(this).GetIndex();
        }
        get isVisible() {
          return map.get(this)._IsVisibleFlagSet();
        }
        set isVisible(e) {
          map.get(this).SetVisible(e);
        }
        get isSelfAndParentsVisible() {
          return map.get(this).IsVisible();
        }
        get isInteractive() {
          return map.get(this).IsInteractive();
        }
        set isInteractive(e) {
          map.get(this).SetInteractive(e);
        }
        get isHTMLElementsLayer() {
          return map.get(this).IsHTMLElementsLayer();
        }
        set isHTMLElementsLayer(e) {
          map.get(this).SetIsHTMLElementsLayer(!!e);
        }
        get isSelfAndParentsInteractive() {
          return map.get(this).IsSelfAndParentsInteractive();
        }
        get opacity() {
          return map.get(this).GetOpacity();
        }
        set opacity(e) {
          e = C33.clamp(+e, 0, 1), isNaN(e) || map.get(this).SetOpacity(e);
        }
        set scale(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetOwnScale(e);
        }
        get scale() {
          return map.get(this).GetOwnScale();
        }
        set scaleRate(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetScaleRate(e);
        }
        get scaleRate() {
          return map.get(this).GetScaleRate();
        }
        set angle(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);
        }
        get angle() {
          return map.get(this).GetOwnAngle();
        }
        set parallaxX(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetParallaxX(e);
        }
        get parallaxX() {
          return map.get(this).GetParallaxX();
        }
        set parallaxY(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetParallaxY(e);
        }
        get parallaxY() {
          return map.get(this).GetParallaxY();
        }
        set zElevation(e) {
          C3X.RequireFiniteNumber(e), map.get(this).SetZElevation(e);
        }
        get zElevation() {
          return map.get(this).GetZElevation();
        }
        set isTransparent(e) {
          map.get(this).SetTransparent(e);
        }
        get isTransparent() {
          return map.get(this).IsTransparent();
        }
        set isForceOwnTexture(e) {
          map.get(this).SetForceOwnTexture(e);
        }
        get isForceOwnTexture() {
          return map.get(this).IsForceOwnTexture();
        }
        set blendMode(e) {
          C3X.RequireString(e);
          const t = BLEND_MODE_TO_INDEX.get(e);
          if ("number" != typeof t) throw new Error("invalid blend mode");
          map.get(this).SetBlendMode(t);
        }
        get blendMode() {
          return INDEX_TO_BLEND_MODE.get(map.get(this).GetBlendMode());
        }
        set backgroundColor(e) {
          if (C3X.RequireArray(e), e.length < 3) throw new Error("expected 3 elements");
          tempColor.setRgb(e[0], e[1], e[2]);
          const t = map.get(this), r = t.GetBackgroundColor();
          r.equalsIgnoringAlpha(tempColor) || (r.copyRgb(tempColor), t.GetRuntime().UpdateRender());
        }
        get backgroundColor() {
          const e = map.get(this).GetBackgroundColor();
          return [e.getR(), e.getG(), e.getB()];
        }
        set scrollX(e) {
          C3X.RequireNumber(e);
          const t = map.get(this);
          t.SetOwnScrollPositionEnabled(true), t.SetScrollX(e);
        }
        get scrollX() {
          return map.get(this).GetScrollX();
        }
        set scrollY(e) {
          C3X.RequireNumber(e);
          const t = map.get(this);
          t.SetOwnScrollPositionEnabled(true), t.SetScrollY(e);
        }
        get scrollY() {
          return map.get(this).GetScrollY();
        }
        scrollTo(e, t) {
          C3X.RequireNumber(e), C3X.RequireNumber(t);
          const r = map.get(this);
          r.SetOwnScrollPositionEnabled(true), r.SetScrollX(e), r.SetScrollY(t);
        }
        getScrollPosition() {
          const e = map.get(this);
          return [e.GetScrollX(), e.GetScrollY()];
        }
        restoreScrollPosition() {
          map.get(this).SetOwnScrollPositionEnabled(false);
        }
        getViewport() {
          return map.get(this).GetViewport().toDOMRect();
        }
        cssPxToLayer(e, t, r = 0) {
          C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);
          const a = map.get(this), s = a.GetRuntime();
          return a.CanvasCssToLayer(e - s.GetCanvasClientX(), t - s.GetCanvasClientY(), r);
        }
        layerToCssPx(e, t, r = 0) {
          C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);
          const a = map.get(this), s = a.GetRuntime(), [i, n] = a.LayerToCanvasCss(e, t, r);
          return [i + s.GetCanvasClientX(), n + s.GetCanvasClientY()];
        }
        drawSurfaceToLayer(e, t, r = 0) {
          return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).DrawSurfaceToLayer(e, t, r);
        }
        layerToDrawSurface(e, t, r = 0) {
          return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).LayerToDrawSurface(e, t, r);
        }
        get renderScale() {
          return map.get(this).GetRenderScale();
        }
      };
    }
    {
      let GetDispatcher2 = function(e) {
        let t = dispatchers.get(e);
        return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t)), t;
      };
      GetDispatcher = GetDispatcher2;
      const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.IInstance = class {
        #private;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: (this.#private = e).GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };
          e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
        }
        static _GetInitInst() {
          return C33.AddonManager._GetInitObject();
        }
        _release() {
          const e = dispatchers.get(this);
          e && (e.Release(), dispatchers.delete(this));
        }
        addEventListener(e, t, i) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).addEventListener(e, t, i);
        }
        removeEventListener(e, t, i) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).removeEventListener(e, t, i);
        }
        dispatchEvent(e) {
          GetDispatcher2(this).dispatchEvent(e);
        }
        destroy() {
          const e = this.#private, t = e.GetRuntime();
          t.DestroyInstance(e), t.GetEventSheetManager().IsInEventEngine() || t.GetLayoutManager().IsEndingLayout() || t.GetEventSheetManager().IsFlushingBlocked() || t.FlushPendingInstances();
        }
        getOtherContainerInstances() {
          const e = this.#private.GetSiblings();
          return e ? e.map((e2) => e2.GetInterfaceClass()) : [];
        }
        *otherContainerInstances() {
          const e = this.#private;
          if (e.IsInContainer()) for (const t of e.siblings()) yield t.GetInterfaceClass();
        }
        get uid() {
          return this.#private.GetUID();
        }
        get templateName() {
          return this.#private.GetTemplateName();
        }
        set timeScale(e) {
          C3X.RequireFiniteNumber(e), this.#private.SetTimeScale(e);
        }
        get timeScale() {
          return this.#private.GetActiveTimeScale();
        }
        restoreTimeScale() {
          this.#private.RestoreTimeScale();
        }
        get dt() {
          const e = this.#private;
          return e.GetRuntime().GetDt(e);
        }
        hasTags(...e) {
          C3X.RequireArray(e);
          const t = new Set(e), i = this.#private.GetTagsSet();
          return t.isSubsetOf(i);
        }
        setAllTags(e) {
          C3X.RequireInstanceOf(e, Set), this.#private.SetTagsSet(e);
        }
        getAllTags() {
          return new Set(this.#private.GetTagsSet());
        }
        signal(e) {
          C3X.RequireString(e);
          const t = this.#private;
          t.GetRuntime().GetEventSheetManager().InstanceSignal(t, e);
        }
        waitForSignal(e) {
          C3X.RequireString(e);
          const t = this.#private;
          return t.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t, e);
        }
      };
    }
    var GetDispatcher;
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.ISDKInstanceBase = class extends self.IInstance {
        #private;
        #isTicking = false;
        #tickFunc = null;
        #isTicking2 = false;
        #tickFunc2 = null;
        #domComponentId;
        #wrapperComponentId;
        constructor(e) {
          super(), this.#private = C33.AddonManager._GetInitObject2(internalApiToken), this.#isTicking = false, this.#tickFunc = null, this.#isTicking2 = false, this.#tickFunc2 = null, this.#domComponentId = e?.domComponentId, this.#wrapperComponentId = e?.wrapperComponentId;
        }
        _release() {
          this._setTicking(false), this._setTicking2(false), super._release();
        }
        _getInitProperties() {
          return C33.AddonManager._GetInitProperties();
        }
        _trigger(e) {
          const t = this.#private;
          t.GetRuntime().Trigger(e, t);
        }
        _triggerAsync(e) {
          const t = this.#private;
          return t.GetRuntime().TriggerAsync(e, t);
        }
        _addDOMMessageHandler(e, t) {
          if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#domComponentId) throw new Error("no DOM component id set");
          const n = this.#private.GetRuntime();
          n.AddDOMComponentMessageHandler(this.#domComponentId, e, t);
        }
        _addDOMMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [t, n] of e) this._addDOMMessageHandler(t, n);
        }
        _postToDOM(e, t) {
          if (C3X.RequireString(e), !this.#domComponentId) throw new Error("no DOM component id set");
          const n = this.#private.GetRuntime();
          n.PostComponentMessageToDOM(this.#domComponentId, e, t);
        }
        _postToDOMAsync(e, t) {
          if (C3X.RequireString(e), !this.#domComponentId) throw new Error("no DOM component id set");
          const n = this.#private.GetRuntime();
          return n.PostComponentMessageToDOMAsync(this.#domComponentId, e, t);
        }
        _postToDOMMaybeSync(e, t) {
          const n = this.#private.GetRuntime();
          if (!n.IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this.#domComponentId, "handler": e, "data": t, "responseId": null });
          this._postToDOM(e, t);
        }
        _setTicking(e) {
          if (this.#isTicking !== (e = !!e)) {
            this.#isTicking = e;
            const t = this.#private.GetRuntime();
            e ? (this.#tickFunc || (this.#tickFunc = () => this._tick()), t.Dispatcher().addEventListener("tick", this.#tickFunc)) : t.Dispatcher().removeEventListener("tick", this.#tickFunc);
          }
        }
        _isTicking() {
          return this.#isTicking;
        }
        _tick() {
        }
        _setTicking2(e) {
          if (this.#isTicking2 !== (e = !!e)) {
            this.#isTicking2 = e;
            const t = this.#private.GetRuntime();
            e ? (this.#tickFunc2 || (this.#tickFunc2 = () => this._tick2()), t.Dispatcher().addEventListener("tick2", this.#tickFunc2)) : t.Dispatcher().removeEventListener("tick2", this.#tickFunc2);
          }
        }
        _isTicking2() {
          return this.#isTicking2;
        }
        _tick2() {
        }
        _getDebuggerProperties() {
          return [];
        }
        _saveToJson() {
          return null;
        }
        _loadFromJson(e) {
        }
        _isWrapperExtensionAvailable() {
          if (!this.#wrapperComponentId) throw new Error("no wrapper component id set");
          const e = this.#private.GetRuntime();
          return e.HasWrapperComponentId(this.#wrapperComponentId);
        }
        _addWrapperExtensionMessageHandler(e, t) {
          if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#wrapperComponentId) throw new Error("no wrapper component id set");
          const n = this.#private.GetRuntime();
          n.AddWrapperExtensionMessageHandler(this.#wrapperComponentId, e, t);
        }
        _addWrapperMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [t, n] of e) this._addWrapperExtensionMessageHandler(t, n);
        }
        _sendWrapperExtensionMessage(e, t) {
          if (!this.#wrapperComponentId) throw new Error("no wrapper component id set");
          this.runtime.sdk.sendWrapperExtensionMessage(this.#wrapperComponentId, e, t);
        }
        _sendWrapperExtensionMessageAsync(e, t) {
          if (this.#wrapperComponentId) return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#wrapperComponentId, e, t);
          throw new Error("no wrapper component id set");
        }
      };
    }
    {
      let MakeIWorldInstanceClass2 = function(e) {
        return class r extends e {
          #privateInst;
          #privateWi;
          constructor(e2) {
            super(e2);
            const t = C33.AddonManager._GetInitObject2(internalApiToken), i = t.GetWorldInfo(), n = (this.#privateInst = t, this.#privateWi = i, map.set(this, t), []), r2 = i.GetInstanceEffectList();
            if (r2) {
              const a = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
              for (let e3 = 0; e3 < a; ++e3) n.push(new self.IEffectInstance(r2, e3));
            }
            const s = { effects: { value: n, writable: false } };
            Object.defineProperties(this, s);
          }
          get layout() {
            return this.#privateWi.GetLayout().GetILayout();
          }
          get layer() {
            return this.#privateWi.GetLayer().GetILayer();
          }
          get x() {
            return this.#privateWi.GetX();
          }
          set x(e2) {
            e2 = +e2;
            const t = this.#privateWi;
            isNaN(e2) || t.GetX() === e2 || (t.SetX(e2), t.SetBboxChanged());
          }
          get y() {
            return this.#privateWi.GetY();
          }
          set y(e2) {
            e2 = +e2;
            const t = this.#privateWi;
            isNaN(e2) || t.GetY() === e2 || (t.SetY(e2), t.SetBboxChanged());
          }
          setPosition(e2, t) {
            e2 = +e2, t = +t;
            const i = this.#privateWi;
            isNaN(e2) || isNaN(t) || i.GetX() === e2 && i.GetY() === t || (i.SetXY(e2, t), i.SetBboxChanged());
          }
          getPosition() {
            const e2 = this.#privateWi;
            return [e2.GetX(), e2.GetY()];
          }
          offsetPosition(e2, t) {
            if (e2 = +e2, t = +t, !(isNaN(e2) || isNaN(t) || 0 === e2 && 0 === t)) {
              const i = this.#privateWi;
              i.OffsetXY(e2, t), i.SetBboxChanged();
            }
          }
          get zElevation() {
            return this.#privateWi.GetZElevation();
          }
          set zElevation(e2) {
            e2 = +e2;
            const t = this.#privateInst, i = this.#privateWi;
            isNaN(e2) || i.GetZElevation() === e2 || (i.SetZElevation(e2), t.GetRuntime().UpdateRender());
          }
          get totalZElevation() {
            return this.#privateWi.GetTotalZElevation();
          }
          get width() {
            return this.#privateWi.GetWidth();
          }
          set width(e2) {
            e2 = +e2;
            const t = this.#privateWi;
            isNaN(e2) || t.GetWidth() === e2 || (t.SetWidth(e2), t.SetBboxChanged());
          }
          get height() {
            return this.#privateWi.GetHeight();
          }
          set height(e2) {
            e2 = +e2;
            const t = this.#privateWi;
            isNaN(e2) || t.GetHeight() === e2 || (t.SetHeight(e2), t.SetBboxChanged());
          }
          setSize(e2, t) {
            e2 = +e2, t = +t;
            const i = this.#privateWi;
            isNaN(e2) || isNaN(t) || i.GetWidth() === e2 && i.GetHeight() === t || (i.SetSize(e2, t), i.SetBboxChanged());
          }
          getSize() {
            const e2 = this.#privateWi;
            return [e2.GetWidth(), e2.GetHeight()];
          }
          get angle() {
            return this.#privateWi.GetAngle();
          }
          set angle(e2) {
            e2 = C33.clampAngle(+e2);
            const t = this.#privateWi;
            isNaN(e2) || t.GetAngle() === e2 || (t.SetAngle(e2), t.SetBboxChanged());
          }
          get angleDegrees() {
            return C33.toDegrees(this.angle);
          }
          set angleDegrees(e2) {
            this.angle = C33.toRadians(e2);
          }
          getBoundingBox() {
            return this.#privateWi.GetBoundingBox().toDOMRect();
          }
          getBoundingQuad() {
            return this.#privateWi.GetBoundingQuad().toDOMQuad();
          }
          isOnScreen() {
            return this.#privateWi.IsInViewport2();
          }
          get isVisible() {
            return this.#privateWi.IsVisible();
          }
          set isVisible(e2) {
            e2 = !!e2;
            const t = this.#privateInst, i = this.#privateWi;
            i.IsVisible() !== e2 && (i.SetVisible(e2), t.GetRuntime().UpdateRender());
          }
          get opacity() {
            return this.#privateWi.GetOpacity();
          }
          set opacity(e2) {
            e2 = C33.clamp(+e2, 0, 1);
            const t = this.#privateInst, i = this.#privateWi;
            isNaN(e2) || i.GetOpacity() === e2 || (i.SetOpacity(e2), t.GetRuntime().UpdateRender());
          }
          set colorRgb(e2) {
            if (C3X.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
            tempColor.setRgb(e2[0], e2[1], e2[2]);
            const t = this.#privateInst, i = this.#privateWi;
            i.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i.SetUnpremultipliedColor(tempColor), t.GetRuntime().UpdateRender());
          }
          get colorRgb() {
            const e2 = this.#privateWi.GetUnpremultipliedColor();
            return [e2.getR(), e2.getG(), e2.getB()];
          }
          set blendMode(e2) {
            C3X.RequireString(e2);
            const t = BLEND_MODE_TO_INDEX.get(e2);
            if ("number" != typeof t) throw new Error("invalid blend mode");
            const i = this.#privateInst, n = this.#privateWi;
            n.SetBlendMode(t), i.GetRuntime().UpdateRender();
          }
          get blendMode() {
            return INDEX_TO_BLEND_MODE.get(this.#privateWi.GetBlendMode());
          }
          moveToTop() {
            this.#privateWi.ZOrderMoveToTop();
          }
          moveToBottom() {
            this.#privateWi.ZOrderMoveToBottom();
          }
          moveToLayer(e2) {
            C3X.RequireInstanceOf(e2, ILayer);
            const t = this.#privateInst, i = t.GetRuntime()._UnwrapScriptInterface(e2);
            if (!i) throw new Error("invalid layer");
            t.GetWorldInfo().ZOrderMoveToLayer(i);
          }
          moveAdjacentToInstance(e2, t) {
            C3X.RequireInstanceOf(e2, r), this.#privateWi.ZOrderMoveAdjacentToInstance(map.get(e2), t);
          }
          get zIndex() {
            return this.#privateWi.GetZIndex();
          }
          get isCollisionEnabled() {
            return this.#privateWi.IsCollisionEnabled();
          }
          set isCollisionEnabled(e2) {
            this.#privateWi.SetCollisionEnabled(!!e2);
          }
          containsPoint(e2, t) {
            return C3X.RequireNumber(e2), C3X.RequireNumber(t), this.#privateWi.ContainsPoint(+e2, +t);
          }
          testOverlap(e2) {
            C3X.RequireInstanceOf(e2, r);
            const t = this.#privateInst, i = map.get(e2);
            return t.GetRuntime().GetCollisionEngine().TestOverlap(t, i);
          }
          testOverlapSolid() {
            const e2 = this.#privateInst, t = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);
            return t ? t.GetInterfaceClass() : null;
          }
          getParent() {
            const e2 = this.#privateInst.GetParent();
            return e2 ? e2.GetInterfaceClass() : null;
          }
          getTopParent() {
            const e2 = this.#privateInst.GetTopParent();
            return e2 ? e2.GetInterfaceClass() : null;
          }
          *parents() {
            for (const e2 of this.#privateInst.parents()) yield e2.GetInterfaceClass();
          }
          getChildCount() {
            return this.#privateInst.GetChildCount();
          }
          getChildAt(e2) {
            const t = this.#privateInst.GetChildAt(e2);
            return t ? t.GetInterfaceClass() : null;
          }
          *children() {
            for (const e2 of this.#privateInst.children()) yield e2.GetInterfaceClass();
          }
          *allChildren() {
            for (const e2 of this.#privateInst.allChildren()) yield e2.GetInterfaceClass();
          }
          addChild(e2, t) {
            C3X.RequireInstanceOf(e2, r), C3X.RequireOptionalObject(t), t = t || {};
            const i = this.#privateInst, n = map.get(e2);
            i.AddChild(n, t);
          }
          removeChild(e2) {
            C3X.RequireInstanceOf(e2, r);
            const t = this.#privateInst, i = map.get(e2);
            t.RemoveChild(i);
          }
          removeFromParent() {
            const e2 = this.#privateInst;
            if (e2.HasParent()) {
              const t = e2.GetParent();
              t.RemoveChild(e2);
            }
          }
          getHierarchyOpts() {
            const e2 = this.#privateWi;
            return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };
          }
          createMesh(e2, t) {
            C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t), this.#privateWi.CreateMesh(e2, t);
          }
          releaseMesh() {
            const e2 = this.#privateWi;
            e2.ReleaseMesh(), e2.SetBboxChanged();
          }
          setMeshPoint(e2, t, i) {
            C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t), C3X.RequireObject(i);
            const n = this.#privateWi;
            n.SetMeshPoint(e2, t, i) && n.SetBboxChanged();
          }
          getMeshPoint(e2, t) {
            let i = NaN, n = NaN, r2 = NaN, s = NaN, a = NaN;
            const o = this.#privateWi;
            if (o.HasMesh()) {
              const l = o.GetSourceMesh(), h = l.GetMeshPointAt(e2, t);
              null !== h && (i = h.GetX(), n = h.GetY(), r2 = h.GetZElevation(), s = h.GetU(), a = h.GetV());
            }
            return { x: i, y: n, zElevation: r2, u: s, v: a };
          }
          getMeshSize() {
            const e2 = this.#privateWi;
            if (!e2.HasMesh()) return [0, 0];
            const t = e2.GetSourceMesh();
            return [t.GetHSize(), t.GetVSize()];
          }
        };
      };
      MakeIWorldInstanceClass = MakeIWorldInstanceClass2;
      const C33 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C33.New(C33.Color);
      self.IWorldInstance = MakeIWorldInstanceClass2(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass2(self.ISDKInstanceBase);
    }
    var MakeIWorldInstanceClass;
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IDOMInstance = class extends self.IWorldInstance {
        #private;
        constructor() {
          super(), this.#private = self.IInstance._GetInitInst();
        }
        getElement() {
          return this.#private.GetSdkInstance()._GetElementInDOMMode();
        }
        focus() {
          this.#private.GetSdkInstance().FocusElement();
        }
        blur() {
          this.#private.GetSdkInstance().BlurElement();
        }
        setCssStyle(e, t) {
          C3X.RequireString(e), this.#private.GetSdkInstance().SetElementCSSStyle(e, t);
        }
      };
    }
    {
      let GetDispatcher2 = function(e) {
        let t = dispatchers.get(e);
        return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t)), t;
      };
      GetDispatcher = GetDispatcher2;
      const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.IBehaviorInstance = class {
        #private;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: (this.#private = e).GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };
          Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);
        }
        static _GetInitInst() {
          return C33.AddonManager._GetInitObject();
        }
        get instance() {
          return this.#private.GetObjectInstance().GetInterfaceClass();
        }
        _release() {
          const e = dispatchers.get(this);
          e && (e.Release(), dispatchers.delete(this));
        }
        addEventListener(e, t, i) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).addEventListener(e, t, i);
        }
        removeEventListener(e, t, i) {
          C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher2(this).removeEventListener(e, t, i);
        }
        dispatchEvent(e) {
          GetDispatcher2(this).dispatchEvent(e);
        }
      };
    }
    var GetDispatcher;
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IBehaviorType = class {
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };
          Object.defineProperties(this, t);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.IBehavior = class {
        #private;
        constructor() {
          const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: (this.#private = e).GetRuntime().GetIRuntime(), writable: false } };
          Object.defineProperties(this, t);
        }
        getAllInstances() {
          return this.#private.GetInstances().map((e) => e.GetInterfaceClass());
        }
        static getByConstructor(e) {
          if (!e) return null;
          const t = C33.AddonManager.GetBehaviorByConstructorFunction(e);
          return t ? t.GetIBehavior() : null;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, tempColor = C33.New(C33.Color);
      self.IEffectInstance = class {
        #private;
        constructor(e, t) {
          this.#private = e;
          const i = { index: { value: t, writable: false } };
          Object.defineProperties(this, i);
        }
        get name() {
          const e = this.#private.GetAllEffectTypes();
          return e[this.index].GetName();
        }
        get isActive() {
          return this.#private.IsEffectIndexActive(this.index);
        }
        set isActive(e) {
          e = !!e;
          const t = this.#private;
          t.IsEffectIndexActive(this.index) !== e && (t.SetEffectIndexActive(this.index, e), t.UpdateActiveEffects(), t.GetRuntime().UpdateRender());
        }
        setParameter(e, t) {
          C3X.RequireFiniteNumber(e), e = Math.floor(+e);
          const i = this.#private, r = i.GetEffectParameter(this.index, e);
          if (null === r) throw new RangeError("invalid index");
          if (r instanceof C33.Color) {
            if (!Array.isArray(t) || t.length < 3) throw new TypeError("expected array with 3 elements");
            tempColor.setRgb(t[0], t[1], t[2]), t = tempColor;
          } else if ("number" != typeof t) throw new TypeError("expected number");
          const n = i.SetEffectParameter(this.index, e, t);
          n && i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender();
        }
        getParameter(e) {
          C3X.RequireFiniteNumber(e), e = Math.floor(+e);
          const t = this.#private, i = t.GetEffectParameter(this.index, e);
          if (null === i) throw new RangeError("invalid index");
          return i instanceof C33.Color ? [i.getR(), i.getG(), i.getB()] : i;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IAnimation = class {
        #private;
        constructor(e) {
          this.#private = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });
        }
        get speed() {
          return this.#private.GetSpeed();
        }
        get isLooping() {
          return this.#private.IsLooping();
        }
        get repeatCount() {
          return this.#private.GetRepeatCount();
        }
        get repeatTo() {
          return this.#private.GetRepeatTo();
        }
        get isPingPong() {
          return this.#private.IsPingPong();
        }
        get frameCount() {
          return this.#private.GetFrameCount();
        }
        getFrames() {
          return this.#private.GetFrames().map((e) => e.GetIAnimationFrame());
        }
        *frames() {
          for (const e of this.#private.GetFrames()) yield e.GetIAnimationFrame();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IImageInfo = class {
        #private;
        constructor(t) {
          this.#private = t;
        }
        static _Unwrap(t) {
          return t.#private;
        }
        get width() {
          return this.#private.GetWidth();
        }
        get height() {
          return this.#private.GetHeight();
        }
        getSize() {
          const t = this.#private;
          return [t.GetWidth(), t.GetHeight()];
        }
        getTexture(t) {
          return t.getTextureForImageInfo(this);
        }
        getTexRect() {
          return this.#private.GetTexRect().toDOMRect();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.IAnimationFrame = class extends self.IImageInfo {
        #private;
        constructor(t) {
          super(t.GetImageInfo()), this.#private = t, Object.defineProperties(this, { duration: { value: t.GetDuration(), writable: false }, originX: { value: t.GetOriginX(), writable: false }, originY: { value: t.GetOriginY(), writable: false } });
        }
        getOrigin() {
          const t = this.#private;
          return [t.GetOriginX(), t.GetOriginY()];
        }
        getImagePointCount() {
          return this.#private.GetImagePointCount();
        }
        getImagePointX(t) {
          return this.getImagePoint(t)[0];
        }
        getImagePointY(t) {
          return this.getImagePoint(t)[1];
        }
        getImagePoint(t) {
          const e = this.#private;
          let i = null;
          if ("number" == typeof t) i = e.GetImagePointByIndex(Math.floor(t));
          else {
            if ("string" != typeof t) throw new TypeError("expected string or number");
            i = e.GetImagePointByName(t);
          }
          return i ? [i.GetX(), i.GetY()] : this.getOrigin();
        }
        getPolyPointCount() {
          const t = this.#private.GetCollisionPoly();
          return t ? t.pointCount() : 0;
        }
        getPolyPointX(t) {
          return this.getPolyPoint(t)[0];
        }
        getPolyPointY(t) {
          return this.getPolyPoint(t)[1];
        }
        getPolyPoint(t) {
          C3X.RequireFiniteNumber(t), t = Math.floor(t);
          const e = this.#private.GetCollisionPoly();
          if (!e || t < 0 || t >= e.pointCount()) return [0, 0];
          const i = e.pointsArr(), n = i[2 * t], r = i[2 * t + 1];
          return [n, r];
        }
        get tag() {
          return this.#private.GetTag();
        }
      };
    }
    {
      let GetTimelineState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("timeline/tween was released and is no longer valid");
        return t;
      };
      GetTimelineState = GetTimelineState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      self.ITimelineStateBase = class {
        constructor(e) {
          map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);
        }
        pause() {
          GetTimelineState2(this).Stop();
        }
        resume() {
          GetTimelineState2(this).Resume();
        }
        stop() {
          GetTimelineState2(this).Reset();
        }
        hasTags(e) {
          return GetTimelineState2(this).HasTags(e);
        }
        set time(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetTime(e);
        }
        get time() {
          return GetTimelineState2(this).GetTime();
        }
        set totalTime(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetTotalTime(e);
        }
        get totalTime() {
          return GetTimelineState2(this).GetTotalTime();
        }
        set isLooping(e) {
          GetTimelineState2(this).SetLoop(!!e);
        }
        get isLooping() {
          return GetTimelineState2(this).GetLoop();
        }
        set isPingPong(e) {
          GetTimelineState2(this).SetPingPong(!!e);
        }
        get isPingPong() {
          return GetTimelineState2(this).GetPingPong();
        }
        set playbackRate(e) {
          C3X.RequireFiniteNumber(e), GetTimelineState2(this).SetPlaybackRate(e);
        }
        get playbackRate() {
          return GetTimelineState2(this).GetPlaybackRate();
        }
        get progress() {
          const e = GetTimelineState2(this);
          return e.GetTime() / e.GetTotalTime();
        }
        get tags() {
          return GetTimelineState2(this).GetTags();
        }
        get finished() {
          return GetTimelineState2(this).GetPlayPromise();
        }
        get isPlaying() {
          return GetTimelineState2(this).IsPlaying();
        }
        get isPaused() {
          return GetTimelineState2(this).IsPaused();
        }
        get isReleased() {
          return map.get(this).IsReleased();
        }
      };
    }
    var GetTimelineState;
    {
      let GetTimelineState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("timeline was released and is no longer valid");
        return t;
      };
      GetTimelineState = GetTimelineState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      let easeToIndexFunc = null;
      self.ITimelineState = class extends self.ITimelineStateBase {
        constructor(e) {
          super(e), map.set(this, e);
          const t = { name: { value: e.GetName(), writable: false } };
          Object.defineProperties(this, t);
        }
      };
    }
    var GetTimelineState;
    {
      let GetTweenState2 = function(e) {
        const t = map.get(e);
        if (t.IsReleased()) throw new Error("tween was released and is no longer valid");
        return t;
      };
      GetTweenState = GetTweenState2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();
      let easeToIndexFunc = null;
      self.ITweenState = class extends self.ITimelineStateBase {
        constructor(e, t, n) {
          super(e), easeToIndexFunc = easeToIndexFunc || n.easeToIndexFunc, map.set(this, e), t && behInstMap.set(this, t);
        }
        stop() {
          const e = GetTweenState2(this), t = behInstMap.get(this);
          t.ReleaseTween(e);
        }
        setEase(e) {
          C3X.RequireString(e);
          const t = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));
          GetTweenState2(this).SetEase(t);
        }
        get instance() {
          const e = GetTweenState2(this).GetInstance();
          return e ? e.GetInterfaceClass() : null;
        }
        get isDestroyOnComplete() {
          return GetTweenState2(this).GetDestroyInstanceOnComplete();
        }
        set isDestroyOnComplete(e) {
          GetTweenState2(this).SetDestroyInstanceOnComplete(!!e);
        }
        get value() {
          const e = GetTweenState2(this);
          if ("value" !== e.GetId()) throw new Error("not a value tween");
          return e.GetPropertyTrack("value").GetSourceAdapterValue();
        }
      };
    }
    var GetTweenState;
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKPluginBase = class extends self.IPlugin {
        constructor() {
          super();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();
      self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {
        #private;
        #domComponentId;
        #nextElementId = 0;
        #instMap = /* @__PURE__ */ new Map();
        constructor(e) {
          if (super(), this.#private = C33.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error("no DOM component ID specified");
          this.#domComponentId = e.domComponentId, this._addElementMessageHandler("elem-focused", (e2) => e2._onElemFocused()), this._addElementMessageHandler("elem-blurred", (e2) => {
            e2 && e2._onElemBlurred();
          });
        }
        _addElement(e) {
          const n = this.#nextElementId++;
          return this.#instMap.set(n, e), n;
        }
        _removeElement(e) {
          this.#instMap.delete(e);
        }
        _addElementMessageHandler(e, t) {
          const n = this.#private.GetRuntime();
          n.AddDOMComponentMessageHandler(this.#domComponentId, e, (e2) => {
            const n2 = this.#instMap.get(e2["elementId"]);
            t(n2, e2);
          });
        }
        _addElementMessageHandlers(e) {
          C3X.RequireArray(e);
          for (const [n, t] of e) this._addElementMessageHandlers(n, t);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKObjectTypeBase = class extends self.IObjectClass {
        #private;
        constructor() {
          super(), this.#private = C33.AddonManager._GetInitObject2(internalApiToken);
        }
        _onCreate() {
        }
        getImageInfo() {
          return this.#private.GetImageInfo().GetIImageInfo();
        }
        _loadTextures(e) {
        }
        _releaseTextures(e) {
        }
        _onDynamicTextureLoadComplete() {
        }
        _preloadTexturesWithInstances(e) {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {
        #private;
        #renderercontextlost_handler = null;
        #renderercontextrestored_handler = null;
        constructor(e) {
          super(e), this.#private = C33.AddonManager._GetInitObject2(internalApiToken);
        }
        _release() {
          if (super._release(), this.#renderercontextlost_handler) {
            const e = this.#private.GetRuntime().Dispatcher();
            e.removeEventListener("renderercontextlost", this.#renderercontextlost_handler), e.removeEventListener("renderercontextrestored", this.#renderercontextrestored_handler), this.#renderercontextlost_handler = null, this.#renderercontextrestored_handler = null;
          }
        }
        _handleRendererContextLoss() {
          if (!this.#renderercontextlost_handler) {
            this.#renderercontextlost_handler = () => this._onRendererContextLost(), this.#renderercontextrestored_handler = () => this._onRendererContextRestored();
            const e = this.#private.GetRuntime().Dispatcher();
            e.addEventListener("renderercontextlost", this.#renderercontextlost_handler), e.addEventListener("renderercontextrestored", this.#renderercontextrestored_handler);
          }
        }
        _onRendererContextLost() {
        }
        _onRendererContextRestored() {
        }
        _draw(e) {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, tempRect = C33.New(C33.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {
        #elementId = -1;
        #isElementShowing = true;
        #elemHasFocus = false;
        #autoFontSize = false;
        #autoFontSizeOffset = -0.2;
        #lastRect = C33.New(C33.Rect, 0, 0, -1, -1);
        #lastWindowWidth = 0;
        #lastWindowHeight = 0;
        #lastHTMLIndex = -1;
        #lastHTMLZIndex = -1;
        #isPendingUpdateState = false;
        constructor(e) {
          if (!e?.domComponentId) throw new Error("no DOM component ID specified");
          super(e);
          const t = C33.AddonManager._GetInitObject2(internalApiToken), s = (map.set(this, t), this.#elementId = this.plugin._addElement(this), t.GetRuntime().GetCanvasManager());
          this.#lastWindowWidth = s.GetLastWidth(), this.#lastWindowHeight = s.GetLastHeight(), this._setTicking(true);
        }
        _release() {
          super._release(), this.plugin._removeElement(this.#elementId), this._postToDOMElement("destroy"), this.#elementId = -1, map.delete(this);
        }
        _getElementInDOMMode() {
          const e = map.get(this).GetRuntime();
          if (e.IsInWorker()) throw new Error("not valid in worker mode");
          return this._postToDOMElementMaybeSync("get-element");
        }
        _postToDOMElement(e, t) {
          (t = t || {})["elementId"] = this.#elementId, this._postToDOM(e, t);
        }
        _postToDOMElementMaybeSync(e, t) {
          return (t = t || {})["elementId"] = this.#elementId, this._postToDOMMaybeSync(e, t);
        }
        _postToDOMElementAsync(e, t) {
          return (t = t || {})["elementId"] = this.#elementId, this._postToDOMAsync(e, t);
        }
        _createElement(e) {
          e = e || {};
          const t = map.get(this).GetWorldInfo();
          e["elementId"] = this.#elementId, e["isVisible"] = t.IsVisible(), e["htmlIndex"] = t.GetLayer().GetHTMLIndex(), e["htmlZIndex"] = t.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#isElementShowing = !!e["isVisible"], this._postToDOMMaybeSync("create", e), this._updatePosition(true);
        }
        setElementVisible(e) {
          this.#isElementShowing !== (e = !!e) && (this.#isElementShowing = e, this._postToDOMElement("set-visible", { "isVisible": e }));
        }
        _tick() {
          this._updatePosition(false);
        }
        _shouldPreserveElement() {
          const e = map.get(this).GetRuntime(), t = e.GetCanvasManager().GetFullscreenMode();
          return "Android" === C33.Platform.OS && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
        }
        _updatePosition(n) {
          const o = map.get(this);
          if (!o.IsDestroyed()) {
            const l = o.GetWorldInfo(), a = l.GetLayer(), h = l.GetBoundingBox();
            let [e, t] = a.LayerToCanvasCss(h.getLeft(), h.getTop()), [s, i] = a.LayerToCanvasCss(h.getRight(), h.getBottom());
            const m = o.GetRuntime().GetCanvasManager(), d = m.GetCssWidth(), r = m.GetCssHeight();
            if (l.IsVisible() && a.IsVisible()) if (!this._shouldPreserveElement() && (s <= 0 || i <= 0 || d <= e || r <= t)) this.setElementVisible(false);
            else {
              tempRect.set(e, t, s, i);
              const c = m.GetLastWidth(), p = m.GetLastHeight(), u = a.GetHTMLIndex(), M = l.GetHTMLZIndex();
              if (!n && tempRect.equals(this.#lastRect) && this.#lastWindowWidth === c && this.#lastWindowHeight === p && this.#lastHTMLIndex === u && this.#lastHTMLZIndex === M) this.setElementVisible(true);
              else {
                this.#lastRect.copy(tempRect), this.#lastWindowWidth = c, this.#lastWindowHeight = p, this.#lastHTMLIndex = u, this.#lastHTMLZIndex = M, this.setElementVisible(true);
                let e2 = null;
                this.#autoFontSize && (e2 = a.GetDisplayScale() + this.#autoFontSizeOffset), this._postToDOMElement("update-position", { "left": Math.round(this.#lastRect.getLeft()), "top": Math.round(this.#lastRect.getTop()), "width": Math.round(this.#lastRect.width()), "height": Math.round(this.#lastRect.height()), "htmlIndex": u, "htmlZIndex": M, "fontSize": e2 });
              }
            }
            else this.setElementVisible(false);
          }
        }
        focusElement() {
          this._postToDOMElementMaybeSync("focus", { "focus": true });
        }
        blurElement() {
          this._postToDOMElementMaybeSync("focus", { "focus": false });
        }
        _onElemFocused() {
          this.#elemHasFocus = true;
        }
        _onElemBlurred() {
          this.#elemHasFocus = false;
        }
        isElementFocused() {
          return this.#elemHasFocus;
        }
        setElementCSSStyle(e, t) {
          this.postToDOMElement("set-css-style", { "prop": C33.CSSToCamelCase(e), "val": t });
        }
        setElementAttribute(e, t) {
          this.postToDOMElement("set-attribute", { "name": e, "val": t });
        }
        removeElementAttribute(e) {
          this.postToDOMElement("remove-attribute", { "name": e });
        }
        _updateElementState() {
          this.#isPendingUpdateState || (this.#isPendingUpdateState = true, Promise.resolve().then(() => {
            this.#isPendingUpdateState = false, this._postToDOMElement("update-state", this._getElementState());
          }));
        }
        _getElementState() {
        }
        _getElementId() {
          return this.#elementId;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKBehaviorBase = class extends self.IBehavior {
        constructor() {
          super();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {
        constructor() {
          super();
        }
        _onCreate() {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();
      self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {
        #isTicking = false;
        #isTicking2 = false;
        #isPostTicking = false;
        constructor() {
          super(), map.set(this, C33.AddonManager._GetInitObject2(internalApiToken));
        }
        _release() {
          super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);
        }
        _getInitProperties() {
          return C33.AddonManager._GetInitProperties();
        }
        _postCreate() {
        }
        _trigger(i) {
          const t = map.get(this);
          t.GetRuntime().Trigger(i, t.GetObjectInstance(), t.GetBehaviorType());
        }
        _triggerAsync(i) {
          const t = map.get(this);
          return t.GetRuntime().TriggerAsync(i, t.GetObjectInstance(), t.GetBehaviorType());
        }
        _setTicking(i) {
          if (this.#isTicking !== (i = !!i)) {
            this.#isTicking = i;
            const t = map.get(this).GetRuntime();
            i ? t._AddBehInstToTick(this) : t._RemoveBehInstToTick(this);
          }
        }
        _isTicking() {
          return this.#isTicking;
        }
        _tick() {
        }
        _setTicking2(i) {
          if (this.#isTicking2 !== (i = !!i)) {
            this.#isTicking2 = i;
            const t = map.get(this).GetRuntime();
            i ? t._AddBehInstToTick2(this) : t._RemoveBehInstToTick2(this);
          }
        }
        _isTicking2() {
          return this.#isTicking2;
        }
        _tick2() {
        }
        _setPostTicking(i) {
          if (this.#isPostTicking !== (i = !!i)) {
            this.#isPostTicking = i;
            const t = map.get(this).GetRuntime();
            i ? t._AddBehInstToPostTick(this) : t._RemoveBehInstToPostTick(this);
          }
        }
        _isPostTicking() {
          return this.#isPostTicking;
        }
        _postTick() {
        }
        _getDebuggerProperties() {
          return [];
        }
        _saveToJson() {
          return null;
        }
        _loadFromJson(i) {
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let runtime = null;
      self.ISDKUtils = class {
        constructor(e) {
          runtime = e;
        }
        addLoadPromise(e) {
          runtime.AddLoadPromise(e);
        }
        sendWrapperExtensionMessage(e, n, t) {
          C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessage(e, n, t);
        }
        sendWrapperExtensionMessageAsync(e, n, t) {
          return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessageAsync(e, n, t);
        }
        createLoopingConditionContext(e) {
          return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);
        }
        set isAutoSuspendEnabled(e) {
          runtime._SetAutoSuspendEnabled(!!e);
        }
        get isAutoSuspendEnabled() {
          return runtime._IsAutoSuspendEnabled();
        }
        setSuspended(e) {
          runtime.SetSuspended(!!e);
        }
        getObjectClassBySid(e) {
          C3X.RequireNumber(e);
          const n = runtime.GetObjectClassBySID(e);
          return n ? n.GetIObjectClass() : null;
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      self.ILoopingConditionContext = class {
        #runtime;
        #currentEvent;
        #solModifiers;
        #oldFrame;
        #newFrame;
        #loop;
        constructor(e, t) {
          const o = (this.#runtime = e).GetEventSheetManager(), n = e.GetCurrentEvent(), r = (this.#currentEvent = n, this.#solModifiers = n.GetSolModifiers(), e.GetEventStack()), s = (this.#oldFrame = r.GetCurrentStackFrame(), this.#newFrame = r.Push(n), o.GetLoopStack()), i = s.Push();
          this.#loop = i, t && i.SetName(t), e.SetDebuggingEnabled(false);
        }
        retrigger() {
          const e = this.#runtime.GetEventSheetManager(), t = this.#solModifiers, o = this.#loop;
          e.PushCopySol(t), this.#currentEvent.Retrigger(this.#oldFrame, this.#newFrame), e.PopSol(t), o.SetIndex(o.GetIndex() + 1);
        }
        get isStopped() {
          return this.#loop.IsStopped();
        }
        release() {
          const e = this.#runtime, t = e.GetEventStack(), o = e.GetEventSheetManager().GetLoopStack();
          e.SetDebuggingEnabled(true), o.Pop(), t.Pop();
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X;
      let renderer = null, runtime = null;
      self.IRenderer = class {
        constructor(e, r) {
          runtime = e, renderer = r;
        }
        setAlphaBlendMode() {
          renderer.SetAlphaBlend();
        }
        setBlendMode(e) {
          renderer.SetNamedBlendMode(e);
        }
        setColorFillMode() {
          renderer.SetColorFillMode();
        }
        setTextureFillMode() {
          renderer.SetTextureFillMode();
        }
        setSmoothLineFillMode() {
          renderer.SetSmoothLineFillMode();
        }
        setColor(e) {
          renderer.SetColorRgba(e[0], e[1], e[2], e[3]);
        }
        setColorRgba(e, r, n, t) {
          renderer.SetColorRgba(e, r, n, t);
        }
        resetColor() {
          renderer.ResetColor();
        }
        setOpacity(e) {
          renderer.SetOpacity(e);
        }
        setCurrentZ(e) {
          renderer.SetCurrentZ(e);
        }
        getCurrentZ() {
          renderer.GetCurrentZ();
        }
        rect(e) {
          renderer.Rect2(e.left, e.top, e.right, e.bottom);
        }
        rect2(e, r, n, t) {
          renderer.Rect2(e, r, n, t);
        }
        quad(e) {
          renderer.Quad(C33.Quad.fromDOMQuad(e));
        }
        quad2(e, r, n, t, a, d, o, i) {
          renderer.Quad2(e, r, n, t, a, d, o, i);
        }
        quad3(e, r) {
          renderer.Quad3(C33.Quad.fromDOMQuad(e), C33.Rect.fromDOMRect(r));
        }
        quad4(e, r) {
          renderer.Quad4(C33.Quad.fromDOMQuad(e), C33.Quad.fromDOMQuad(r));
        }
        quad3D(e, r, n, t, a, d, o, i, u, l, s, p, c) {
          renderer.Quad3D(e, r, n, t, a, d, o, i, u, l, s, p, C33.Rect.fromDOMRect(c));
        }
        quad3D2(e, r, n, t, a, d, o, i, u, l, s, p, c) {
          renderer.Quad3D2(e, r, n, t, a, d, o, i, u, l, s, p, C33.Quad.fromDOMQuad(c));
        }
        drawMesh(e, r, n) {
          renderer.DrawMesh(e, r, n);
        }
        convexPoly(e) {
          renderer.ConvexPoly(e);
        }
        line(e, r, n, t) {
          renderer.Line(e, r, n, t);
        }
        texturedLine(e, r, n, t, a, d) {
          renderer.TexturedLine(e, r, n, t, a, d);
        }
        lineRect(e, r, n, t) {
          renderer.LineRect(e, r, n, t);
        }
        lineRect2(e) {
          renderer.LineRect2(C33.Rect.fromDOMRect(e));
        }
        lineQuad(e) {
          renderer.LineQuad(C33.Quad.fromDOMQuad(e));
        }
        pushLineWidth(e) {
          renderer.PushLineWidth(e);
        }
        popLineWidth() {
          renderer.PopLineWidth();
        }
        pushLineCap(e) {
          renderer.PushLineCap(e);
        }
        popLineCap() {
          renderer.PopLineCap();
        }
        setTexture(e) {
          C3X.RequireOptionalInstanceOf(e, self.ITexture);
          const r = e ? runtime._UnwrapScriptInterface(e) : null;
          renderer.SetTexture(r);
        }
        loadTextureForImageInfo(e, r) {
          const n = self.IImageInfo._Unwrap(e);
          if (n) return n.LoadStaticTexture(renderer, { wrapX: r?.wrapX ?? "clamp-to-edge", wrapY: r?.wrapY ?? "clamp-to-edge", sampling: r?.sampling ?? "trilinear", mipMap: r?.mipMap ?? true });
          throw new Error("invalid IImageInfo");
        }
        releaseTextureForImageInfo(e) {
          const r = self.IImageInfo._Unwrap(e);
          if (!r) throw new Error("invalid IImageInfo");
          r.ReleaseTexture();
        }
        getTextureForImageInfo(e) {
          const r = self.IImageInfo._Unwrap(e);
          if (!r) throw new Error("invalid IImageInfo");
          const n = r.GetTexture();
          return self.ITexture.GetInterface(runtime, n);
        }
        createDynamicTexture(e, r, n) {
          C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r);
          const t = renderer.CreateDynamicTexture(e, r, { wrapX: n?.wrapX ?? "clamp-to-edge", wrapY: n?.wrapY ?? "clamp-to-edge", sampling: n?.sampling ?? "trilinear", mipMap: n?.mipMap ?? true });
          return self.ITexture.GetInterface(runtime, t);
        }
        updateTexture(e, r, n) {
          C3X.RequireInstanceOf(r, self.ITexture);
          const t = runtime._UnwrapScriptInterface(r);
          renderer.UpdateTexture(e, t, { premultiplyAlpha: n?.premultiplyAlpha ?? true });
        }
        deleteTexture(e) {
          C3X.RequireInstanceOf(e, self.ITexture);
          const r = runtime._UnwrapScriptInterface(e);
          renderer.DeleteTexture(r);
        }
        createRendererText() {
          const e = renderer.CreateRendererText();
          return new self.IRendererText(runtime, e);
        }
        setDeviceTransform() {
          runtime.GetCanvasManager().SetDeviceTransform(renderer);
        }
        setLayerTransform(e) {
          C3X.RequireInstanceOf(e, globalThis.ILayer);
          const r = runtime._UnwrapScriptInterface(e);
          r._SetTransform(renderer);
        }
      };
    }
    {
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();
      self.ITexture = class {
        constructor(e, t) {
          map.set(this, { runtime: e, texture: t }), reverseMap.set(t, this), e._MapScriptInterface(this, t), Object.defineProperties(this, { width: { value: t.GetWidth(), writable: false }, height: { value: t.GetHeight(), writable: false } });
        }
        static GetInterface(e, t) {
          if (!t) return null;
          const r = reverseMap.get(t);
          return r || new self.ITexture(e, t);
        }
      };
    }
    {
      let getActual2 = function(t) {
        return map.get(t).rendererText;
      };
      getActual = getActual2;
      const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
      self.IRendererText = class {
        constructor(t, e) {
          map.set(this, { runtime: t, rendererText: e }), t._MapScriptInterface(this, e);
        }
        release() {
          getActual2(this).Release();
        }
        set fontFace(t) {
          C3X.RequireString(t), getActual2(this).SetFontName(t);
        }
        get fontFace() {
          return getActual2(this).GetFontName();
        }
        set sizePt(t) {
          C3X.RequireFiniteNumber(t), getActual2(this).SetFontSize(t);
        }
        get sizePt() {
          return getActual2(this).GetFontSize();
        }
        set lineHeight(t) {
          C3X.RequireFiniteNumber(t), getActual2(this).SetLineHeight(t);
        }
        get lineHeight() {
          return getActual2(this).GetLineHeight();
        }
        set isBold(t) {
          getActual2(this).SetBold(t);
        }
        get isBold() {
          return getActual2(this).IsBold();
        }
        set isItalic(t) {
          getActual2(this).SetItalic(t);
        }
        get isItalic() {
          return getActual2(this).IsItalic();
        }
        setColor(t) {
          C3X.RequireArray(t), this.setColorRgb(t[0], t[1], t[2]);
        }
        setColorRgb(t, e, i) {
          getActual2(this).SetColorRgb(t, e, i);
        }
        setCssColor(t) {
          C3X.RequireString(t), getActual2(this).SetColor(t);
        }
        set horizontalAlign(t) {
          getActual2(this).SetHorizontalAlignment(t);
        }
        get horizontalAlign() {
          return getActual2(this).GetHorizontalAlignment();
        }
        set verticalAlign(t) {
          getActual2(this).SetVerticalAlignment(t);
        }
        get verticalAlign() {
          return getActual2(this).GetVerticalAlignment();
        }
        set wordWrapMode(t) {
          getActual2(this).SetWordWrapMode(t);
        }
        get wordWrapMode() {
          return getActual2(this).GetWordWrapMode();
        }
        set textDirection(t) {
          getActual2(this).SetTextDirection(t);
        }
        get textDirection() {
          return getActual2(this).GetTextDirection();
        }
        set text(t) {
          C3X.RequireString(t), getActual2(this).SetText(t);
        }
        get text() {
          return getActual2(this).GetText();
        }
        setSize(t, e, i) {
          C3X.RequireFiniteNumber(t), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i), getActual2(this).SetSize(t, e, i);
        }
        getTexture() {
          const { runtime: t, rendererText: e } = map.get(this), i = e.GetTexture();
          return self.ITexture.GetInterface(t, i);
        }
        getTexRect() {
          return getActual2(this).GetTexRect().toDOMRect();
        }
        setTextureUpdateCallback(t) {
          C3X.RequireFunction(t), getActual2(this).ontextureupdate = t;
        }
        releaseTexture() {
          getActual2(this).ReleaseTexture();
        }
        get textWidth() {
          return getActual2(this).GetTextWidth();
        }
        get textHeight() {
          return getActual2(this).GetTextHeight();
        }
      };
    }
    var getActual;
    {
      let GetTypeFromFileExtension2 = function(e) {
        if (!e) return "";
        const t = e.split(".");
        if (t.length < 2) return "";
        const i = t.at(-1).toLowerCase();
        return EXT_TO_TYPE.get(i) || "";
      }, AddScript2 = function(o) {
        return new Promise((e, t) => {
          const i = document.createElement("script");
          i.onload = e, i.onerror = t, i.async = false, i.type = "module", i.src = o, document.head.appendChild(i);
        });
      };
      GetTypeFromFileExtension = GetTypeFromFileExtension2, AddScript = AddScript2;
      const C33 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set(["local", "remote"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
      C33.AssetManager = class extends C33.DefendedBase {
        constructor(e, t) {
          super();
          const i = t["exportType"], o = (this._runtime = e, this._fileStructure = "folders", this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = "cordova" === i, this._isiOSCordova = !!t["isiOSCordova"], this._isFileProtocol = !!t["isFileProtocol"], this._swClientId = t["swClientId"], this._supportedAudioFormats = t["supportedAudioFormats"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t["scriptFolder"], this._mediaSubfolder = "", this._fontsSubfolder = "", this._iconsSubfolder = "", this._fileMap = t["fileMap"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map(), "html5" === i || "scirra-arcade" === i || "instant-games" === i);
          this._defaultLoadPolicy = o ? "remote" : "local", this._assetsByUrl = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C33.New(C33.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C33.New(C33.PromiseThrottle, Math.max(C33.hardwareConcurrency, 8)), this._remotePromiseThrottle = C33.New(C33.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);
        }
        Release() {
          for (const e of this._assetsByUrl.values()) e.Release();
          this._assetsByUrl.clear(), C33.clearArray(this._loadPromises), this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        _SetFileStructure(e) {
          this._fileStructure = e;
        }
        GetFileStructure() {
          return this._fileStructure;
        }
        GetScriptSubfolder() {
          return this._scriptSubfolder;
        }
        _SetMediaSubfolder(e) {
          this._mediaSubfolder = e;
        }
        GetMediaSubfolder() {
          return this._mediaSubfolder;
        }
        _SetFontsSubfolder(e) {
          this._fontsSubfolder = e;
        }
        GetFontsSubfolder() {
          return this._fontsSubfolder;
        }
        _SetIconsSubfolder(e) {
          this._iconsSubfolder = e;
        }
        GetIconsSubfolder() {
          return this._iconsSubfolder;
        }
        IsFileProtocol() {
          return this._isFileProtocol;
        }
        FetchBlob(e, t) {
          return t = t || this._defaultLoadPolicy, C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e) : ("local" === t ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C33.FetchBlob(e))) : C33.FetchBlob(e);
        }
        FetchArrayBuffer(e) {
          return C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? C33.BlobToArrayBuffer(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : ("local" === this._defaultLoadPolicy ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C33.FetchArrayBuffer(e))) : C33.FetchArrayBuffer(e);
        }
        FetchText(e) {
          return C33.IsRelativeURL(e) ? ("flat" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? C33.BlobToString(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : ("local" === this._defaultLoadPolicy ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C33.FetchText(e))) : C33.FetchText(e);
        }
        async FetchJson(e) {
          const t = await this.FetchText(e);
          return JSON.parse(t);
        }
        _CordovaFetchLocalFileAs(e, t) {
          return "flat" === this._fileStructure && (e = e.toLowerCase()), this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", { "filename": e, "as": t });
        }
        CordovaFetchLocalFileAsText(e) {
          return this._CordovaFetchLocalFileAs(e, "text");
        }
        async CordovaFetchLocalFileAsBlob(e) {
          const t = await this._CordovaFetchLocalFileAs(e, "buffer"), i = GetTypeFromFileExtension2(e);
          return new Blob([t], { "type": i });
        }
        async CordovaFetchLocalFileAsBlobURL(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          let t = this._cordovaBlobUrlCache.get(e);
          if (!t) {
            const i = await this.CordovaFetchLocalFileAsBlob(e);
            t = URL.createObjectURL(i), this._cordovaBlobUrlCache.set(e, t);
          }
          return t;
        }
        CordovaFetchLocalFileAsArrayBuffer(e) {
          return this._CordovaFetchLocalFileAs(e, "buffer");
        }
        GetMediaFileUrl(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          let t = this._mediaSubfolder + e;
          return t = "Gecko" === C33.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() ? this._GetLocalBlobURLFromFileMap(t) : t;
        }
        GetProjectFileUrl(e) {
          return C33.IsAbsoluteURL(e) ? Promise.resolve(e) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(e) : "playable-ad-single-file" === this._runtime.GetExportType() ? URL.createObjectURL(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : ("flat" === this._fileStructure && (e = e.toLowerCase()), Promise.resolve(e));
        }
        GetProjectFileIframeUrl(t) {
          if (C33.IsAbsoluteURL(t) || "preview" !== this._runtime.GetExportType() || !this._swClientId || !t) return t;
          try {
            const e = new URL(t, location.href);
            return e.searchParams.set("__c3_client_id", this._swClientId), e.toString();
          } catch (e) {
            return console.warn("Invalid iframe URL: " + t), t;
          }
        }
        LoadProjectFileUrl(e) {
          return this.GetProjectFileUrl(e);
        }
        LoadImage(e) {
          if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error("invalid load policy");
          let t = this._assetsByUrl.get(e.url);
          return t || (t = C33.New(C33.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy }), this._assetsByUrl.set(t.GetURL(), t), this._hasFinishedInitialLoad) || (this._totalAssetSizeToLoad += t.GetSize(), this._loadPromises.push(t.Load().then(() => this._AddLoadedSize(t.GetSize())))), t;
        }
        _ReleaseAsset(e) {
          this._assetsByUrl.delete(e.GetURL());
        }
        async WaitForAllToLoad() {
          try {
            await Promise.all(this._loadPromises), this._lastLoadProgress = 1;
          } catch (e) {
            console.error("Error loading: ", e), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();
          }
        }
        SetInitialLoadFinished() {
          this._hasFinishedInitialLoad = true;
        }
        HasHadErrorLoading() {
          return this._hasHadErrorLoading;
        }
        _AddLoadedSize(e) {
          this._assetSizeLoaded += e, this._loadingRateLimiter.Call();
        }
        _FireLoadingProgressEvent() {
          const e = C33.New(C33.Event, "loadingprogress");
          this._lastLoadProgress = C33.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e);
        }
        GetLoadProgress() {
          return this._lastLoadProgress;
        }
        _SetWebFonts(e) {
          C33.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());
        }
        async _LoadWebFonts() {
          const e = [], t = [];
          for (const [i, o, s] of this._webFonts) this._totalAssetSizeToLoad += s, e.push(this._LoadWebFont(i, o, t).then(() => this._AddLoadedSize(s)));
          await Promise.all(e), this._runtime.IsInWorker() && 0 < t.length && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", { "webfonts": t });
        }
        async _LoadWebFont(t, i, o) {
          try {
            let e = await this.GetProjectFileUrl(i);
            "Gecko" === C33.Platform.BrowserEngine && (t = `'${t}'`), ("Gecko" === C33.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() || "playable-ad-single-file" === this._runtime.GetExportType()) && (e = this._GetLocalBlobURLFromFileMap(e));
            const s = new FontFace(t, `url('${e}')`);
            (this._runtime.IsInWorker() ? self : document).fonts.add(s), await s.load(), this._runtime.IsInWorker() && o.push({ name: t, url: e });
          } catch (e) {
            console.warn(`[C3 runtime] Failed to load web font '${t}': `, e);
          }
        }
        IsAudioFormatSupported(e) {
          return !!this._supportedAudioFormats[e];
        }
        _SetAudioFiles(e, t) {
          this._preloadSounds = !!t;
          for (const [i, o, s] of e) this._audioFiles.set(i, { fileName: i, formats: o.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: i + e2[1], fileSize: e2[2] })), isMusic: s });
        }
        GetPreferredAudioFile(e) {
          "flat" === this._fileStructure && (e = e.toLowerCase());
          const t = this._audioFiles.get(e);
          if (!t) return null;
          let i = null;
          for (const o of t.formats) if (i || "audio/webm; codecs=opus" !== o.type || (i = o), this.IsAudioFormatSupported(o.type)) return o;
          return i;
        }
        GetProjectAudioFileUrl(e) {
          const t = this.GetPreferredAudioFile(e);
          return t ? { url: this.GetMediaFileUrl(t.fullName), type: t.type } : null;
        }
        GetAudioToPreload() {
          if (this._preloadSounds) {
            const e = [];
            for (const t of this._audioFiles.values()) if (!t.isMusic) {
              const i = this.GetPreferredAudioFile(t.fileName);
              i && e.push({ originalUrl: t.fileName, url: this.GetMediaFileUrl(i.fullName), type: i.type, fileSize: i.fileSize });
            }
            return e;
          }
          return [];
        }
        _GetLocalBlobFromFileMap(e) {
          return "preview" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;
        }
        _GetLocalBlobURLFromFileMap(e) {
          let t = this._fileMapBlobUrls.get(e);
          if (!t) {
            const i = this._GetLocalBlobFromFileMap(e);
            if (!i) return e;
            t = URL.createObjectURL(i), this._fileMapBlobUrls.set(e, t);
          }
          return t;
        }
        GetIAssetManager() {
          return this._iAssetManager;
        }
        async LoadScripts(...e) {
          const t = await Promise.all(e.map((e2) => this.GetProjectFileUrl(e2)));
          if (this._runtime.IsInWorker()) if (1 === e.length) {
            const i = e[0];
            await import((C33.IsRelativeURL(i) ? "./" : "") + i);
          } else {
            const o = e.map((e2) => `import "${C33.IsRelativeURL(e2) ? "./" : ""}${e2}";`).join("\n"), s = URL.createObjectURL(new Blob([o], { type: "application/javascript" }));
            await import(s);
          }
          else await Promise.all(t.map((e2) => AddScript2(e2)));
        }
        async CompileWebAssembly(e) {
          if (WebAssembly.compileStreaming) {
            const t = await this.GetProjectFileUrl(e);
            return WebAssembly.compileStreaming(fetch(t));
          }
          {
            const i = await C33.FetchArrayBuffer(e);
            return WebAssembly.compile(i);
          }
        }
        async LoadStyleSheet(e) {
          const t = await this.GetProjectFileUrl(e);
          return this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", { "url": t });
        }
      };
    }
    var GetTypeFromFileExtension;
    var AddScript;
    {
      const C33 = self.C3;
      C33.Asset = class extends C33.DefendedBase {
        constructor(s, e) {
          super(), this._assetManager = s, this._runtime = s.GetRuntime(), this._url = e.url || "", this._size = e.size, this._loadPolicy = e.loadPolicy, this._blob = e.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;
        }
        Release() {
          this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;
        }
        GetURL() {
          return this._url;
        }
        GetSize() {
          return this._size;
        }
        Load() {
          return "local" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s) => (this._isLoaded = true, this._loadPromise = null, this._blob = s)).catch((s) => {
            console.error("Error loading resource: ", s), this._loadPromise = null;
          })), this._loadPromise);
        }
        IsLoaded() {
          return this._isLoaded;
        }
        GetBlob() {
          return this._blob ? Promise.resolve(this._blob) : this._loadPromise || this._assetManager.FetchBlob(this._url, this._loadPolicy);
        }
      };
    }
    {
      const C33 = self.C3, promiseThrottle = new C33.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();
      C33.ImageAsset = class extends C33.Asset {
        constructor(e, t) {
          super(e, t), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, allImageAssets.add(this);
        }
        Release() {
          if (0 !== this._refCount) throw new Error("released image asset which still has texture references");
          this._assetManager._ReleaseAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();
        }
        static OnRendererContextLost() {
          for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;
        }
        LoadStaticTexture(e, t) {
          return t = t || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t)), this._texturePromise);
        }
        async _DoLoadStaticTexture(t, s) {
          try {
            const r = await this.GetBlob();
            return 0 === this._refCount ? this._texturePromise = null : await promiseThrottle.Add(async () => {
              const e = await t.CreateStaticTextureAsync(r, s);
              return this._texturePromise = null, 0 === this._refCount ? (t.DeleteTexture(e), null) : (this._webglTexture = e, this._imageWidth = e.GetWidth(), this._imageHeight = e.GetHeight(), this._webglTexture);
            });
          } catch (e) {
            throw console.error("Failed to load texture: ", e), e;
          }
        }
        ReleaseTexture() {
          if (this._refCount <= 0) throw new Error("texture released too many times");
          if (this._refCount--, 0 === this._refCount && this._webglTexture) {
            const e = this._webglTexture.GetRenderer();
            e.DeleteTexture(this._webglTexture), this._webglTexture = null;
          }
        }
        GetRefCount() {
          return this._refCount;
        }
        GetTexture() {
          return this._webglTexture;
        }
        GetWidth() {
          return this._imageWidth;
        }
        GetHeight() {
          return this._imageHeight;
        }
        async LoadToDrawable() {
          const e = await this.GetBlob();
          return C33.Supports.ImageBitmap ? createImageBitmap(e) : C33.BlobToImage(e);
        }
      };
    }
    {
      let SortByInstLastCachedZIndex2 = function(e, s) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - s.GetWorldInfo()._GetLastCachedZIndex();
      };
      SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2;
      const C33 = self.C3, assert = self.assert;
      C33.RenderCell = class extends C33.DefendedBase {
        constructor(e, s, n) {
          super(), this._grid = e, this._x = s, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;
        }
        Release() {
          C33.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;
        }
        Reset() {
          C33.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;
        }
        SetChanged() {
          this._isSorted = false;
        }
        IsEmpty() {
          if (this._instances.length) {
            if (this._instances.length > this._pendingRemoval.size) return false;
            this._FlushPending();
          }
          return true;
        }
        Insert(e) {
          this._pendingRemoval.has(e) ? (this._pendingRemoval.delete(e), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false)) : (this._instances.push(e), this._isSorted = 1 === this._instances.length);
        }
        Remove(e) {
          this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, 50 <= this._pendingRemoval.size && this._FlushPending();
        }
        _FlushPending() {
          this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ? this.Reset() : (C33.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false));
        }
        _EnsureSorted() {
          this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex2), this._isSorted = true);
        }
        Dump(e) {
          this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);
        }
      };
    }
    var SortByInstLastCachedZIndex;
    {
      const C33 = self.C3;
      C33.RenderGrid = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._cellWidth = e, this._cellHeight = t, this._cells = C33.New(C33.PairMap);
        }
        Release() {
          this._cells.Release(), this._cells = null;
        }
        GetCell(e, t, l) {
          let s = this._cells.Get(e, t);
          return s || (l ? (s = C33.New(C33.RenderCell, this, e, t), this._cells.Set(e, t, s), s) : null);
        }
        XToCell(e) {
          return Math.floor(e / this._cellWidth);
        }
        YToCell(e) {
          return Math.floor(e / this._cellHeight);
        }
        Update(s, o, i) {
          if (o) {
            for (let l = o.getLeft(), e = o.getRight(); l <= e; ++l) for (let e2 = o.getTop(), t = o.getBottom(); e2 <= t; ++e2) if (!i || !i.containsPoint(l, e2)) {
              const h = this.GetCell(l, e2, false);
              h && (h.Remove(s), h.IsEmpty()) && this._cells.Delete(l, e2);
            }
          }
          if (i) for (let l = i.getLeft(), e = i.getRight(); l <= e; ++l) for (let e2 = i.getTop(), t = i.getBottom(); e2 <= t; ++e2) o && o.containsPoint(l, e2) || this.GetCell(l, e2, true).Insert(s);
        }
        QueryRange(e, t) {
          let l = this.XToCell(e.getLeft());
          const s = this.YToCell(e.getTop()), o = this.XToCell(e.getRight()), i = this.YToCell(e.getBottom());
          for (; l <= o; ++l) for (let e2 = s; e2 <= i; ++e2) {
            const h = this.GetCell(l, e2, false);
            h && h.Dump(t);
          }
        }
        MarkRangeChanged(e) {
          let t = e.getLeft();
          const l = e.getTop(), s = e.getRight(), o = e.getBottom();
          for (; t <= s; ++t) for (let e2 = l; e2 <= o; ++e2) {
            const i = this.GetCell(t, e2, false);
            i && i.SetChanged();
          }
        }
      };
    }
    {
      let SortByInstLastCachedZIndex2 = function(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex();
      }, SortByInstZElevation2 = function(e, t) {
        return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation();
      };
      SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2, SortByInstZElevation = SortByInstZElevation2;
      const C33 = self.C3, assert = self.assert, tmpRect = new C33.Rect(), tmpQuad = new C33.Quad(), renderCellArr = [], tmpDestRect = new C33.Rect(), tmpSrcRect = new C33.Rect(), glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, mat42 = glMatrix.mat4, tempMat4 = mat42.create(), tempVec3 = vec32.create(), tempVec4 = vec42.create(), camVector = vec32.create(), lookVector = vec32.create(), upVector = vec32.create(), tempVec2 = C33.New(C33.Vector2), tempRect = C33.New(C33.Rect);
      const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: "", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] };
      C33.Layer = class extends C33.DefendedBase {
        constructor(e, t, s) {
          super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t, this._name = s.name, this._index = -1, this._isHTMLElementsLayer = !!s.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s.sid, this._isDynamic = !!s.isDynamic, this._isVisible = !!s.isVisible, this._isInteractive = !!s.isInteractive, this._backgroundColor = C33.New(C33.Color), this._backgroundColor.setFromJSON(s.backgroundColor), this._isTransparent = !!s.isTransparent, this._parallaxX = s.parallax[0], this._parallaxY = s.parallax[1], this._color = C33.New(C33.Color, 1, 1, 1, s.opacity), this._premultipliedColor = C33.New(C33.Color), this._isForceOwnTexture = !!s.isForceOwnTexture, this._renderAs3d = !!s.renderAs3d, this._useCameraDistanceDrawOrder = !!s.useCameraDistanceDrawOrder, this._useRenderCells = !!s.useRenderCells, this._scaleRate = s.scaleRate, this._blendMode = s.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C33.New(C33.Rect), this._viewportZ0 = C33.New(C33.Rect), this._viewport3D = C33.New(C33.Rect), this._isViewportChanged = true, this._projectionMatrix = mat42.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat42.create(), this._isMVMatrixChanged = true, this._viewFrustum = C33.New(C33.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;
          const i = this._runtime.GetCanvasManager();
          this._effectList = C33.New(C33.EffectList, this, s.effectListData), this._effectChain = C33.New(C33.Gfx.EffectChain, i.GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s2 = t2.GetContentObject(), a = s2.GetRenderTarget();
            e2.SetColor(s2.GetPremultipliedColor()), e2.DrawRenderTarget(a), e2.InvalidateRenderTarget(a), i.ReleaseAdditionalRenderTarget(a);
          }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._curRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C33.New(C33.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s.subLayersData.map((e2) => C33.Layer.CreateFromExportData(this._layout, this, e2));
        }
        _InitInitialInstances() {
          for (const e of this._initialInstancesData) {
            const t = this._runtime.GetObjectClassByIndex(e[1]);
            this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);
          }
          C33.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;
        }
        static CreateFromExportData(e, t, s) {
          return C33.New(C33.Layer, e, t, { name: s[0], sid: s[2], isVisible: s[3], isInteractive: s[13], isHTMLElementsLayer: s[19], backgroundColor: s[4].map((e2) => e2 / 255), isTransparent: s[5], parallax: [s[6], s[7]], opacity: s[8], isForceOwnTexture: s[9], renderAs3d: s[17], useCameraDistanceDrawOrder: s[18], useRenderCells: s[10], scaleRate: s[11], blendMode: s[12], zElevation: s[16], initialInstancesData: s[14], effectListData: s[15], subLayersData: s[20] });
        }
        Release() {
          for (const e of this._subLayers) e.Release();
          C33.clearArray(this._subLayers);
          for (const t of this._instances) this._runtime.DestroyInstance(t);
          C33.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;
        }
        GetInitialInstanceData(e) {
          return this._initialUIDsToInstanceData.get(e);
        }
        CreateInitialInstances(s) {
          const a = this._layout.IsFirstVisit();
          let i = 0;
          const r = this._initialInstances;
          for (let t = 0, e = r.length; t < e; ++t) {
            const n = r[t], l = this._runtime.GetObjectClassByIndex(n[1]);
            let e2 = true;
            if (!l.HasPersistBehavior() || a) {
              const o = this._runtime.CreateInstanceFromData(n, this, true);
              s.push(o), l.IsGlobal() && (e2 = false, this._createdGlobalUids.push(o.GetUID()));
            }
            e2 && (r[i] = r[t], ++i);
          }
          C33.truncateArray(r, i), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();
        }
        _AddInstance(e, t) {
          if (!e.GetPlugin().IsWorldType()) throw new Error("instance is not of world type");
          const s = e.GetWorldInfo();
          if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
          this._instances.push(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);
        }
        _MaybeAddInstance(e) {
          this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));
        }
        _PrependInstance(e, t) {
          const s = e.GetWorldInfo();
          if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
          this._instances.unshift(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();
        }
        _RemoveInstance(e, t) {
          const s = this._instances.indexOf(e);
          s < 0 || (t && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());
        }
        _SetAnyInstanceZElevated() {
          this._anyInstanceZElevated = true;
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
          0 === this._instances.length && (this._anyInstanceZElevated = false);
        }
        _SortInstancesByLastCachedZIndex(e) {
          if (e) {
            const t = /* @__PURE__ */ new Set();
            for (const s of this._instances) {
              const a = s.GetWorldInfo()._GetLastCachedZIndex();
              0 <= a && t.add(a);
            }
            let e2 = -1;
            for (const i of this._instances) {
              const r = i.GetWorldInfo();
              if (!(0 <= r._GetLastCachedZIndex())) {
                for (++e2; t.has(e2); ) ++e2;
                r._SetZIndex(e2);
              }
            }
          }
          this._instances.sort(SortByInstLastCachedZIndex2);
        }
        _Start() {
        }
        _End() {
          for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
          this._runtime.FlushPendingInstances(), C33.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();
        }
        RecreateInitialObjects(t, e, s, a, i, r) {
          const n = this._runtime.GetEventSheetManager(), l = this._runtime.GetAllObjectClasses(), o = t.IsFamily(), h = [];
          for (const c of this._initialInstances) {
            const d = c[0], _ = d[0], u = d[1];
            if (e.containsPoint(_, u)) {
              const G = l[c[1]];
              if (G !== t) {
                if (!o) continue;
                if (!t.FamilyHasMember(G)) continue;
              }
              let e2 = i;
              if (!e2) {
                const I = this._runtime.GetCurrentLayout();
                e2 = this.GetLayout() === I ? this : (e2 = I.GetLayerByName(this.GetName())) || I.GetLayerByIndex(this.GetIndex());
              }
              const f = this._runtime.CreateInstanceFromData(c, e2, false, void 0, void 0, false, r), p = (e2.SortAndAddInstancesByZIndex(f), f.GetWorldInfo());
              p.OffsetXY(s, a), p.SetBboxChanged(), n.BlockFlushingInstances(true), f._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h.push(f);
            }
          }
          return h;
        }
        GetInstanceCount() {
          return this._instances.length;
        }
        GetLayout() {
          return this._layout;
        }
        GetName() {
          return this._name;
        }
        _SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        _SetHTMLIndex(e) {
          this._htmlIndex = e;
        }
        GetHTMLIndex() {
          return this._htmlIndex;
        }
        IsHTMLElementsLayer() {
          return this._isHTMLElementsLayer;
        }
        SetIsHTMLElementsLayer(e) {
          this._isHTMLElementsLayer !== (e = !!e) && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());
        }
        _GetSiblingIndex() {
          let e = -1;
          const t = this.GetParentLayer();
          return e = (t ? t.GetSubLayers() : this.GetLayout()._GetRootLayers()).indexOf(this);
        }
        GetSID() {
          return this._sid;
        }
        GetRuntime() {
          return this._runtime;
        }
        IsDynamic() {
          return this._isDynamic;
        }
        HasAnyDynamicParentLayer() {
          for (const e of this.parentLayers()) if (e.IsDynamic()) return true;
          return false;
        }
        GetDevicePixelRatio() {
          return this._runtime.GetDevicePixelRatio();
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = this.HasDefaultColor();
          if (this._needsRebuildEffectChainSteps || e !== this._wasDefaultColor || this._effectChain.NeedsRebuild()) {
            const t = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;
          }
        }
        UpdateActiveEffects() {
          this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
        }
        UsesRenderCells() {
          return this._useRenderCells && !this._useCameraDistanceDrawOrder;
        }
        GetRenderGrid() {
          return this._renderGrid;
        }
        SetRenderListStale() {
          this._isRenderListUpToDate = false;
        }
        IsVisible() {
          for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;
          return true;
        }
        _IsVisibleFlagSet() {
          return this._isVisible;
        }
        SetVisible(e) {
          this._isVisible !== (e = !!e) && (this._isVisible = e, this._runtime.UpdateRender());
        }
        SetInteractive(e) {
          this._isInteractive = !!e;
        }
        IsInteractive() {
          return this._isInteractive;
        }
        IsSelfAndParentsInteractive() {
          for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;
          return true;
        }
        SetOwnScrollPositionEnabled(e) {
          if (this._hasOwnScrollPosition !== (e = !!e)) {
            if (this._hasOwnScrollPosition = e) {
              const t = this.GetLayout();
              this._scrollX = t.GetScrollX(), this._scrollY = t.GetScrollY();
            }
            this._SetMVMatrixChanged(), this._runtime.UpdateRender();
          }
        }
        IsOwnScrollPositionEnabled() {
          return this._hasOwnScrollPosition;
        }
        SetScrollX(e) {
          const t = this.GetLayout(), s = t.GetScrollLeftBound(), a = t.GetScrollRightBound();
          this._scrollX !== (e = (e = a < e ? a : e) < s ? s : e) && (this._scrollX = e, this.IsOwnScrollPositionEnabled()) && (this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        SetScrollY(e) {
          const t = this.GetLayout(), s = t.GetScrollTopBound(), a = t.GetScrollBottomBound();
          this._scrollY !== (e = (e = a < e ? a : e) < s ? s : e) && (this._scrollY = e, this.IsOwnScrollPositionEnabled()) && (this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetScrollX() {
          return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();
        }
        GetScrollY() {
          return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();
        }
        GetViewport() {
          return this._MaybeUpdateViewport(), this._viewport;
        }
        _GetViewportZ0() {
          return this._MaybeUpdateViewport(), this._viewportZ0;
        }
        GetViewport3D() {
          return this._MaybeUpdateViewport(), this._viewport3D;
        }
        _GetVanishingPoint() {
          const e = this.GetLayout();
          return [e.GetVanishingPointX(), e.GetVanishingPointY()];
        }
        GetDefaultCameraZ(e) {
          return this._runtime.GetDefaultCameraZ(e);
        }
        GetViewportForZ(l, o) {
          const h = this._GetViewportZ0();
          if (0 === l) o.copy(h);
          else {
            let s = h.midX(), a = h.midY(), e = this.Get2DScaleFactorToZ(l), t = h.width() / e, i = h.height() / e, [r, n] = this._GetVanishingPoint();
            if (0.5 !== r || 0.5 !== n) {
              const c = this.Get2DCameraZ(), d = this._runtime, _ = this.GetDefaultCameraZ() / c;
              let e2 = (r - 0.5) * d.GetViewportWidth() / _, t2 = (n - 0.5) * d.GetViewportHeight() / _;
              const u = this.GetAngle(), G = (0 !== u && (tempVec2.set(e2, t2), tempVec2.rotate(u), e2 = tempVec2.getX(), t2 = tempVec2.getY()), C33.unlerp(c, 0, l));
              s += C33.lerp(e2, 0, G), a += C33.lerp(t2, 0, G);
            }
            o.set(s - t / 2, a - i / 2, s + t / 2, a + i / 2);
          }
        }
        GetOpacity() {
          return this._color.getA();
        }
        SetOpacity(e) {
          e = C33.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());
        }
        _UpdatePremultipliedColor() {
          this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();
        }
        GetPremultipliedColor() {
          return this._premultipliedColor;
        }
        HasDefaultColor() {
          return this._color.equalsRgba(1, 1, 1, 1);
        }
        GetScaleRate() {
          return this._scaleRate;
        }
        SetScaleRate(e) {
          this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetParallaxX() {
          return this._parallaxX;
        }
        GetParallaxY() {
          return this._parallaxY;
        }
        SetParallax(e, t) {
          this._parallaxX === e && this._parallaxY === t || (this._parallaxX = e, this._parallaxY = t, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        SetParallaxX(e) {
          this.SetParallax(e, this.GetParallaxY());
        }
        SetParallaxY(e) {
          this.SetParallax(this.GetParallaxX(), e);
        }
        SetZElevation(e) {
          this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());
        }
        GetZElevation() {
          return this._zElevation;
        }
        SetAngle(e) {
          e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetAngle() {
          return C33.clampAngle(this._layout.GetAngle() + this._angle);
        }
        GetOwnAngle() {
          return this._angle;
        }
        HasInstances() {
          return 0 < this._instances.length;
        }
        _GetInstances() {
          return this._instances;
        }
        _GetInstancesInDrawOrder() {
          return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C33.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t) => this._SortInstancesByCameraDistance(e, t)), tempInstancesByCameraDist) : this._GetInstances();
        }
        _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {
          C33.appendArray(e, this._GetInstancesInDrawOrder());
          for (const t of this._subLayers) t.IsVisible() && 0 < t.GetOpacity() && t._AppendAllInstancesIncludingSubLayersInDrawOrder(e);
        }
        _SortInstancesByCameraDistance(e, t) {
          const s = this.GetLayout().Get3DCameraPosition(), a = s[0], i = s[1], r = s[2], n = e.GetWorldInfo(), l = t.GetWorldInfo(), o = n.GetX() - a, h = n.GetY() - i, c = n.GetZElevation() - r, d = l.GetX() - a, _ = l.GetY() - i, u = l.GetZElevation() - r;
          return d * d + _ * _ + u * u - (o * o + h * h + c * c);
        }
        GetBackgroundColor() {
          return this._backgroundColor;
        }
        IsTransparent() {
          return this._isTransparent;
        }
        SetTransparent(e) {
          this._isTransparent !== (e = !!e) && (this._isTransparent = e, this._runtime.UpdateRender());
        }
        IsForceOwnTexture() {
          return this._isForceOwnTexture;
        }
        SetForceOwnTexture(e) {
          this._isForceOwnTexture !== (e = !!e) && (this._isForceOwnTexture = e, this._runtime.UpdateRender());
        }
        RendersIn2DMode() {
          return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;
        }
        RendersIn3DMode() {
          return !this.RendersIn2DMode();
        }
        Has3DCamera() {
          return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();
        }
        SelfAndAllSubLayersHave3DCamera() {
          if (!this.Has3DCamera()) return false;
          for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;
          return true;
        }
        SetBlendMode(e) {
          this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());
        }
        GetBlendMode() {
          return this._blendMode;
        }
        IsRootLayer() {
          return !this._parentLayer;
        }
        GetParentLayer() {
          return this._parentLayer;
        }
        _SetParentLayer(e) {
          this._parentLayer = e;
        }
        GetSubLayers() {
          return this._subLayers;
        }
        HasAnySubLayers() {
          return 0 < this._subLayers.length;
        }
        _AddSubLayer(e, t = true) {
          t ? this._subLayers.push(e) : this._subLayers.unshift(e);
        }
        _InsertSubLayer(e, t, s) {
          let a = this._subLayers.indexOf(t);
          if (-1 === a) throw new Error("cannot find layer to insert by");
          s && ++a, this._subLayers.splice(a, 0, e);
        }
        _RemoveSubLayer(e) {
          const t = this._subLayers.indexOf(e);
          if (-1 === t) throw new Error("cannot find layer to remove");
          this._subLayers.splice(t, 1);
        }
        HasAnyVisibleSubLayer() {
          for (const e of this._subLayers) if (e.ShouldDraw()) return true;
          return false;
        }
        *selfAndAllSubLayers() {
          for (const e of this._subLayers) yield* e.selfAndAllSubLayers();
          yield this;
        }
        *parentLayers() {
          let e = this.GetParentLayer();
          for (; e; ) yield e, e = e.GetParentLayer();
        }
        *selfAndParentLayers() {
          yield this, yield* this.parentLayers();
        }
        HasParentLayer(e) {
          for (const t of this.parentLayers()) if (t === e) return true;
          return false;
        }
        IsTransformCompatibleWith(e) {
          return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();
        }
        SaveTransform() {
          return { "parallaxX": this.GetParallaxX(), "parallaxY": this.GetParallaxY(), "scale": this.GetOwnScale(), "scaleRate": this.GetScaleRate(), "angle": this.GetOwnAngle(), "hasOwnScroll": this.IsOwnScrollPositionEnabled(), "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY() };
        }
        RestoreTransform(e) {
          this.SetParallax(e["parallaxX"], e["parallaxY"]), this.SetOwnScale(e["scale"]), this.SetScaleRate(e["scaleRate"]), this.SetAngle(e["angle"]), this.SetOwnScrollPositionEnabled(e["hasOwnScroll"]), this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this._MaybeUpdateViewport();
        }
        _RemoveAllInstancesInSet(e) {
          if (0 !== e.size) {
            const t = C33.arrayRemoveAllInSet(this._instances, e);
            0 < t && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());
          }
        }
        SetZIndicesChanged(e) {
          this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);
        }
        _UpdateZIndices() {
          if (!this._zIndicesUpToDate) {
            if (this._instances.sort(SortByInstZElevation2), this.UsesRenderCells()) for (let e = 0, t = this._instances.length; e < t; ++e) {
              const s = this._instances[e].GetWorldInfo();
              s._SetZIndex(e), this._renderGrid.MarkRangeChanged(s.GetRenderCellRange());
            }
            else for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);
            this._zIndicesUpToDate = true;
          }
        }
        _UpdateHTMLZIndices() {
          if (!this._htmlZIndicesUpToDate) {
            const t = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()), s = t.map((e2) => [...e2.selfAndAllSubLayers()]).flat();
            let e = 0;
            for (const a of s) {
              for (const i of a._GetInstances()) i.GetObjectClass().GetPlugin().IsHTMLElementType() && i.GetWorldInfo()._SetHTMLZIndex(e++);
              a._SetHTMLZIndicesUpToDate();
            }
          }
        }
        _SetHTMLZIndicesUpToDate() {
          this._htmlZIndicesUpToDate = true;
        }
        _GetHTMLLayerDOMState() {
          return { "isVisible": this.IsVisible(), "opacity": this.GetOpacity(), "isInteractive": this.IsInteractive() };
        }
        MoveInstanceAdjacent(e, t, s) {
          const a = e.GetWorldInfo(), i = t.GetWorldInfo();
          if (a.GetLayer() !== this || i.GetLayer() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
          const r = a.GetZIndex();
          let n = i.GetZIndex();
          return r !== n + (s ? 1 : -1) && (C33.arrayRemove(this._instances, r), r < n && n--, s && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);
        }
        _MergeSortedZArrays(e, t) {
          const s = [];
          let a = 0, i = 0, r = e.length, n = t.length;
          for (; a < r && i < n; ) {
            const l = e[a], o = t[i];
            l.GetWorldInfo()._GetLastCachedZIndex() < o.GetWorldInfo()._GetLastCachedZIndex() ? (s.push(l), ++a) : (s.push(o), ++i);
          }
          for (; a < r; ++a) s.push(e[a]);
          for (; i < n; ++i) s.push(t[i]);
          return s;
        }
        _MergeAllSortedZArrays_pass(t) {
          const s = [], a = t.length;
          for (let e = 0; e < a - 1; e += 2) {
            const i = t[e], r = t[e + 1];
            s.push(this._MergeSortedZArrays(i, r));
          }
          return a % 2 == 1 && s.push(t[a - 1]), s;
        }
        _MergeAllSortedZArrays(e) {
          for (; 1 < e.length; ) e = this._MergeAllSortedZArrays_pass(e);
          return e[0];
        }
        _GetRenderCellInstancesToDraw() {
          return this._UpdateZIndices(), C33.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];
        }
        ShouldDraw() {
          return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers();
        }
        _DrawsAnyContentInSelfOrSubLayers() {
          if (this.HasInstances() || !this.IsTransparent()) return true;
          for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;
          return false;
        }
        UsesOwnTexture() {
          return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();
        }
        SelfOrAnySubLayerUsesOwnTexture() {
          if (this.UsesOwnTexture()) return true;
          for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;
          return false;
        }
        GetRenderTarget() {
          return this._curRenderTarget;
        }
        Get2DScaleFactorToZ(e) {
          if (this._layout.IsOrthographicProjection()) return 1;
          {
            const t = this.Get3DCameraZ();
            return t / (t - e);
          }
        }
        GetResolutionScaleFactorToZ(e) {
          const t = this._runtime.GetRenderScale();
          if (this._layout.IsOrthographicProjection()) return t;
          {
            const s = this.Get3DCameraZ(), a = this.GetDefaultCameraZ();
            return a / Math.abs(s - e) * t;
          }
        }
        _SetMVMatrixChanged() {
          this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
        }
        _GetModelViewMatrix(e) {
          return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;
        }
        Get2DCameraZ(e) {
          return this.GetDefaultCameraZ(e) / this.GetNormalScale();
        }
        Get3DCameraZ() {
          return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();
        }
        GetCameraPosition() {
          if (this.Has3DCamera()) {
            const e = this.GetLayout().Get3DCameraPosition();
            return [e[0], e[1], e[2]];
          }
          return this._Get2DCameraPosition();
        }
        _Get2DCameraPosition(e = 0, t = 0, s = 0) {
          const a = this._runtime, i = this.GetLayout(), r = a.GetParallaxXOrigin(), n = a.GetParallaxYOrigin();
          let l = (this.GetScrollX() - r) * this._parallaxX + r, o = (this.GetScrollY() - n) * this._parallaxY + n, h = (a.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o)), l + e), c = o + t, d = i.IsOrthographicProjection() ? this.GetDefaultCameraZ(s) : this.Get2DCameraZ(s), [_, u] = this._GetVanishingPoint();
          if (0.5 !== _ || 0.5 !== u) {
            const G = this.GetDefaultCameraZ(s) / d;
            let e2 = (_ - 0.5) * a.GetViewportWidth() / G, t2 = (u - 0.5) * a.GetViewportHeight() / G;
            const f = this.GetAngle();
            0 !== f && (tempVec2.set(e2, t2), tempVec2.rotate(f), e2 = tempVec2.getX(), t2 = tempVec2.getY()), h += e2, c += t2;
          }
          return [h, c, d];
        }
        _CalculateModelViewMatrix(e, t, s, a, i) {
          const r = this._runtime, n = this.GetLayout();
          if (this.Has3DCamera()) {
            vec32.copy(camVector, n.Get3DCameraPosition()), vec32.copy(lookVector, n.Get3DCameraLookAt()), vec32.copy(upVector, n.Get3DCameraUpVector());
            const l = r.GetParallaxXOrigin(), o = r.GetParallaxYOrigin(), h = lookVector[0] - camVector[0], c = lookVector[1] - camVector[1], d = lookVector[2] - camVector[2];
            camVector[0] = (camVector[0] - l) * this._parallaxX + l, camVector[1] = (camVector[1] - o) * this._parallaxY + o, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + h, lookVector[1] = camVector[1] + c, lookVector[2] = camVector[2] + d;
          } else {
            const [_, u, G] = this._Get2DCameraPosition(s, a, i), f = (vec32.set(camVector, _, u, G), vec32.set(lookVector, _, u, G - 100), this.GetAngle());
            0 === f ? vec32.set(upVector, 0, 1, 0) : vec32.set(upVector, Math.sin(f), Math.cos(f), 0);
          }
          e.CalculateLookAtModelView(t, camVector, lookVector, upVector, i || r.GetViewportHeight());
        }
        _SetProjectionMatrixChanged() {
          this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
        }
        _GetProjectionMatrix(e) {
          return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;
        }
        _CalculateProjectionMatrix(e) {
          const t = this._runtime.GetCanvasManager(), [s, a] = this._GetVanishingPoint();
          if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t.GetDrawWidth(), t.GetDrawHeight());
          else if (0.5 === s && 0.5 === a) mat42.copy(this._projectionMatrix, t.GetDefaultProjectionMatrix());
          else {
            const i = t.GetDrawWidth(), r = t.GetDrawHeight();
            e.CalculatePerspectiveMatrix(this._projectionMatrix, i / r, s, a);
          }
        }
        _SetTransform(e, t = true, s = 0, a = 0, i = 0) {
          t && e.SetProjectionMatrix(this._GetProjectionMatrix(e));
          let r = null;
          r = 0 === s && 0 === a && 0 === i ? this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s, a, i), tempMat4), e.SetModelViewMatrix(r);
        }
        PrepareForDraw(e) {
          this._SetTransform(e), e.SetBaseZ(this.GetZElevation());
        }
        _MaybeStartWebGLProfiling(e) {
          let t = null;
          if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {
            const s = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
            s && (t = s.AddTimeElapsedQuery(), e.StartQuery(t));
          }
          return t;
        }
        _MaybeStartWebGPUProfiling(e) {
          if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {
            const t = 2 * (this.GetIndex() + 1);
            e.StartMeasuringRenderPassTime(t, 1 + t);
          }
        }
        Draw(e, t, s) {
          const a = this._runtime.GetCanvasManager(), i = this.UsesOwnTexture();
          let r = null;
          const n = this._MaybeStartWebGLProfiling(e);
          if (this._MaybeStartWebGPUProfiling(e), i) {
            const l = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
            "low" === a.GetCurrentFullscreenScalingQuality() && (l.width = a.GetDrawWidth(), l.height = a.GetDrawHeight()), r = this._runtime.GetAdditionalRenderTarget(l), this._curRenderTarget = r, e.SetRenderTarget(r), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);
          } else this._curRenderTarget = t, e.SetRenderTarget(t);
          if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this.GetNormalScale() > Number.EPSILON) {
            this._UpdateZIndices();
            const o = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;
            this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : o ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());
          }
          e.SetBaseZ(0), e.SetCurrentZ(0), i && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r, t, s)), n && e.EndQuery(n), this._curRenderTarget = null;
        }
        _DrawInstances(s, a) {
          const i = this.GetViewport(), r = this._curRenderTarget, n = this.GetLayout().IsOrthographicProjection(), l = this.GetLayout().HasVanishingPointOutsideViewport();
          let o = null;
          for (let e = 0, t = a.length; e < t; ++e) {
            const h = a[e];
            if (h !== o) {
              const c = (o = h).GetWorldInfo();
              c.IsVisible() && c.IsInViewport(i, l, n) && this._DrawInstanceMaybeWithEffects(h, c, s, r);
            }
          }
        }
        _DrawInstances_3DCamera(a) {
          const i = this._curRenderTarget, r = this._GetViewFrustum(), n = tempInstanceList1, l = tempInstanceList2, o = this._GetInstancesInDrawOrder();
          for (let t = 0, s = o.length; t < s; ) {
            const h = o[t], c = h.GetWorldInfo();
            if (c.IsVisible() && c.IsInViewport3D(r)) {
              (!h.RendersToOwnZPlane() || 0 < c.GetDepth()) && l.push(h);
              const d = h.GetWorldInfo().GetTotalZElevation();
              n.push(h);
              let e = t + 1;
              for (; e < s; ++e) {
                const _ = o[e], u = _.GetWorldInfo();
                if (u.IsVisible() && u.IsInViewport3D(r)) {
                  if (u.GetTotalZElevation() !== d) break;
                  (_.RendersToOwnZPlane() ? (0 < u.GetDepth() && l.push(_), n) : l).push(_);
                }
              }
              if (1 !== n.length || n[0].MustMitigateZFighting()) {
                this._DrawCoplanarInstances_3DCamera(a, n);
                for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {
                  const G = l[e2], f = G.GetWorldInfo();
                  f._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(G, f, a, i), f._SetDrawNonBackFacesOnly(false);
                }
              } else {
                this._DrawInstanceMaybeWithEffects(h, c, a, i);
                for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {
                  const p = l[e2];
                  if (p !== h) {
                    const I = p.GetWorldInfo(), C = I.GetLayer();
                    C._DrawInstanceMaybeWithEffects(p, I, a, i);
                  }
                }
              }
              t = e, C33.clearArray(n), C33.clearArray(l);
            } else ++t;
          }
        }
        _DrawCoplanarInstances_3DCamera(s, a) {
          const i = this._curRenderTarget;
          s.CoplanarStartStencilPass();
          for (let e = 0, t = a.length; e < t; ++e) {
            const r = a[e], n = r.GetWorldInfo();
            n._SetDrawBackFaceOnly(true), this._DrawInstance(r, n, s);
          }
          s.CoplanarStartColorPass();
          for (let e = 0, t = a.length; e < t; ++e) {
            const l = a[e], o = l.GetWorldInfo();
            this._DrawInstanceMaybeWithEffects(l, o, s, i), o._SetDrawBackFaceOnly(false);
          }
          s.CoplanarRestoreStandardRendering();
        }
        _DrawInstances_RenderCells(e) {
          const t = this._renderGrid, s = this._curRenderCells, a = this._lastRenderCells, i = this.GetViewport();
          let r;
          s.set(t.XToCell(i.getLeft()), t.YToCell(i.getTop()), t.XToCell(i.getRight()), t.YToCell(i.getBottom())), this._isRenderListUpToDate && s.equals(a) ? r = this._lastRenderList : (r = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a.copy(s)), this._DrawInstances(e, r), r !== this._lastRenderList && C33.shallowAssignArray(this._lastRenderList, r);
        }
        _DrawInstanceMaybeWithEffects(e, t, s, a) {
          t.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t, s, a) : this._DrawInstance(e, t, s);
        }
        _DrawInstance(e, t, s) {
          const a = t.GetRendererStateGroup();
          s.GetCurrentStateGroup() !== a && a.Apply(), e.Draw(s);
        }
        _DrawInstanceWithEffectsAndRestore(e, t, s, a) {
          this._DrawInstanceWithEffects(e, t, s, a, null) && this._SetTransform(s);
        }
        _DrawInstanceWithEffects(e, t, s, a, i) {
          const r = t.GetInstanceEffectList().GetEffectChain();
          return r.Render(s, a, { contentObject: e, blendMode: t.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t.GetBoundingBox(), drawSurfaceRect: r.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t), drawContentHook: i && i.drawContentHook, compositOffX: i && i.compositOffX, compositOffY: i && i.compositOffY, updateOwnProjection: i && i.updateOwnProjection }), s.SetBaseZ(this.GetZElevation()), r.DidChangeTransform();
        }
        _DrawLayerOwnTextureToRenderTarget(e, t, s, a) {
          const i = this._effectList.GetActiveEffectTypes(), r = this._runtime;
          0 === i.length ? (e.SetRenderTarget(s), e.SetTextureFillMode(), a && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t)), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : this.GetEffectChain().Render(e, s, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r.GetEffectDevicePixelRatioParam(), layerScale: r.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });
        }
        GetOwnScale() {
          return this._scale;
        }
        SetOwnScale(e) {
          this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());
        }
        GetRenderScale() {
          return this.GetNormalScale() * this._runtime.GetRenderScale();
        }
        GetDisplayScale() {
          return this.GetNormalScale() * this._runtime.GetDisplayScale();
        }
        GetNormalScale() {
          return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;
        }
        _MaybeUpdateViewport() {
          if (this._isViewportChanged) {
            this._isViewportChanged = false;
            const s = this._runtime.GetParallaxXOrigin(), a = this._runtime.GetParallaxYOrigin(), i = (this.GetScrollX() - s) * this._parallaxX + s, r = (this.GetScrollY() - a) * this._parallaxY + a, n = this.GetNormalScale(), l = this._runtime.GetViewportWidth() / n, o = this._runtime.GetViewportHeight() / n;
            let e = i - l / 2, t = r - o / 2;
            this._runtime.IsPixelRoundingEnabled() && (e = Math.round(e), t = Math.round(t));
            const h = this._viewportZ0, c = (h.set(e, t, e + l, t + o), this.GetAngle()), d = (0 !== c && (tmpRect.copy(h), tmpRect.offset(-h.midX(), -h.midY()), tmpQuad.setFromRotatedRect(tmpRect, c), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h.midX(), h.midY()), h.copy(tmpRect)), this._zElevation);
            this.GetViewportForZ(d, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d, this._viewport3D) : this._viewport3D.copy(this._viewport);
          }
        }
        CalculateViewport3D(e, t) {
          let s = this._runtime.GetCanvasManager(), a = s.GetCssWidth(), i = s.GetCssHeight(), [r, n] = this.CanvasCssToLayer(0, 0, e), [l, o] = this.CanvasCssToLayer(a, 0, e), [h, c] = this.CanvasCssToLayer(a, i, e), [d, _] = this.CanvasCssToLayer(0, i, e), u = Math.min(r, l, h, d), G = Math.min(n, o, c, _), f = Math.max(r, l, h, d), p = Math.max(n, o, c, _);
          isFinite(u) || (u = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(f) || (f = 1 / 0), isFinite(p) || (p = 1 / 0), t.set(u, G, f, p);
        }
        CanvasCssToLayer(e, t, s = 0) {
          return this._CanvasToLayer(e, t, s, this.GetDisplayScale());
        }
        DrawSurfaceToLayer(e, t, s = 0) {
          return this._CanvasToLayer(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());
        }
        _CanvasToLayer(e, t, s, a) {
          const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4, c = (vec42.set(h, 0, 0, l, o), e /= a, t = h[3] - t / a, this._GetProjectionMatrix(r)), d = this._GetModelViewMatrix(r), _ = tempVec3, u = C33.Gfx.UnprojectScreenToWorldZ(e, t, s, d, c, h, _);
          return u ? [_[0], _[1]] : [NaN, NaN];
        }
        CanvasCssToLayer_DefaultTransform(e, t) {
          const s = this._scale, a = this._scaleRate, i = this._parallaxX, r = this._parallaxY, n = this._angle, l = (this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged(), this.CanvasCssToLayer(e, t));
          return this._scale = s, this._scaleRate = a, this._parallaxX = i, this._parallaxY = r, this._angle = n, this._SetMVMatrixChanged(), l;
        }
        LayerToCanvasCss(e, t, s = 0) {
          return this._LayerToCanvas(e, t, s, this.GetDisplayScale());
        }
        LayerToDrawSurface(e, t, s = 0) {
          return this._LayerToCanvas(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());
        }
        _LayerToCanvas(e, t, s, a) {
          const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4, c = (vec42.set(h, 0, 0, l, o), this._GetProjectionMatrix(r)), d = this._GetModelViewMatrix(r), _ = tempVec3, u = C33.Gfx.Project(e, t, s, d, c, h, _);
          return u ? [_[0] * a, (h[3] - _[1]) * a] : [NaN, NaN];
        }
        _GetLayerToDrawSurfaceScale(e, t) {
          return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t && (e *= this.Get2DScaleFactorToZ(t)), e;
        }
        _InstanceBoxToDrawSurface(e) {
          const t = e.GetBoundingBox(), s = e.GetTotalZElevation(), a = e.GetDepth(), h = s + a, c = t.getLeft(), d = t.getTop(), _ = t.getRight(), u = t.getBottom();
          if (this.Has3DCamera()) {
            if (this._IsPointBehindNearPlane(c, d, s) || this._IsPointBehindNearPlane(_, d, s) || this._IsPointBehindNearPlane(_, u, s) || this._IsPointBehindNearPlane(c, u, s)) return null;
            if (0 < a && (this._IsPointBehindNearPlane(c, d, h) || this._IsPointBehindNearPlane(_, d, h) || this._IsPointBehindNearPlane(_, u, h) || this._IsPointBehindNearPlane(c, u, h))) return null;
          } else if (h >= this.Get2DCameraZ()) return null;
          let [G, f] = this.LayerToDrawSurface(c, d, s), [p, I] = this.LayerToDrawSurface(_, u, s);
          if (0 !== this.GetAngle() || 0 < a || this.Has3DCamera()) {
            const [C, m] = this.LayerToDrawSurface(_, d, s), [y, S] = this.LayerToDrawSurface(c, u, s);
            if (0 < a) {
              let [e2, t2] = this.LayerToDrawSurface(c, d, h), [s2, a2] = this.LayerToDrawSurface(_, d, h), [i, r] = this.LayerToDrawSurface(_, u, h), [n, l] = this.LayerToDrawSurface(c, u, h), o = Math.min(G, p, C, y, e2, s2, i, n);
              p = Math.max(G, p, C, y, e2, s2, i, n), G = o, o = Math.min(f, I, m, S, t2, a2, r, l), I = Math.max(f, I, m, S, t2, a2, r, l), f = o;
            } else {
              let e2 = Math.min(G, p, C, y);
              p = Math.max(G, p, C, y), G = e2, e2 = Math.min(f, I, m, S), I = Math.max(f, I, m, S), f = e2;
            }
          }
          return tmpRect.set(G, f, p, I), tmpRect;
        }
        _GetViewFrustum() {
          return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;
        }
        _UpdateViewFrustum() {
          const e = this._runtime.GetRenderer(), t = this._GetProjectionMatrix(e), s = this._GetModelViewMatrix(e);
          this._viewFrustum.CalculatePlanes(s, t);
        }
        _IsPointBehindNearPlane(e, t, s) {
          return this._GetViewFrustum().IsBehindNearPlane(e, t, s);
        }
        _SaveToJson() {
          const e = { "d": this.IsDynamic(), "s": this.GetOwnScale(), "a": this.GetOwnAngle(), "v": this._IsVisibleFlagSet(), "i": this.IsInteractive(), "html": this.IsHTMLElementsLayer(), "bc": this._backgroundColor.toJSON(), "t": this.IsTransparent(), "sx": this._scrollX, "sy": this._scrollY, "hosp": this._hasOwnScrollPosition, "px": this.GetParallaxX(), "py": this.GetParallaxY(), "c": this._color.toJSON(), "sr": this.GetScaleRate(), "fx": this._effectList.SaveToJson(), "cg": this._createdGlobalUids };
          return e;
        }
        _LoadFromJson(e) {
          this._isDynamic = !!e["d"], this._scale = e["s"], this._angle = e["a"], this._isVisible = !!e["v"], this._isInteractive = !e.hasOwnProperty("i") || e["i"], this._isHTMLElementsLayer = !!e["html"], this._backgroundColor.setFromJSON(e["bc"]), this._isTransparent = !!e["t"], e.hasOwnProperty("sx") && (this._scrollX = e["sx"]), e.hasOwnProperty("sy") && (this._scrollY = e["sy"]), e.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!e["hosp"]), this._parallaxX = e["px"], this._parallaxY = e["py"], this._color.setFromJSON(e["c"]), this._UpdatePremultipliedColor(), this._scaleRate = e["sr"], C33.shallowAssignArray(this._createdGlobalUids, e["cg"]), C33.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
          const s = new Set(this._createdGlobalUids);
          let a = 0;
          for (let e2 = 0, t = this._initialInstances.length; e2 < t; ++e2) s.has(this._initialInstances[e2][2]) || (this._initialInstances[a] = this._initialInstances[e2], ++a);
          C33.truncateArray(this._initialInstances, a), this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
        }
        _LoadFromJsonAfterInstances() {
          this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();
        }
        GetILayer() {
          return this._iLayer;
        }
        SortAndAddInstancesByZIndex(e, t = false) {
          if (this._instances.includes(e)) t && this._instances.sort((e2, t2) => {
            const s = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();
            return s - a;
          });
          else if (e.HasChildren()) {
            const s = [...e.allChildren()];
            s.push(e), s.sort((e2, t2) => {
              const s2 = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();
              return s2 - a;
            });
            for (const a of s) if (a.IsInContainer()) {
              for (const i of a.siblings()) if (!s.includes(i)) {
                const r = [...i.allChildren()];
                r.push(i), r.sort((e2, t2) => {
                  const s2 = e2.GetWorldInfo().GetSceneGraphZIndex(), a2 = t2.GetWorldInfo().GetSceneGraphZIndex();
                  return s2 - a2;
                }), r && r.length && s.splice(s.length, 0, ...r);
              }
            }
            for (const n of s) n.GetPlugin().IsWorldType() && this._AddInstance(n, true);
          } else if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), e.IsInContainer()) for (const l of e.siblings()) {
            const o = [...l.allChildren()];
            if (o.push(l), o.sort((e2, t2) => {
              const s = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();
              return s - a;
            }), o && o.length) for (const h of o) h.GetPlugin().IsWorldType() && this._AddInstance(h, true);
          }
        }
      };
    }
    var SortByInstLastCachedZIndex;
    var SortByInstZElevation;
    {
      let vec3EqualsXYZ2 = function(e, t, s, a) {
        return e[0] === Math.fround(t) && e[1] === Math.fround(s) && e[2] === Math.fround(a);
      }, MaybePrepareLayerDraw2 = function(e, t) {
        lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t), lastLayerPreparedForDrawing = e);
      };
      vec3EqualsXYZ = vec3EqualsXYZ2, MaybePrepareLayerDraw = MaybePrepareLayerDraw2;
      const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C33.New(C33.Rect), tempSrcRect = C33.New(C33.Rect), tempLayoutRect = C33.New(C33.Rect), tempColor = C33.New(C33.Color), glMatrix = self.glMatrix, vec32 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];
      let lastLayerPreparedForDrawing = null;
      C33.Layout = class extends C33.DefendedBase {
        constructor(e, t, s) {
          super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._isOrthographicProjection = !!s[4], this._vanishingPointX = s[5], this._vanishingPointY = s[6], this._eventSheetName = s[7], this._eventSheet = null, this._sid = s[8], this._index = t, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec32.create(), this._cam3dlook = vec32.create(), this._cam3dup = vec32.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;
          const r = this._runtime.GetCanvasManager();
          this._effectList = C33.New(C33.EffectList, this, s[11]), this._effectChain = C33.New(C33.Gfx.EffectChain, r.GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s2 = t2.GetContentObject(), a = s2.GetRenderTarget();
            e2.ResetColor(), e2.DrawRenderTarget(a), e2.InvalidateRenderTarget(a), r.ReleaseAdditionalRenderTarget(a);
          }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C33.New(C33.Event.Dispatcher);
          for (const a of s[9]) this._rootLayers.push(C33.Layer.CreateFromExportData(this, null, a));
          this._ReindexLayers();
          for (const n of this.allLayers()) n._InitInitialInstances();
          for (const i of s[10]) {
            const o = this._runtime.GetObjectClassByIndex(i[1]);
            if (!o) throw new Error("missing nonworld object class");
            o.GetDefaultInstanceData() || o.SetDefaultInstanceData(i), this._initialNonWorld.push(i), this._AddInitialObjectClass(o);
          }
        }
        Release() {
          for (const e of this._allLayersFlat) e.Release();
          C33.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetIndex() {
          return this._index;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
          if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== e || this._effectChain.NeedsRebuild()) {
            const t = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;
          }
        }
        UpdateActiveEffects() {
          this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
        }
        GetMinLayerScale() {
          let s = this._allLayersFlat[0].GetNormalScale();
          for (let e = 1, t = this._allLayersFlat.length; e < t; ++e) {
            const a = this._allLayersFlat[e];
            0 === a.GetParallaxX() && 0 === a.GetParallaxY() || (s = Math.min(s, a.GetNormalScale()));
          }
          return s;
        }
        _GetScrollBoundMarginHorizontal() {
          return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();
        }
        _GetScrollBoundMarginVertical() {
          return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();
        }
        GetScrollLeftBound() {
          return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();
        }
        GetScrollRightBound() {
          return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();
        }
        GetScrollTopBound() {
          return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();
        }
        GetScrollBottomBound() {
          return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();
        }
        SetScrollX(e) {
          const t = this.GetScrollLeftBound(), s = this.GetScrollRightBound();
          this._scrollX !== (e = (e = s < e ? s : e) < t ? t : e) && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetScrollX() {
          return this._scrollX;
        }
        SetScrollY(e) {
          const t = this.GetScrollTopBound(), s = this.GetScrollBottomBound();
          this._scrollY !== (e = (e = s < e ? s : e) < t ? t : e) && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetScrollY() {
          return this._scrollY;
        }
        IsUnboundedScrolling() {
          return this._isUnboundedScrolling;
        }
        BoundScrolling() {
          this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());
          for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));
        }
        SetVanishingPointXY(e, t) {
          this._vanishingPointX === e && this._vanishingPointY === t || (this._vanishingPointX = e, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));
        }
        GetVanishingPointX() {
          return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;
        }
        GetVanishingPointY() {
          return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;
        }
        HasVanishingPointOutsideViewport() {
          const e = this.GetVanishingPointX(), t = this.GetVanishingPointY();
          return e < 0 || 1 < e || t < 0 || 1 < t;
        }
        SetPerspectiveProjection() {
          this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        SetOrthographicProjection() {
          this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        IsOrthographicProjection() {
          return this._isOrthographicProjection;
        }
        IsPerspectiveProjection() {
          return !this.IsOrthographicProjection();
        }
        Set3DCameraEnabled(e) {
          this._is3dCameraEnabled !== (e = !!e) && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        Is3DCameraEnabled() {
          return this._is3dCameraEnabled;
        }
        Set3DCameraOrientation(e, t, s, a, r, n, i, o, l) {
          vec3EqualsXYZ2(this._cam3dposition, e, t, s) && vec3EqualsXYZ2(this._cam3dlook, a, r, n) && vec3EqualsXYZ2(this._cam3dup, i, o, l) || (vec32.set(this._cam3dposition, e, t, s), vec32.set(this._cam3dlook, a, r, n), vec32.set(this._cam3dup, i, o, l), this.Set3DCameraChanged());
        }
        Set3DCameraChanged() {
          this._SetAllLayersMVChanged(), this._runtime.UpdateRender();
        }
        Get3DCameraPosition() {
          return this._cam3dposition;
        }
        Get3DCameraLookAt() {
          return this._cam3dlook;
        }
        Get3DCameraUpVector() {
          return this._cam3dup;
        }
        GetScale() {
          return this._scale;
        }
        SetScale(e) {
          this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());
        }
        SetAngle(e) {
          e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
        }
        GetAngle() {
          return this._angle;
        }
        GetWidth() {
          return this._width;
        }
        SetWidth(e) {
          !isFinite(e) || e < 1 || (this._width = e);
        }
        GetHeight() {
          return this._height;
        }
        SetHeight(e) {
          !isFinite(e) || e < 1 || (this._height = e);
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        _GetRootLayers() {
          return this._rootLayers;
        }
        *allLayers() {
          for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();
        }
        GetLayers() {
          return this._allLayersFlat;
        }
        GetLayerCount() {
          return this._allLayersFlat.length;
        }
        GetLayer(e) {
          return "number" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());
        }
        GetLayerByIndex(e) {
          return e = C33.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];
        }
        GetLayerByName(e) {
          return this._layersByName.get(e.toLowerCase()) || null;
        }
        HasLayerByName(e) {
          return !!this.GetLayerByName(e);
        }
        GetLayerBySID(e) {
          return this._layersBySid.get(e) || null;
        }
        _SetAllLayersProjectionChanged() {
          for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();
        }
        _SetAllLayersMVChanged() {
          for (const e of this._allLayersFlat) e._SetMVMatrixChanged();
        }
        AddLayer(e, t, s) {
          if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);
          if (!t && s < 2) throw new Error("invalid insert position");
          const a = 2 <= s ? t : t.GetParentLayer(), r = C33.New(C33.Layer, this, a, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });
          this._InsertLayer(r, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
        }
        MoveLayer(e, t, s) {
          if (!t && s < 2) throw new Error("invalid insert position");
          e === t && s < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());
        }
        RemoveLayer(e) {
          if (this._RemoveLayer(e)) {
            const t = this._runtime.GetEventSheetManager();
            t.BlockFlushingInstances(true), e.Release(), t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
          }
        }
        RemoveAllDynamicLayers() {
          const e = /* @__PURE__ */ new Set();
          for (const t of this.allLayers()) t.IsDynamic() && !t.HasAnyDynamicParentLayer() && e.add(t);
          if (0 !== e.size) {
            const s = this._runtime.GetEventSheetManager();
            s.BlockFlushingInstances(true);
            for (const a of e) this._RemoveLayer(a), a.Release();
            s.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
          }
        }
        _InsertLayer(t, s, a) {
          if (2 <= a) if (s) {
            if (s === t || s.HasParentLayer(t)) throw new Error(`cannot move layer '${t.GetName()}' to sub-layer of itself`);
            s._AddSubLayer(t, 2 === a), t._SetParentLayer(s);
          } else 2 === a ? this._rootLayers.push(t) : this._rootLayers.unshift(t), t._SetParentLayer(null);
          else {
            const e = s.GetParentLayer();
            if (e) {
              if (s.HasParentLayer(t)) throw new Error(`cannot move layer '${t.GetName()}' to sub-layer of itself`);
              e._InsertSubLayer(t, s, 0 === a), t._SetParentLayer(e);
            } else {
              let e2 = this._rootLayers.indexOf(s);
              if (-1 === e2) throw new Error("cannot find layer to insert by");
              0 === a && ++e2, this._rootLayers.splice(e2, 0, t), t._SetParentLayer(null);
            }
          }
        }
        _RemoveLayer(e) {
          const t = e.GetParentLayer();
          if (t) return t._RemoveSubLayer(e), true;
          if (1 < this._rootLayers.length) {
            const s = this._rootLayers.indexOf(e);
            if (-1 === s) throw new Error("cannot find layer to remove");
            return this._rootLayers.splice(s, 1), true;
          }
          return false;
        }
        _ReindexLayers() {
          this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();
          for (let e = 0, t = this._allLayersFlat.length; e < t; ++e) {
            const s = this._allLayersFlat[e];
            s._SetIndex(e), this._layersByName.set(s.GetName().toLowerCase(), s), this._layersBySid.set(s.GetSID(), s);
          }
        }
        _ReindexHTMLLayers() {
          let e = 0;
          for (const t of this._rootLayers) {
            for (const s of t.selfAndAllSubLayers()) s._SetHTMLIndex(e);
            t.IsHTMLElementsLayer() && e++;
          }
        }
        GetHTMLLayerCount() {
          return this._rootLayers.at(-1).GetHTMLIndex() + 1;
        }
        async _ReindexAndUpdateAllLayers() {
          this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();
        }
        _GetPendingSetHTMLLayerCount() {
          return this._pendingSetHTMLLayerCount;
        }
        _ResetPendingHTMLLayerCount() {
          this._pendingSetHTMLLayerCount = -1;
        }
        GetRootLayersForHTMLLayer(e) {
          const t = [];
          for (const s of this._rootLayers) {
            const a = s.GetHTMLIndex();
            if (a === e) t.push(s);
            else if (e < a) break;
          }
          return t;
        }
        SaveTransform() {
          return { "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY(), "scale": this.GetScale(), "angle": this.GetAngle(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY() };
        }
        RestoreTransform(e) {
          this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this.SetScale(e["scale"]), this.SetAngle(e["angle"]), this.SetVanishingPointXY(e["vpX"], e["vpY"]);
        }
        GetLayoutBackgroundColor() {
          let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];
          for (; e; ) {
            if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;
            if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;
            e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];
          }
          return tempColor.setRgba(0, 0, 0, 0), tempColor;
        }
        IsFirstVisit() {
          return this._isFirstVisit;
        }
        _GetInitialObjectClasses() {
          return [...this._initialObjectClasses];
        }
        _AddInitialObjectClass(e) {
          if (e.IsInContainer()) for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);
          else this._initialObjectClasses.add(e);
        }
        _GetTextureLoadedObjectTypes() {
          return [...this._textureLoadedTypes];
        }
        _Load(e, t) {
          if (e === this || !t) return Promise.resolve();
          e && (C33.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());
          const s = [];
          for (const a of this._initialObjectClasses) this._textureLoadedTypes.has(a) || (s.push(a.LoadTextures(t)), this._textureLoadedTypes.add(a));
          return Promise.all(s);
        }
        async MaybeLoadTexturesFor(e) {
          if (e.IsFamily()) throw new Error("cannot load textures for family");
          const t = this._runtime.GetRenderer();
          if (t && !t.IsContextLost() && !this._textureLoadedTypes.has(e)) {
            this._textureLoadedTypes.add(e);
            const s = e.LoadTextures(t);
            this._AddPendingTextureLoadPromise(s), await s, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();
          }
        }
        _AddPendingTextureLoadPromise(e) {
          this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));
        }
        WaitForPendingTextureLoadsToComplete() {
          return Promise.all([...this._textureLoadPendingPromises]);
        }
        MaybeUnloadTexturesFor(e) {
          if (e.IsFamily() || 0 < e.GetInstanceCount()) throw new Error("cannot unload textures");
          const t = this._runtime.GetRenderer();
          t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t));
        }
        _Unload(e, t) {
          if (e !== this && t) for (const s of this._textureLoadedTypes) s.IsGlobal() || e._initialObjectClasses.has(s) || (s.ReleaseTextures(), this._textureLoadedTypes.delete(s));
        }
        _OnRendererContextLost() {
          this._textureLoadedTypes.clear();
        }
        async _StartRunning(e) {
          const t = this._runtime, s = this._layoutManager, a = t.GetEventSheetManager(), r = (this._eventSheetName && (this._eventSheet = a.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t.GetOriginalViewportWidth() / 2, this._scrollY = t.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), t.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false), this._runtime.GetCreatePromises());
          if (await Promise.all(r), C33.clearArray(r), !t.IsLoadingState()) {
            for (const n of this._createdInstances) n.SetupInitialSceneGraphConnections();
            for (const i of this._createdPersistedInstances) i.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
            for (const [o, l] of Object.entries(this._persistData)) {
              const h = this._runtime.GetObjectClassBySID(parseInt(o, 10));
              h && !h.IsFamily() && h.HasPersistBehavior() && C33.clearArray(l);
            }
            for (const c of this._createdInstances) c._TriggerOnCreated();
            for (const d of this._createdPersistedInstances) d._TriggerOnCreated();
          }
          C33.clearArray(this._createdInstances), C33.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t.Dispatcher().dispatchEvent(new C33.Event("beforefirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C33.Event("beforeprojectstart"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("beforeanylayoutstart")), t.Dispatcher().dispatchEvent(new C33.Event("beforelayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("beforelayoutstart")), t.IsLoadingState() || await t.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutStart, null, null), t.Dispatcher().dispatchEvent(new C33.Event("afterlayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("afterlayoutstart")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("afteranylayoutstart")), e && (t.Dispatcher().dispatchEvent(new C33.Event("afterfirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new C33.Event("afterprojectstart"))), a._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;
        }
        _MoveGlobalObjectsToThisLayout(e) {
          for (const t of this._runtime.GetAllObjectClasses()) if (!t.IsFamily() && t.IsWorldType()) for (const s of t.GetInstances()) {
            const a = s.GetWorldInfo(), r = a.GetLayer(), n = C33.clamp(r.GetIndex(), 0, this._allLayersFlat.length - 1), i = this._allLayersFlat[n];
            a._SetLayer(i, true), i._MaybeAddInstance(s);
          }
          if (!e) for (const o of this._allLayersFlat) o._SortInstancesByLastCachedZIndex(false);
        }
        _CreateInitialInstances() {
          for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();
        }
        _CreatePersistedInstances() {
          let t = false;
          for (const [e, s] of Object.entries(this._persistData)) {
            const a = this._runtime.GetObjectClassBySID(parseInt(e, 10));
            if (a && !a.IsFamily() && a.HasPersistBehavior()) for (const r of s) {
              let e2 = null;
              if (!a.IsWorldType() || (e2 = r.hasOwnProperty("instJson") ? this.GetLayerBySID(r["instJson"]["w"]["l"]) : this.GetLayerBySID(r["w"]["l"]))) {
                const n = this._runtime.CreateInstanceFromData(a, e2, false, 0, 0, true);
                r.hasOwnProperty("instJson") ? n.LoadFromJson(r["instJson"]) : n.LoadFromJson(r), t = true, this._createdPersistedInstances.push(n), r.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(n, r), this._createdPersistedIndexToInstanceMap.set(r["index"], n));
              }
            }
          }
          for (const i of this._allLayersFlat) i._SortInstancesByLastCachedZIndex(true), i.SetZIndicesChanged();
          t && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());
        }
        _CreateAndLinkContainerInstances(t) {
          for (const s of t) if (s.IsInContainer()) {
            const a = s.GetWorldInfo(), e = s.GetIID();
            for (const r of s.GetObjectClass().GetContainer().objectTypes()) if (r !== s.GetObjectClass()) {
              const n = r.GetInstances();
              if (n.length > e) s._AddSibling(n[e]);
              else {
                let e2;
                e2 = a ? this._runtime.CreateInstanceFromData(r, a.GetLayer(), true, a.GetX(), a.GetY(), true) : this._runtime.CreateInstanceFromData(r, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), r._UpdateIIDs(), s._AddSibling(e2), t.push(e2);
              }
            }
          }
        }
        _CreateInitialNonWorldInstances() {
          for (const e of this._initialNonWorld) {
            const t = this._runtime.GetObjectClassByIndex(e[1]);
            t.IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);
          }
        }
        _CreateGlobalNonWorlds() {
          const s = [], a = this._initialNonWorld;
          let r = 0;
          for (let e = 0, t = a.length; e < t; ++e) {
            const n = a[e], i = this._runtime.GetObjectClassByIndex(n[1]);
            i.IsGlobal() ? i.IsInContainer() && i.GetContainer().HasAnyWorldType() || s.push(this._runtime.CreateInstanceFromData(n, null, true)) : (a[r] = n, ++r);
          }
          C33.truncateArray(a, r), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(s);
        }
        RecreateInitialObjects(e, t, s, a, r, n, i) {
          if (s) return s.RecreateInitialObjects(e, t, r, n, a, i);
          {
            const o = [];
            for (const l of this._allLayersFlat) o.push(l.RecreateInitialObjects(e, t, r, n, a, i));
            return o.flat();
          }
        }
        async _StopRunning() {
          const e = this._layoutManager;
          this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("beforeanylayoutend")), await this.DispatchUserScriptEventAsyncWait(new C33.Event("beforelayoutend")), await this._runtime.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C33.Event("afterlayoutend")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event("afteranylayoutend"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();
          for (const t of this._allLayersFlat) t._End();
          for (const s of this._runtime.GetAllObjectClasses()) if (!(s.IsGlobal() || s.IsWorldType() || s.GetPlugin().IsSingleGlobal() || s.IsFamily())) {
            for (const a of s.GetInstances()) this._runtime.DestroyInstance(a);
            this._runtime.FlushPendingInstances();
          }
          e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);
        }
        _SaveInstanceToPersist(e, t) {
          const s = e.GetObjectClass().GetSID().toString(), a = (this._persistData.hasOwnProperty(s) || (this._persistData[s] = []), this._persistData[s]), r = { "index": t, "instJson": e.SaveToJson(), "sceneGraphJson": { "children": [] } };
          a.push(r), this._persistedIntances.set(e, r);
        }
        _SaveSceneGraphInfoToPersist(e) {
          const t = this._persistedIntances.get(e);
          for (const s of e.GetChildren()) {
            const a = this._persistedIntances.get(s);
            a && t["sceneGraphJson"]["children"].push({ "index": a["index"], "flags": C33.SceneGraphInfo._GetFlagsNumber(s.GetWorldInfo()) });
          }
        }
        _SavePersistData() {
          this._persistedIntances.clear();
          let e = 0;
          for (const t of this._allLayersFlat) {
            t._UpdateZIndices();
            for (const s of t._GetInstances()) {
              const a = s.GetObjectClass();
              !a.IsGlobal() && a.HasPersistBehavior() && (this._SaveInstanceToPersist(s, e), e++);
            }
          }
          for (const r of this._allLayersFlat) for (const n of r._GetInstances()) {
            const i = n.GetObjectClass();
            !i.IsGlobal() && i.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(n);
          }
          this._persistedIntances.clear();
        }
        ResetPersistData() {
          this._persistData = {}, this._isFirstVisit = true;
        }
        GetRenderTarget() {
          return this._curRenderTarget;
        }
        UsesOwnTexture() {
          const e = this._runtime, t = e.GetRenderer().IsWebGL();
          return "low" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t && e.Uses3DFeatures();
        }
        _MaybeStartDrawToOwnTexture(e) {
          const t = this._runtime.GetCanvasManager();
          if (this.UsesOwnTexture()) {
            e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);
            const s = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
            "low" === t.GetCurrentFullscreenScalingQuality() && (s.width = t.GetDrawWidth(), s.height = t.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s);
          } else this._curRenderTarget = null;
        }
        _MaybeCopyOwnTextureToBackbuffer(e) {
          this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));
        }
        _MaybeEndDrawToOwnTexture(e) {
          this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));
        }
        DrawMain(e) {
          e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();
          const t = this.GetRootLayersForHTMLLayer(0);
          this._DrawLayerList(e, this._curRenderTarget, t, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;
        }
        DrawForHTMLLayerIndex(e, t) {
          let s = null;
          this._runtime._NeedsHTMLLayerCompositing(e) && (s = this._curRenderTarget), e.SetRenderTarget(s), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();
          const a = this.GetRootLayersForHTMLLayer(t);
          this._DrawLayerList(e, s, a, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t);
        }
        _DrawLayerList(e, a, t, r) {
          const n = t.filter((e2) => e2.ShouldDraw());
          for (let t2 = 0, s = n.length; t2 < s; ) {
            const i = n[t2];
            if (i.SelfAndAllSubLayersHave3DCamera() && !i.SelfOrAnySubLayerUsesOwnTexture()) {
              tempRender3dList.push(i);
              for (let e2 = t2 + 1; e2 < s; ++e2) {
                const o = n[e2];
                if (!o.SelfAndAllSubLayersHave3DCamera() || o.SelfOrAnySubLayerUsesOwnTexture()) break;
                tempRender3dList.push(n[e2]);
              }
              if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
                this._Draw3DLayers(e, a, tempRender3dList), t2 += tempRender3dList.length, C33.clearArray(tempRender3dList);
                continue;
              }
              C33.clearArray(tempRender3dList);
            }
            i.Draw(e, a, r && 0 === t2), ++t2;
          }
        }
        _DrawLayoutOwnTextureToRenderTarget(e, t) {
          const s = this._effectList.GetActiveEffectTypes(), a = this._runtime;
          0 === s.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t), e.InvalidateRenderTarget(t), a.ReleaseAdditionalRenderTarget(t)) : (tempLayoutRect.set(0, 0, a.GetViewportWidth(), a.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));
        }
        _Draw3DLayers(a, r, e) {
          e[0].IsTransparent() || (tempColor.copyRgb(e[0].GetBackgroundColor()), tempColor.setA(1), a.Clear(tempColor));
          this._runtime.GetCanvasManager();
          a.SetDepthEnabled(true);
          const n = tempInstanceList1, i = tempInstanceList2, o = tempInstanceList3;
          for (const l of e) l._UpdateZIndices(), l._AppendAllInstancesIncludingSubLayersInDrawOrder(n);
          const t = e[0], s = t._MaybeStartWebGLProfiling(a);
          t._MaybeStartWebGPUProfiling(a);
          for (let t2 = 0, s2 = n.length; t2 < s2; ) {
            const h = n[t2], c = h.GetWorldInfo(), d = c.GetLayer();
            if (c.IsVisible() && c.IsInViewport3D(d._GetViewFrustum())) {
              (!h.RendersToOwnZPlane() || 0 < c.GetDepth()) && o.push(h);
              const _ = h.GetWorldInfo().GetTotalZElevation();
              i.push(h);
              let e2 = t2 + 1;
              for (; e2 < s2; ++e2) {
                const u = n[e2], y = u.GetWorldInfo();
                if (y.IsVisible() && y.IsInViewport3D(y.GetLayer()._GetViewFrustum())) {
                  if (y.GetTotalZElevation() !== _) break;
                  (u.RendersToOwnZPlane() ? (0 < y.GetDepth() && o.push(u), i) : o).push(u);
                }
              }
              if (1 !== i.length || i[0].MustMitigateZFighting()) {
                this._Draw3DLayersCoplanarInstances(a, r, i);
                for (let e3 = 0, t3 = o.length; e3 < t3; ++e3) {
                  const L = o[e3], p = L.GetWorldInfo(), f = p.GetLayer();
                  p._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw2(f, a), f._DrawInstanceMaybeWithEffects(L, p, a, r), p._SetDrawNonBackFacesOnly(false);
                }
              } else {
                MaybePrepareLayerDraw2(d, a), d._DrawInstanceMaybeWithEffects(h, c, a, r);
                for (let e3 = 0, t3 = o.length; e3 < t3; ++e3) {
                  const g = o[e3];
                  if (g !== h) {
                    const S = g.GetWorldInfo(), m = S.GetLayer();
                    MaybePrepareLayerDraw2(m, a), m._DrawInstanceMaybeWithEffects(g, S, a, r);
                  }
                }
              }
              t2 = e2, C33.clearArray(i), C33.clearArray(o);
            } else ++t2;
          }
          s && a.EndQuery(s), C33.clearArray(n), lastLayerPreparedForDrawing = null;
        }
        _Draw3DLayersCoplanarInstances(s, a, r) {
          s.CoplanarStartStencilPass();
          for (let e = 0, t = r.length; e < t; ++e) {
            const n = r[e], i = n.GetWorldInfo(), o = i.GetLayer();
            i._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw2(o, s), o._DrawInstance(n, i, s);
          }
          s.CoplanarStartColorPass();
          for (let e = 0, t = r.length; e < t; ++e) {
            const l = r[e], h = l.GetWorldInfo(), c = h.GetLayer();
            MaybePrepareLayerDraw2(c, s), c._DrawInstanceMaybeWithEffects(l, h, s, a), h._SetDrawBackFaceOnly(false);
          }
          s.CoplanarRestoreStandardRendering();
        }
        _SaveToJson() {
          const e = { "sx": this.GetScrollX(), "sy": this.GetScrollY(), "s": this.GetScale(), "a": this.GetAngle(), "w": this.GetWidth(), "h": this.GetHeight(), "ortho": this.IsOrthographicProjection(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY(), "fv": this._isFirstVisit, "persist": this._persistData, "fx": this._effectList.SaveToJson(), "layers": {}, "dynamicLayers": [] };
          for (const t of this._allLayersFlat) if (t.IsDynamic()) {
            const s = t.GetParentLayer();
            e["dynamicLayers"].push({ "sid": t.GetSID(), "name": t.GetName(), "parentSid": s ? s.GetSID() : null, "siblingIndex": t._GetSiblingIndex(), "data": t._SaveToJson() });
          } else e["layers"][t.GetSID().toString()] = t._SaveToJson();
          return e;
        }
        _LoadFromJson(e) {
          this._scrollX = e["sx"], this._scrollY = e["sy"], this._scale = e["s"], this._angle = e["a"], this._width = e["w"], this._height = e["h"], this._isOrthographicProjection = !!e["ortho"], e.hasOwnProperty("vpX") && (this._vanishingPointX = e["vpX"]), e.hasOwnProperty("vpY") && (this._vanishingPointY = e["vpY"]), this._isFirstVisit = !!e["fv"], this._persistData = e["persist"], this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
          for (const [t, s] of Object.entries(e["layers"])) {
            const a = parseInt(t, 10), r = this.GetLayerBySID(a);
            r && r._LoadFromJson(s);
          }
          if (e.hasOwnProperty("dynamicLayers")) {
            this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();
            const n = /* @__PURE__ */ new Map(), i = e["dynamicLayers"];
            for (let e2 = i.length - 1; 0 <= e2; --e2) {
              const o = i[e2], l = o["sid"], h = o["name"], c = o["parentSid"], d = o["siblingIndex"], _ = o["data"];
              if (this._ReindexLayers(), !this.HasLayerByName(h) && !this.GetLayerBySID(l)) {
                let e3, t;
                if (null === c) e3 = null, t = this._rootLayers;
                else {
                  if (!(e3 = this.GetLayerBySID(c))) continue;
                  t = e3.GetSubLayers();
                }
                const u = C33.New(C33.Layer, this, e3, { name: h, sid: l, isDynamic: true });
                t.push(u);
                let s = n.get(t);
                s || (s = [], n.set(t, s)), s.push({ layer: u, siblingIndex: d }), u._LoadFromJson(_);
              }
            }
            for (const [y, L] of n) {
              L.sort((e2, t) => e2.siblingIndex - t.siblingIndex);
              for (const p of L) {
                const f = p.layer, g = p.siblingIndex;
                let e2 = y.indexOf(f);
                y.splice(e2, 1), y.splice(g, 0, f);
              }
            }
          }
          this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();
        }
        GetILayout() {
          return this._iLayout;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        DispatchUserScriptEvent(e) {
          e.layout = this.GetILayout();
          const t = this._runtime, s = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
          s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && C3Debugger.AddScriptTime();
        }
        DispatchUserScriptEventAsyncWait(e) {
          return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
        }
        DispatchRuntimeUserScriptEventAsyncWait(e) {
          return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);
        }
        _LogLayerTree() {
          this._LogLayerList(this._rootLayers);
        }
        _LogLayerList(e, t = 0) {
          const s = e.slice(0);
          s.reverse();
          for (const a of s) console.log("	".repeat(t) + "- " + a.GetName()), this._LogLayerList(a.GetSubLayers(), t + 1);
        }
      };
    }
    var vec3EqualsXYZ;
    var MaybePrepareLayerDraw;
    {
      const C33 = self.C3;
      C33.LayoutManager = class extends C33.DefendedBase {
        #runtime;
        #allLayouts = [];
        #layoutsByName = /* @__PURE__ */ new Map();
        #layoutsBySid = /* @__PURE__ */ new Map();
        #mainRunningLayout = null;
        #runningSubLayouts = [];
        #firstLayout = null;
        #isEndingLayout = 0;
        #pendingChangeLayout = null;
        constructor(t) {
          super(), this.#runtime = t;
        }
        Release() {
          this.#runtime = null, this.#mainRunningLayout = null, this.#firstLayout = null, this.#pendingChangeLayout = null, C33.clearArray(this.#allLayouts), this.#layoutsByName.clear(), this.#layoutsBySid.clear(), C33.clearArray(this.#runningSubLayouts);
        }
        Create(t) {
          const n = C33.New(C33.Layout, this, this.#allLayouts.length, t);
          this.#allLayouts.push(n), this.#layoutsByName.set(n.GetName().toLowerCase(), n), this.#layoutsBySid.set(n.GetSID(), n);
        }
        GetRuntime() {
          return this.#runtime;
        }
        SetFirstLayout(t) {
          this.#firstLayout = t;
        }
        GetFirstLayout() {
          if (this.#firstLayout) return this.#firstLayout;
          if (this.#allLayouts.length) return this.#allLayouts[0];
          throw new Error("no first layout");
        }
        GetLayoutByName(t) {
          return this.#layoutsByName.get(t.toLowerCase()) || null;
        }
        GetLayoutBySID(t) {
          return this.#layoutsBySid.get(t) || null;
        }
        GetLayoutByIndex(t) {
          return t = C33.clamp(Math.floor(t), 0, this.#allLayouts.length - 1), this.#allLayouts[t];
        }
        GetLayout(t) {
          return "number" == typeof t ? this.GetLayoutByIndex(t) : this.GetLayoutByName(t.toString());
        }
        GetAllLayouts() {
          return this.#allLayouts;
        }
        _SetMainRunningLayout(t) {
          this.#mainRunningLayout = t;
        }
        GetMainRunningLayout() {
          return this.#mainRunningLayout;
        }
        _AddRunningSubLayout(t) {
          if (this.#runningSubLayouts.includes(t)) throw new Error("layout already running");
          this.#runningSubLayouts.push(t);
        }
        _RemoveRunningSubLayout(t) {
          const n = this.#runningSubLayouts.indexOf(t);
          if (-1 === n) throw new Error("layout not running");
          this.#runningSubLayouts.splice(n, 1);
        }
        *runningLayouts() {
          this.#mainRunningLayout && (yield this.#mainRunningLayout), this.#runningSubLayouts.length && (yield* this.#runningSubLayouts);
        }
        IsLayoutRunning(t) {
          return this.#mainRunningLayout === t || this.#runningSubLayouts.includes(t);
        }
        SetIsEndingLayout(t) {
          if (t) this.#isEndingLayout++;
          else {
            if (this.#isEndingLayout <= 0) throw new Error("already unset");
            this.#isEndingLayout--;
          }
        }
        IsEndingLayout() {
          return 0 < this.#isEndingLayout;
        }
        ChangeMainLayout(t) {
          this.#pendingChangeLayout = t;
        }
        ClearPendingChangeLayout() {
          this.#pendingChangeLayout = null;
        }
        IsPendingChangeMainLayout() {
          return !!this.#pendingChangeLayout;
        }
        GetPendingChangeMainLayout() {
          return this.#pendingChangeLayout;
        }
        SetAllLayerProjectionChanged() {
          const t = this.GetMainRunningLayout();
          t && t._SetAllLayersProjectionChanged();
        }
        SetAllLayerMVChanged() {
          const t = this.GetMainRunningLayout();
          t && t._SetAllLayersMVChanged();
        }
      };
    }
    {
      const C33 = self.C3, NAMES_REGEXP = new RegExp("<(.+?)>", "g");
      C33.TimelineManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._timelineDataManager = C33.New(C33.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;
        }
        Release() {
          this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;
          for (const e of this._timelines) e.Stop(), e.Release();
          C33.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C33.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C33.clearArray(this._playingTimelines), this._playingTimelines = null, C33.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C33.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;
        }
        AddRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e.addEventListener("pretick", this._tickFunc), e.addEventListener("tick2", this._tick2Func), e.addEventListener("beforelayoutchange", this._beforeLayoutChange), e.addEventListener("layoutchange", this._layoutChange), e.addEventListener("instancedestroy", this._instanceDestroy), e.addEventListener("beforeload", this._beforeLoad), e.addEventListener("afterload", this._afterLoad), e.addEventListener("afterlayoutstart", this._afterLayoutStart);
        }
        RemoveRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e.removeEventListener("pretick", this._tickFunc), e.removeEventListener("tick2", this._tick2Func), e.removeEventListener("beforelayoutchange", this._beforeLayoutChange), e.removeEventListener("layoutchange", this._layoutChange), e.removeEventListener("instancedestroy", this._instanceDestroy), e.removeEventListener("beforeload", this._beforeLoad), e.removeEventListener("afterload", this._afterLoad), e.removeEventListener("afterlayoutstart", this._afterLayoutStart);
        }
        Create(e) {
          this._timelineDataManager.Add(e);
          const i = C33.TimelineState.CreateInitial(e, this);
          this.Add(i), this.SetTimelineObjectClassesToMap(i), this._timelinesCreatedByTemplate.set(i.GetName(), 0);
        }
        CreateFromTemplate(e) {
          const i = this.GetTimelineDataManager(), t = e.GetTemplateName(), s = i.Get(t), n = C33.TimelineState.CreateFromTemplate(t + ":" + this._timelinesCreatedByTemplate.get(t), s, this);
          return this._IncreaseTemplateTimelinesCount(t), this.Add(n), n;
        }
        _IncreaseTemplateTimelinesCount(e) {
          this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);
        }
        _SetCreatedTemplateTimelinesCount() {
          for (const e of this._timelines) if (!e.IsTemplate()) {
            const i = e.GetTemplateName();
            this._IncreaseTemplateTimelinesCount(i);
          }
        }
        _ClearCreatedTemplateTimelinesCount() {
          for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);
        }
        Add(e) {
          this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);
        }
        Remove(e) {
          e.Removed(), e.IsTemplate() || (C33.arrayFindRemove(this._timelines, e), C33.arrayFindRemove(this._scheduledTimelines, e), C33.arrayFindRemove(this._playingTimelines, e), C33.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), e.IsReleased()) || e.Release();
        }
        Trigger(e) {
          this._runtime.Trigger(e, this._pluginInstance, null);
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTimelineDataManager() {
          return this._timelineDataManager;
        }
        SetPluginInstance(e) {
          this._pluginInstance = e;
        }
        GetPluginInstance() {
          return this._pluginInstance;
        }
        *GetTimelines() {
          for (const e of this._timelines) yield e;
        }
        *GetPlayingTimelines() {
          for (const e of this._playingTimelines) yield e;
        }
        SetTimelineObjectClassToMap(e, i) {
          this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i);
        }
        SetTimelineObjectClassesToMap(e) {
          for (const i of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i, e);
        }
        RemoveTimelineFromObjectClassMap(e) {
          for (const [i, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), 0 === t.size) && this._objectClassToTimelineMap.delete(i);
        }
        GetTimelinesForObjectClass(e) {
          if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);
        }
        GetTimelineOfTemplateForInstances(e, i) {
          if (i) for (const t of this._timelines) {
            const s = i.every((e2) => t.HasTrackInstance(e2.instance, e2.trackId));
            if (s && t.GetName().includes(e.GetName())) return t;
          }
        }
        GetTimelineByName(e) {
          return this._timelinesByName.get(e.toLowerCase()) || null;
        }
        GetScheduledOrPlayingTimelineByName(e) {
          for (const i of this._scheduledTimelines) if (i.GetName() === e) return i;
          for (const t of this._playingTimelines) if (t.GetName() === e) return t;
          return null;
        }
        *GetTimelinesByName(i) {
          if (NAMES_REGEXP.test(i)) {
            NAMES_REGEXP.lastIndex = 0;
            let e;
            const t = /* @__PURE__ */ new Set();
            do {
              if (e = NAMES_REGEXP.exec(i)) {
                const s = e[1].split(",");
                for (const i2 of s) t.add(i2);
              }
            } while (e);
            for (const i2 of t.values()) {
              const n = this.GetTimelineByName(i2);
              n && (yield n);
            }
            t.clear();
          } else {
            const e = this.GetTimelineByName(i);
            e && (yield e);
          }
        }
        *GetTimelinesByTags(e) {
          for (const i of this._timelines) i.HasTags(e) && (yield i);
        }
        AddScheduledTimeline(e) {
          this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();
        }
        RemovePlayingTimeline(e) {
          C33.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();
        }
        ScheduleTimeline(e) {
          this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();
        }
        DeScheduleTimeline(e) {
          e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C33.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();
        }
        CompleteTimeline(e) {
          e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C33.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);
        }
        CompleteTimelineBeforeChangeOfLayout(e) {
          e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C33.arrayFindRemove(this._playingTimelines, e);
        }
        CompleteTimelineAndResolve(e) {
          this.CompleteTimeline(e), e.ResolvePlayPromise();
        }
        _OnTick() {
          if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            for (this._isTickingTimelines = true; this._scheduledTimelines.length; ) {
              const e = this._scheduledTimelines.pop();
              (e.IsMarkedForRemoval() ? (e.SetInitialStateForce(), this._markedForRemovalTimelines) : (e.SetInitialState(), this._playingTimelines)).push(e), 0 !== e.GetRenderChange() && (this._renderChange = 1);
            }
            const i = this._runtime._GetDtFast(), t = this._runtime.GetDt1(), s = this._runtime.GetTimeScale();
            for (let e = this._playingTimelines.length - 1; 0 <= e; e--) {
              const n = this._playingTimelines[e];
              n && n.Tick(i, s, t);
            }
            this._isTickingTimelines = false, 0 !== this._renderChange && this.GetRuntime().UpdateRender();
          }
        }
        _OnTick2() {
          if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            let t;
            for (let e = 0, i = this._markedForRemovalTimelines.length; e < i; e++) {
              const s = this._markedForRemovalTimelines[e];
              t = t || /* @__PURE__ */ new Set(), s.Removed(), this._MaybeExecuteTimelineFinishTriggers(s), t.add(s);
            }
            if (t) {
              C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, t);
              for (let e = this._renderChange = 0, i = this._playingTimelines.length; e < i; e++) if (0 !== this._playingTimelines[e].GetRenderChange()) {
                this._renderChange = 1;
                break;
              }
            }
            this._MaybeDisableRuntimeListeners();
          }
        }
        _MaybeExecuteTimelineFinishTriggers(e) {
          e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();
        }
        _MaybeEnableRuntimeListeners() {
          this._hasRuntimeListeners || (this._hasRuntimeListeners = true);
        }
        _MaybeDisableRuntimeListeners() {
          this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);
        }
        _OnBeforeChangeLayout() {
          for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());
          const e = /* @__PURE__ */ new Set();
          for (const i of this._playingTimelines) {
            const t = i._OnBeforeChangeLayout();
            t && (i.Removed(), e.add(i));
          }
          C33.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();
          for (const s of this._markedForRemovalTimelines) {
            const n = s._OnBeforeChangeLayout();
            n && (s.Removed(), e.add(s));
          }
          C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();
          for (const a of this._timelines) a.CleanCaches();
        }
        _OnAfterChangeLayout() {
          this._changingLayout = false;
        }
        _OnInstanceDestroy(e) {
          const i = e.GetObjectClass(), t = this.GetTimelinesForObjectClass(i);
          if (t) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);
          else for (const s of t) s.IsTemplate() || (s.IsReleased() ? this.Remove(s) : s.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(s), this.Remove(s)));
        }
        _OnBeforeLoad() {
          for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
          for (const i of this._playingTimelines.map((e) => e)) this._MaybeExecuteTimelineFinishTriggers(i), this.Remove(i);
        }
        _OnAfterLoad() {
          for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);
          C33.clearArray(this._destroyedWhileLoadingState);
          for (const i of this._timelines) i._OnAfterLoad();
        }
        _OnAfterLayoutStart() {
          const e = this._runtime.GetLayoutManager(), i = e.GetMainRunningLayout();
          if (i) for (const t of this._timelines) {
            const s = t.GetStartOnLayout();
            s && i.GetName() === s && this.ScheduleTimeline(t);
          }
        }
        _SaveToJson() {
          return { "timelinesJson": this._SaveTimelinesToJson(), "scheduledTimelinesJson": this._SaveScheduledTimelinesToJson(), "playingTimelinesJson": this._SavePlayingTimelinesToJson(), "markedForRemovalTimelinesJson": this._SaveMarkedForRemovalTimelinesToJson(), "hasRuntimeListeners": this._hasRuntimeListeners, "changingLayout": this._changingLayout, "isTickingTimelines": this._isTickingTimelines };
        }
        _LoadFromJson(e) {
          e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e["timelinesJson"]), this._LoadScheduledTimelinesFromJson(e["scheduledTimelinesJson"]), this._LoadPlayingTimelinesFromJson(e["playingTimelinesJson"]), this._LoadMarkedForRemovalTimelinesFromJson(e["markedForRemovalTimelinesJson"]), this._hasRuntimeListeners = !e["hasRuntimeListeners"], this._changingLayout = !!e["changingLayout"], this._isTickingTimelines = !!e["isTickingTimelines"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());
        }
        _SaveTimelinesToJson() {
          return this._timelines.map((e) => e._SaveToJson());
        }
        _LoadTimelinesFromJson(e) {
          for (const i of e) {
            let e2 = this.GetTimelineByName(i["name"]);
            if (e2) e2._LoadFromJson(i);
            else {
              const t = this._GetTemplateNameFromJson(i);
              if (!t) continue;
              const s = this.GetTimelineByName(t);
              (e2 = this.CreateFromTemplate(s))._LoadFromJson(i);
            }
            e2.HasTracks() || this.Remove(e2);
          }
        }
        _GetTemplateNameFromJson(e) {
          const i = e["name"], t = i.split(":");
          return t && 2 === t.length ? t[0] : null;
        }
        _SaveScheduledTimelinesToJson() {
          return this._SaveTimelines(this._scheduledTimelines);
        }
        _LoadScheduledTimelinesFromJson(e) {
          this._LoadTimelines(e, this._scheduledTimelines);
        }
        _SavePlayingTimelinesToJson() {
          return this._SaveTimelines(this._playingTimelines);
        }
        _LoadPlayingTimelinesFromJson(e) {
          this._LoadTimelines(e, this._playingTimelines);
        }
        _SaveMarkedForRemovalTimelinesToJson() {
          return this._SaveTimelines(this._markedForRemovalTimelines);
        }
        _LoadMarkedForRemovalTimelinesFromJson(e) {
          this._LoadTimelines(e, this._markedForRemovalTimelines);
        }
        _IsTimelineInJson(e, i) {
          if (i) {
            for (const t of i) if (t === e.GetName()) return true;
          }
          return false;
        }
        _SaveTimelines(e) {
          return e.map((e2) => e2.GetName());
        }
        _LoadTimelines(e, i) {
          const t = /* @__PURE__ */ new Set();
          for (const s of i) this._IsTimelineInJson(s, e) || t.add(s);
          if (C33.arrayRemoveAllInSet(i, t), e) for (const n of e) {
            const a = this.GetTimelineByName(n);
            if (a) {
              const l = i.find(/* @__PURE__ */ ((i2) => (e2) => e2.GetName() === i2)(n));
              l || i.push(a);
            }
          }
        }
      };
    }
    {
      const C33 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };
      C33.TimelineInfo = class {
        constructor(t, i) {
          this._initialized = false, this._timeline = t, this._segments = [];
          let e = null;
          if (e = i ? this._timeline.GetTrackById(i) : C33.first(this._timeline.GetTracks())) {
            const s = e.GetPropertyTrack("offsetX"), _ = e.GetPropertyTrack("offsetY");
            if (s && _) {
              this._xTrack = s, this._yTrack = _;
              const h = s.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _.GetPropertyKeyframeDataItemArrayIncludingDisabled();
              for (let t2 = 1, i2 = Math.min(h.length, n.length); t2 < i2; ++t2) {
                const r = h[t2], a = (r.GetNext(), r.GetPrevious()), c = n[t2], l = (c.GetNext(), c.GetPrevious());
                a && "cubic-bezier" === a.GetPathMode() && l && "cubic-bezier" === l.GetPathMode() ? this._segments.push(C33.New(C33.TimelineCubicBezierSegmentInfo, a, l, r, c, this._segments.length)) : (a && "line" === a.GetPathMode() && l && l.GetPathMode(), this._segments.push(C33.New(C33.TimelineLineSegmentInfo, r, c, this._segments.length)));
              }
              this._initialized = true;
            }
          }
        }
        Release() {
          for (const t of this._segments) t.Release();
          C33.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;
        }
        WasInitialized() {
          return this._initialized;
        }
        segments() {
          return this._segments;
        }
        SetOrigin(t) {
          const i = "relative" === this._xTrack.GetResultMode() ? t.GetX() : 0, e = "relative" === this._yTrack.GetResultMode() ? t.GetY() : 0;
          for (const s of this._segments) s.SetOrigin(i, e);
        }
        Project(i, e, t) {
          let s = NaN, _ = this._segments.length;
          for (let t2 = 0; t2 < _; t2++) {
            const h = this._segments[t2];
            if ("cubic-bezier" === h.GetType()) {
              const n = h.Project(i, e);
              (isNaN(s) || n[3] < s) && (s = n[3], SHORT_PROJECTION_RESULT[0] = n[2], SHORT_PROJECTION_RESULT[1] = h.GetIndex());
            }
          }
          return SHORT_PROJECTION_RESULT;
        }
        ProjectWithOptions(i, e, t) {
          const s = t.tRange;
          C33.IsFiniteNumber(s[0]) || (s[0] = 0), C33.IsFiniteNumber(s[1]) || (s[1] = 1);
          let _ = NaN, h = this._segments.length;
          for (let t2 = 0; t2 < h; t2++) {
            const n = this._segments[t2];
            if ("cubic-bezier" === n.GetType()) {
              const r = n.ProjectWithRange(i, e, s);
              (isNaN(_) || r[3] < _) && (_ = r[3], SHORT_PROJECTION_RESULT[0] = r[2], SHORT_PROJECTION_RESULT[1] = n.GetIndex());
            }
          }
          return SHORT_PROJECTION_RESULT;
        }
        Tangent(t, i) {
          return this._segments[i].Tangent(t);
        }
        TangentAngle(t, i) {
          return this._segments[i].TangentAngle(t);
        }
      }, C33.TimelineCubicBezierSegmentInfo = class {
        constructor(t, i, e, s, _) {
          this._index = _;
          const h = t.GetAddOn("cubic-bezier"), n = e.GetAddOn("cubic-bezier"), r = i.GetAddOn("cubic-bezier"), a = s.GetAddOn("cubic-bezier");
          this._aX = t.GetValueWithResultMode(), this._aY = i.GetValueWithResultMode(), this._bX = t.GetValueWithResultMode() + h.GetStartAnchor(), this._bY = i.GetValueWithResultMode() + r.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s.GetValueWithResultMode() + a.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = STEPS, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];
          for (let t2 = 0; t2 < STEPS; t2++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });
          this._CalculateLength();
        }
        Release() {
          C33.clearArray(this._arcLengths), this._arcLengths = null, C33.clearArray(this._lut), this._lut = null, C33.clearArray(this._lutObjects), this._lutObjects = null;
        }
        GetType() {
          return "cubic-bezier";
        }
        GetIndex() {
          return this._index;
        }
        GetStepCount() {
          return Math.floor(this._length / BEZIER_STEP_SIZE);
        }
        GetStepIncrement() {
          return 1 / this.GetStepCount();
        }
        SetOrigin(t, i) {
          this._originX = t, this._originY = i, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);
        }
        Map(t) {
          if (!this._initialized) return NaN;
          const i = this._Map(t);
          return MAP_RESULT[0] = this._X(i), MAP_RESULT[1] = this._Y(i), MAP_RESULT;
        }
        Project(t, i) {
          const e = this._GenerateLUT(STEPS), s = this._FindClosestFromLUT(t, i, e), _ = this._RefineProjection(t, i, e, s);
          return PROJECTION_RESULT[0] = _.x, PROJECTION_RESULT[1] = _.y, PROJECTION_RESULT[2] = _.t, PROJECTION_RESULT[3] = _.distance, PROJECTION_RESULT;
        }
        ProjectWithRange(t, i, e) {
          const s = this._GenerateLUT(STEPS), _ = this._FindClosestFromLUTWithRange(t, i, s, e), h = this._RefineProjection(t, i, s, _);
          return PROJECTION_RESULT[0] = h.x, PROJECTION_RESULT[1] = h.y, PROJECTION_RESULT[2] = h.t, PROJECTION_RESULT[3] = h.distance, PROJECTION_RESULT;
        }
        Tangent(t) {
          const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y, r = Math.hypot(h, n);
          return TANGENT_RESULT[0] = h / r, TANGENT_RESULT[1] = n / r, TANGENT_RESULT;
        }
        TangentAngle(t) {
          const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y;
          return Math.atan2(n, h);
        }
        _Map(_) {
          if (this._initialized) {
            let t = _ * this._arcLengths[this._len], i = 0, e = this._len, s = 0;
            for (; i < e; ) s = i + ((e - i) / 2 | 0), this._arcLengths[s] < t ? i = s + 1 : e = s;
            this._arcLengths[s] > t && s--;
            const h = this._arcLengths[s];
            return h === t ? s / this._len : (s + (t - h) / (this._arcLengths[s + 1] - h)) / this._len;
          }
        }
        _X(t) {
          return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;
        }
        _Y(t) {
          return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;
        }
        _GenerateLUT(i) {
          if (i = i || STEPS, !(this._lut.length >= i)) {
            this._lut = new Array(i), i++;
            for (let t = 0; t < i - 1; t++) {
              const e = t / (i - 1), s = e ** 2, _ = e ** 3, h = this._x1Factor * e, n = this._x2Factor * s, r = this._x3Factor * _, a = this._y1Factor * e, c = this._y2Factor * s, l = this._y3Factor * _, o = this._aXO + h + n + r, T = this._aYO + a + c + l;
              this._lutObjects[t].x = o, this._lutObjects[t].y = T, this._lutObjects[t].t = e, this._lutObjects[t].distance = 0, this._lut[t] = this._lutObjects[t];
            }
          }
          return this._lut;
        }
        _FindClosestFromLUT(i, e, s, t = 0, _ = Number.MAX_SAFE_INTEGER) {
          let h = 0;
          if (isNaN(this._lutIndex)) for (let t2 = 0; t2 < STEPS; t2++) {
            const n = s[t2], r = n.x - i, a = n.y - e;
            n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = t2);
          }
          else {
            for (let t2 = this._lutIndex; t2 < this._lutIndex + LOOKUP_STEPS_FROM_LAST && !(t2 >= s.length); t2++) {
              const c = s[t2], l = c.x - i, o = c.y - e;
              c.distance = l * l + o * o, c.distance < _ && (_ = c.distance, h = t2);
            }
            for (let t2 = this._lutIndex; t2 > this._lutIndex - LOOKUP_STEPS_FROM_LAST && !(t2 < 0); t2--) {
              const T = s[t2], d = T.x - i, E = T.y - e;
              T.distance = d * d + E * E, T.distance < _ && (_ = T.distance, h = t2);
            }
          }
          return this._lutIndex = h;
        }
        _FindClosestFromLUTWithRange(i, e, s, _, h = Number.MAX_SAFE_INTEGER) {
          let n = 0;
          if (isNaN(this._lutIndex)) for (let t = 0; t < STEPS; t++) {
            const r = s[t], a = r.x - i, c = r.y - e;
            r.distance = a * a + c * c, r.t >= _[0] && r.t <= _[1] && r.distance < h && (h = r.distance, n = t);
          }
          else {
            for (let t = this._lutIndex; t < this._lutIndex + LOOKUP_STEPS_FROM_LAST && !(t >= s.length); t++) {
              const l = s[t], o = l.x - i, T = l.y - e;
              l.distance = o * o + T * T, l.t >= _[0] && l.t <= _[1] && l.distance < h && (h = l.distance, n = t);
            }
            for (let t = this._lutIndex; t > this._lutIndex - LOOKUP_STEPS_FROM_LAST && !(t < 0); t--) {
              const d = s[t], E = d.x - i, O = d.y - e;
              d.distance = E * E + O * O, d.t >= _[0] && d.t <= _[1] && d.distance < h && (h = d.distance, n = t);
            }
          }
          return this._lutIndex = n;
        }
        _RefineProjection(h, n, r, a) {
          let c = r[a], t = 1, l = Number.MAX_SAFE_INTEGER;
          t: do {
            const o = r.length;
            let t2 = 0 === a ? 0 : a - 1, i = a === o - 1 ? o - 1 : a + 1, e = r[t2].t, s = r[i].t, _ = (s - e) / 4;
            if (_ < 1e-3) break;
            REFINE_LUT[0] = r[t2];
            for (let t3 = 1; t3 <= 2; t3++) {
              const T = e + t3 * _, d = T ** 2, E = T ** 3, O = this._x1Factor * T, u = this._x2Factor * d, R = this._x3Factor * E, S = this._y1Factor * T, g = this._y2Factor * d, I = this._y3Factor * E, N = this._aXO + O + u + R, L = this._aYO + S + g + I, x = N - h, y = L - n, G = x * x + y * y;
              if (G < l) {
                l = G, a = t3, REFINE_RESULT.x = N, REFINE_RESULT.y = L, REFINE_RESULT.t = T, REFINE_RESULT.distance = G, c = REFINE_RESULT;
                break t;
              }
              const P = REFINE_LUT_OBJECTS[t3 - 1];
              P.x = N, P.y = L, P.t = T, P.distance = G, REFINE_LUT[t3] = P;
            }
            REFINE_LUT[3] = r[i], r = REFINE_LUT;
          } while (t++ < REFINE_ITERATIONS);
          return c;
        }
        _CalculateLength() {
          this._initialized = true;
          let i = this._X(0), e = this._Y(0), s = 0;
          for (let t = 1; t <= this._len; t++) {
            const _ = this._X(t * LENGTH_STEP_SIZE), h = this._Y(t * LENGTH_STEP_SIZE), n = i - _, r = e - h;
            s += Math.hypot(n, r), this._arcLengths[t] = s, i = _, e = h;
          }
          this._length = s;
        }
      }, C33.TimelineLineSegmentInfo = class {
        constructor(t, i, e) {
          this._index = e, this._targetX = t.GetValueWithResultMode(), this._targetY = i.GetValueWithResultMode(), this._originX = 0, this._originY = 0;
        }
        Release() {
        }
        GetType() {
          return "line";
        }
        GetIndex() {
          return this._index;
        }
        SetOrigin(t, i) {
          this._originX = t, this._originY = i;
        }
        GetX() {
          return this._targetX + this._originX;
        }
        GetY() {
          return this._targetY + this._originY;
        }
      };
    }
    {
      const C33 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;
      C33.TimelineState = class extends C33.DefendedBase {
        constructor(e, t, i) {
          super(), this._runtime = i.GetRuntime(), this._timelineManager = i, this._timelineDataItem = t, this._name = e, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = PING_PONG_BEGIN, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [""], this._stringTags = "", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._iTimelineState = null;
        }
        static CreateInitial(e, t) {
          const i = t.GetTimelineDataManager(), s = i.GetNameId(), a = i.Get(e[s]), n = C33.New(C33.TimelineState, e[s], a, t);
          return n.SetIsTemplate(true), n;
        }
        static CreateFromTemplate(e, t, i) {
          return C33.New(C33.TimelineState, e, t, i);
        }
        Release() {
          if (!this.IsReleased()) {
            const e = this._runtime.Dispatcher();
            this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);
            for (const t of this._tracks) t.Release();
            C33.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(e);
          }
        }
        FireReleaseEvent(e) {
          const t = C33.New(C33.Event, "timelinestatereleased");
          t.timelineState = this, e.dispatchEvent(t);
        }
        GetType() {
          return 0;
        }
        CreateTrackStates() {
          for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C33.TrackState.Create(this, e));
        }
        GetTimelineManager() {
          return this._timelineManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTracks() {
          return this._tracks;
        }
        GetSimilarPropertyTracks(s, a, n, r) {
          if (this._hasNestedContent) {
            let i;
            for (let t = 0; t < this._tracks.length; t++) {
              let e = this._tracks[t];
              if (s === e.GetInstance()) {
                const h = e.GetPropertyTrack(n);
                h && a.constructor === h.GetSourceAdapter().constructor && h.GetResultMode() === r.GetResultMode() && (i = i || []).push(h);
              }
            }
            return i;
          }
        }
        HasTracks() {
          return !!this._tracks.length;
        }
        GetTrackById(e) {
          for (const t of this._tracks) if (C33.equalsNoCase(t.GetId(), e)) return t;
          return null;
        }
        GetTrackByName(e) {
          for (const t of this._tracks) if (!t.IsInstanceTrack() && C33.equalsNoCase(t.GetName(), e)) return t;
          return null;
        }
        SetName(e) {
          this._name = e;
        }
        GetName() {
          return this._name;
        }
        GetTimelineDataItem() {
          return this._timelineDataItem;
        }
        GetTemplateName() {
          return this._timelineDataItem.GetName();
        }
        GetTotalTime() {
          return this._timelineDataItem.GetTotalTime();
        }
        SetTotalTime(e) {
          this._timelineDataItem.SetTotalTime(e);
        }
        GetStep() {
          return this._timelineDataItem.GetStep();
        }
        SetStep(e) {
          this._timelineDataItem.SetStep(e);
        }
        GetInterpolationMode() {
          return this._timelineDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(e) {
          this._timelineDataItem.SetInterpolationMode(e);
        }
        GetResultMode() {
          return this._timelineDataItem.GetResultMode();
        }
        SetResultMode(e) {
          this._timelineDataItem.GetResultMode(e);
        }
        SetEase(e) {
          for (const t of this.GetTracks()) t.SetEase(e);
        }
        GetLoop() {
          return this._timelineDataItem.GetLoop();
        }
        SetLoop(e) {
          return this._timelineDataItem.SetLoop(e);
        }
        GetPingPong() {
          return this._timelineDataItem.GetPingPong();
        }
        SetPingPong(e) {
          return this._timelineDataItem.SetPingPong(e);
        }
        GetRepeatCount() {
          return this._timelineDataItem.GetRepeatCount();
        }
        SetRepeatCount(e) {
          return this._timelineDataItem.SetRepeatCount(e);
        }
        SetPlaybackRate(e) {
          return this._playbackRate = e;
        }
        GetPlaybackRate() {
          return this._playbackRate;
        }
        GetStartOnLayout() {
          return this._timelineDataItem.GetStartOnLayout();
        }
        GetTransformWithSceneGraph() {
          return this._timelineDataItem.GetTransformWithSceneGraph();
        }
        GetUseSystemTimescale() {
          return this._timelineDataItem.GetUseSystemTimescale();
        }
        GetPingPongState() {
          return this._pingPongState;
        }
        IsForwardPlayBack() {
          return !this.IsPlaying() || 0 < this._playbackRate;
        }
        GetPlayPromise() {
          return this._playPromise || (this._playPromise = new Promise((e) => {
            this._playResolve = e;
          })), this._playPromise;
        }
        ResolvePlayPromise() {
          this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);
        }
        SetTags(e) {
          this._tags = C33.TimelineState._GetTagArray(e), this._tagsChanged = true;
        }
        GetTags() {
          return this._tags;
        }
        GetStringTags() {
          return this._tagsChanged && (this._stringTags = this._tags.join(" ")), this._tagsChanged = false, this._stringTags;
        }
        HasTags(e) {
          if (!this._tags) return false;
          if (!this._tags.length) return false;
          const t = C33.TimelineState._GetTagArray(e);
          return !!t && !!t.length && t.every(C33.TimelineState._HasTag, this);
        }
        OnStarted() {
          C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());
        }
        OnCompleted() {
          this._completedTick = this._runtime.GetTickCount();
        }
        FinishTriggers() {
          this._finishedTriggers || (this._finishedTriggers = true, C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C33.Plugins.Timeline.Cnds.PopTriggerTimeline()));
        }
        SetPlaying(e) {
          this._isPlaying = e;
        }
        IsCompletedTick() {
          return this._completedTick === this._runtime.GetTickCount();
        }
        IsPlaying(e = false) {
          return !!this.IsCompletedTick() || !(!this.IsScheduled() || e) || this._isPlaying;
        }
        _IsPlaying() {
          return this.IsPlaying(true);
        }
        IsPaused() {
          return this._IsPaused();
        }
        _IsPaused() {
          return !(this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete());
        }
        SetScheduled(e) {
          this._isScheduled = e;
        }
        IsScheduled() {
          return this._isScheduled;
        }
        SetComplete(e) {
          this._complete = e;
          const t = this.GetTime();
          (t <= 0 || t >= this.GetTotalTime()) && (this._complete = true);
        }
        IsComplete() {
          return this._complete;
        }
        IsReleased() {
          return this._released;
        }
        SetMarkedForRemoval(e) {
          this._markedForRemoval = e;
        }
        IsMarkedForRemoval() {
          return this._markedForRemoval;
        }
        SetImplicitPause(e) {
          this._implicitPause = e;
        }
        IsImplicitPause() {
          return this._implicitPause;
        }
        SetIsTemplate(e) {
          this._isTemplate = !!e;
        }
        IsTemplate() {
          return this._isTemplate;
        }
        InitialStateSet() {
          return this._initialStateSet;
        }
        GetTime() {
          return this._playheadTime;
        }
        SetTime(e) {
          const t = this.GetTime();
          this._SetTime(e), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), !this._IsPlaying() && !this.IsScheduled() && this._initialStateSet || (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, t), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();
        }
        _SetTime(e) {
          (e = C33.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e;
        }
        _SetTimeAndReset(e) {
          (e = C33.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e;
          for (const t of this._tracks) t.SetResetState();
        }
        _OnSetTime() {
          C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByTags), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());
        }
        _CanResume() {
          if (!this.GetLoop()) {
            if (this.GetPingPong() && this._pingPongState === PING_PONG_END) {
              if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime()) return false;
              } else if (this.GetTime() <= 0) return false;
            } else if (!this.GetLoop() && !this.GetPingPong()) {
              if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime()) return false;
              } else if (this.GetTime() <= 0) return false;
            }
          }
          return true;
        }
        Resume() {
          this.IsReleased() || this._CanResume() && this.Play(true);
        }
        Play(e = false) {
          return !this.IsReleased() && !this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && !!(this.IsComplete() || e || this.IsImplicitPause()) && this._ScheduleStoppedTimeline());
        }
        _SchedulePlayingTimeline() {
          return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
        }
        _ScheduleStoppedTimeline() {
          return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
        }
        Stop(e = false) {
          this.IsReleased() || (this.SetComplete(e), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());
        }
        Reset(e = true, t = false) {
          if (!this.IsReleased()) {
            if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
            if (!this.IsComplete()) {
              this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
              const i = this.GetTime();
              this._SetUpdateStateBefore(), t ? this._InterpolateBeforeChangeLayout(i) : this._Interpolate(i, false, false, true), e && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && e && this.GetRuntime().UpdateRender();
            }
          }
        }
        ResetBeforeChangeLayout() {
          this.Reset(false, true);
        }
        _InterpolateBeforeChangeLayout(e) {
          this._Interpolate(e, false, false, true, NaN, false, true);
        }
        _OnBeforeChangeLayout() {
          if (!this.IsReleased()) {
            if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) return false;
            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();
          }
          return true;
        }
        SetInitialStateFromSetTime() {
          this.SetInitialState(true);
        }
        SetInitialStateForce() {
          this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);
        }
        SetInitialState(e = false, t = false) {
          if (!this.IsMarkedForRemoval() || t) {
            if (e) {
              this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();
              for (const i of this._tracks) i.SetInitialState();
            } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {
              this._completedTick = -1, this._pingPongState !== PING_PONG_BEGIN && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = PING_PONG_BEGIN, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();
              for (const s of this._tracks) s.SetInitialState();
            } else {
              this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();
              for (const a of this._tracks) a.SetResumeState();
            }
            this._SetUpdateStateAfter();
          }
        }
        GetRenderChange() {
          return this._renderChange;
        }
        _SetUpdateStateBefore() {
          this._hasNestedContent = 0;
          for (const e of this._tracks) e.IsNested() && (this._hasNestedContent = 1);
        }
        _SetUpdateStateAfter() {
          this._renderChange = 0;
          for (const e of this._tracks) e._SetUpdateState(), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== e.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(e));
        }
        Tick(e, t, i) {
          if (this.GetUseSystemTimescale()) {
            if (0 === e && 0 === this._lastDelta) return;
            this._lastDelta = e, e = i;
          } else {
            if (0 === i && 0 === this._lastDelta) return;
            e = this._lastDelta = i, t = 1;
          }
          const s = this._playheadTime + this._overshoot, a = e * t * this._playbackRate, n = s + a, r = this._timelineDataItem._totalTime;
          n < 0 ? (this._playheadTime = 0, this._overshoot = -n) : r <= n ? (this._playheadTime = r, this._overshoot = this._playheadTime - n) : (this._playheadTime = n, this._overshoot = 0);
          let h = false, l = false;
          const o = this.GetLoop(), _ = this.GetPingPong();
          o || _ ? o && !_ ? 0 < this._playbackRate ? this._playheadTime >= r && (this._SetTimeAndReset(0), l = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(r), l = true) : !o && _ ? 0 < this._playbackRate ? this._playheadTime >= r && (this._SetTime(r), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = PING_PONG_BEGIN) : h = true : this._pingPongState === PING_PONG_BEGIN && (this._pingPongState = PING_PONG_END)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = PING_PONG_BEGIN) : h = true : this._pingPongState === PING_PONG_BEGIN && (this._pingPongState = PING_PONG_END)) : o && _ && (0 < this._playbackRate ? this._playheadTime >= r && (this._SetTime(r), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= r && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), l = true) : (this._SetTime(r), h = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(r), l = true) : (this._SetTime(0), h = true));
          let m;
          const c = this._tracksLength;
          if (h) {
            for (m = 0; m < c; m++) this._tracks[m].SetEndState();
            this.Stop(true), this.OnCompleted();
          } else {
            const T = this._beforeAndAfterTracksLength;
            for (m = 0; m < T; m++) this._beforeAndAfterTracks[m].BeforeInterpolate();
            if (1 === this._hasNestedContent) for (m = 0; m < c; m++) {
              const g = this._tracks[m], d = g.GetStartOffset(), u = this._playheadTime - d, S = s - d;
              u < 0 && 0 < S ? (this._playheadTime = d < 0 ? 0 : r <= d ? r : d, g.Interpolate(d, true, false, l, this._firstTick, false)) : g.Interpolate(this._playheadTime, true, false, l, this._firstTick, false);
            }
            else for (m = 0; m < c; m++) this._tracks[m].Interpolate(this._playheadTime, true, false, l, this._firstTick, false);
            for (m = 0; m < T; m++) this._beforeAndAfterTracks[m].AfterInterpolate();
            this._firstTick && (this._firstTick = false);
          }
        }
        _Interpolate(t, i = false, s = false, a = false, n = NaN, e = false, r = false) {
          for (const h of this._tracks) h.BeforeInterpolate();
          for (const l of this._tracks) {
            let e2 = t;
            if ("number" == typeof n && !isNaN(n)) {
              const o = this.GetTime(), _ = o - l.GetStartOffset(), m = n - l.GetStartOffset();
              _ < 0 && 0 < m && (e2 = l.GetStartOffset(), this._SetTime(e2));
            }
            l.Interpolate(e2, i, s, a, this._firstTick, r);
          }
          for (const c of this._tracks) c.AfterInterpolate();
          this._firstTick && e && (this._firstTick = false);
        }
        AddTrack() {
          const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C33.TrackState.Create(this, e);
          return this._tracksLength = this._tracks.push(t), t;
        }
        Removed() {
          if (!this.IsReleased()) for (const e of this._tracks) e.TimelineRemoved();
        }
        CleanCaches() {
          for (const e of this._tracks) e.CleanCaches();
        }
        ClearTrackInstances() {
          for (const e of this._tracks) e.ClearInstance();
        }
        SetTrackInstance(e, t, i) {
          if (t) {
            if ("number" == typeof i && 0 <= i) {
              const s = this._tracks[i];
              return s ? (s.SetInstance(t), void this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this)) : void 0;
            }
            for (const a of this._tracks) if (a.IsInstanceTrack()) {
              if (e) {
                if (a.GetId() === e) {
                  a.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                  break;
                }
              } else if (!a.HasInstance()) {
                a.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                break;
              }
            }
          }
        }
        HasTrackInstance(e, t) {
          for (const i of this._tracks) if (i.IsInstanceTrack()) {
            if (t) {
              if (t === i.GetId() && e === i.GetInstance()) return true;
            } else if (e === i.GetInstance()) return true;
          }
          return false;
        }
        HasValidTracks() {
          return this._tracks.some((e) => !e.IsInstanceTrack() || e.CanInstanceBeValid());
        }
        HasValidGlobalTracks() {
          return this._tracks.some((e) => {
            if (e.IsInstanceTrack()) {
              if (!e.CanInstanceBeValid()) return false;
              const t = e.GetObjectClass();
              return t ? t.IsGlobal() : false;
            }
            return false;
          });
        }
        GetPropertyTrack(e) {
          for (const t of this.GetTracks()) for (const i of t.GetPropertyTracks()) if (i.GetPropertyName() === e) return i;
        }
        GetTrackFromInstance(e) {
          for (const t of this._tracks) if (e === t.GetInstance()) return t;
          return null;
        }
        GetKeyframeWithTags(e) {
          let t = e ? e.split(" ") : [];
          const i = new Set(t.map((e2) => e2.toLowerCase().trim()));
          t = [...i.values()];
          for (const s of this.GetTracks()) for (const a of s.GetKeyframeDataItems()) {
            const n = t.every((e2) => a.HasTag(e2));
            if (n) return a;
          }
        }
        GetObjectClasses() {
          const e = [];
          for (const t of this.GetTracks()) e.push(t.GetObjectClass());
          return e.filter((e2) => e2);
        }
        _OnAfterLoad() {
          for (const e of this.GetTracks()) e._OnAfterLoad();
        }
        _SaveToJson() {
          return { "tracksJson": this._SaveTracksToJson(), "name": this._name, "playheadTime": this.GetTime(), "playbackRate": this._playbackRate, "pingPongState": this._pingPongState, "currentRepeatCount": this._currentRepeatCount, "isPlaying": this._isPlaying, "isScheduled": this._isScheduled, "initialStateSet": this._initialStateSet, "finishedTriggers": this._finishedTriggers, "complete": this._complete, "released": this._released, "markedForRemoval": this._markedForRemoval, "completedTick": this._completedTick, "implicitPause": this._implicitPause, "isTemplate": this._isTemplate, "tags": this._tags.join(" "), "stringTags": this._stringTags, "tagsChanged": this._tagsChanged, "firstTick": this._firstTick };
        }
        _LoadFromJson(e) {
          e && (this._LoadTracksFromJson(e["tracksJson"]), this._name = e["name"], this._playheadTime = e["playheadTime"], this._playbackRate = e["playbackRate"], this._pingPongState = e["pingPongState"], this._currentRepeatCount = e["currentRepeatCount"], this._isPlaying = !!e["isPlaying"], this._isScheduled = !!e["isScheduled"], this._initialStateSet = !!e["initialStateSet"], this._finishedTriggers = !!e.hasOwnProperty("finishedTriggers") && !!e["finishedTriggers"], this._complete = !!e["complete"], this._released = !!e["released"], this._markedForRemoval = !!e["markedForRemoval"], this._completedTick = e["completedTick"], this._implicitPause = !!e["implicitPause"], this._isTemplate = !!e["isTemplate"], this._tags = e["tags"].split(" "), this._stringTags = e["stringTags"], this._tagsChanged = !!e["tagsChanged"], this._firstTick = !!e["firstTick"]);
        }
        _SaveTracksToJson() {
          return this._tracks.map((e) => e._SaveToJson());
        }
        _LoadTracksFromJson(e) {
          this.ClearTrackInstances(), e.forEach((e2, t) => {
            const i = this._tracks[t];
            i._LoadFromJson(e2);
          }), this._tracks.filter((e2) => e2.CanInstanceBeValid());
        }
        static _HasTag(e) {
          const t = this.GetTags();
          return "" === e ? 1 === t.length && "" === t[0] : t.map((e2) => e2.toLowerCase()).includes(e.toLowerCase());
        }
        static _GetTagArray(e) {
          if (C33.IsArray(e)) return e.slice(0);
          if (C33.IsString(e)) return e.split(" ");
          throw new Error("invalid tags");
        }
        GetITimelineState() {
          return this._iTimelineState || (this._iTimelineState = C33.New(self.ITimelineState, this)), this._iTimelineState;
        }
      };
    }
    {
      const C33 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;
      C33.TrackState = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._timeline = t, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = 0 < e.GetStartOffset(), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0;
        }
        static Create(t, e) {
          return C33.New(C33.TrackState, t, e);
        }
        Release() {
          this._keyframeDataItems = null;
          for (const t of this._propertyTracks) t.Release();
          C33.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;
        }
        CreatePropertyTrackStates() {
          for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.PropertyTrackState.Create(this, t));
        }
        TimelineRemoved() {
          for (const t of this._propertyTracks) t.TimelineRemoved();
        }
        CleanCaches() {
          for (const t of this._propertyTracks) t.CleanCaches();
          this._instance = null, this._worldInfo = null;
        }
        GetTimeline() {
          return this._timeline;
        }
        GetRuntime() {
          return this._timeline.GetRuntime();
        }
        GetKeyframeDataItems() {
          return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;
        }
        GetPropertyTracks() {
          return this._propertyTracks;
        }
        GetPropertyTrack(e) {
          for (let t = 0; t < this._propertyTracks.length; t++) {
            const a = this._propertyTracks[t];
            if (a.GetPropertyName() === e) return a;
          }
        }
        MaybeGetInstance() {
          this._instance || this.GetInstance();
        }
        IsInstanceValid() {
          return !!this._instance && !this._instance.IsDestroyed();
        }
        CanInstanceBeValid() {
          if (!this.IsInstanceTrack()) return false;
          const t = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t);
          return !!e && !e.IsDestroyed();
        }
        GetObjectClass() {
          if (this.IsInstanceTrack()) {
            const t = this.GetObjectClassIndex();
            if (-1 !== t) return this.GetRuntime().GetObjectClassByIndex(t);
          }
        }
        GetTrackIndexInTimeline() {
          return this._timeline.GetTracks().indexOf(this);
        }
        ClearInstance() {
          this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;
        }
        HasInstance() {
          return !!this._instance;
        }
        GetInstance() {
          if (!this._cleared) {
            if (!this._instance || !this.IsInstanceValid()) {
              const t = this.GetInstanceUID();
              this._instance = this.GetRuntime().GetInstanceByUID(t);
            }
            return this._instance;
          }
        }
        SetInstance(t) {
          if (this._cleared = false, this._instance !== t) {
            this.CleanCaches(), this._instance = t, this._objectClassIndex = t.GetObjectClass().GetIndex(), this._instanceUid = t.GetUID(), this._worldInfo = t.GetWorldInfo();
            for (const e of this.propertyTrackItems()) {
              const a = e.propertyTrack, s = e.sourceAdapter, r = a.GetSourceAdapterId();
              switch (r) {
                case "instance-variable": {
                  s.GetEditorIndex();
                  const i = t.GetObjectClass(), n = i.GetInstanceVariableIndexByName(e.name), o = i.GetInstanceVariableName(n), h = i.GetInstanceVariableType(n);
                  o === e.name && h === e.type && s.UpdateInstanceVariableIndex(n);
                  break;
                }
                case "behavior": {
                  const c = e.behaviorType, l = this.GetObjectClass(), I = t.GetObjectClass(), d = s.GetBehaviorType(I);
                  if (c && d) {
                    const f = c.GetName();
                    l.GetBehaviorIndexByName(f), I.GetBehaviorIndexByName(f), s.GetEditorIndex();
                    s.UpdateBehaviorTypeSid(d.GetSID());
                  }
                  break;
                }
              }
            }
          }
        }
        *propertyTrackItems() {
          for (const t of this._propertyTracks) {
            const e = t.GetSourceAdapter(), a = this.GetObjectClass(), s = { propertyTrack: t, sourceAdapter: e };
            switch (t.GetSourceAdapterId()) {
              case "world-instance":
                s.property = t.GetPropertyName();
                break;
              case "instance-variable": {
                const r = e.GetEditorIndex();
                s.name = a.GetInstanceVariableName(r), s.type = a.GetInstanceVariableType(r);
                break;
              }
              case "effect": {
                const i = a.GetEffectList(), n = e.GetEffectType(i);
                s.effectType = n;
                break;
              }
              case "behavior": {
                const o = e.GetBehaviorType(a);
                s.behaviorType = o;
                break;
              }
              case "plugin":
                s.plugin = a.GetPlugin();
            }
            yield s;
          }
        }
        GetWorldInfo() {
          if (!this._worldInfo || !this.IsInstanceValid()) {
            const t = this.GetInstance();
            t && (this._worldInfo = t.GetWorldInfo());
          }
          return this._worldInfo;
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        GetInstanceUID() {
          return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;
        }
        SetInstanceUID(t) {
          this._trackDataItem.SetInstanceUID(t);
        }
        GetInterpolationMode() {
          return this._trackDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(t) {
          this._trackDataItem.SetInterpolationMode(t);
        }
        GetResultMode() {
          return this._trackDataItem.GetResultMode();
        }
        GetId() {
          return this._trackDataItem.GetId();
        }
        GetStartOffset() {
          return this._trackDataItem.GetStartOffset();
        }
        GetLocalTotalTime() {
          return this._trackDataItem.GetLocalTotalTime();
        }
        SetLocalTotalTime(t) {
          this._trackDataItem.SetLocalTotalTime(t);
        }
        SetResultMode(t) {
          this._trackDataItem.SetResultMode(t);
        }
        SetEase(t) {
          for (const e of this.GetKeyframeDataItems()) e.SetEase(t);
          for (const a of this.GetPropertyTracks()) a.SetEase(t);
        }
        GetEnable() {
          return this._trackDataItem.GetEnable();
        }
        SetEnable(t) {
          this._trackDataItem.SetEnable(t);
        }
        GetObjectClassIndex() {
          return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;
        }
        SetObjectClassIndex(t) {
          this._trackDataItem.SetObjectClassIndex(t);
        }
        SetOriginalWidth(t) {
          this._trackDataItem.SetOriginalWidth(t);
        }
        GetOriginalWidth() {
          const t = this.GetInstance();
          if (t) {
            const e = t.GetSdkInstance();
            if (e.IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalWidth();
          }
          return this._trackDataItem.GetOriginalWidth();
        }
        SetOriginalHeight(t) {
          this._trackDataItem.SetOriginalHeight(t);
        }
        GetOriginalHeight() {
          const t = this.GetInstance();
          if (t) {
            const e = t.GetSdkInstance();
            if (e.IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalHeight();
          }
          return this._trackDataItem.GetOriginalHeight();
        }
        GetType() {
          return this._trackDataItem.GetType();
        }
        GetName() {
          return this._trackDataItem.GetName();
        }
        IsInstanceTrack() {
          return this.GetType() === INSTANCE_TRACK;
        }
        IsValueTrack() {
          return this.GetType() === VALUE_TRACK;
        }
        IsAudioTrack() {
          return this.GetType() === AUDIO_TRACK;
        }
        GetWorldInfoChange() {
          return this._worldInfoChange;
        }
        GetRenderChange() {
          return this._renderChange;
        }
        GetNeedsBeforeAndAfter() {
          return this._needsBeforeAndAfter;
        }
        IsNested() {
          return this._isNested;
        }
        SetResetState() {
          for (const t of this._propertyTracks) t.SetResetState();
        }
        SetInitialState() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {
            const t = this.GetTimeline(), e = t.IsForwardPlayBack(), a = e ? 0 : this.GetLocalTotalTime();
            for (const r of this._propertyTracks) r.SetInitialState(a), 0 === this._worldInfoChange && 1 === r.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === r.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            const s = this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter());
            s && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(a), this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(a));
          }
        }
        SetResumeState() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {
            this._timeline.IsForwardPlayBack();
            const t = this._timeline.GetTime() - this.GetStartOffset();
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t);
            for (const e of this._propertyTracks) e.SetResumeState(t);
          }
        }
        SetEndState() {
          if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested) {
            const t = this._timeline.GetTime(), e = this.GetStartOffset() + this.GetLocalTotalTime();
            e <= t ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t <= 0 && this.Interpolate(0, true, false, true, false, false, true);
          }
        }
        _SetUpdateState() {
          for (let t = 0, e = this._propertyTracks.length; t < e; t++) {
            const a = this._propertyTracks[t];
            a._SetUpdateState(), 0 === this._worldInfoChange && 1 === a.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1);
          }
        }
        BeforeInterpolate() {
          const e = this._propertyTracks.length;
          for (let t = 0; t < e; t++) this._propertyTracks[t].BeforeInterpolate();
        }
        Interpolate(a, t = false, s = false, r = false, e = false, i = false, n = false) {
          this._instance || this.GetInstance();
          const o = this._instance && !this._instance.IsDestroyed(), h = this._trackDataItem._type === INSTANCE_TRACK;
          if ((o || !h) && !(i && h && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset()) < 0)) {
            this.MaybeSetInitialStateOfNestedTrack(a, t), this.MaybeTriggerKeyframeReachedConditions(a, t, e);
            for (let t2 = 0, e2 = this._propertyTracks.length; t2 < e2; t2++) this._propertyTracks[t2].Interpolate(a, s, r, n);
            this.MaybeSetEndStateOfNestedTrack(a, t), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo) && this._worldInfo.SetBboxChanged();
          }
        }
        AfterInterpolate() {
          const e = this._propertyTracks.length;
          for (let t = 0; t < e; t++) this._propertyTracks[t].AfterInterpolate();
        }
        MaybeSetInitialStateOfNestedTrack(t, e) {
          if (e && this._isNested && !this._initialStateOfNestedSet) {
            const a = this.GetTimeline();
            if (a.IsForwardPlayBack()) {
              if (t < 0) return;
            } else if (t > this.GetLocalTotalTime()) return;
            for (const s of this._propertyTracks) s.SetInitialState();
            this._initialStateOfNestedSet = true;
          }
        }
        MaybeSetEndStateOfNestedTrack(t, e) {
          if (e && this._isNested && !this._endStateOfNestedSet) {
            const a = this.GetTimeline();
            if (a.IsForwardPlayBack()) {
              if (t >= this.GetLocalTotalTime()) {
                for (const s of this._propertyTracks) s.Interpolate(this.GetLocalTotalTime(), false, true);
                this._endStateOfNestedSet = true;
              }
            } else if (t <= 0) {
              for (const r of this._propertyTracks) r.Interpolate(0, false, true);
              this._endStateOfNestedSet = true;
            }
          }
        }
        MaybeTriggerKeyframeReachedConditions(t, e, a) {
          if (!a && e && C33.Plugins.Timeline) {
            const s = this.GetTimeline(), r = this._lastKeyframeDataItem.GetNext(), i = this._lastKeyframeDataItem.GetTime(), n = r ? r.GetTime() : s.GetTotalTime();
            if (t <= i || n <= t) if (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem), s.IsForwardPlayBack()) r && this.OnKeyframeReached(this._lastKeyframeDataItem);
            else {
              const r2 = this._lastKeyframeDataItem.GetNext();
              r2 && this.OnKeyframeReached(r2);
            }
          }
        }
        _GetLastKeyFrameBeforeTime(t) {
          const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);
          return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem);
        }
        OnKeyframeReached(t) {
          if (C33.Plugins.Timeline) {
            const e = this.GetTimeline(), a = e.GetTimelineManager();
            C33.Plugins.Timeline.Cnds.PushTriggerTimeline(e), C33.Plugins.Timeline.Cnds.PushTriggerKeyframe(t), a.Trigger(C33.Plugins.Timeline.Cnds.OnAnyKeyframeReached), a.Trigger(C33.Plugins.Timeline.Cnds.OnKeyframeReached), C33.Plugins.Timeline.Cnds.PopTriggerTimeline(e), C33.Plugins.Timeline.Cnds.PopTriggerKeyframe(t);
          }
        }
        AddKeyframe() {
          const t = this._trackDataItem.GetKeyframeData(), e = t.AddEmptyKeyframeDataItem();
          return e;
        }
        AddPropertyTrack() {
          const t = this._trackDataItem.GetPropertyTrackData(), e = t.AddEmptyPropertyTrackDataItem(), a = C33.PropertyTrackState.Create(this, e);
          return this._propertyTracks.push(a), a;
        }
        DeleteKeyframes(t) {
          const e = this._trackDataItem.GetKeyframeData();
          e.DeleteKeyframeDataItems(t);
        }
        DeletePropertyKeyframes(t) {
          for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t);
        }
        SaveState() {
          for (const t of this._propertyTracks) t.SaveState();
        }
        CompareInitialStateWithCurrent() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t of this._propertyTracks) t.CompareInitialStateWithCurrent();
        }
        CompareSaveStateWithCurrent() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {
            let t = false;
            for (const e of this._propertyTracks) {
              const a = e.CompareSaveStateWithCurrent();
              !t && a && (t = true);
            }
            if (t) {
              const s = this.AddKeyframe();
              s.SetTime(this.GetTimeline().GetTime()), s.SetEase("noease"), s.SetEnable(true), s.SetTags("");
            }
          }
        }
        _OnAfterLoad() {
          isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;
        }
        _SaveToJson() {
          const t = this.GetInstance(), e = t ? t.GetUID() : this.GetInstanceUID();
          return { "propertyTracksJson": this._SavePropertyTracksToJson(), "lastKeyframeDataItemJson": this._SaveLastKeyframeDataItemToJson(), "initialStateOfNestedSet": this._initialStateOfNestedSet, "endStateOfNestedSet": this._endStateOfNestedSet, "instanceUid": e, "cleared": this._cleared };
        }
        _LoadFromJson(t) {
          if (t) {
            this._LoadPropertyTracksFromJson(t["propertyTracksJson"]), this._LoadLastKeyframeDataItemFromJson(t["lastKeyframeDataItemJson"]), this._instanceUidToLoad = t["instanceUid"], this._initialStateOfNestedSet = false, t.hasOwnProperty["initialStateOfNestedSet"] && (this._initialStateOfNestedSet = t["initialStateOfNestedSet"]), this._endStateOfNestedSet = false, t.hasOwnProperty["endStateOfNestedSet"] && (this._endStateOfNestedSet = t["endStateOfNestedSet"]), this._cleared = !!t.hasOwnProperty("cleared") && t["cleared"];
            for (const e of this._propertyTracks) 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0, this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
          }
        }
        _SaveLastKeyframeDataItemToJson() {
          const t = this._trackDataItem.GetKeyframeData();
          return t.GetKeyframeDataItemIndex(this._lastKeyframeDataItem);
        }
        _SavePropertyTracksToJson() {
          return this._propertyTracks.map((t) => t._SaveToJson());
        }
        _LoadPropertyTracksFromJson(t) {
          t.forEach((t2, e) => {
            const a = this._propertyTracks[e];
            a._LoadFromJson(t2);
          });
        }
        _LoadInstanceFromJson(t) {
          if (C33.IsFiniteNumber(t)) {
            const e = this.GetRuntime().GetInstanceByUID(t);
            if (e) {
              const a = this.GetTimeline();
              a.SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());
            }
          }
        }
        _LoadLastKeyframeDataItemFromJson(t) {
          const e = this._trackDataItem.GetKeyframeData();
          this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;
        }
        static Create(e, t) {
          return C33.New(C33.PropertyTrackState, e, t);
        }
        Release() {
          this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;
        }
        GetWorldInfoChange() {
          return this._worldInfoChange;
        }
        GetRenderChange() {
          return this._renderChange;
        }
        GetNeedsBeforeAndAfter() {
          return this._needsBeforeAndAfter;
        }
        HasAbsoluteValueObject() {
          return !!this._absoluteValueObject;
        }
        SetAbsoluteValueObject(e) {
          this._absoluteValueObject = e;
        }
        GetAbsoluteValueObject() {
          return this._absoluteValueObject;
        }
        GetTrack() {
          return this._track;
        }
        GetPropertyTrackDataItem() {
          return this._propertyTrackDataItem;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData;
        }
        GetTimeline() {
          return this._track.GetTimeline();
        }
        GetRuntime() {
          return this._track.GetRuntime();
        }
        GetInstance() {
          return this._track.GetInstance();
        }
        GetSourceAdapter() {
          if (!this._sourceAdapter) {
            const t = this._propertyTrackDataItem.GetSourceAdapterId();
            let e;
            switch (t) {
              case "behavior":
                e = new C33.PropertyTrackState.BehaviorSourceAdapter(this);
                break;
              case "effect":
                e = new C33.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;
                break;
              case "instance-variable":
                e = new C33.PropertyTrackState.InstanceVariableSourceAdapter(this);
                break;
              case "plugin":
                e = new C33.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;
                break;
              case "world-instance":
                e = new C33.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;
                break;
              case "value":
                e = new C33.PropertyTrackState.ValueSourceAdapter(this);
                break;
              case "audio":
                e = new C33.PropertyTrackState.AudioSourceAdapter(this);
            }
            this._sourceAdapter = e;
          }
          return this._sourceAdapter;
        }
        GetSourceAdapterId() {
          return this._propertyTrackDataItem.GetSourceAdapterId();
        }
        SetSourceAdapterId(e) {
          this._propertyTrackDataItem.SetSourceAdapterId(e);
        }
        GetSourceAdapterArgs() {
          return this._propertyTrackDataItem.GetSourceAdapterArguments();
        }
        SetSourceAdapterArgs(e) {
          this._propertyTrackDataItem.SetSourceAdapterArguments(e);
        }
        GetSourceAdapterValue() {
          return this.GetSourceAdapter().GetValue();
        }
        GetPropertyName() {
          return this._propertyTrackDataItem.GetProperty();
        }
        SetPropertyName(e) {
          this._propertyTrackDataItem.SetProperty(e);
        }
        GetPropertyType() {
          return this._propertyTrackDataItem.GetType();
        }
        SetPropertyType(e) {
          this._propertyTrackDataItem.SetType(e);
        }
        GetPropertyKeyframeType() {
          return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();
        }
        GetMin() {
          return this._propertyTrackDataItem.GetMin();
        }
        SetMin(e) {
          this._propertyTrackDataItem.SetMin(e);
        }
        GetMax() {
          return this._propertyTrackDataItem.GetMax();
        }
        SetMax(e) {
          this._propertyTrackDataItem.SetMax(e);
        }
        GetEnable() {
          return this._propertyTrackDataItem.GetEnable();
        }
        SetEnable(e) {
          this._propertyTrackDataItem.SetEnable(e);
        }
        GetInterpolationMode() {
          return this._propertyTrackDataItem.GetInterpolationMode();
        }
        SetInterpolationMode(e) {
          this._propertyTrackDataItem.SetInterpolationMode(e);
        }
        GetResultMode() {
          return this._propertyTrackDataItem.GetResultMode();
        }
        SetResultMode(e) {
          this._propertyTrackDataItem.SetResultMode(e);
        }
        SetEase(e) {
          for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e);
        }
        CanHavePropertyKeyframes() {
          return this._propertyTrackDataItem.CanHavePropertyKeyframes();
        }
        GetPropertyKeyframeDataItems() {
          return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;
        }
        GetPropertyKeyframeDataItemArrayIncludingDisabled() {
          return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();
        }
        GetPropertyKeyFrameDataItemAtTime(e) {
          return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {
          return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
        }
        GetPropertyKeyframeDataItemPairForTime(e) {
          let t = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem), r;
          return r = t ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: t, end: r };
        }
        *GetPropertyKeyframeValues() {
          for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();
        }
        *GetPropertyKeyframeTimes() {
          for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();
        }
        TimelineRemoved() {
          this.GetSourceAdapter().TimelineRemoved();
        }
        CleanCaches() {
          this.GetSourceAdapter().CleanCaches();
        }
        GetCurrentState() {
          return this.GetSourceAdapter().GetCurrentState();
        }
        SetResetState() {
          this.GetSourceAdapter().SetResetState();
        }
        SetInitialState(e) {
          this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();
        }
        SetResumeState(e) {
          this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);
        }
        _SetUpdateState() {
          const e = this.GetTrack();
          if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {
            const t = this.GetTimeline(), r = e.GetInstance(), a = this.GetSourceAdapter(), o = this.GetPropertyName(), s = a.MayNeedBeforeAndAfterInterpolate();
            if (s) {
              const p = t.GetSimilarPropertyTracks(r, a, o, this);
              p && p.length && (this._needsBeforeAndAfter = 1);
            } else this._needsBeforeAndAfter = 0;
          }
        }
        _GetLastPropertyKeyFrameBeforeTime(e) {
          const t = this.GetTimeline(), r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
          return r || (t.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));
        }
        BeforeInterpolate() {
          this._sourceAdapter.BeforeInterpolate();
        }
        Interpolate(e, t = false, r = false, a = false) {
          let o, s, p = false;
          if (t) o = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
          else {
            if (this._lastPropertyKeyframeDataItem) {
              const i = this.GetTimeline(), y = this._lastPropertyKeyframeDataItem.GetNext(), m = this._lastPropertyKeyframeDataItem.GetTime(), n = y ? y.GetTime() : i.GetTotalTime();
              (e <= m || n <= e) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true);
            } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true;
            o = this._lastPropertyKeyframeDataItem;
          }
          o && (s = o.GetNext()), this._sourceAdapter.Interpolate(e, o, s, t, r, a, p);
        }
        GetInterpolatedValue(e) {
          if (this._lastPropertyKeyframeDataItem) {
            const a = this.GetTimeline(), o = this._lastPropertyKeyframeDataItem.GetNext(), s = this._lastPropertyKeyframeDataItem.GetTime(), p = o ? o.GetTime() : a.GetTotalTime();
            (e <= s || p <= e) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
          } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
          const t = this._lastPropertyKeyframeDataItem, r = t.GetNext();
          return this._sourceAdapter.GetInterpolatedValue(e, t, r);
        }
        GetInterpolatedValueFast(e, t, r) {
          return this._sourceAdapter.GetInterpolatedValue(e, t, r);
        }
        AfterInterpolate() {
          this._sourceAdapter.AfterInterpolate();
        }
        static GetStartPropertyKeyframeForTime(e, t) {
          const r = t.GetPropertyTrackDataItem(), a = t._propertyTrackData;
          return a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r);
        }
        static GetEndPropertyKeyframeForTime(e, t) {
          const r = t.GetPropertyTrackDataItem(), a = t._propertyTrackData;
          return a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r);
        }
        AddPropertyKeyframe() {
          const e = this._propertyTrackDataItem.GetPropertyKeyframeData(), t = e.AddEmptyPropertyKeyframeDataItem();
          return this._lastPropertyKeyframeDataItem = null, t;
        }
        DeletePropertyKeyframes(e) {
          this._lastPropertyKeyframeDataItem = null;
          const t = this._propertyTrackDataItem.GetPropertyKeyframeData();
          t.DeletePropertyKeyframeDataItems(e);
        }
        SaveState() {
          this.GetSourceAdapter().SaveState();
        }
        CompareInitialStateWithCurrent() {
          const e = this.GetSourceAdapter().CompareInitialStateWithCurrent();
          if (e) {
            const t = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), r = this.GetSourceAdapter().GetCurrentState();
            t.SetAbsoluteValue(r);
          }
        }
        CompareSaveStateWithCurrent() {
          const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
          return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;
        }
        AddPropertyKeyframeAtCurrentTime() {
          const e = this.GetTimeline().GetTime(), t = this.GetSourceAdapter(), r = C33.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a = this.AddPropertyKeyframe();
          a.SetType(r.GetType()), a.SetTime(e), a.SetEase(r.GetEase()), a.SetEnable(true), a.SetValue(t.GetValueAtTime()), a.SetAbsoluteValue(t.GetCurrentState());
        }
        _SaveToJson() {
          return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson() };
        }
        _LoadFromJson(e) {
          e && this.GetSourceAdapter()._LoadFromJson(e["sourceAdapterJson"]);
        }
      };
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState;
      NS.PropertySourceAdapter = class {
        constructor(e) {
          this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();
        }
        Release() {
          this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();
        }
        GetPropertyTrack() {
          return this._propertyTrack;
        }
        TimelineRemoved() {
          this._propertyAdapter && this._propertyAdapter.TimelineRemoved();
        }
        CleanCaches() {
          this._propertyAdapter && this._propertyAdapter.CleanCaches();
        }
        GetPropertyAdapter() {
          return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;
        }
        GetEditorIndex() {
        }
        GetIndex() {
          return this.GetEditorIndex();
        }
        GetTarget() {
        }
        SetResetState() {
          this.GetPropertyAdapter().SetResetState();
        }
        SetInitialState() {
          this.GetPropertyAdapter().SetInitialState();
        }
        SetResumeState() {
          this.GetPropertyAdapter().SetResumeState();
        }
        BeforeInterpolate() {
          this._propertyAdapter.BeforeChangeProperty();
        }
        Interpolate(e, t, r, p, a, o, n) {
          const s = this._propertyTrack.GetPropertyKeyframeType();
          let i;
          switch (s) {
            case "numeric":
              i = NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
              break;
            case "angle":
              i = NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
              break;
            case "boolean":
              i = NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
              break;
            case "color":
              i = NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
              break;
            case "text":
              i = NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          }
          this._propertyAdapter.ChangeProperty(e, i, t, r, p, a, o, n);
        }
        GetInterpolatedValue(e, t, r) {
          switch (this._propertyTrack.GetPropertyKeyframeType()) {
            case "numeric":
              return NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
            case "angle":
              return NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
            case "boolean":
              return NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
            case "color":
              return NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
            case "text":
              return NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);
          }
        }
        AfterInterpolate() {
          this._propertyAdapter.AfterChangeProperty();
        }
        SaveState() {
          this.GetPropertyAdapter().SetSaveState();
        }
        ClearSaveState() {
          this.GetPropertyAdapter().ClearSaveState();
        }
        GetCurrentState() {
          return this.GetPropertyAdapter().GetCurrentState();
        }
        CompareInitialStateWithCurrent() {
          return this.GetPropertyAdapter().CompareInitialStateWithCurrent();
        }
        CompareSaveStateWithCurrent() {
          return this.GetPropertyAdapter().CompareSaveStateWithCurrent();
        }
        GetValueAtTime() {
          const e = this._propertyTrack, t = e.GetTrack(), r = t.GetTimeline().GetTime(), p = NS.GetStartPropertyKeyframeForTime(r, e), a = p.GetNext(), o = e.GetPropertyKeyframeType();
          switch (o) {
            case "numeric":
              return NS.NumericTypeAdapter.Interpolate(r, p, a, e);
            case "angle":
              return NS.AngleTypeAdapter.Interpolate(r, p, a, e);
            case "boolean":
              return NS.BooleanTypeAdapter.Interpolate(r, p, a, e);
            case "color":
              return NS.ColorTypeAdapter.Interpolate(r, p, a, e);
            case "text":
              return NS.TextTypeAdapter.Interpolate(r, p, a, e);
          }
        }
        _CreatePropertyAdapter() {
          const e = this._propertyTrack, t = e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : "";
          switch (t) {
            case "combo":
            case "boolean":
            case "text":
            case "string":
              return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
            case "numeric":
            case "number":
            case "angle":
              return new ("combo" === this._propertyTrack.GetPropertyType() ? NS.PropertyInterpolationAdapter.NoInterpolationAdapter : NS.PropertyInterpolationAdapter.NumericInterpolationAdapter)(this);
            case "color":
            case "offsetColor":
              return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
            default:
              return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
          }
        }
        _SaveToJson() {
          return { "propertyAdapterJson": this.GetPropertyAdapter()._SaveToJson() };
        }
        _LoadFromJson(e) {
          e && this.GetPropertyAdapter()._LoadFromJson(e["propertyAdapterJson"]);
        }
      };
    }
    {
      const C33 = self.C3, INDEX = 0;
      class InstanceVariableSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e), this._updatedIndex = NaN;
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];
        }
        GetIndex() {
          return this._updatedIndex || super.GetIndex();
        }
        GetTarget() {
          return this._propertyTrack.GetTrack().GetInstance();
        }
        UpdateInstanceVariableIndex(e) {
          const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];
          t !== e && (this._updatedIndex = e);
        }
        Interpolate(e, t, r, a, n, p, d) {
          this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, r, a, n, p, d);
        }
        GetInterpolatedValue(e, t, r) {
          if (this.GetPropertyAdapter().CanChange(t.GetValue())) return super.GetInterpolatedValue(e, t, r);
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "index": this._updatedIndex });
        }
        _LoadFromJson(e) {
          e && (super._LoadFromJson(e), this._updatedIndex = e["index"]);
        }
      }
      C33.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
    }
    {
      const C33 = self.C3, SID = 0, INDEX = 1, NAME = 2;
      class BehaviorSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e), this._sid = NaN;
        }
        GetEditorIndex() {
          const e = this._propertyTrack.GetPropertyTrackDataItem();
          return e.GetSourceAdapterArguments()[INDEX];
        }
        GetTarget() {
          const e = this._propertyTrack.GetPropertyTrackDataItem(), t = this._propertyTrack.GetTrack(), r = this._sid || e.GetSourceAdapterArguments()[SID], a = t.GetInstance(), s = a.GetBehaviorIndexBySID(r), o = a.GetBehaviorInstances()[s];
          return o.GetSdkInstance();
        }
        GetBehaviorType(e) {
          const t = this._propertyTrack.GetPropertyTrackDataItem(), r = t.GetSourceAdapterArguments()[NAME];
          return e.GetBehaviorTypeByName(r);
        }
        UpdateBehaviorTypeSid(e) {
          const t = this._propertyTrack.GetPropertyTrackDataItem();
          t.GetSourceAdapterArguments()[SID] !== e && (this._sid = e);
        }
        Interpolate(e, t, r, a, s, o, p) {
          const c = this._propertyTrack.GetTrack(), n = c.GetInstance();
          this.GetBehaviorType(n.GetObjectClass()) && super.Interpolate(e, t, r, a, s, o, p);
        }
        GetInterpolatedValue(e, t, r) {
          const a = this._propertyTrack.GetTrack(), s = a.GetInstance();
          if (this.GetBehaviorType(s.GetObjectClass())) return super.GetInterpolatedValue(e, t, r);
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "sid": this._sid });
        }
        _LoadFromJson(e) {
          e && (super._LoadFromJson(e), this._sid = e["sid"]);
        }
      }
      C33.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
    }
    {
      const C33 = self.C3, NAME = 0, INDEX = 1;
      class EffectSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
          super(e);
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];
        }
        GetTarget() {
          const e = this._propertyTrack, t = e.GetTrack(), r = t.GetWorldInfo(), c = r.GetInstanceEffectList(), f = c.GetEffectList(), a = this.GetEffectType(f), s = a.GetIndex();
          return c.IsEffectIndexActive(s) ? c.GetEffectParametersForIndex(s) : null;
        }
        GetEffectType(e) {
          const t = this._propertyTrack, r = t.GetPropertyTrackDataItem().GetSourceAdapterArguments()[NAME];
          return e.GetEffectTypeByName(r);
        }
        Interpolate(e, t, r, c, f, a, s) {
          this._IsEffectActive() && super.Interpolate(e, t, r, c, f, a, s);
        }
        GetInterpolatedValue(e, t, r) {
          if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t, r);
        }
        _IsEffectActive() {
          const e = this._propertyTrack, t = e.GetTrack(), r = t.GetWorldInfo(), c = r.GetInstanceEffectList(), f = c.GetEffectList(), a = this.GetEffectType(f);
          if (a) {
            const s = a.GetIndex();
            return c.IsEffectIndexActive(s);
          }
        }
      }
      C33.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
    }
    {
      const C33 = self.C3, INDEX = 0;
      class PluginSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t);
        }
        GetEditorIndex() {
          return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];
        }
        GetTarget() {
          return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();
        }
        Interpolate(t, e, r, a, s, n, c) {
          const p = this._propertyTrack.GetTrack(), i = p.GetObjectClass().GetPlugin(), o = p.GetInstance().GetObjectClass().GetPlugin();
          i === o && super.Interpolate(t, e, r, a, s, n, c);
        }
        GetInterpolatedValue(t, e, r) {
          const a = this._propertyTrack.GetTrack(), s = a.GetObjectClass().GetPlugin(), n = a.GetInstance().GetObjectClass().GetPlugin();
          if (s === n) return super.GetInterpolatedValue(t, e, r);
        }
        GetOptionalCallbacks() {
          const t = this._propertyTrack.GetTrack(), e = t.GetObjectClass().GetPlugin();
          if (C33.Plugins.Sprite && e instanceof C33.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {
            case "relative":
            case "absolute":
              return null;
          }
        }
      }
      C33.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
    }
    {
      const C33 = self.C3;
      class ValueSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t), this._value = 0, this._init = false;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        SetInitialState() {
          const t = this._propertyTrack.GetPropertyTrackData();
          let e = this._propertyTrack.GetPropertyTrackDataItem();
          e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();
        }
        SetResumeState() {
        }
        GetValue() {
          return this._init || this._propertyTrack.Interpolate(0), this._value;
        }
        Interpolate(t, e, r, a, i, o, u) {
          this._value = C33.PropertyTrackState.NumericTypeAdapter.Interpolate(t, e, r, this._propertyTrack), this._init = true;
        }
        SaveState() {
        }
        ClearSaveState() {
        }
        GetCurrentState() {
          return this._value;
        }
        CompareInitialStateWithCurrent() {
          return false;
        }
        CompareSaveStateWithCurrent() {
          return false;
        }
        _SaveToJson() {
          return { "value": this._value, "init": this._init };
        }
        _LoadFromJson(t) {
          t && (this._value = t["value"], this._init = !t.hasOwnProperty("init") || t["init"]);
        }
      }
      C33.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
    }
    {
      const C33 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;
      class AudioSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {
        constructor(t) {
          super(t), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[PROJECT_FILE], this._startOffsetTime = this._sourceAdapterArgs[START_OFFSET], this._sourceAdapterArgs[AUDIO_TAG] ? this._audioTag = this._sourceAdapterArgs[AUDIO_TAG] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();
        }
        Release() {
          super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;
        }
        _Initialize() {
          if (self.C3.Plugins.Audio) {
            const t = this._propertyTrack.GetRuntime(), e = t.GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
            e && (this._sdkInstance = e.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;
          }
        }
        _MaybeSetAudioSource() {
          if (!this._audioSource) {
            const t = this._propertyTrack.GetTrack(), e = t.GetPropertyTrack("audioSource");
            e && (this._audioSource = e.GetSourceAdapter());
          }
        }
        _GetPauseVolume() {
          const t = this._propertyTrack.GetTrack(), e = t.GetPropertyTrack("volume");
          return (e ? e.GetSourceAdapter() : this)._pauseVolume;
        }
        TimelineRemoved() {
          super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions) && this._actions.Stop.call(this._sdkInstance, this._audioTag);
        }
        GetAudioTag() {
          return this._audioTag;
        }
        GetVolume() {
          return this._volume;
        }
        SetVolume(t) {
          this._volume = t;
        }
        SetInitialState() {
          super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;
        }
        SetResumeState() {
          super.SetResumeState();
          const t = this._propertyTrack.GetTimeline(), e = t.GetTime();
          switch (this._pauseTime = e - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {
            case "audioSource":
              break;
            case "volume":
              this._pauseVolume = this._propertyTrack.GetInterpolatedValue(e);
          }
          this._audioPlaybackStarted = false;
        }
        Interpolate(t, e, s, i, a, o, r) {
          if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource": {
              if (!this._timeline.IsForwardPlayBack()) return;
              if (i) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
              if (t < this._startOffsetTime) return void (this._audioPlaybackStarted = false);
              const u = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), _ = this._timeline.GetPlaybackRate();
              if (_ !== u && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, _), this._audioPlaybackStarted) return;
              if (!this._propertyTrack.GetTimeline().IsPlaying()) return;
              if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {
                const l = self["performance"].now(), h = t - this._startOffsetTime, c = this._sdkInstance.GetAudioContextState();
                if ("suspended" === c) return void (this._audioPlaybackStarted = false);
                const n = self["performance"].now(), d = (n - l) / 1e3, p = h + d;
                if (this._actions) {
                  let t2 = this.GetVolume();
                  isNaN(t2) ? (this.SetVolume(0), t2 = 0) : this.SetVolume(t2), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t2, this._audioTag, p);
                }
              } else {
                const S = this._pauseTime, m = (this._pauseTime = NaN, this._GetPauseVolume()), T = (this._pauseVolume = NaN, this._sdkInstance.GetAudioContextState());
                if ("suspended" === T) return void (this._audioPlaybackStarted = false);
                this._actions && (this.SetVolume(m), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, m, this._audioTag, S));
              }
              break;
            }
            case "volume":
              this._MaybeSetAudioSource(), super.Interpolate(t, e, s, i, a, o, r);
          }
        }
        GetInterpolatedValue(t, e, s) {
          if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource":
              return;
            case "volume":
              return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t, e, s);
          }
        }
        Getter(t, e) {
          return this._audioSource ? this._audioSource.GetVolume() : 0;
        }
        Setter(t, e, s, i) {
          this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
        }
        AbsoluteSetter(t, e, s) {
          this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
        }
        DoesRounding() {
          return true;
        }
        _SaveToJson() {
          return { "audioPlaybackStarted": this._audioPlaybackStarted, "audioTag": this._audioTag, "pauseTime": this._pauseTime, "pauseVolume": this._pauseVolume, "volume": this._volume };
        }
        _LoadFromJson(t) {
          t && (this._audioPlaybackStarted = t["audioPlaybackStarted"], this._audioTag = t["audioTag"], this._pauseTime = t["pauseTime"], this._pauseVolume = t["pauseVolume"], this._volume = t["volume"], this._Initialize());
        }
      }
      C33.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.PropertyInterpolationAdapter = class {
        constructor(t) {
          this._sourceAdapter = t, this._propertyTrack = t.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;
        }
        Release() {
          this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        TimelineRemoved() {
        }
        CleanCaches() {
          this._worldInfo = null, this._saveState = null, this._target = null;
        }
        GetSourceAdapter() {
          return this._sourceAdapter;
        }
        GetPropertyTrack() {
          return this._propertyTrack;
        }
        GetWorldInfo() {
          return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;
        }
        SetFirstAbsoluteUpdate(t) {
          this._firstAbsoluteUpdate = !!t;
        }
        GetFirstAbsoluteUpdate() {
          return this._firstAbsoluteUpdate;
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        SetSaveState() {
          this._saveState = this.GetCurrentState();
        }
        ClearSaveState() {
          this._saveState = null;
        }
        GetCurrentState() {
        }
        CompareInitialStateWithCurrent() {
        }
        CompareSaveStateWithCurrent() {
        }
        CanChange(t) {
          const e = typeof this._Getter(), r = typeof t;
          return e == r;
        }
        BeforeChangeProperty() {
        }
        ChangeProperty(t, e, r, a, s, o, i, n) {
        }
        AfterChangeProperty() {
        }
        _FirstKeyframeGetter() {
          const t = this._PickTimelinePlaybackMode(() => {
            const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e = this._propertyTrack.GetPropertyTrackData();
            return e.GetFirstPropertyKeyframeDataItem(t2);
          }, () => {
            const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e = this._propertyTrack.GetPropertyTrackData();
            return e.GetLastPropertyKeyframeDataItem(t2);
          });
          return t.GetAbsoluteValue();
        }
        _CurrentKeyframeGetter() {
          const t = this._propertyTrack.GetTimeline(), a = t.GetTime() - this._propertyTrack.GetTrack().GetStartOffset(), e = this._PickTimelinePlaybackMode(() => {
            const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e2 = this._propertyTrack.GetPropertyTrackData();
            return e2.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, t2);
          }, () => {
            const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e2 = this._propertyTrack.GetPropertyTrackData(), r = e2.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, t2);
            return r || e2.GetLastPropertyKeyframeDataItem(t2);
          });
          return e.GetAbsoluteValue();
        }
        _PickTimelinePlaybackMode(t, e) {
          const r = this._propertyTrack.GetTimeline();
          return (r.IsForwardPlayBack() ? t : e)();
        }
        _PickResultMode(t, e) {
          const r = this._propertyTrack.GetResultMode();
          return ("relative" === r ? t : e)();
        }
        _PickFirstAbsoluteUpdate(t, e) {
          return (this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t) : e)();
        }
        _GetAbsoluteInitialValue(t) {
        }
        _GetIndex() {
          return this._sourceAdapter.GetIndex();
        }
        _GetTarget() {
          return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;
        }
        _PickSource(t, e, r, a, s, o) {
          const i = this._propertyTrack.GetSourceAdapterId();
          switch (i) {
            case "behavior":
              return t();
            case "effect":
              return e();
            case "instance-variable":
              return r();
            case "plugin":
              return a();
            case "world-instance":
              return s();
            case "audio":
              return o();
          }
        }
        _SaveToJson() {
          return { "firstAbsoluteUpdate": this._firstAbsoluteUpdate, "saveState": this._saveState };
        }
        _LoadFromJson(t) {
          t && (this._firstAbsoluteUpdate = t["firstAbsoluteUpdate"], this._saveState = t["saveState"]);
        }
        _GetPropertyKeyframeStubs(t, e = false) {
          const r = [];
          for (const a of t) {
            const s = a.GetTrack().GetStartOffset();
            for (const o of a.GetPropertyKeyframeDataItems()) (!e || 0 !== o.GetTime()) && e || r.push({ time: s + o.GetTime(), value: o.GetAbsoluteValue() });
          }
          return r.sort((t2, e2) => t2.time - e2.time);
        }
        _GetLastPropertyKeyframeStub(t, e, r) {
          return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r);
        }
        _GetPropertyKeyframeStubLowerThanPlayhead(e, r) {
          for (let t = r.length - 1; 0 <= t; t--) {
            const a = r[t].time;
            if (a <= e) return r[t];
          }
          return null;
        }
      };
    }
    {
      const C33 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];
      class ColorInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
          super(e);
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        GetCurrentState() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
          switch (e) {
            case "behavior":
              return this._ToColorArray(t.GetPropertyValueByIndex(r));
            case "effect":
              return this._ToColorArray(t[r]);
            case "plugin":
              return this._ToColorArray(t.GetPropertyValueByIndex(r));
            case "world-instance":
              return this._ToColorArray(this._Getter());
          }
        }
        CompareInitialStateWithCurrent() {
          const e = this._FirstKeyframeGetter();
          return !this._CompareColors(e, this._Getter());
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());
        }
        _CompareColors(e, t) {
          return e = this._GetColorFromArray(e), t = this._GetColorFromArray(t), e.equalsIgnoringAlpha(t);
        }
        _FirstKeyframeGetter() {
          const e = super._FirstKeyframeGetter();
          return this._GetColorFromArray(e);
        }
        _CurrentKeyframeGetter() {
          const e = super._CurrentKeyframeGetter();
          return this._GetColorFromArray(e);
        }
        _GetAbsoluteInitialValue(e) {
        }
        _ToColorArray(e) {
          return (C33.IsInstanceOf(e, C33.Color) ? e.toArray() : e).slice(0, 3);
        }
        _GetColorFromArray(e) {
          return C33.IsInstanceOf(e, C33.Color) ? e : new C33.Color(e[0], e[1], e[2], 1);
        }
        CanChange(e) {
          return true;
        }
        MayNeedBeforeAndAfterInterpolate() {
          return true;
        }
        BeforeChangeProperty() {
          const e = this._propertyTrack.GetTimeline(), t = this._propertyTrack.GetInstance(), r = this._propertyTrack.GetSourceAdapter(), o = e.GetSimilarPropertyTracks(t, r, this._property, this._propertyTrack);
          if (o && 1 < o.length) {
            TMP_COLORS_MAP.has(t) || TMP_COLORS_MAP.set(t, /* @__PURE__ */ new Map());
            const a = TMP_COLORS_MAP.get(t), s = this._propertyTrack.GetSourceAdapterId(), n = (a.has(s) || a.set(s, /* @__PURE__ */ new Map()), a.get(s));
            n.has(this._property) || n.set(this._property, { used: false, color: new C33.Color(0, 0, 0, 1) });
          }
        }
        _GetTmpColor(e, t, r) {
          const o = TMP_COLORS_MAP.get(e).get(t).get(r);
          return o.used = true, o.color;
        }
        ChangeProperty(e, t, r, o, a, s, n, i) {
          const p = this._propertyTrack.GetTimeline(), _ = this._propertyTrack.GetTrack(), l = this._propertyTrack.GetInstance(), c = this._propertyTrack.GetSourceAdapter(), h = this._propertyTrack.GetSourceAdapterId(), C = this._property, y = p.GetSimilarPropertyTracks(l, c, C, this._propertyTrack);
          if (y && 1 < y.length) {
            const u = this._GetPropertyKeyframeStubs(y, true), G = this._GetLastPropertyKeyframeStub(p, p.GetTime(), u);
            if (G) {
              const T = _.GetStartOffset(), d = G.time - T;
              if (0 == d) this._GetTmpColor(l, h, this._property).addRgb(t[0], t[1], t[2]);
              else if (!(d < 0)) {
                const P = t[0], S = t[1], f = t[2], A = this._propertyTrack.Interpolate(d, false, true), O = C33.Color.DiffChannel(P, A[0]), I = C33.Color.DiffChannel(S, A[1]), m = C33.Color.DiffChannel(f, A[2]);
                this._GetTmpColor(l, h, this._property).addRgb(O, I, m);
              }
            }
          } else this._Setter(t[0], t[1], t[2]);
        }
        AfterChangeProperty() {
          const e = this._propertyTrack.GetInstance();
          if (TMP_COLORS_MAP.has(e)) {
            const t = TMP_COLORS_MAP.get(e), r = this._propertyTrack.GetSourceAdapterId();
            if (t.has(r)) {
              const o = t.get(r);
              if (o.has(this._property)) {
                const a = o.get(this._property), s = a.used, n = a.color;
                s && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o.size && t.delete(r), 0 === t.size && TMP_COLORS_MAP.delete(e);
              }
            }
          }
        }
        _Getter() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
          switch (e) {
            case "behavior":
              return this._GetColorFromArray(t.GetPropertyValueByIndex(r));
            case "effect":
              return t[r].clone();
            case "plugin":
              return this._GetColorFromArray(t.GetPropertyValueByIndex(r));
            case "world-instance":
              return this.GetWorldInfo().GetUnpremultipliedColor().clone();
          }
        }
        _Setter(e, t, r) {
          const o = this._propertyTrack.GetSourceAdapterId(), a = this._GetTarget(), s = this._GetIndex();
          switch (o) {
            case "behavior":
              TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, a.SetPropertyValueByIndex(s, TMP_COLOR);
              break;
            case "effect":
              a[s].setRgb(e, t, r);
              break;
            case "plugin":
              TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, a.SetPropertyValueByIndex(s, TMP_COLOR);
              break;
            case "world-instance":
              this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t, r);
          }
        }
        _SaveToJson() {
        }
        _LoadFromJson(e) {
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState;
      class NoInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
          super(e);
        }
        SetResetState() {
        }
        SetInitialState() {
        }
        SetResumeState() {
        }
        GetCurrentState() {
          return this._Getter();
        }
        CompareInitialStateWithCurrent() {
          const e = this._FirstKeyframeGetter();
          return e !== this.GetCurrentState();
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        ChangeProperty(e, t, r, a, n, s, i, o) {
          const p = this._propertyTrack, c = p.GetTrack(), l = p.GetSourceAdapterId(), h = p.GetTimeline(), u = c.GetInstance(), S = p.GetSourceAdapter(), G = this._property, d = h.GetSimilarPropertyTracks(u, S, G, p);
          if (d && 1 < d.length) {
            const _ = this._GetPropertyKeyframeStubs(d), I = e + c.GetStartOffset(), T = this._GetLastPropertyKeyframeStub(h, I, _);
            T && (t = T.value);
          }
          const y = p.GetPropertyKeyframeType();
          switch (y) {
            case "numeric":
              if (NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;
              return;
            case "angle":
              if (NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;
              return;
            case "boolean":
              if (NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;
              return;
            case "color":
              if (NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;
              return;
            case "text":
              if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;
          }
          this._Setter(t);
        }
        _Getter() {
          const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();
          switch (e) {
            case "behavior":
              return t.GetPropertyValueByIndex(r);
            case "effect":
              return t[r];
            case "instance-variable":
              return t.GetInstanceVariableValue(r);
            case "plugin":
              return t.GetPropertyValueByIndex(r);
          }
        }
        _Setter(e) {
          const t = this._propertyTrack.GetSourceAdapterId(), r = this._GetTarget(), a = this._GetIndex();
          switch (t) {
            case "behavior":
              r.SetPropertyValueByIndex(a, e);
              break;
            case "effect":
              r[a] = e;
              break;
            case "instance-variable":
              r.SetInstanceVariableValue(a, e);
              break;
            case "plugin":
              r.SetPropertyValueByIndex(a, e);
          }
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
    }
    {
      const C33 = self.C3, NS = C33.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add2 = (t, e, r, a, i, s = false, o = null, n = null) => {
        INSTANCE_FUNC_MAP.set(t, { setter: e, absolute_setter: r, getter: a, round: i, fRound: s, init: o, reset: n });
      };
      add2("offsetX", (t, e, r, a) => {
        "relative" === a._propertyTrack.GetResultMode() ? t.OffsetX(e, r.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetX(e);
      }, (t, e) => t.SetX(e), (t) => t.GetX(), true), add2("offsetY", (t, e, r, a) => {
        "relative" === a._propertyTrack.GetResultMode() ? t.OffsetY(e, r.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetY(e);
      }, (t, e) => t.SetY(e), (t) => t.GetY(), true), add2("offsetWidth", (e, t, a, i, r) => {
        if (0 !== t) {
          const s = "relative" === i._propertyTrack.GetResultMode(), o = 1 === i._typeAdapter.GetType();
          if ((s || o) && e.HasParent() && e.GetTransformWithParentWidth()) {
            if (isNaN(i._absoluteToFactor)) {
              const n = [];
              let t2 = e.GetParent();
              for (; t2; ) n.push(t2), t2 = t2.GetParent();
              n.reverse();
              const c = (t3, e2) => e2.GetTimeline().GetTrackFromInstance(t3.GetInstance()), l = (t3, e2) => {
                const r3 = c(t3, e2);
                if (r3) return r3.GetOriginalWidth();
                const a2 = t3.GetInstance().GetSdkInstance();
                return a2.IsOriginalSizeKnown() ? a2.GetOriginalWidth() : t3._GetSceneGraphInfo()._GetStartWidth();
              }, p = (t3, e2, r3, a2 = 0) => {
                const i2 = c(t3, e2);
                if (!i2) return a2;
                const s2 = i2.GetPropertyTrack(r3);
                if (!s2) return a2;
                const o2 = s2.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                if (!o2) return a2;
                const n2 = o2.GetLastPropertyKeyframeDataItem();
                return n2 ? n2.GetValue() : a2;
              };
              let r2;
              if (o) {
                let t3 = n[n.length - 1];
                r2 = t3.GetWidth();
              } else {
                let e2 = n[0];
                const _ = e2._GetSceneGraphInfo()._GetStartWidth(), h = e2._GetSceneGraphInfo().GetStartScaleX();
                r2 = _ * h, r2 = (r2 += p(e2, a, "offsetWidth")) + l(e2, a) * p(e2, a, "offsetScaleX");
                for (let t3 = 1; t3 < n.length; t3++) {
                  const u = (e2 = n[t3])._GetSceneGraphInfo().GetStartScaleX();
                  r2 = (r2 = (r2 *= u) + p(e2, a, "offsetWidth")) + l(e2, a) * p(e2, a, "offsetScaleX");
                }
              }
              i._absoluteToFactor = 0 === r2 ? Number.EPSILON : r2;
            }
            r || e.OffsetWidth(t / i._absoluteToFactor, true);
          } else e.OffsetWidth(t);
        }
      }, (t, e) => t.SetWidth(e), (t) => t.GetWidth(), true), add2("offsetHeight", (e, t, a, i, r) => {
        if (0 !== t) {
          const s = "relative" === i._propertyTrack.GetResultMode(), o = 1 === i._typeAdapter.GetType();
          if ((s || o) && e.HasParent() && e.GetTransformWithParentHeight()) {
            if (isNaN(i._absoluteToFactor)) {
              const n = [];
              let t2 = e.GetParent();
              for (; t2; ) n.push(t2), t2 = t2.GetParent();
              n.reverse();
              const c = (t3, e2) => {
                a2 = t3;
                const r3 = e2.GetTimeline().GetTrackFromInstance(a2.GetInstance());
                var a2;
                if (r3) return r3.GetOriginalHeight();
                const i2 = t3.GetInstance().GetSdkInstance();
                return i2.IsOriginalSizeKnown() ? i2.GetOriginalHeight() : t3._GetSceneGraphInfo()._GetStartHeight();
              }, l = (t3, e2, r3, a2 = 0) => {
                const i2 = e2.GetTimeline().GetTrackFromInstance(t3.GetInstance());
                if (!i2) return a2;
                const s2 = i2.GetPropertyTrack(r3);
                if (!s2) return a2;
                const o2 = s2.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                if (!o2) return a2;
                const n2 = o2.GetLastPropertyKeyframeDataItem();
                return n2 ? n2.GetValue() : a2;
              };
              let r2;
              if (o) {
                let t3 = n[n.length - 1];
                r2 = t3.GetHeight();
              } else {
                let e2 = n[0];
                const p = e2._GetSceneGraphInfo()._GetStartHeight(), _ = e2._GetSceneGraphInfo().GetStartScaleY();
                r2 = p * _, r2 = (r2 += l(e2, a, "offsetHeight")) + c(e2, a) * l(e2, a, "offsetScaleY");
                for (let t3 = 1; t3 < n.length; t3++) {
                  const h = (e2 = n[t3])._GetSceneGraphInfo().GetStartScaleY();
                  r2 = (r2 = (r2 *= h) + l(e2, a)) + c(e2, a) * l(e2, a, "offsetScaleY");
                }
              }
              i._absoluteToFactor = 0 === r2 ? Number.EPSILON : r2;
            }
            r || e.OffsetHeight(t / i._absoluteToFactor, true);
          } else e.OffsetHeight(t);
        }
      }, (t, e) => t.SetHeight(e), (t) => t.GetHeight(), true), add2("offsetAngle", (t, e, r, a, i) => {
        t.OffsetAngle(e);
      }, (t, e) => t.SetAngle(e), (t) => t.GetAngle(), false, true), add2("offsetOpacity", (t, e, r, a, i) => {
        const s = a._opacityFactor || 1, o = (e /= s, t.GetOpacity()), n = o + e;
        if (0 === a._clampAccumulator) 1 < n ? a._clampAccumulator += n - 1 : n < 0 && (a._clampAccumulator += n), t.OffsetOpacity(e);
        else {
          const n2 = t.GetOpacity() + e;
          0 < e && 0 < a._clampAccumulator ? 1 < n2 && (a._clampAccumulator += n2 - 1) : 0 < e && a._clampAccumulator < 0 ? (a._clampAccumulator += e, 0 < a._clampAccumulator && (t.OffsetOpacity(a._clampAccumulator), a._clampAccumulator = 0)) : e < 0 && 0 < a._clampAccumulator ? (a._clampAccumulator += e, a._clampAccumulator < 0 && (t.OffsetOpacity(a._clampAccumulator), a._clampAccumulator = 0)) : e < 0 && a._clampAccumulator < 0 && n2 < 0 && (a._clampAccumulator += n2);
        }
      }, (t, e) => {
        t.SetOpacity(e);
      }, (t) => t.GetOpacity(), false, true, (r, a, i) => {
        switch (r._clampAccumulator = 0, r._propertyTrack.GetResultMode()) {
          case "relative": {
            r._propertyTrack.GetPropertyTrackData();
            const s = r._propertyTrack.GetPropertyTrackDataItem(), o = s.GetPropertyKeyframeData(), n = o.GetPropertyKeyframeDataItemArray();
            let t2 = r.GetWorldInfo().GetOpacity(), e2 = t2;
            for (const c of n) {
              const l = c.GetTime(), p = r._propertyTrack.GetInterpolatedValue(l);
              e2 = t2 + p, e2 = C33.clamp(e2, 0, 1);
            }
            r._totalForewardOpacityDelta = t2 - e2, r._totalForewardOpacityDelta = Math.round(100 * (r._totalForewardOpacityDelta + Number.EPSILON)) / 100, e2 = t2;
            for (let t3 = n.length - 1; 0 <= t3; t3--) {
              const _ = n[t3].GetTime(), h = r._propertyTrack.GetInterpolatedValue(_);
              e2 -= h, e2 = C33.clamp(e2, 0, 1);
            }
            r._totalBackwardOpacityDelta = e2, r._totalBackwardOpacityDelta = Math.round(100 * (r._totalBackwardOpacityDelta + Number.EPSILON)) / 100;
            break;
          }
        }
        const t = "relative" === r._propertyTrack.GetResultMode(), e = 1 === r._typeAdapter.GetType();
        if ((t || e) && a.HasParent() && a.GetTransformWithParentOpacity()) {
          const u = [];
          let t2 = a.GetParent();
          for (; t2; ) u.push(t2), t2 = t2.GetParent();
          u.reverse();
          const f = (t3, e3, r2) => {
            const a2 = e3.GetTimeline().GetTrackFromInstance(t3.GetInstance());
            if (!a2) return 0;
            const i2 = a2.GetPropertyTrack(r2);
            if (!i2) return 0;
            const s = i2.GetPropertyTrackDataItem().GetPropertyKeyframeData();
            if (!s) return 0;
            const o = s.GetLastPropertyKeyframeDataItem();
            return o ? o.GetValue() : 0;
          };
          let e2 = u[0]._GetSceneGraphInfo().GetStartOpacity();
          e2 += f(u[0], i, "offsetOpacity");
          for (let t3 = 1; t3 < u.length; t3++) e2 += f(u[t3], i, "offsetOpacity");
          r._opacityFactor = 0 === e2 ? 1 : e2;
        }
      }, (e) => {
        switch (e._propertyTrack.GetResultMode()) {
          case "relative": {
            e._clampAccumulator = 0;
            const r = e.GetWorldInfo();
            let t = r.GetOpacity();
            t = Math.round(100 * (t + Number.EPSILON)) / 100, e._propertyTrack.GetTimeline().IsForwardPlayBack() ? (r.SetOpacity(t + e._totalForewardOpacityDelta), e._lastValue = 0) : (r.SetOpacity(t - e._totalBackwardOpacityDelta), e._lastValue = e.GetSourceAdapter().GetValueAtTime());
            break;
          }
        }
      }), add2("offsetOriginX", (t, e) => t.OffsetOriginX(e), (t, e) => t.SetOriginX(e), (t) => t.GetOriginX(), false), add2("offsetOriginY", (t, e) => t.OffsetOriginY(e), (t, e) => t.SetOriginY(e), (t) => t.GetOriginY(), false), add2("offsetZElevation", (t, e) => t.OffsetZElevation(e), (t, e) => t.SetZElevation(e), (t) => t.GetZElevation(), true), add2("offsetScaleX", (t, e, r, a) => {
        if (0 !== e) {
          const i = t.GetWidth() < 0 ? -1 : 1;
          if ("relative" === a._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentWidth()) {
            const s = r.GetOriginalWidth() * i * e;
            isNaN(a._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(t, 1, r, a, true), t.OffsetWidth(s / a._absoluteToFactor, true);
          } else t.OffsetWidth(r.GetOriginalWidth() * i * e);
        }
      }, (t, e, r) => {
        t.SetWidth(r.GetOriginalWidth() * e);
      }, (e, r) => {
        const a = e.GetWidth() < 0 ? -1 : 1;
        if (e.GetTransformWithParentWidth()) {
          const i = e.GetParent(), s = r.GetTimeline().GetTrackFromInstance(i.GetInstance());
          let t = NaN;
          if (s) t = i.GetWidth() / s.GetOriginalWidth();
          else {
            const o = i.GetInstance().GetSdkInstance();
            t = o.IsOriginalSizeKnown() ? i.GetWidth() / o.GetOriginalWidth() : 1;
          }
          return e.GetWidth() * a / (r.GetOriginalWidth() * t);
        }
        return e.GetWidth() * a / r.GetOriginalWidth();
      }, false), add2("offsetScaleY", (t, e, r, a) => {
        if (0 !== e) {
          const i = t.GetHeight() < 0 ? -1 : 1;
          if ("relative" === a._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentHeight()) {
            const s = r.GetOriginalHeight() * i * e;
            isNaN(a._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(t, 1, r, a, true), t.OffsetHeight(s / a._absoluteToFactor, true);
          } else t.OffsetHeight(r.GetOriginalHeight() * i * e);
        }
      }, (t, e, r) => {
        t.SetHeight(r.GetOriginalHeight() * e);
      }, (e, r) => {
        const a = e.GetHeight() < 0 ? -1 : 1;
        if (e.GetTransformWithParentHeight()) {
          const i = e.GetParent(), s = r.GetTimeline().GetTrackFromInstance(i.GetInstance());
          let t = NaN;
          if (s) t = i.GetHeight() / s.GetOriginalHeight();
          else {
            const o = i.GetInstance().GetSdkInstance();
            t = o.IsOriginalSizeKnown() ? i.GetHeight() / o.GetOriginalHeight() : 1;
          }
          return e.GetHeight() * a / (r.GetOriginalHeight() * t);
        }
        return e.GetHeight() * a / r.GetOriginalHeight();
      }, false);
      class NumericInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(t) {
          super(t), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C33.IsInstanceOf(this._propertyTrack.GetTimeline(), C33.TweenState) ? this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
          const e = this._propertyTrack.GetPropertyName();
          switch (this._propertyTrack.GetSourceAdapterId()) {
            case "world-instance": {
              const r = INSTANCE_FUNC_MAP.get(e);
              this._instance_getter = r.getter, this._instance_setter = r.setter, this._instance_absolute_setter = r.absolute_setter, this._round = r.round, this._fRound = r.fRound, this._init_action = r.init, this._reset_action = r.reset;
              break;
            }
            case "audio":
              this._source_adapter_getter = t.Getter, this._source_adapter_setter = t.Setter, this._source_adapter_absolute_setter = t.AbsoluteSetter, this._round = !!t.DoesRounding(), this._fRound = false;
          }
        }
        Release() {
          this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();
        }
        MayNeedBeforeAndAfterInterpolate() {
          return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();
        }
        GetLastValue() {
          return this._lastValue;
        }
        SetLastValue(t) {
          this._lastValue = t;
        }
        SetResetState() {
          this._reset_action && this._reset_action(this);
        }
        SetInitialState() {
          const t = this._typeAdapter.SetInitialState();
          if ("number" == typeof t && (this._lastValue = t), this._init_action) {
            const e = this.GetWorldInfo(), r = this._propertyTrack.GetTrack();
            this._init_action(this, e, r);
          }
        }
        SetResumeState() {
          const t = this._typeAdapter.SetResumeState();
          "number" == typeof t && (this._lastValue = t);
        }
        GetCurrentState() {
          return this._Getter();
        }
        CompareInitialStateWithCurrent() {
          const t = this._FirstKeyframeGetter();
          return t !== this.GetCurrentState();
        }
        CompareSaveStateWithCurrent() {
          return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
        }
        BeforeChangeProperty() {
          this._typeAdapter.BeforeChangeProperty();
        }
        ChangeProperty(t, e, r, a, i, s, o, n) {
          return this._typeAdapter.ChangeProperty(t, e, r, a, i, s, o, n);
        }
        AfterChangeProperty() {
          this._typeAdapter.AfterChangeProperty();
        }
        _Getter() {
          const t = this._GetTarget(), e = this._GetIndex(), r = this.GetWorldInfo(), a = this._propertyTrack.GetTrack(), i = this._propertyTrack.GetSourceAdapterId();
          switch (i) {
            case "behavior":
              return t.GetPropertyValueByIndex(e);
            case "effect":
              return t[e];
            case "instance-variable":
              return t.GetInstanceVariableValue(e);
            case "plugin":
              return t.GetPropertyValueByIndex(e);
            case "world-instance":
              return this._instance_getter(r, a);
            case "audio":
              return this._source_adapter_getter.call(this.GetSourceAdapter(), r, a);
          }
        }
        _Setter(t, e, r) {
          const a = this._GetTarget(), i = this._GetIndex(), s = this.GetWorldInfo(), o = this._propertyTrack.GetTrack(), n = this._propertyTrack.GetSourceAdapterId();
          switch (n) {
            case "behavior":
              a.OffsetPropertyValueByIndex(i, t);
              break;
            case "effect":
              a[i] += t;
              break;
            case "instance-variable":
              a.SetInstanceVariableOffset(i, t);
              break;
            case "plugin":
              a.OffsetPropertyValueByIndex(i, t, this.GetSourceAdapter().GetOptionalCallbacks());
              break;
            case "world-instance":
              this._instance_setter(s, t, o, this);
              break;
            case "audio":
              this._source_adapter_setter.call(this.GetSourceAdapter(), s, t, o, this);
          }
        }
        _SetterAbsolute(t, e, r) {
          let a = this._propertyTrack.GetInterpolationMode();
          if ("discrete" !== (a = "default" === a ? "continuous" : a) || e) {
            if ("discrete" === a && r) {
              const l = this._propertyTrack.GetTimeline(), p = l.GetTime(), _ = this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(p);
              if (!_) return;
            }
            const i = this._GetTarget(), s = this._GetIndex(), o = this.GetWorldInfo(), n = this._propertyTrack.GetTrack(), c = this._propertyTrack.GetSourceAdapterId();
            switch (c) {
              case "behavior":
                i.SetPropertyValueByIndex(s, t);
                break;
              case "effect":
                i[s] = t;
                break;
              case "instance-variable":
                i.SetInstanceVariableValue(s, t);
                break;
              case "plugin":
                i.SetPropertyValueByIndex(s, t, this.GetSourceAdapter().GetOptionalCallbacks());
                break;
              case "world-instance":
                this._instance_absolute_setter(o, t, n);
                break;
              case "audio":
                this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), o, t, n);
            }
          }
        }
        _MaybeEnsureValue(t, e, r, a, i, s, o, n) {
          this._typeAdapter._MaybeEnsureValue(t, e, r, a, i, s, o, n);
        }
        _AddDelta(t, e, r, a, i) {
          const s = (t = "angle" === this._propertyTrack.GetPropertyType() ? C33.toDegrees(t) : t).toString(), o = s.split(".")[1] || "", n = o.length, c = this._Getter();
          let l;
          switch (l = 0 === n ? this._round ? Math.round(c) : this._fRound ? "angle" === this._propertyTrack.GetPropertyType() ? C33.toRadians(Math.round(C33.toDegrees(c))) : Number(C33.toFixed(c, 2)) : c : this._round ? Number(C33.toFixed(c, n)) : (this._fRound, c), this._Setter(l - c, e, r), this._propertyTrack.GetPropertyName()) {
            case "offsetWidth":
            case "offsetScaleX": {
              const p = this.GetWorldInfo(), _ = p.GetWidth(), h = Number(C33.toFixed(_, 2));
              p.OffsetWidth(h - _);
              break;
            }
            case "offsetHeight":
            case "offsetScaleY": {
              const u = this.GetWorldInfo(), f = u.GetHeight(), d = Number(C33.toFixed(f, 2));
              u.OffsetHeight(d - f);
              break;
            }
          }
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "v": this._lastValue, "a": this._clampAccumulator, "fod": this._totalForewardOpacityDelta, "bod": this._totalBackwardOpacityDelta, "of": this._opacityFactor, "sf": this._absoluteToFactor, "armorf": this._angleReflectMirrorOrFlip, "armandf": this._angleReflectMirrorAndFlip });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._lastValue = t["v"], this._clampAccumulator = t["a"], this._totalForewardOpacityDelta = C33.IsFiniteNumber(t["fod"]) ? t["fod"] : 0, this._totalBackwardOpacityDelta = C33.IsFiniteNumber(t["bod"]) ? t["bod"] : 0, this._opacityFactor = C33.IsFiniteNumber(t["of"]) ? t["of"] : NaN, this._absoluteToFactor = C33.IsFiniteNumber(t["sf"]) ? t["sf"] : NaN, this._angleReflectMirrorOrFlip = C33.IsFiniteNumber(t["armorf"]) ? t["armorf"] : void 0, this._angleReflectMirrorAndFlip = C33.IsFiniteNumber(t["armandf"]) ? t["armandf"] : void 0);
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
    }
    {
      const C33 = self.C3;
      class AbsoluteValueObject {
        constructor(e) {
          this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;
          for (let e2 = 0, t = this._propertyTracks.length; e2 < t; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);
        }
        GetPropertyTracks() {
          return this._propertyTracks;
        }
        SetUsed() {
          this._used = true;
        }
        GetUsed() {
          return this._used;
        }
        SetValue(e) {
          this._value = e;
        }
        GetValue() {
          return this._value;
        }
        SetPropertyKeyframeReached(e) {
          this._propertyKeyframeReached = e;
        }
        GetPropertyKeyframeReached() {
          return this._propertyKeyframeReached;
        }
        SetEndState(e) {
          this._endState = e;
        }
        GetEndState() {
          return this._endState;
        }
        Reset() {
          this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;
        }
      }
      class NumericInterpolationAdapterForTimeline {
        constructor(e) {
          this._numericInterpolationAdapter = e;
        }
        Release() {
          this._numericInterpolationAdapter = null;
        }
        GetType() {
          return 0;
        }
        SetInitialState() {
          const e = this._numericInterpolationAdapter;
          this._numericInterpolationAdapter.GetPropertyTrack();
          return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {
          });
        }
        SetResumeState() {
        }
        MayNeedBeforeAndAfterInterpolate() {
          this._numericInterpolationAdapter;
          const e = this._numericInterpolationAdapter.GetPropertyTrack();
          switch (e.GetResultMode()) {
            case "relative":
              return false;
            case "absolute":
              return true;
          }
        }
        BeforeChangeProperty() {
          this._numericInterpolationAdapter;
          const e = this._numericInterpolationAdapter.GetPropertyTrack(), t = e.GetPropertyName();
          switch (e.GetResultMode()) {
            case "relative":
              break;
            case "absolute":
              if (e.HasAbsoluteValueObject()) {
                const r = e.GetAbsoluteValueObject();
                r.Reset();
              } else {
                const a = e.GetTimeline(), s = e.GetInstance(), o = e.GetSourceAdapter(), i = a.GetSimilarPropertyTracks(s, o, t, e);
                i && 1 < i.length && new AbsoluteValueObject(i);
              }
          }
        }
        ChangeProperty(e, t, r, a, s, o, i, n) {
          const l = this._numericInterpolationAdapter, u = this._numericInterpolationAdapter.GetPropertyTrack();
          switch (u.GetResultMode()) {
            case "relative": {
              const c = l.GetLastValue();
              l._Setter(t - c, r, a), o && this._MaybeEnsureValue(e, r, a, s, c, t), l.SetLastValue(t);
              break;
            }
            case "absolute": {
              const p = u.GetTimeline(), d = u.GetTrack();
              u.GetInstance(), u.GetSourceAdapter();
              if (u.HasAbsoluteValueObject()) {
                const h = u.GetAbsoluteValueObject(), G = h.GetPropertyTracks(), y = l._GetPropertyKeyframeStubs(G, true), _ = l._GetLastPropertyKeyframeStub(p, p.GetTime(), y);
                if (_) {
                  const m = d.GetStartOffset(), A = _.time - m;
                  if (0 == A) h.SetEndState(i), h.SetPropertyKeyframeReached(n), h.SetUsed(), h.SetValue(h.GetValue() + t);
                  else {
                    if (A < 0) return;
                    const S = u.GetInterpolatedValue(A);
                    h.SetEndState(i), h.SetPropertyKeyframeReached(n), h.SetUsed(), h.SetValue(h.GetValue() + (t - S));
                  }
                }
              } else l._SetterAbsolute(t, n, i);
              break;
            }
          }
        }
        AfterChangeProperty() {
          const e = this._numericInterpolationAdapter, t = this._numericInterpolationAdapter.GetPropertyTrack();
          switch (t.GetResultMode()) {
            case "relative":
              break;
            case "absolute":
              if (t.HasAbsoluteValueObject()) {
                const r = t.GetAbsoluteValueObject();
                r.GetUsed() && e._SetterAbsolute(r.GetValue(), r.GetPropertyKeyframeReached(), r.GetEndState());
              }
          }
        }
        _MaybeEnsureValue(e, t, r, a, s, o) {
          const i = this._numericInterpolationAdapter;
          a || (t && e === t.GetTime() ? i._AddDelta(t.GetValueWithResultMode(), t, r) : r && e === r.GetTime() ? i._AddDelta(r.GetValueWithResultMode(), t, r) : o - s == 0 && i._AddDelta(t.GetValueWithResultMode(), t, r));
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
    }
    {
      const C33 = self.C3;
      class NumericInterpolationAdapterForTween {
        constructor(e) {
          this._numericInterpolationAdapter = e;
        }
        Release() {
          this._numericInterpolationAdapter = null;
        }
        GetType() {
          return 1;
        }
        SetInitialState() {
          const e = this._numericInterpolationAdapter;
          return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());
        }
        SetResumeState() {
          const e = this._numericInterpolationAdapter;
          if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());
        }
        MayNeedBeforeAndAfterInterpolate() {
          return false;
        }
        BeforeChangeProperty() {
        }
        ChangeProperty(e, t, r, a, n, i, o, l) {
          const s = this._numericInterpolationAdapter, u = s.GetLastValue();
          switch (s.GetPropertyTrack().GetResultMode()) {
            case "relative":
              s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, false, o);
              break;
            case "absolute":
              s.GetFirstAbsoluteUpdate() ? (s.SetFirstAbsoluteUpdate(false), s._Setter(u, r, a)) : 0 === e && 0 === s.GetPropertyTrack().GetTimeline().GetTotalTime() ? s._SetterAbsolute(t, true, false) : (s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, this._ForceEndValue(), o));
          }
          s.SetLastValue(t);
        }
        AfterChangeProperty() {
        }
        _GetAbsoluteInitialValue(e) {
          const t = this._numericInterpolationAdapter;
          return e - t.GetCurrentState();
        }
        _ForceEndValue() {
          const e = this._numericInterpolationAdapter, t = e.GetWorldInfo().GetInstance(), r = e.GetPropertyTrack().GetRuntime(), a = r.GetTimelineManager();
          let n = 0;
          for (const i of a.GetPlayingTimelines()) 0 === i.GetType() ? i.HasTrackInstance(t) && n++ : 1 === i.GetType() && i.GetInstance() === t && n++;
          return n <= 1;
        }
        _MaybeEnsureValue(e, t, r, a, n, i, o, l) {
          const s = this._numericInterpolationAdapter;
          a ? t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : r || s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : i - n == 0 && s._AddDelta(t.GetValueWithResultMode(), t, r, o, l);
        }
      }
      C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
    }
    {
      const C33 = self.C3, Ease = self.Ease;
      C33.PropertyTrackState.NumericTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a, r) {
          let s;
          switch (r) {
            case "behavior":
              s = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              s = t[e];
              break;
            case "instance-variable":
              s = t.GetInstanceVariableValue(e);
              break;
            case "plugin":
              s = t.GetPropertyValueByIndex(e);
          }
          return s !== a;
        }
        static Interpolate(t, a, r, s) {
          if (!r) {
            let e = s.GetPropertyTrackDataItem();
            const i = s.GetPropertyTrackData();
            return (e = i.GetLastPropertyKeyframeDataItem(e)).GetValueWithResultMode();
          }
          let n = s.GetInterpolationMode();
          if ("default" === n && (n = "continuous"), "discrete" === (n = "combo" === s.GetPropertyType() ? "discrete" : n)) return a.GetValueWithResultMode();
          if ("continuous" === n || "step" === n) {
            const o = s.GetTimeline().GetStep();
            if ("step" === n && 0 !== o) {
              const m = 1 / o;
              t = Math.floor(t * m) / m;
            }
            const c = a.GetValueWithResultMode(), l = r.GetValueWithResultMode(), u = a.GetAddOn("cubic-bezier"), G = r.GetAddOn("cubic-bezier"), p = u && u.GetStartEnable() && G && G.GetEndEnable();
            if (!p && c === l) return c;
            const d = a.GetTime(), b = r.GetTime(), f = ("step" === n && 0 !== o && (t = C33.clamp(t, d, b)), C33.normalize(t, d, b)), y = a.GetEase();
            let e;
            if (p) {
              const E = b - d;
              e = Ease.GetRuntimeEase(y)(E * f, 0, 1, E), e = Ease.GetRuntimeEase("cubicbezier")(e, c, c + u.GetStartAnchor(), l + G.GetEndAnchor(), l);
            } else e = Ease.GetRuntimeEase(y)((b - d) * f, c, l - c, b - d);
            return "integer" === s.GetPropertyType() ? Math.floor(e) : e;
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.AngleTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a, r) {
          let s;
          switch (r) {
            case "behavior":
              s = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              s = t[e];
              break;
            case "instance-variable":
              s = t.GetInstanceVariableValue(e);
              break;
            case "plugin":
              s = t.GetPropertyValueByIndex(e);
          }
          return s !== a;
        }
        static Interpolate(e, t, a, r) {
          if (!a) {
            let e2 = r.GetPropertyTrackDataItem();
            const n = r.GetPropertyTrackData();
            return (e2 = n.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode();
          }
          let s = r.GetInterpolationMode();
          if ("default" === s && (s = "continuous"), "discrete" === (s = "combo" === r.GetPropertyType() ? "discrete" : s)) return t.GetValueWithResultMode();
          if ("continuous" === s || "step" === s) {
            const o = r.GetTimeline().GetStep();
            if ("step" === s && 0 !== o) {
              const p = 1 / o;
              e = Math.floor(e * p) / p;
            }
            const i = t.GetTime(), l = a.GetTime(), c = t.GetValueWithResultMode(), u = a.GetValueWithResultMode(), G = ("step" === s && 0 !== o && (e = C33.clamp(e, i, l)), t.GetAddOn("angle"));
            if (!G) {
              if (c === u) return c;
              const f = C33.normalize(e, i, l), d = self.Ease.GetRuntimeEase(t.GetEase());
              return C33.angleLerp(c, u, d(f, 0, 1, 1));
            }
            {
              const C = G.GetRevolutions();
              if (c === u && 0 === C) return c;
              const m = C33.normalize(e, i, l), y = self.Ease.GetRuntimeEase(t.GetEase()), k = y(m, 0, 1, 1);
              switch (G.GetDirection()) {
                case "closest":
                  return C33.angleLerp(c, u, k, C);
                case "clockwise":
                  return C33.angleLerpClockwise(c, u, k, C);
                case "anti-clockwise":
                  return C33.angleLerpAntiClockwise(c, u, k, C);
              }
            }
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.BooleanTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a, r) {
          let c;
          switch (r) {
            case "behavior":
              c = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              c = t[e];
              break;
            case "instance-variable":
              c = t.GetInstanceVariableValue(e);
              break;
            case "plugin":
              c = t.GetPropertyValueByIndex(e);
          }
          return !!c != !!a;
        }
        static Interpolate(e, t, a, r) {
          if (a) return t.GetValueWithResultMode() ? 1 : 0;
          {
            let e2 = r.GetPropertyTrackDataItem();
            const c = r.GetPropertyTrackData();
            return (e2 = c.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode() ? 1 : 0;
          }
        }
      };
    }
    {
      const C33 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];
      C33.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {
        }
        static WillChange(R, e, _, t) {
          let A;
          switch (t) {
            case "behavior":
              A = e.GetPropertyValueByIndex(R);
              break;
            case "effect":
              A = e[R];
              break;
            case "instance-variable":
              A = e.GetInstanceVariableValue(R);
              break;
            case "plugin":
              A = e.GetPropertyValueByIndex(R);
          }
          return Array.isArray(_) ? (TEMP_COLOR_ARRAY[0] = _[0], TEMP_COLOR_ARRAY[1] = _[1], TEMP_COLOR_ARRAY[2] = _[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(_), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2];
        }
        static Interpolate(R, e, _, t) {
          if (!_) {
            let R2 = t.GetPropertyTrackDataItem();
            const O = t.GetPropertyTrackData(), a = (R2 = O.GetLastPropertyKeyframeDataItem(R2)).GetValueWithResultMode();
            return TEMP_COLOR_ARRAY[0] = a[0], TEMP_COLOR_ARRAY[1] = a[1], TEMP_COLOR_ARRAY[2] = a[2], TEMP_COLOR_ARRAY;
          }
          let A = t.GetInterpolationMode();
          if ("discrete" === (A = "default" === A ? "continuous" : A)) {
            const r = e.GetValueWithResultMode();
            return TEMP_COLOR_ARRAY[0] = r[0], TEMP_COLOR_ARRAY[1] = r[1], TEMP_COLOR_ARRAY[2] = r[2], TEMP_COLOR_ARRAY;
          }
          if ("continuous" === A || "step" === A) {
            const M = t.GetTimeline().GetStep();
            if ("step" === A && 0 !== M) {
              const f = 1 / M;
              R = Math.floor(R * f) / f;
            }
            const C = e.GetTime(), T = _.GetTime(), P = e.GetValueWithResultMode(), o = _.GetValueWithResultMode(), E = ("step" === A && 0 !== M && (R = C33.clamp(R, C, T)), C33.normalize(R, C, T)), L = e.GetEase(), Y = P[0], s = P[1], l = P[2], i = o[0], n = o[1], c = o[2], u = self.Ease.GetRuntimeEase(L), p = T - C, G = p * E;
            return TEMP_COLOR_ARRAY[0] = Y === i ? Y : u(G, Y, i - Y, p), TEMP_COLOR_ARRAY[1] = s === n ? s : u(G, s, n - s, p), TEMP_COLOR_ARRAY[2] = l === c ? l : u(G, l, c - l, p), TEMP_COLOR_ARRAY;
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.PropertyTrackState.TextTypeAdapter = class {
        constructor() {
        }
        static WillChange(e, t, a, r) {
          let c;
          switch (r) {
            case "behavior":
              c = t.GetPropertyValueByIndex(e);
              break;
            case "effect":
              c = t[e];
              break;
            case "instance-variable":
              c = t.GetInstanceVariableValue(e);
              break;
            case "plugin":
              c = t.GetPropertyValueByIndex(e);
          }
          return c !== a;
        }
        static Interpolate(e, t, a, r) {
          if (a) return t.GetValueWithResultMode();
          {
            let e2 = r.GetPropertyTrackDataItem();
            const c = r.GetPropertyTrackData();
            return (e2 = c.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode();
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TimelineDataManager = class {
        constructor() {
          this._timelineDataItems = /* @__PURE__ */ new Map();
        }
        Release() {
          for (const e of this._timelineDataItems.values()) e.Release();
          this._timelineDataItems.clear(), this._timelineDataItems = null;
        }
        Add(e) {
          const a = new C33.TimelineDataItem(e), t = a.GetName();
          this._timelineDataItems.set(t, a);
        }
        Get(e) {
          return this._timelineDataItems.get(e);
        }
        GetNameId() {
          return 0;
        }
        static _CreateDataItems(e, a, t, s) {
          if (a) for (const i of a) C33.TimelineDataManager._CreateDataItem("create", i, e, t, s);
        }
        static _CreateDataItemsIncludingDisabled(e, a, t, s) {
          if (a) for (const i of a) C33.TimelineDataManager._CreateDataItem("create-including-disabled", i, e, t, s);
        }
        static _LoadDataItemsFromJson(t, e, a, s) {
          t.length ? e.forEach((e2, a2) => {
            t[a2]._LoadFromJson(e2);
          }) : e.forEach((e2) => {
            C33.TimelineDataManager._CreateDataItem("load", e2, t, a, s);
          });
        }
        static _CreateDataItem(e, a, t, s, i) {
          let n;
          if ("function" == typeof s) switch (e) {
            case "load":
              n = new s(null, i);
              break;
            case "create":
            case "create-including-disabled":
              n = new s(a, i);
          }
          else if ("object" == typeof s) {
            const c = s.prop, l = a[c], r = s.map.get(l);
            switch (e) {
              case "load":
                n = new r(null, i);
                break;
              case "create":
              case "create-including-disabled":
                n = new r(a, i);
            }
          }
          switch (e) {
            case "load":
              n._LoadFromJson(a), t.push(n);
              break;
            case "create":
              if ("function" == typeof n.GetEnable && !n.GetEnable()) return n.Release();
              t.push(n);
              break;
            case "create-including-disabled":
              t.push(n);
          }
        }
      };
    }
    {
      const C33 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;
      C33.TimelineDataItem = class {
        constructor(t) {
          this._name = "", this._totalTime = NaN, this._step = 0, this._interpolationMode = "default", this._resultMode = "default", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = "", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t && (this._name = t[NAME], this._totalTime = t[TOTAL_TIME], this._step = t[STEP], this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._loop = !!t[LOOP], this._pingPong = !!t[PING_PONG], this._repeatCount = t[REPEAT_COUNT], this._startOnLayout = t[START_ON_LAYOUT], this._transformWithSceneGraph = !!t[TRANSFORM_WITH_SCENE_GRAPH], this._useSystemTimescale = !!t[USE_SYSTEM_TIMESCALE], this._trackData = new C33.TrackData(t[TRACKS], this));
        }
        Release() {
          this._trackData.Release(), this._trackData = null;
        }
        GetTrackData() {
          return this._trackData || (this._trackData = new C33.TrackData(null, this)), this._trackData;
        }
        GetName() {
          return this._name;
        }
        SetName(t) {
          this._name = t;
        }
        GetTotalTime() {
          return this._totalTime;
        }
        SetTotalTime(t) {
          this._totalTime = t;
        }
        GetStep() {
          return this._step;
        }
        SetStep(t) {
          this._step = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetLoop() {
          return this._loop;
        }
        SetLoop(t) {
          this._loop = t;
        }
        GetPingPong() {
          return this._pingPong;
        }
        SetPingPong(t) {
          this._pingPong = t;
        }
        GetRepeatCount() {
          return this._repeatCount;
        }
        SetRepeatCount(t) {
          this._repeatCount = t;
        }
        GetStartOnLayout() {
          return this._startOnLayout;
        }
        GetTransformWithSceneGraph() {
          return this._transformWithSceneGraph;
        }
        GetUseSystemTimescale() {
          return this._useSystemTimescale;
        }
        _SaveToJson() {
          return { "trackDataJson": this._trackData._SaveToJson(), "name": this._name, "totalTime": this._totalTime, "step": this._step, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "loop": this._loop, "pingPong": this._pingPong, "repeatCount": this._repeatCount, "startOnLayout": this._startOnLayout, "transformWithSceneGraph": !!this._transformWithSceneGraph, "useSystemTimescale": this._useSystemTimescale };
        }
        _LoadFromJson(t) {
          t && (this.GetTrackData()._LoadFromJson(t["trackDataJson"]), this._name = t["name"], this._totalTime = t["totalTime"], this._step = t["step"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._loop = t["loop"], this._pingPong = t["pingPong"], this._repeatCount = t["repeatCount"], this._startOnLayout = t["startOnLayout"], this._transformWithSceneGraph = !!t["transformWithSceneGraph"], this._useSystemTimescale = !!t["useSystemTimescale"]);
        }
      };
    }
    {
      const C33 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;
      class TrackDataItem {
        constructor(t, a) {
          this._trackData = a, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = "", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = "", t && (t[WI_DATA] && (this._instanceData = t[WI_DATA], this._instanceUid = t[WI_DATA][WI_UID], this._objectClassIndex = t[WI_DATA][OC_INDEX]), this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._enabled = !!t[ENABLED], t[ID] && (this._id = t[ID]), t[NESTED_DATA] && (this._nestedData = t[NESTED_DATA], this._startOffset = t[NESTED_DATA][START_OFFSET], this._localTotalTime = t[NESTED_DATA][LOCAL_TOTAL_TIME]), t[WI_ADDITIONAL_DATA] && (this._additionalInstanceData = t[WI_ADDITIONAL_DATA]), t[WI_ADDITIONAL_DATA] && (this._additionalInstanceData = t[WI_ADDITIONAL_DATA]), t[TRACK_TYPE] && (this._type = t[TRACK_TYPE]), t[TRACK_NAME] && (this._name = t[TRACK_NAME]), this._keyframeData = new C33.KeyframeData(t[KEYFRAMES], this), this._propertyTrackData = new C33.PropertyTrackData(t[PROPERTY_TRACKS], this));
        }
        Release() {
          this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;
        }
        GetTrackData() {
          return this._trackData;
        }
        GetKeyframeData() {
          return this._keyframeData || (this._keyframeData = new C33.KeyframeData(null, this)), this._keyframeData;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData || (this._propertyTrackData = new C33.PropertyTrackData(null, this)), this._propertyTrackData;
        }
        GetInstanceData() {
          return this._instanceData;
        }
        GetObjectClassIndex() {
          return this._objectClassIndex;
        }
        SetObjectClassIndex(t) {
          this._objectClassIndex = t;
        }
        GetInstanceUID() {
          return this._instanceUid;
        }
        SetInstanceUID(t) {
          this._instanceUid = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetEnable() {
          return this._enabled;
        }
        SetEnable(t) {
          this._enabled = !!t;
        }
        GetId() {
          return this._id;
        }
        GetStartOffset() {
          return this._startOffset;
        }
        GetLocalTotalTime() {
          return this._localTotalTime;
        }
        SetLocalTotalTime(t) {
          this._localTotalTime = t;
        }
        GetOriginalWidth() {
          return this._additionalInstanceData[ORIGINAL_WIDTH];
        }
        SetOriginalWidth(t) {
          this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_WIDTH] = t;
        }
        GetOriginalHeight() {
          return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_HEIGHT];
        }
        SetOriginalHeight(t) {
          this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_HEIGHT] = t;
        }
        GetType() {
          return this._type;
        }
        GetName() {
          return this._name;
        }
        _SaveToJson() {
          return { "keyframeDataJson": this._keyframeData._SaveToJson(), "propertyTrackDataJson": this._propertyTrackData._SaveToJson(), "instanceData": this._instanceData, "additionalInstanceData": this._additionalInstanceData, "instanceUid": this._instanceUid, "objectClassIndex": this._objectClassIndex, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "id": this._id, "nestedData": this._nestedData, "type": this._type, "name": this._name };
        }
        _LoadFromJson(t) {
          t && (this._instanceData = t["instanceData"], this._instanceUid = t["instanceUid"], this._objectClassIndex = t["objectClassIndex"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._id = t["id"], this._type = t["type"] || 0, this._name = t["name"] || "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t["nestedData"] && (this._nestedData = t["nestedData"], this._startOffset = this._nestedData[START_OFFSET], this._localTotalTime = this._nestedData[LOCAL_TOTAL_TIME]), t["additionalInstanceData"] && (this._additionalInstanceData = t["additionalInstanceData"]), this.GetKeyframeData()._LoadFromJson(t["keyframeDataJson"]), this.GetPropertyTrackData()._LoadFromJson(t["propertyTrackDataJson"]));
        }
      }
      C33.TrackData = class {
        constructor(t, a) {
          this._timelineDataItem = a, this._trackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._trackDataItems, t, TrackDataItem, this);
        }
        Release() {
          this._timelineDataItem = null;
          for (const t of this._trackDataItems) t.Release();
          C33.clearArray(this._trackDataItems), this._trackDataItems = null;
        }
        GetTimelineDataItem() {
          return this._timelineDataItem;
        }
        AddEmptyTrackDataItem() {
          const t = new TrackDataItem(null, this);
          return this._trackDataItems.push(t), t;
        }
        GetFirstKeyframeDataItem(t) {
          return t.GetKeyframeData().GetKeyframeDataItemArray()[0];
        }
        GetLastKeyframeDataItem(t) {
          const a = t.GetKeyframeData().GetKeyframeDataItemArray();
          return a.at(-1);
        }
        GetKeyFrameDataItemAtTime(a, t) {
          const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
          for (let t2 = 0; t2 < s; t2++) {
            const i = e[t2];
            if (i.GetTime() === a) return i;
          }
        }
        GetFirstKeyFrameDataItemHigherThan(a, t) {
          const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
          for (let t2 = 0; t2 < s; t2++) {
            const i = e[t2];
            if (i.GetTime() > a) return i;
          }
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(a, t) {
          const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
          for (let t2 = 0; t2 < s; t2++) {
            const i = e[t2];
            if (i.GetTime() >= a) return i;
          }
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(a, t) {
          const e = t.GetKeyframeData().GetKeyframeDataItemArray();
          for (let t2 = e.length - 1; 0 <= t2; t2--) {
            const s = e[t2];
            if (s.GetTime() <= a) return s;
          }
        }
        *trackDataItems() {
          for (const t of this._trackDataItems) yield t;
        }
        _SaveToJson() {
          return { "trackDataItemsJson": this._trackDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t["trackDataItemsJson"], TrackDataItem, this);
        }
      };
    }
    {
      const C33 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;
      class PropertyTrackDataItem {
        constructor(t, e) {
          this._propertyTrackData = e, this._sourceAdapterId = "", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t && (this._sourceAdapterId = t[SOURCE_DATA][SOURCE], this._sourceAdapterArguments = t[SOURCE_DATA].slice(1), this._property = t[PROPERTY], this._type = t[TYPE], this._min = t[MIN], this._max = t[MAX], this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._enabled = !!t[ENABLED], this._propertyKeyframeData = new C33.PropertyKeyframeData(t[PROPERTY_KEYFRAMES], this), this._canHavePropertyKeyframes = t[CAN_HAVE_PROPERTY_KEYFRAMES]);
        }
        Release() {
          this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;
        }
        GetPropertyTrackData() {
          return this._propertyTrackData;
        }
        GetPropertyKeyframeData() {
          return this._propertyKeyframeData || (this._propertyKeyframeData = new C33.PropertyKeyframeData(null, this)), this._propertyKeyframeData;
        }
        GetSourceAdapterId() {
          return this._sourceAdapterId;
        }
        SetSourceAdapterId(t) {
          this._sourceAdapterId = t;
        }
        GetSourceAdapterArguments() {
          return this._sourceAdapterArguments;
        }
        SetSourceAdapterArguments(t) {
          this._sourceAdapterArguments = t;
        }
        GetProperty() {
          return this._property;
        }
        SetProperty(t) {
          this._property = t;
        }
        GetType() {
          return this._type;
        }
        SetType(t) {
          this._type = t;
        }
        GetMin() {
          return this._min;
        }
        SetMin(t) {
          this._min = t;
        }
        GetMax() {
          return this._max;
        }
        SetMax(t) {
          this._max = t;
        }
        GetInterpolationMode() {
          return this._interpolationMode;
        }
        SetInterpolationMode(t) {
          this._interpolationMode = t;
        }
        GetResultMode() {
          return this._resultMode;
        }
        SetResultMode(t) {
          this._resultMode = t;
        }
        GetEnable() {
          return this._enabled;
        }
        SetEnable(t) {
          this._enabled = !!t;
        }
        CanHavePropertyKeyframes() {
          return !!this._canHavePropertyKeyframes;
        }
        _SaveToJson() {
          return { "propertyKeyframeDataJson": this._propertyKeyframeData._SaveToJson(), "sourceAdapterId": this._sourceAdapterId, "sourceAdapterArguments": this._sourceAdapterArguments, "property": this._property, "type": this._type, "min": this._min, "max": this._max, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "canHavePropertyKeyframes": this._canHavePropertyKeyframes };
        }
        _LoadFromJson(t) {
          t && (this._sourceAdapterId = t["sourceAdapterId"], this._sourceAdapterArguments = t["sourceAdapterArguments"], this._property = t["property"], this._type = t["type"], this._min = t["min"], this._max = t["max"], this._interpolationMode = t["interpolationMode"], this._resultMode = t["resultMode"], this._enabled = t["enabled"], this._canHavePropertyKeyframes = t["canHavePropertyKeyframes"], this.GetPropertyKeyframeData()._LoadFromJson(t["propertyKeyframeDataJson"]));
        }
      }
      C33.PropertyTrackData = class {
        constructor(t, e) {
          this._trackDataItem = e, this._propertyTrackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t, PropertyTrackDataItem, this);
        }
        Release() {
          this._trackDataItem = null;
          for (const t of this._propertyTrackDataItems) t.Release();
          C33.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        AddEmptyPropertyTrackDataItem() {
          const t = new PropertyTrackDataItem(null, this);
          return this._propertyTrackDataItems.push(t), t;
        }
        GetFirstPropertyKeyframeDataItem(t) {
          const e = t.GetPropertyKeyframeData();
          return e.GetPropertyKeyframeDataItemArray()[0];
        }
        GetLastPropertyKeyframeDataItem(t) {
          const e = t.GetPropertyKeyframeData(), r = e.GetPropertyKeyframeDataItemArray();
          return r.at(-1);
        }
        GetPropertyKeyFrameDataItemAtTime(e, t) {
          const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;
          for (let t2 = 0; t2 < s; t2++) {
            const o = a[t2];
            if (o.GetTime() === e) return o;
          }
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(e, t) {
          const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;
          for (let t2 = 0; t2 < s; t2++) {
            const o = a[t2];
            if (o.GetTime() > e) return o;
          }
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, t) {
          const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;
          for (let t2 = 0; t2 < s; t2++) {
            const o = a[t2];
            if (o.GetTime() >= e) return o;
          }
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, t) {
          const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray();
          for (let t2 = a.length - 1; 0 <= t2; t2--) {
            const s = a[t2];
            if (s.GetTime() <= e) return s;
          }
        }
        *propertyTrackDataItems() {
          for (const t of this._propertyTrackDataItems) yield t;
        }
        _SaveToJson() {
          return { "propertyTrackDataItemsJson": this._propertyTrackDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t["propertyTrackDataItemsJson"], PropertyTrackDataItem, this);
        }
      };
    }
    {
      const C33 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;
      class KeyframeDataItem {
        constructor(e, t) {
          if (this._keyframeData = t, this._time = -1, this._ease = "noease", this._enable = false, this._tags = null, this._lowerTags = null, e) {
            this._time = e[TIME], this._ease = e[EASE], this._enable = !!e[ENABLE];
            const a = e[TAGS];
            this._tags = a ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null;
          }
        }
        Release() {
          this._keyframeData = null, C33.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;
        }
        GetKeyframeData() {
          return this._keyframeData;
        }
        GetNext() {
          return this._next;
        }
        SetNext(e) {
          this._next = e;
        }
        GetTime() {
          return this._time;
        }
        SetTime(e) {
          this._time = e, this._keyframeData._LinkKeyframeDataItems();
        }
        GetEase() {
          return this._ease;
        }
        SetEase(e) {
          this._ease = e;
        }
        GetEnable() {
          return this._enable;
        }
        SetEnable(e) {
          this._enable = !!e;
        }
        GetTags() {
          return this._tags;
        }
        SetTags(e) {
          this._tags = e ? e.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));
        }
        GetLowerTags() {
          return this._lowerTags;
        }
        HasTag(e) {
          return this._lowerTags.has(e.toLowerCase());
        }
        _SaveToJson() {
          return { "time": this._time, "ease": this._ease, "enable": this._enable, "tags": this._tags };
        }
        _LoadFromJson(e) {
          e && (this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"], this._tags = e["tags"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));
        }
      }
      C33.KeyframeData = class {
        constructor(e, t) {
          this._trackDataItem = t, this._keyframeDataItems = [], C33.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();
        }
        Release() {
          this._trackDataItem = null;
          for (const e of this._keyframeDataItems) e.Release();
          C33.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;
        }
        _LinkKeyframeDataItems() {
          this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
          for (let e = 0; e < this._keyframeDataItems.length; e++) {
            const t = this._keyframeDataItems[e];
            t.SetNext(this._keyframeDataItems[e + 1]);
          }
        }
        GetTrackDataItem() {
          return this._trackDataItem;
        }
        GetKeyframeDataItemCount() {
          return this._keyframeDataItems.length;
        }
        GetKeyframeDataItemArray() {
          return this._keyframeDataItems;
        }
        AddEmptyKeyframeDataItem() {
          const e = new KeyframeDataItem(null, this);
          return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;
        }
        DeleteKeyframeDataItems(e) {
          for (const t of this._keyframeDataItems) if (e(t)) {
            const a = this._keyframeDataItems.indexOf(t);
            -1 !== a && (t.Release(), this._keyframeDataItems.splice(a, 1));
          }
          this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();
        }
        SortKeyframeDataItems() {
          this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
        }
        GetKeyframeDataItemIndex(e) {
          return this._keyframeDataItems.indexOf(e);
        }
        GetKeyframeDataItemFromIndex(e) {
          return this._keyframeDataItems[e];
        }
        *keyframeDataItems() {
          for (const e of this._keyframeDataItems) yield e;
        }
        *keyframeDataItemsReverse() {
          for (let e = this._keyframeDataItems.length - 1; 0 <= e; e--) yield this._keyframeDataItems[e];
        }
        _SaveToJson() {
          return { "keyframeDataItemsJson": this._keyframeDataItems.map((e) => e._SaveToJson()) };
        }
        _LoadFromJson(e) {
          e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e["keyframeDataItemsJson"], KeyframeDataItem, this), this._LinkKeyframeDataItems());
        }
      };
    }
    {
      const C33 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;
      class PropertyKeyframeDataItem {
        constructor(e, t) {
          this._propertyKeyframeData = t, this._value = null, this._aValue = null, this._type = "", this._time = NaN, this._ease = "noease", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = "line", e && (this._value = e[VALUE_DATA][VALUE_DATA_VALUE], this._aValue = e[VALUE_DATA][VALUE_DATA_ABSOLUTE_VALUE], this._type = e[VALUE_DATA][VALUE_DATA_TYPE], this._time = e[TIME], this._ease = e[EASE], this._enable = !!e[ENABLE], this._pathMode = e[PATH_MODE], this._addonData = null, e[ADDONS] && (this._addonData = new C33.AddonData(e[ADDONS], this)), this._next = null, this._prev = null);
        }
        Release() {
          this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;
        }
        GetAddonData() {
          return this._addonData;
        }
        SetNext(e) {
          this._next = e;
        }
        GetNext() {
          return this._next;
        }
        SetPrevious(e) {
          this._prev = e;
        }
        GetPrevious() {
          return this._prev;
        }
        GetValue() {
          return this._value;
        }
        SetValue(e) {
          "color" === this._type && C33.IsFiniteNumber(e) ? (this._value[0] = C33.GetRValue(e), this._value[1] = C33.GetGValue(e), this._value[2] = C33.GetBValue(e)) : this._value = e;
        }
        GetAbsoluteValue() {
          return this._aValue;
        }
        SetAbsoluteValue(e) {
          "color" === this._type && C33.IsFiniteNumber(e) ? (this._aValue[0] = C33.GetRValue(e), this._aValue[1] = C33.GetGValue(e), this._aValue[2] = C33.GetBValue(e)) : this._aValue = e;
        }
        GetValueWithResultMode() {
          const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
          return "relative" === e ? this.GetValue() : "absolute" === e ? this.GetAbsoluteValue() : void 0;
        }
        GetType() {
          return this._type;
        }
        SetType(e) {
          this._type = e;
        }
        GetTime() {
          return this._time;
        }
        SetTime(e) {
          this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();
        }
        GetEase() {
          return this._ease;
        }
        SetEase(e) {
          this._ease = e;
        }
        GetEnable() {
          return this._enable;
        }
        SetEnable(e) {
          this._enable = !!e;
        }
        GetPathMode() {
          return this._pathMode;
        }
        GetAddOn(t) {
          if (this._addonData) {
            if (!this._addonInstance && null !== this._addonInstance) {
              const a = this._addonData.GetAddDataItemArray();
              if (a) {
                const r = a.length;
                for (let e = 0; e < r; e++) {
                  const s = a[e];
                  if (s.GetId() === t) return this._addonInstance = s, this._addonInstance;
                }
              }
              this._addonInstance = null;
            }
            return this._addonInstance;
          }
        }
        _SaveToJson() {
          const e = this._addonData;
          return { "addonDataJson": e && e._SaveToJson(), "value": this._value, "aValue": this._aValue, "type": this._type, "time": this._time, "ease": this._ease, "enable": this._enable };
        }
        _LoadFromJson(e) {
          e && (e["addonDataJson"] && this._addonData._SetFromJson(e["addonDataJson"]), this._value = e["value"], this._aValue = e["aValue"], this._type = e["type"], this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"]);
        }
      }
      C33.PropertyKeyframeData = class {
        constructor(e, t) {
          this._propertyTrackDataItem = t, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C33.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C33.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();
        }
        Release() {
          this._propertyTrackDataItem = null;
          for (const e of this._propertyKeyframeDataItems) e.Release();
          C33.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;
          for (const t of this._propertyKeyframeDataItemsIncludingDisabled) t.Release();
          C33.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;
        }
        _LinkPropertyKeyframeDataItems() {
          let t = this._propertyKeyframeDataItems;
          t.sort((e, t2) => e.GetTime() - t2.GetTime());
          for (let e = 0; e < t.length; e++) {
            const a = t[e];
            e + 1 < t.length && a.SetNext(t[e + 1]), 0 <= e - 1 && a.SetPrevious(t[e - 1]);
          }
          (t = this._propertyKeyframeDataItemsIncludingDisabled).sort((e, t2) => e.GetTime() - t2.GetTime());
          for (let e = 0; e < t.length; e++) {
            const r = t[e];
            e + 1 < t.length && r.SetNext(t[e + 1]), 0 <= e - 1 && r.SetPrevious(t[e - 1]);
          }
        }
        AddEmptyPropertyKeyframeDataItem() {
          const e = new PropertyKeyframeDataItem(null, this);
          return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;
        }
        DeletePropertyKeyframeDataItems(e) {
          for (const t of this._propertyKeyframeDataItems) if (e(t)) {
            const a = this._propertyKeyframeDataItems.indexOf(t);
            -1 !== a && (t.Release(), this._propertyKeyframeDataItems.splice(a, 1));
          }
          this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();
        }
        SortPropertyKeyFrameDataItems() {
          this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());
        }
        GetPropertyTrackDataItem() {
          return this._propertyTrackDataItem;
        }
        GetPropertyKeyframeDataItemCount() {
          return this._propertyKeyframeDataItems.length;
        }
        GetLastPropertyKeyframeDataItem() {
          return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];
        }
        GetPropertyKeyframeDataItemArray() {
          return this._propertyKeyframeDataItems;
        }
        GetPropertyKeyframeDataItemArrayIncludingDisabled() {
          return this._propertyKeyframeDataItemsIncludingDisabled;
        }
        *propertyKeyframeDataItems() {
          for (const e of this._propertyKeyframeDataItems) yield e;
        }
        *propertyKeyframeDataItemsReverse() {
          for (let e = this._propertyKeyframeDataItems.length - 1; 0 <= e; e--) yield this._propertyKeyframeDataItems[e];
        }
        _SaveToJson() {
          const e = this._propertyKeyframeDataItems, t = this._propertyKeyframeDataItemsIncludingDisabled;
          return { "propertyKeyframeDataItemsJson": e.map((e2) => e2._SaveToJson()), "propertyKeyframeDataItemsIncludingDisabledJson": t.map((e2) => e2._SaveToJson()) };
        }
        _LoadFromJson(e) {
          e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e["propertyKeyframeDataItemsJson"], PropertyKeyframeDataItem, this), C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e["propertyKeyframeDataItemsIncludingDisabledJson"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());
        }
      };
    }
    {
      const C33 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;
      class AddonDataItem {
        constructor(t, a) {
          this._addonData = a, this._id = t[ADDON_ID], this._data = t[ADDON_DATA];
        }
        Release() {
          this._addonData = null, this._data = null;
        }
        GetAddonData() {
          return this._addonData;
        }
        GetId() {
          return this._id;
        }
        _SaveToJson() {
          return { "id": this._id, "data": this._data };
        }
        _LoadFromJson(t) {
          t && (this._id = t["id"], this._data = t["data"]);
        }
      }
      const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;
      class AddonDataCubicBezierItem extends AddonDataItem {
        constructor(t, a) {
          super(t, a), this._startAnchor = this._data[START_ANCHOR], this._startEnable = !!this._data[START_ENABLE], this._endAnchor = this._data[END_ANCHOR], this._endEnable = !!this._data[END_ENABLE];
        }
        Release() {
          super.Release();
        }
        GetStartAnchor() {
          return this._startAnchor;
        }
        GetStartEnable() {
          return this._startEnable;
        }
        GetEndAnchor() {
          return this._endAnchor;
        }
        GetEndEnable() {
          return this._endEnable;
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "startAnchor": this._startAnchor, "startEnable": !!this._startEnable, "endAnchor": this._endAnchor, "endEnable": !!this._endEnable });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._startAnchor = t["startAnchor"], this._startEnable = !!t["startEnable"], this._endAnchor = t["endAnchor"], this._endEnable = !!t["endEnable"]);
        }
      }
      const DIRECTION = 0, REVOLUTIONS = 1;
      class AddonDataAngleItem extends AddonDataItem {
        constructor(t, a) {
          super(t, a), this._direction = this._data[DIRECTION], this._revolutions = this._data[REVOLUTIONS];
        }
        Release() {
          super.Release();
        }
        GetDirection() {
          return this._direction;
        }
        GetRevolutions() {
          return this._revolutions;
        }
        _SaveToJson() {
          return Object.assign(super._SaveToJson(), { "direction": this._direction, "revolutions": this._revolutions });
        }
        _LoadFromJson(t) {
          t && (super._LoadFromJson(t), this._direction = t["direction"], this._revolutions = t["revolutions"]);
        }
      }
      C33.AddonData = class {
        constructor(t, a) {
          this._propertyKeyframeDataItem = a, this._addonDataItems = [], C33.TimelineDataManager._CreateDataItems(this._addonDataItems, t, { prop: 0, map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
        }
        Release() {
          this._propertyKeyframeDataItem = null;
          for (const t of this._addonDataItems) t.Release();
          C33.clearArray(this._addonDataItems), this._addonDataItems = null;
        }
        GetPropertyKeyframeDataItem() {
          return this._propertyKeyframeDataItem;
        }
        GetAddDataItemArray() {
          return this._addonDataItems;
        }
        *addonDataItems() {
          for (const t of this._addonDataItems) yield t;
        }
        _SaveToJson() {
          return { "addonDataItemsJson": this._addonDataItems.map((t) => t._SaveToJson()) };
        }
        _LoadFromJson(t) {
          t && C33.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t["addonDataItemsJson"], { prop: "id", map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
        }
      };
    }
    {
      const C33 = self.C3, INITIAL_VALUE_MODE_START_VALUE = "start-value", INITIAL_VALUE_MODE_CURRENT_STATE = "current-state", PING_PONG_BEGIN = 0, PING_PONG_END = 1;
      let createdTweens = 0;
      C33.TweenState = class extends C33.TimelineState {
        constructor(e, t) {
          super("tween-" + createdTweens++, e, t), this._id = "", this._destroyInstanceOnComplete = false, this._initialValueMode = INITIAL_VALUE_MODE_START_VALUE, this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._track = null, this._iTweenState = null;
        }
        FireReleaseEvent(e) {
          const t = C33.New(C33.Event, "tweenstatereleased");
          t.tweenState = this, e.dispatchEvent(t);
        }
        GetType() {
          return 1;
        }
        CreateTrackStates() {
          for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C33.TweenTrackState.Create(this, e));
          this._track = this._tracks[0];
        }
        AddTrack() {
          const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C33.TweenTrackState.Create(this, e);
          return this._tracks.push(t), this._CacheTrack(), t;
        }
        _CacheTrack() {
          this._track = this._tracks[0];
        }
        GetPropertyTrack(e) {
          return this._track.GetPropertyTracks()[0];
        }
        SetPropertyType(e) {
          this._propertyType = e;
        }
        GetInstance() {
          const e = this.GetTracks();
          if (e && e.length) {
            const t = e[0];
            if (this._track = t) {
              const n = t.GetInstance();
              return t.IsInstanceValid() ? n : void 0;
            }
          }
        }
        AddStartedCallback(e) {
          this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);
        }
        AddCompletedCallback(e) {
          this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);
        }
        RemoveStartedCallback(e) {
          if (this._on_started_callbacks) {
            const t = this._on_started_callbacks.indexOf(e);
            -1 !== t && this._on_started_callbacks.splice(t, 1);
          }
        }
        RemoveCompletedCallback(e) {
          if (this._on_completed_callbacks) {
            const t = this._on_completed_callbacks.indexOf(e);
            -1 !== t && this._on_completed_callbacks.splice(t, 1);
          }
        }
        SetStartValue(e, t) {
          for (const n of this._tracks) for (const s of n._propertyTracks) if (s.GetPropertyName() === t) {
            const i = s.GetPropertyTrackData(), a = s.GetPropertyTrackDataItem(), r = i.GetFirstPropertyKeyframeDataItem(a);
            r.SetValue(e), r.SetAbsoluteValue(e);
          }
        }
        _GetPropertyTrackState(e) {
          for (const t of this._tracks) for (const n of t._propertyTracks) if (n.GetPropertyName() === e) return n;
        }
        BeforeSetEndValues(e) {
          for (const t of e) {
            const n = this._GetPropertyTrackState(t);
            this.SetStartValue(n.GetCurrentState(), t);
          }
          if (this.IsForwardPlayBack()) {
            const s = this.GetTotalTime() - this.GetTime();
            this.SetTotalTime(s);
            for (const i of this._tracks) i.SetLocalTotalTime(s);
            this._SetTime(0);
          } else {
            const a = this.GetTime();
            this.SetTotalTime(a);
            for (const r of this._tracks) r.SetLocalTotalTime(a);
            this._SetTime(a);
          }
          this.SetInitialStateFromSetTime();
        }
        SetEndValue(e, t) {
          const n = this._GetPropertyTrackState(t), s = n.GetPropertyTrackData(), i = n.GetPropertyTrackDataItem(), a = s.GetLastPropertyKeyframeDataItem(i);
          a.SetTime(this.GetTotalTime()), a.SetValue(e), a.SetAbsoluteValue(e);
        }
        SetId(e) {
          this._id = e;
        }
        GetId() {
          return this._id;
        }
        SetInitialValueMode(e) {
          this._initialValueMode = e;
        }
        GetInitialValueMode() {
          return this._initialValueMode;
        }
        SetDestroyInstanceOnComplete(e) {
          this._destroyInstanceOnComplete = e;
        }
        GetDestroyInstanceOnComplete() {
          return this._destroyInstanceOnComplete;
        }
        OnStarted() {
          if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);
          if (!this.IsComplete()) for (const t of this._tracks) t.CompareSaveStateWithCurrent();
        }
        OnCompleted() {
          this._completedTick = this._runtime.GetTickCount();
        }
        FinishTriggers() {
          if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);
        }
        SetTime(e) {
          this._DeleteIntermediateKeyframes(), super.SetTime(e);
        }
        _SetTimeAndReset(e) {
          (e = C33.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();
        }
        SetInitialState(e) {
          if (!this.InitialStateSet() && this.GetInitialValueMode() === INITIAL_VALUE_MODE_CURRENT_STATE) for (const t of this._tracks) t.CompareInitialStateWithCurrent();
          super.SetInitialState(e);
        }
        Stop(e = false) {
          if (super.Stop(e), !this.IsComplete()) for (const t of this._tracks) t.SaveState();
        }
        Reset(e = true, t = false) {
          this._DeleteIntermediateKeyframes(), super.Reset(e, t);
        }
        _DeleteIntermediateKeyframes() {
          for (const e of this._tracks) {
            const t = (e2) => {
              const t2 = e2.GetTime(), n = this.GetTotalTime();
              return 0 !== t2 && t2 !== n;
            };
            e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t);
          }
        }
        _OnBeforeChangeLayout() {
          if (!this.IsReleased()) {
            const e = this.GetInstance();
            if (e && e.GetObjectClass().IsGlobal()) return false;
            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout();
          }
          return true;
        }
        Tick(n, e, t) {
          if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) this.Stop(true), this.OnCompleted();
          else {
            const s = this._instance.GetTimeScale();
            if (0 !== (n = -1 !== s ? t * s : n) || 0 !== this._lastDelta) {
              this._lastDelta = n;
              const i = this._playheadTime + this._overshoot, a = n * this._playbackRate, r = i + a, o = this._timelineDataItem._totalTime;
              r < 0 ? (this._playheadTime = 0, this._overshoot = -r) : o <= r ? (this._playheadTime = o, this._overshoot = this._playheadTime - r) : (this._playheadTime = r, this._overshoot = 0);
              let e2 = false, t2 = false;
              const h = this.GetLoop(), T = this.GetPingPong();
              h || T ? h && !T ? 0 < this._playbackRate ? this._playheadTime >= o && (this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(o), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : !h && T ? 0 < this._playbackRate ? this._playheadTime >= o && (this._SetTime(o), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_BEGIN) : (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), e2 = true) : this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_END)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_BEGIN) : (e2 = true, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)) : this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_END)) : h && T && (0 < this._playbackRate ? this._playheadTime >= o && (this._SetTime(o), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState === PING_PONG_END && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState === PING_PONG_END && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= o && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : (this._SetTime(o), e2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(o), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : (this._SetTime(0), e2 = true)), e2 ? (this._track.SetEndState(), this.Stop(true), this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, true, false, t2, this._firstTick, false), this._firstTick && (this._firstTick = false));
            }
          }
        }
        _TweenTrigger(e) {
          const t = this.GetInstance(), n = t.GetBehaviorSdkInstanceFromCtor(C33.Behaviors.Tween);
          n.PushTriggerTween(this), this._runtime.Trigger(e, t, n.GetBehaviorType()), n.PopTriggerTween();
        }
        _SaveToJson() {
          const e = super._SaveToJson(), t = this.GetTimelineDataItem();
          return Object.assign(e, { "tweenDataItemJson": t._SaveToJson(), "id": this._id, "destroyInstanceOnComplete": this._destroyInstanceOnComplete, "initialValueMode": this._initialValueMode });
        }
        _LoadFromJson(e) {
          if (e) {
            const t = this.GetTimelineDataItem();
            t._LoadFromJson(e["tweenDataItemJson"]), super._LoadFromJson(e), this._id = e["id"], this._destroyInstanceOnComplete = e["destroyInstanceOnComplete"], this._initialValueMode = e["initialValueMode"], this._CacheTrack();
          }
        }
        static IsPlaying(e) {
          return e.IsPlaying();
        }
        static IsPaused(e) {
          return e.IsPaused();
        }
        static IsPing(e) {
          return !!e.GetPingPong() && e.GetPingPongState() === PING_PONG_BEGIN;
        }
        static IsPong(e) {
          return !!e.GetPingPong() && e.GetPingPongState() === PING_PONG_END;
        }
        static Build(e) {
          const t = e.runtime.GetTimelineManager(), n = new C33.TimelineDataItem();
          if (e.json) {
            n._LoadFromJson(e.json["tweenDataItemJson"]);
            const s = new C33.TweenState(n, t);
            return s._LoadFromJson(e.json), s;
          }
          {
            const i = new C33.TweenState(n, t), a = (C33.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), i.SetId(e.id), i.SetTags(e.tags), i.SetInitialValueMode(e.initialValueMode), i.SetDestroyInstanceOnComplete(e.releaseOnComplete), i.SetLoop(e.loop), i.SetPingPong(e.pingPong), i.SetTotalTime(e.time), i.SetStep(0), i.SetInterpolationMode("default"), i.SetResultMode(e.propertyTracksConfig[0].resultMode), i.SetRepeatCount(e.repeatCount), i.AddTrack()), r = (a.SetInstanceUID(e.instance.GetUID()), a.SetInterpolationMode("default"), a.SetResultMode(e.propertyTracksConfig[0].resultMode), a.SetEnable(true), a.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex()), e.instance.GetSdkInstance()), o = r.IsOriginalSizeKnown() ? r.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), h = r.IsOriginalSizeKnown() ? r.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight(), T = (a.SetOriginalWidth(o), a.SetOriginalHeight(h), a.AddKeyframe()), _ = (T.SetTime(0), T.SetEase("noease"), T.SetEnable(true), T.SetTags(""), a.AddKeyframe());
            _.SetTime(e.time), _.SetEase("noease"), _.SetEnable(true), _.SetTags("");
            for (const l of e.propertyTracksConfig) {
              const c = a.AddPropertyTrack(), g = (c.SetSourceAdapterId(l.sourceId), c.SetSourceAdapterArgs(l.sourceArgs), c.SetPropertyName(l.property), c.SetPropertyType(l.type), c.SetMin(NaN), c.SetMax(NaN), c.SetInterpolationMode("default"), c.SetResultMode(l.resultMode), c.SetEnable(true), c.AddPropertyKeyframe()), d = (g.SetType(l.valueType), g.SetTime(0), g.SetEase(l.ease), g.SetEnable(true), g.SetValue(l.startValue), g.SetAbsoluteValue(l.startValue), c.AddPropertyKeyframe());
              d.SetType(l.valueType), d.SetTime(e.time), d.SetEase(l.ease), d.SetEnable(true), d.SetValue(l.endValue), d.SetAbsoluteValue(l.endValue), c.GetSourceAdapter();
            }
            return i;
          }
        }
        static SetInstanceUID(e, t) {
          if (!isNaN(t)) for (const n of e.GetTracks()) n.SetInstanceUID(t);
        }
        GetITweenState(e, t) {
          return this._iTweenState || (this._iTweenState = C33.New(self.ITweenState, this, e, t)), this._iTweenState;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TweenTrackState = class extends C33.TrackState {
        constructor(t, e) {
          super(t, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;
        }
        static Create(t, e) {
          return C33.New(C33.TweenTrackState, t, e);
        }
        _CachePropertyTracks() {
          1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);
        }
        CreatePropertyTrackStates() {
          for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.TweenPropertyTrackState.Create(this, t));
          this._CachePropertyTracks();
        }
        AddPropertyTrack() {
          const t = this._trackDataItem.GetPropertyTrackData(), e = t.AddEmptyPropertyTrackDataItem(), r = C33.TweenPropertyTrackState.Create(this, e);
          return this._propertyTracks.push(r), this._CachePropertyTracks(), r;
        }
        SetInitialState() {
          if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {
            const t = this.GetTimeline(), e = t.IsForwardPlayBack(), r = e ? 0 : this.GetLocalTotalTime();
            for (const a of this._propertyTracks) a.SetInitialState(r), 0 === this._worldInfoChange && 1 === a.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            const s = this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter());
            s && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(r), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(r);
          }
        }
        BeforeInterpolate() {
        }
        Interpolate(t, e = 0, r = false, s = false, a, o = false, i = false) {
          if (this._instance || this.GetInstance(), this._instance) {
            const n = !this._instance.IsDestroyed();
            return n ? (!o || !this.GetObjectClass().IsGlobal()) && ((this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t, r, s, i), this._secondPropertyTrack) : this._firstPropertyTrack).Interpolate(t, r, s, i), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo) && this._worldInfo.SetBboxChanged())) : false;
          }
        }
        AfterInterpolate() {
        }
        _LoadFromJson(t) {
          super._LoadFromJson(t), this._CachePropertyTracks();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TweenPropertyTrackState = class extends C33.PropertyTrackState {
        constructor(t, e) {
          super(t, e), this._basic = false;
        }
        static Create(t, e) {
          return C33.New(C33.TweenPropertyTrackState, t, e);
        }
        Interpolate(t, e = false, r = false, a = false) {
          let s, o;
          if (this._basic) s = this._propertyKeyframeDataItems[0], o = this._propertyKeyframeDataItems[1];
          else {
            if (e) s = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);
            else {
              if (this._lastPropertyKeyframeDataItem) {
                const y = this.GetTimeline(), p = this._lastPropertyKeyframeDataItem.GetNext(), i = this._lastPropertyKeyframeDataItem.GetTime(), m = p ? p.GetTime() : y.GetTotalTime();
                (t <= i || m <= t) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem));
              } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);
              s = this._lastPropertyKeyframeDataItem;
            }
            o = s.GetNext();
          }
          this._sourceAdapter.Interpolate(t, s, o, e, r, a);
        }
        AddPropertyKeyframe() {
          const t = this._propertyTrackDataItem.GetPropertyKeyframeData(), e = t.AddEmptyPropertyKeyframeDataItem();
          return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, e;
        }
        DeletePropertyKeyframes(t) {
          this._lastPropertyKeyframeDataItem = null;
          const e = this._propertyTrackDataItem.GetPropertyKeyframeData();
          e.DeletePropertyKeyframeDataItems(t), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;
        }
        _SaveToJson() {
          return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson(), "basic": this._basic };
        }
        _LoadFromJson(t) {
          t && (this.GetSourceAdapter()._LoadFromJson(t["sourceAdapterJson"]), this._basic = t["basic"]);
        }
      };
    }
    {
      const C33 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;
      C33.Transition = class extends C33.DefendedBase {
        constructor(e, t = true) {
          super(), this._name = e[NAME], this._linear = e[LINEAR], this._transitionKeyframes = [];
          for (const a of e[TRANSITION_KEYFRAMES]) {
            const s = C33.TransitionKeyframe.Create(this, a);
            this._transitionKeyframes.push(s);
          }
          for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {
            const r = this._transitionKeyframes[e2], i = this._transitionKeyframes[e2 + 1], n = this._transitionKeyframes[e2 - 1];
            r.SetNext(i), r.SetPrevious(n);
          }
          this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t && Ease.AddCustomEase(this._name, (e2, t2, a, s) => this.Interpolate(e2, t2, a, s), null, { transition: this });
        }
        static Create(e) {
          return C33.New(C33.Transition, e);
        }
        Release() {
          for (const e of this._transitionKeyframes) e.Release();
          C33.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;
        }
        MakeLinear(e) {
          this._linear = !!e;
        }
        GetTransitionKeyFrameAt(e) {
          const t = this._transitionKeyframeCache.get(e);
          if (t) return t;
          for (const t2 of this._transitionKeyframes) if (t2.GetValueX() === e) return this._transitionKeyframeCache.set(e, t2), t2;
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(t) {
          for (let e = this._transitionKeyframes.length - 1; 0 <= e; e--) {
            const a = this._transitionKeyframes[e], s = a.GetValueX();
            if (s <= t) {
              let e2 = a;
              if (s < t) return e2;
              if (s === t) {
                for (; e2; ) {
                  const r = e2.GetPrevious();
                  if (!r) break;
                  if (r.GetValueX() !== e2.GetValueX()) break;
                  e2 = r;
                }
                return e2;
              }
            }
          }
        }
        Interpolate(e, t, a, s) {
          let r = e / s;
          if (this._linear) {
            const E = this.GetTransitionKeyFrameAt(0), n2 = this.GetTransitionKeyFrameAt(1), V = t + (t + a) * E.GetValueY(), p = (t + a) * n2.GetValueY(), S = p - V;
            return 0 === s ? V + S : Ease.NoEase(e, V, S, s);
          }
          0 === s && (r = 1);
          let i = this.GetFirstTransitionKeyFrameLowerOrEqualThan(r), n = i.GetNext();
          if (!n) {
            const X = i.GetPrevious(), A = i;
            i = X, n = A;
          }
          const l = n.GetValueX() - i.GetValueX(), o = C33.mapToRange(r, i.GetValueX(), n.GetValueX(), 0, l);
          if (i.IsSegmentLinear() || 0 == l) {
            const C = t + (t + a) * i.GetValueY(), d = (t + a) * n.GetValueY(), T = d - C;
            return 0 == l ? 1 === o ? C + T : C : Ease.NoEase(o, C, T, l);
          }
          const h = i.GetValueX(), u = i.GetValueY(), c = i.GetValueX() + i.GetStartAnchorX(), f = i.GetValueY() + i.GetStartAnchorY(), G = n.GetValueX() + n.GetEndAnchorX(), m = n.GetValueY() + n.GetEndAnchorY(), _ = n.GetValueX(), K = n.GetValueY();
          let y = Ease.GetRuntimeEase("spline")(o, h, u, c, f, G, m, _, K, this._precalculatedSamples.get(i));
          return (1 - (y += i.GetValueY())) * t + y * (t + a);
        }
        _PreCalcSamples() {
          this._precalculatedSamples.clear();
          for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {
            const t = this._transitionKeyframes[e];
            if (t.GetStartEnable()) {
              const a = t, s = this._transitionKeyframes[e + 1];
              if (s.GetEndEnable()) {
                const r = a.GetValueX(), i = a.GetValueX() + a.GetStartAnchorX(), n = s.GetValueX() + s.GetEndAnchorX(), l = s.GetValueX();
                this._precalculatedSamples.set(a, Ease.GetBezierSamples(r, i, n, l));
              }
            }
          }
        }
      };
    }
    {
      const C33 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;
      C33.TransitionKeyframe = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._transition = t, this._valueX = e[VALUE_X], this._valueY = e[VALUE_Y], this._startAnchorX = e[START_ANCHOR_X], this._startAnchorY = e[START_ANCHOR_Y], this._endAnchorX = e[END_ANCHOR_X], this._endAnchorY = e[END_ANCHOR_Y], this._startEnable = e[START_ENABLE], this._endEnable = e[END_ENABLE], this._segmentMode = e[SEGMENT_MODE], this._next = null, this._prev = null;
        }
        Release() {
          this._transition = null;
        }
        static Create(t, e) {
          return C33.New(C33.TransitionKeyframe, t, e);
        }
        SetNext(t) {
          this._next = t;
        }
        GetNext() {
          return this._next;
        }
        SetPrevious(t) {
          this._prev = t;
        }
        GetPrevious() {
          return this._prev;
        }
        GetValueX() {
          return this._valueX;
        }
        GetValueY() {
          return this._valueY;
        }
        GetStartAnchorX() {
          return this._startAnchorX;
        }
        GetStartAnchorY() {
          return this._startAnchorY;
        }
        GetEndAnchorX() {
          return this._endAnchorX;
        }
        GetEndAnchorY() {
          return this._endAnchorY;
        }
        GetStartEnable() {
          return this._startEnable;
        }
        GetEndEnable() {
          return this._endEnable;
        }
        IsSegmentLinear() {
          return "linear" === this._segmentMode;
        }
        IsSegmentCubic() {
          return "cubic" === this._segmentMode;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TransitionManager = class extends C33.DefendedBase {
        constructor(s) {
          super(), this._runtime = s, this._transitions = [];
        }
        Release() {
          for (const s of this._transitions) s.Release();
          C33.clearArray(this._transitions), this._transitions = null;
        }
        Create(s) {
          this._transitions.push(C33.Transition.Create(s));
        }
      };
    }
    {
      const C33 = self.C3;
      C33.TemplateManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);
        }
        Release() {
          if (this.RemoveRuntimeListeners(), this._templateDataMap) {
            for (const e of this._templateDataMap.values()) e.clear();
            this._templateDataMap.clear();
          }
          this._templateDataMap = null, this._runtime = null;
        }
        Create(e) {
          if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), e) {
            const t = e[0][16], a = t[0], s = e[1], n = (this._templateDataMap.has(s) || this._templateDataMap.set(s, /* @__PURE__ */ new Map()), this._templateDataMap.get(s));
            n.set(a, e);
          }
        }
        AddRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e && e.addEventListener("instancedestroy", this._instanceDestroy);
        }
        RemoveRuntimeListeners() {
          const e = this._runtime.Dispatcher();
          e && e.removeEventListener("instancedestroy", this._instanceDestroy);
        }
        HasTemplates() {
          return !!this._templateDataMap && 0 !== this._templateDataMap.size;
        }
        GetTemplateData(e, t) {
          let a = 0;
          if (a = e instanceof C33.ObjectClass ? e.GetIndex() : e, this._templateDataMap.has(a)) {
            const s = this._templateDataMap.get(a).get(t);
            return s ? JSON.parse(JSON.stringify(s)) : void 0;
          }
        }
        MapInstanceToTemplateName(e, t) {
          this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t);
        }
        GetInstanceTemplateName(e) {
          if (!this._instanceToTemplateNameMap) return "";
          const t = this._instanceToTemplateNameMap.get(e);
          return t || "";
        }
        _OnInstanceDestroy(e) {
          this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartManager = class {
        constructor(a) {
          this._runtime = a, this._flowchartDataManager = new C33.FlowchartDataManager();
        }
        Release() {
          this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        Create(a) {
          this._flowchartDataManager.Add(a);
        }
        GetFlowchartDataItemByName(a) {
          return this._flowchartDataManager.Get(a);
        }
        HasFlowcharts() {
          return this._flowchartDataManager.HasFlowcharts();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartState = class {
        constructor(t, e, r, a, o, h, s) {
          this._runtime = o.GetRuntime(), this._flowchartManager = o, this._flowchartName = t, this._startNodeTag = r, this._flowchartDataItem = a, this._tag = e, this._pluginInstance = h, this._pluginUID = s ?? h.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._triggerCount = 0, this._markForRelease = false, this._released = false;
        }
        Release() {
          this._released || (C33.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._released = true);
        }
        WasReleased() {
          return this._released;
        }
        GetFlowchartManager() {
          return this._flowchartManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._flowchartName;
        }
        GetFlowchartDataItem() {
          return this._flowchartDataItem;
        }
        GetTag() {
          return this._tag;
        }
        GetPluginInstance() {
          return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;
        }
        GetCurrentNode() {
          return this.GetFlowchartElementById(this._currentFlowchartNodeId);
        }
        GetCurrentNodeTag() {
          const t = this.GetCurrentNode();
          return t ? t.GetTag() : "";
        }
        GetCurrentNodeTags() {
          const t = this.GetCurrentNode();
          return t ? t.GetTags() : [];
        }
        CurrentNodeHasTags(t) {
          const e = this.GetCurrentNodeTags();
          if (!e) return false;
          if (!e.length) return false;
          const r = C33.FlowchartState._GetTagArray(t);
          return !(!r || !r.length) && r.every(C33.FlowchartState._HasTag, e);
        }
        CurrentNodeCompareTags(t, e) {
          const r = this.GetCurrentNodeTags();
          if (!r) return false;
          if (!r.length) return false;
          const a = C33.FlowchartState._GetTagArray(t);
          return !(!a || !a.length) && a.every((t2) => C33.FlowchartState._CompareTag.call(r, t2, e));
        }
        static _HasTag(t) {
          const e = this;
          return "" === t ? 1 === e.length && "" === e[0] : e.map((t2) => t2.trim().toLowerCase()).includes(t.trim().toLowerCase());
        }
        static _GetTagArray(t) {
          return t.trim().split(" ");
        }
        static _CompareTag(e, r) {
          const t = this;
          return "" === e ? 1 === t.length && "" === t[0] : t.some((t2) => C33.compare(t2.trim(), r, e.trim()));
        }
        GetCurrentNodeParent(t) {
          const e = this.GetCurrentNode();
          if (e) {
            if (C33.IsFiniteNumber(t)) {
              const r = e.GetParentFlowchartIds(), a = r ? r[t] : void 0;
              if (C33.IsFiniteNumber(a)) return this.GetFlowchartElementById(a);
            }
            if ("string" == typeof t) for (const o of e.GetParentFlowchartIds()) {
              const h = this.GetFlowchartElementById(o);
              if (h.HasTags(t)) return this.GetFlowchartElementById(h.GetFlowchartId());
            }
          }
        }
        GetCurrentNodeParentTag(t) {
          const e = this.GetCurrentNodeParent(t);
          return e ? e.GetTag() : "";
        }
        GetCurrentNodeParentTags(t) {
          const e = this.GetCurrentNodeParent(t);
          return e ? e.GetTags() : "";
        }
        GetCurrentNodeParentIndex(t) {
          const e = this.GetCurrentNode();
          if (!e) return -1;
          const r = e.GetParentFlowchartIds();
          if (!r) return -1;
          const a = this.GetCurrentNodeParent(t);
          return a ? r.indexOf(a.GetFlowchartId()) : -1;
        }
        GetCurrentNodeParentCount() {
          const t = this.GetCurrentNode();
          if (!t) return 0;
          const e = t.GetParentFlowchartIds();
          return e ? e.length : 0;
        }
        GetFlowchartElementById(t) {
          return this._flowchartDataItem.GetFlowchartElementById(t);
        }
        Reset() {
          const t = this._GetRootFlowchartState();
          t._Reset(true);
        }
        _Reset(t) {
          if (this._GetReferenceFlowchartStates()) {
            for (const [e, r] of this._GetReferenceFlowchartStates().entries()) r._Reset(false);
            this._GetReferenceFlowchartStates().clear();
          }
          if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._previousFlowchartNodeIds = [], t) {
            this._flowchartManager.SetCurrentFlowchartState(this);
            const a = this._startFlowchartNode.GetFlowchartId();
            a !== this._currentFlowchartNodeId && this._GotoFlowchartNode(a);
          } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();
        }
        GetCurrentNodeOutputCount() {
          const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;
        }
        GetCurrentNodeOutputNameAt(t) {
          const e = this._GetFlowchartNodeOutputAt(t);
          return e ? e.GetName() : "";
        }
        GetCurrentNodeOutputValueAt(t) {
          let e;
          return C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), "string" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), e ? e.GetValue() : "";
        }
        GotoNextFlowchartNode(t) {
          let e;
          if (C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), e = "string" == typeof t ? this._GetFlowchartNodeOutputByName(t) : e) {
            const r = e.GetConnectedFlowchartNodeFlowchartId();
            C33.IsFiniteNumber(r) && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r));
          }
        }
        GotoAnyFlowchartNode(t) {
          const e = this._flowchartDataItem.GetFlowchartNodeByTags(t);
          if (e) {
            const r = this._flowchartDataItem.GetFlowchartElementById(e.GetFlowchartId());
            r && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r.GetFlowchartId()));
          }
        }
        GotoPreviousFlowchartNode() {
          const t = this._previousFlowchartNodeIds.pop();
          C33.IsFiniteNumber(t) ? this._GotoFlowchartNode(t) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));
        }
        GotoParentFlowchartNode(t) {
          const e = this.GetCurrentNode();
          if (e) {
            e.GetFlowchartId();
            const r = this.GetCurrentNodeParent(t);
            r && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r.GetFlowchartId()));
          }
        }
        HasOutput(e) {
          if (C33.IsFiniteNumber(e)) {
            const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId), r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
            return !!r[e];
          }
          if ("string" == typeof e) {
            const a = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId), o = a.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
            for (let t = 0; t < o.length; t++) if (o[t].GetName() === e) return true;
          }
          return false;
        }
        MarkForRelease() {
          this._markForRelease = true;
        }
        IsInTriggerState() {
          return 0 < this._triggerCount;
        }
        PushIsTriggerState() {
          this._triggerCount++;
        }
        PopIsTriggerState() {
          this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);
        }
        _GotoFlowchartNode(t) {
          const r = this._currentFlowchartNodeId, e = this.GetPluginInstance().GetInstance();
          if (this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, e), this._currentFlowchartNodeId = t, this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, e), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, e), this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased()) {
            const a = this.GetFlowchartElementById(this._currentFlowchartNodeId);
            if ("reference" === a.GetType()) {
              const o = a.GetReferenceFlowchartName();
              if (this._HasReferenceFlowchartState(a)) {
                this._previousFlowchartNodeIds.pop();
                const h = this._GetReferenceFlowchartState(a), s = (this._flowchartManager.SetCurrentFlowchartState(h, true, true, false), h._SetPreviousFlowchart(this, r), this._GetRootFlowchartState());
                s._SetCurrentReferenceFlowchart(h);
              } else {
                const c = a.GetReferenceFlowchartStartNodeTag();
                if (o) {
                  this._previousFlowchartNodeIds.pop();
                  let e2 = a.GetReferenceFlowchartTag();
                  if (e2) {
                    let t2 = this._flowchartManager.GetFlowchartState(e2);
                    for (; t2; ) e2 = C33.IncrementNumberAtEndOf(e2), t2 = this._flowchartManager.GetFlowchartState(e2);
                  } else {
                    e2 = o + "-ref";
                    let t2 = this._flowchartManager.GetFlowchartState(e2);
                    for (; t2; ) e2 = C33.IncrementNumberAtEndOf(e2), t2 = this._flowchartManager.GetFlowchartState(e2);
                  }
                  const n = this._flowchartManager.AddFlowchartState(o, c, e2, this._pluginInstance, true), l = (n._SetPreviousFlowchart(this, r), this._SetReferenceFlowchartState(a, n), this._GetRootFlowchartState());
                  n._SetRootFlowchartState(l), l._SetCurrentReferenceFlowchart(n);
                }
              }
            }
          }
        }
        _GetFlowchartNodeOutputAt(t) {
          const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          if (!e) return null;
          const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
          if (!r) return null;
          const a = r[t];
          return a || null;
        }
        _GetFlowchartNodeOutputByName(t) {
          const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
          if (!e) return null;
          const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t);
          return r || null;
        }
        _SetStartFlowchartNode(e) {
          if ("number" == typeof e) {
            let t = this.GetFlowchartElementById(e);
            t = t || this._flowchartDataItem.GetFlowchartStartNode(), this._startFlowchartNode = t;
          } else {
            let t = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);
            t = t || this._flowchartDataItem.GetFlowchartStartNode(), this._startFlowchartNode = t;
          }
        }
        _SaveToJson() {
          return this._markForRelease ? null : { "flowchartName": this._flowchartName, "flowchartTag": this._tag, "startNodeTag": this._startNodeTag, "currentNodeId": this._currentFlowchartNodeId, "previousNodeIds": this._previousFlowchartNodeIds, "pluginUID": this._pluginInstance.GetInstance().GetUID(), "reference": { "previousFlowchartTag": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : "", "previousStartNodeId": C33.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, "referencesJson": this._GetFlowchartReferencesJson(), "currentReferenceFlowchartTag": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "", "rootFlowchartTag": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : "" } };
        }
        _GetFlowchartReferencesJson() {
          if (!this._HasReferenceFlowchartStates()) return null;
          const t = [];
          for (const [e, r] of this._GetReferenceFlowchartStates().entries()) t.push({ "flowchartElementId": e.GetFlowchartId(), "flowchartStateTag": r.GetTag() });
          return t.length ? t : null;
        }
        _LoadFromJson(t) {
          if (t) {
            if (this._flowchartName = t["flowchartName"], this._tag = t["flowchartTag"], this._startNodeTag = t["startNodeTag"], this._currentFlowchartNodeId = t["currentNodeId"], this._previousFlowchartNodeIds = t["previousNodeIds"], this._pluginUID = t["pluginUID"], t.hasOwnProperty("reference")) {
              const e = t["reference"];
              this._previousFlowchartStateTag = e["previousFlowchartTag"], this._previousFlowchartStateStartNodeId = e["previousStartNodeId"], this._referenceFlowchartStatesJson = e["referencesJson"], this._currentReferenceFlowchartStateTag = e["currentReferenceFlowchartTag"], this._rootFlowchartStateTag = e["rootFlowchartTag"];
            }
            this._SetStartFlowchartNode();
          }
        }
        _GetPreviousFlowchartState() {
          return "string" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = ""), this._previousFlowchartState;
        }
        _GetPreviousFlowchartStateStartNodeId() {
          return this._previousFlowchartStateStartNodeId;
        }
        _SetPreviousFlowchart(t, e) {
          this._previousFlowchartState = t, this._previousFlowchartStateStartNodeId = e;
        }
        GetCurrentReferenceFlowchart() {
          return "string" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = ""), this._currentReferenceFlowchartState;
        }
        _SetCurrentReferenceFlowchart(t) {
          this._currentReferenceFlowchartState = t, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);
        }
        _GetRootFlowchartState() {
          return "string" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = ""), this._rootFlowchartState || this;
        }
        _SetRootFlowchartState(t) {
          this._rootFlowchartState = t;
        }
        _HasReferenceFlowchartStates() {
          return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;
        }
        _HasReferenceFlowchartState(t) {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t);
        }
        _RebuildReferenceFlowchartStates() {
          if (this._referenceFlowchartStatesJson) {
            this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());
            for (const t of this._referenceFlowchartStatesJson) {
              const e = this._flowchartManager.GetFlowchartState(t["flowchartStateTag"]), r = e.GetFlowchartElementById(t["flowchartElementId"]);
              this._referenceFlowchartStates.set(r, e);
            }
            this._referenceFlowchartStatesJson = null;
          }
        }
        _GetReferenceFlowchartStates() {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;
        }
        _GetReferenceFlowchartState(t) {
          return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t);
        }
        _SetReferenceFlowchartState(t, e) {
          this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t, e);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartStateManager = class {
        constructor(t) {
          this._runtime = t, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;
        }
        Release() {
          C33.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        AddFlowchartState(t, e, a, r, h, s) {
          const o = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);
          if (o) {
            if (!this._flowchartStates.has(a)) {
              const c = new C33.FlowchartState(t, a, e, o, this, r, s);
              return this._flowchartStates.set(a, c), h && this.SetCurrentFlowchartState(c, true), c;
            }
            {
              const c = this._flowchartStates.get(a);
              void (c && this.RemoveFlowchartState(c));
            }
          } else console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
        }
        RemoveFlowchartState(t) {
          if (t.MarkForRelease(), !t.IsInTriggerState()) {
            const e = t.GetTag();
            this._flowchartStates.delete(e), t.Release(), this._currentFlowchartState === t && (this._currentFlowchartState = null);
          }
        }
        ResetFlowchartState(t) {
          t.Reset();
        }
        GetFlowchartState(t) {
          return this._flowchartStates.get(t);
        }
        PushFlowchartState(t) {
          this._flowchartStateStack.push(t);
        }
        PopFlowchartState() {
          this._flowchartStateStack.pop();
        }
        SetCurrentFlowchartState(t, e = false, a = false, r = true) {
          if (r) {
            const h = t.GetCurrentReferenceFlowchart();
            t = h || t;
          }
          t !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t, e, a));
        }
        GetCurrentFlowchartState(t) {
          return "string" == typeof t ? this.GetFlowchartState(t) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;
        }
        _TriggerBeforeFlowchartChange() {
          if (this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {
            const t = this._currentFlowchartState.GetPluginInstance().GetInstance();
            this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
          }
        }
        _TriggerAfterFlowchartChange(t, e = false, a = false) {
          if (this._currentFlowchartState = t, this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {
            const r = this._currentFlowchartState.GetPluginInstance().GetInstance();
            this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnFlowchartChange, r), true !== a && "number" != typeof a || this._currentFlowchartState._SetStartFlowchartNode(a), e && (this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, r), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
          }
        }
        _SaveToJson() {
          return { "flowchartJsonObjects": [...this._flowchartStates.values()].map((t) => t._SaveToJson()), "currentFlowchartTag": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };
        }
        _LoadFromJson(t) {
          if (t) {
            this._loadJson = t;
            const e = /* @__PURE__ */ new Map();
            for (const a of this._loadJson["flowchartJsonObjects"]) {
              const r = a["flowchartTag"];
              if (this._flowchartStates.has(r)) {
                const h = this._flowchartStates.get(r);
                h._LoadFromJson(a), e.set(r, h);
              } else {
                const s = this.AddFlowchartState(a["flowchartName"], a["startNodeTag"], a["flowchartTag"], null, false, a["pluginUID"]);
                s._LoadFromJson(a), e.set(a["flowchartTag"], s);
              }
            }
            for (const [o, c] of this._flowchartStates.entries()) e.has(o) || c.Release();
            this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener("afterload", this._on_after_load) : this._OnAfterLoad();
          }
        }
        _OnAfterLoad() {
          this._runtime.Dispatcher().removeEventListener("afterload", this._on_after_load);
          const t = this._flowchartStates.get(this._loadJson["currentFlowchartTag"]);
          t && this.SetCurrentFlowchartState(t, true), this._loadJson = null;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.FlowchartDataManager = class {
        constructor() {
          this._flowchartDataItems = /* @__PURE__ */ new Map();
        }
        Release() {
          for (const t of this._flowchartDataItems.values()) t.Release();
          this._flowchartDataItems.clear(), this._flowchartDataItems = null;
        }
        Add(t) {
          const a = new C33.FlowchartDataItem(t), s = a.GetName();
          this._flowchartDataItems.set(s, a);
        }
        Get(t) {
          return this._flowchartDataItems.get(t);
        }
        HasFlowcharts() {
          return !!this._flowchartDataItems.size;
        }
        static CreateDataItems(t, a, s, e) {
          if (a) for (const o of a) {
            const r = new s(o, e);
            t.push(r);
          }
        }
      };
    }
    {
      const C33 = self.C3, NAME = 0, NODES = 1;
      C33.FlowchartDataItem = class {
        constructor(t) {
          this._name = t[NAME], this._flowchartNodeData = new C33.FlowchartNodeData(t[NODES], this);
        }
        Release() {
          this._flowchartNodeData.Release(), this._flowchartNodeData = null;
        }
        GetFlowchartNodeData() {
          return this._flowchartNodeData;
        }
        GetFlowchartElementById(t) {
          return this._flowchartNodeData.GetFlowchartElementById(t);
        }
        GetFlowchartNodeByTags(t) {
          return this._flowchartNodeData.GetFlowchartNodeByTags(t);
        }
        GetFlowchartStartNode() {
          return this._flowchartNodeData.GetFlowchartStartNode();
        }
        GetName() {
          return this._name;
        }
      };
    }
    {
      const C33 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10;
      class FlowchartNodeDataItem {
        constructor(t, e) {
          this._flowchartNodeData = e, this._type = t[TYPE], this._flowchartId = t[FLOWCHART_ID], this._tag = t[TAG], this._tag ? this._tags = this._tag.trim().split(" ").map((t2) => t2.trim()) : this._tags = [], this._parentFlowchartIds = t[PARENT_FLOWCHART_IDS], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, "dictionary" === this._type && (this._parentOutputFlowchartIds = t[PARENT_OUTPUT_FLOWCHART_IDS], this._childrenFlowchartIds = t[CHILDREN_FLOWCHART_IDS]), this._isStart = t[IS_START], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, "reference" === this._type && (this._referenceFlowchartName = t[REFERENCE_FLOWCHART], this._referenceFlowchartStartNodeTag = t[REFERENCE_FLOWCHART_START_NODE], this._referenceFlowchartTag = t[REFERENCE_FLOWCHART_TAG]), this._flowchartNodeOutputData = new C33.FlowchartNodeOutputData(t[OUTPUTS], this);
        }
        Release() {
          this._flowchartNodeData = null;
        }
        GetFlowchartNodeData() {
          return this._flowchartNodeData;
        }
        GetFlowchartNodeOutputData() {
          return this._flowchartNodeOutputData;
        }
        GetFlowchartId() {
          return this._flowchartId;
        }
        GetTag() {
          return this._tag;
        }
        GetTags() {
          return this._tags;
        }
        HasTags(t) {
          if (!this._tags) return false;
          if (!this._tags.length) return false;
          const e = C33.FlowchartState._GetTagArray(t);
          return !(!e || !e.length) && e.every(C33.FlowchartState._HasTag, this._tags);
        }
        GetIsStart() {
          return this._isStart;
        }
        GetParentFlowchartIds() {
          return this._parentFlowchartIds;
        }
        GetParentOutputFlowchartIds() {
          return this._parentOutputFlowchartIds;
        }
        GetChildrenFlowchartIds() {
          return this._childrenFlowchartIds;
        }
        GetType() {
          return this._type;
        }
        GetReferenceFlowchartName() {
          return this._referenceFlowchartName;
        }
        GetReferenceFlowchartStartNodeTag() {
          return this._referenceFlowchartStartNodeTag;
        }
        GetReferenceFlowchartTag() {
          return this._referenceFlowchartTag;
        }
      }
      C33.FlowchartNodeData = class {
        constructor(t, e) {
          this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t, FlowchartNodeDataItem, this);
          for (const a of this._flowchartNodeItems) {
            const r = a.GetFlowchartId(), h = a.GetTag(), s = a.GetTags(), o = a.GetIsStart();
            if (this._flowchartNodeItemsIdMap.set(r, a), h) for (const c of s) this._flowchartNodeItemsTagMap.has(c) || this._flowchartNodeItemsTagMap.set(c, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(c).add(a);
            o && (this._flowchartNodeStartItem = a);
            const l = a.GetFlowchartNodeOutputData();
            for (const _ of l.flowchartNodeOutputDataItems()) {
              const i = _.GetFlowchartId();
              this._flowchartNodeItemsIdMap.set(i, _);
            }
          }
        }
        Release() {
          this._flowchartDataItem = null;
          for (const t of this._flowchartNodeItems) t.Release();
          C33.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;
        }
        GetFlowchartDataItem() {
          return this._flowchartDataItem;
        }
        GetFlowchartElementById(t) {
          return this._flowchartNodeItemsIdMap.get(t);
        }
        GetFlowchartNodeByTags(t) {
          if (!t || !t.length) return null;
          const a = [];
          for (const r of t.trim().split(" ")) {
            let t2 = this._flowchartNodeItemsTagMap.get(r.trim()) ?? /* @__PURE__ */ new Set();
            if (0 === t2.size) return null;
            a.push(t2);
          }
          const e = a.reduce((t2, e2) => e2.size < t2.size ? e2 : t2);
          return [...e].filter((e2) => a.every((t2) => t2.has(e2)))[0];
        }
        GetFlowchartStartNode() {
          return this._flowchartNodeStartItem;
        }
        *flowchartNodeDataItems() {
          for (const t of this._flowchartNodeItems) yield t;
        }
      };
    }
    {
      const C33 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3;
      class FlowchartNodeDataOutputItem {
        constructor(t, e) {
          this._flowchartNodeOutputData = e, this._flowchartId = t[FLOWCHART_ID], this._name = t[NAME], this._value = t[VALUE], this._connectedFlowchartNodeFlowchartId = t[CONNECTED_FLOWCHART_NODE_FLOWCHART_ID];
        }
        Release() {
          this._flowchartNodeOutputData = null;
        }
        GetFlowchartNodeOutputData() {
          return this._flowchartNodeOutputData;
        }
        GetFlowchartId() {
          return this._flowchartId;
        }
        GetName() {
          return this._name;
        }
        GetValue() {
          return this._value;
        }
        GetConnectedFlowchartNodeFlowchartId() {
          return this._connectedFlowchartNodeFlowchartId;
        }
      }
      C33.FlowchartNodeOutputData = class {
        constructor(t, e) {
          this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t, FlowchartNodeDataOutputItem, this);
          for (const a of this._flowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(a.GetName(), a);
        }
        Release() {
          this._flowchartDataNodeItem = null;
          for (const t of this._flowchartNodeOutputItems) t.Release();
          C33.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null;
        }
        GetFlowchartNodeDataItem() {
          return this._flowchartDataNodeItem;
        }
        GetFlowchartNodeOutputDataItemCount() {
          return this._flowchartNodeOutputItems.length;
        }
        GetFlowchartNodeOutputDataItems() {
          return this._flowchartNodeOutputItems;
        }
        GetFlowchartNodeOutputDataItemByName(t) {
          return this._flowchartNodeOutputItemsNameMap.get(t);
        }
        *flowchartNodeOutputDataItems() {
          for (const t of this._flowchartNodeOutputItems) yield t;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SolStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._objectClass = t, this._stack = [], this._stack.push(C33.New(C33.Sol, this)), this._index = 0, this._current = this._stack[0];
        }
        Release() {
          for (const t of this._stack) t.Release();
          C33.clearArray(this._stack), this._current = null, this._objectClass = null;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetCurrentSol() {
          return this._current;
        }
        GetOneBelowCurrentSol() {
          return this._stack[this._index - 1];
        }
        Clear() {
          this.GetCurrentSol().Clear();
        }
        PushClean() {
          const t = this._stack, s = ++this._index;
          if (s === t.length) {
            const e = C33.New(C33.Sol, this);
            t.push(e), this._current = e;
          } else {
            const n = t[s];
            n.Reset(), this._current = n;
          }
        }
        PushCopy() {
          const t = this._stack, s = ++this._index, e = (s === t.length && t.push(C33.New(C33.Sol, this)), t[s]);
          e.Copy(t[s - 1]), this._current = e;
        }
        Pop() {
          this._current = this._stack[--this._index];
        }
        RemoveInstances(e) {
          const n = this._stack;
          for (let t = 0, s = n.length; t < s; ++t) n[t].RemoveInstances(e);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Sol = class extends C33.DefendedBase {
        constructor(s) {
          super(), this._stack = s, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];
        }
        Release() {
          this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;
        }
        ClearArrays() {
          C33.clearArray(this._instances), C33.clearArray(this._elseInstances);
        }
        GetObjectClass() {
          return this._objectClass;
        }
        IsSelectAll() {
          return this._selectAll;
        }
        HasAnyInstances() {
          return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;
        }
        GetInstances() {
          return this._selectAll ? this._objectClass.GetInstances() : this._instances;
        }
        HasAnyElseInstances() {
          return !!this._elseInstances.length;
        }
        GetElseInstances() {
          return this._elseInstances;
        }
        GetExpressionInstances() {
          const s = this.GetInstances();
          return s.length ? s : this._elseInstances;
        }
        Reset() {
          this._selectAll = true, C33.clearArray(this._elseInstances);
        }
        Clear() {
          this._selectAll = true;
        }
        Copy(s) {
          s.IsSelectAll() ? this.Reset() : (this._selectAll = false, C33.shallowAssignArray(this._instances, s._instances), C33.clearArray(this._elseInstances));
        }
        _PushInstance(s) {
          this._instances.push(s);
        }
        _PushElseInstance(s) {
          this._elseInstances.push(s);
        }
        _SetSelectAll(s) {
          this._selectAll = !!s;
        }
        _GetOwnInstances() {
          return this._instances;
        }
        _GetOwnElseInstances() {
          return this._elseInstances;
        }
        SetSinglePicked(s) {
          this._selectAll = false, C33.clearArray(this._instances), this._instances.push(s);
        }
        SetArrayPicked(s) {
          this._selectAll = false, C33.shallowAssignArray(this._instances, s);
        }
        SetSetPicked(s) {
          this._selectAll = false, C33.clearArray(this._instances);
          for (const e of s) this._instances.push(e);
        }
        AddElseInstances(s, e) {
          for (const t of e) s.has(t) || this._elseInstances.push(t);
        }
        TransferElseInstancesToOwn(s) {
          for (const e of s) this._instances.push(e);
          C33.arrayRemoveAllInSet(this._elseInstances, s);
        }
        ClearElseInstances() {
          C33.clearArray(this._elseInstances);
        }
        PickOne(s) {
          if (s) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
            this.IsSelectAll() && (C33.clearArray(this._instances), C33.shallowAssignArray(this._elseInstances, s.GetObjectClass().GetInstances()), this._selectAll = false);
            const e = this._elseInstances.indexOf(s);
            -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));
          } else this.SetSinglePicked(s);
        }
        RemoveInstances(s) {
          C33.arrayRemoveAllInSet(this._instances, s), C33.arrayRemoveAllInSet(this._elseInstances, s);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EventStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C33.New(C33.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];
        }
        Release() {
          for (const t of this._stack) t.Release();
          C33.clearArray(this._stack), C33.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetCurrentStackFrame() {
          return this._stack[this._index];
        }
        GetAllStackFrames() {
          return this._stack;
        }
        GetCurrentStackFrameIndex() {
          return this._index;
        }
        Push(t) {
          const e = this._stack, n = ++this._index;
          if (n === e.length) {
            const s = C33.New(C33.EventStackFrame, this, t);
            return e.push(s), s;
          }
          {
            const r = e[n];
            return r.Reset(t), r;
          }
        }
        Pop() {
          --this._index;
        }
        PushExpFunc(t) {
          this._expFuncStack.push(t);
        }
        PopExpFunc() {
          this._expFuncStack.pop();
        }
        GetCurrentExpFuncStackFrame() {
          const t = this._expFuncStack;
          return 0 === t.length ? null : t.at(-1);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EventStackFrame = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._stack = t, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;
        }
        Release() {
          this.Reset(null), this._stack = null, this._runtime = null;
        }
        Reset(t) {
          this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;
        }
        _Restore(t, e) {
          this._currentEvent = t, this._cndIndex = 0, this._actIndex = e;
        }
        ResetQuick() {
          this._cndIndex = 0, this._actIndex = 0;
        }
        GetCurrentEvent() {
          return this._currentEvent;
        }
        SetCurrentEvent(t) {
          this._currentEvent = t;
        }
        GetConditionIndex() {
          return this._cndIndex;
        }
        SetConditionIndex(t) {
          this._cndIndex = t;
        }
        GetActionIndex() {
          return this._actIndex;
        }
        SetActionIndex(t) {
          this._actIndex = t;
        }
        SetLastEventTrue(t) {
          this._lastEventTrue = !!t;
        }
        GetLastEventTrue() {
          return this._lastEventTrue;
        }
        SetElseBranchRan(t) {
          this._elseBranchRan = !!t;
        }
        GetElseBranchRan() {
          return this._elseBranchRan;
        }
        SetExpressionObjectClass(t) {
          this._expressionObjectClass = t;
        }
        GetExpressionObjectClass() {
          return this._expressionObjectClass;
        }
        InitCallFunctionExpression(t, e) {
          this._functionReturnType = t, this._functionReturnValue = e;
        }
        GetFunctionReturnType() {
          return this._functionReturnType;
        }
        SetFunctionReturnValue(t) {
          this._functionReturnValue = t;
        }
        GetFunctionReturnValue() {
          return this._functionReturnValue;
        }
        IsSolModifierAfterCnds() {
          const t = this._currentEvent;
          return !!t.IsSolWriterAfterCnds() || this._cndIndex < t.GetConditionCount() - 1 && !!t.GetSolModifiers().length;
        }
        SetDynamicSolModifiers(t) {
          this._dynamicSolModifiers = t;
        }
        GetDynamicSolModifiers() {
          return this._dynamicSolModifiers;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.LocalVarStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];
        }
        Release() {
          C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
        }
        _SetInitialValues(t) {
          this._initialValues = t;
          const e = this._initialValues.slice(0);
          this._stack.push(e), this._index = 0, this._current = e;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetCurrent() {
          return this._current;
        }
        Push() {
          const t = ++this._index, e = this._stack;
          t === e.length ? e.push(this._initialValues.slice(0)) : C33.shallowAssignArray(e[t], this._initialValues), this._current = e[t];
        }
        Pop() {
          this._current = this._stack[--this._index];
        }
      };
    }
    {
      const C33 = self.C3;
      C33.LoopStack = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;
        }
        Release() {
          C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        IsInLoop() {
          return 0 <= this._index;
        }
        GetCurrent() {
          return this._stack[this._index];
        }
        Push() {
          if (++this._index, this._index === this._stack.length) {
            const t = C33.New(C33.Loop, this);
            return this._stack.push(t), t;
          }
          {
            const e = this._stack[this._index];
            return e.Reset(), e;
          }
        }
        Pop() {
          --this._index;
        }
        FindByName(e) {
          const s = this._stack;
          for (let t = this._index; 0 <= t; --t) {
            const n = s[t];
            if (n.GetName() === e) return n;
          }
          return null;
        }
        _GetStack() {
          return this._stack.slice(0, this._index + 1);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Loop = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._loopStack = e, this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
        }
        Reset() {
          this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
        }
        SetName(e) {
          this._name = e;
        }
        GetName() {
          return this._name;
        }
        SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        Stop() {
          this._isStopped = true;
        }
        IsStopped() {
          return this._isStopped;
        }
        SetEnd(e) {
          this._end = e;
        }
        GetEnd() {
          return this._end;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ArrayStack = class extends C33.DefendedBase {
        constructor() {
          super(), this._stack = [], this._index = -1;
        }
        Release() {
          C33.clearArray(this._stack);
        }
        GetCurrent() {
          return this._stack[this._index];
        }
        Push() {
          if (++this._index, this._index !== this._stack.length) return this._stack[this._index];
          {
            const s = [];
            return this._stack.push(s), s;
          }
        }
        Pop() {
          --this._index;
        }
      };
    }
    {
      let SortSolArray2 = function(t, e) {
        return t.GetIndex() - e.GetIndex();
      }, IsSolArrayIdentical2 = function(s, n) {
        for (let t = 0, e = s.length; t < e; ++t) if (s[t] !== n[t]) return false;
        return true;
      };
      SortSolArray = SortSolArray2, IsSolArrayIdentical = IsSolArrayIdentical2;
      const C33 = self.C3, assert = self.assert;
      C33.EventSheetManager = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._runtime = t, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C33.New(C33.EventStack, this), this._localVarStack = C33.New(C33.LocalVarStack, this), this._loopStack = C33.New(C33.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self["c3_callFunction"] = (t2, e) => this._InvokeFunctionFromJS(t2, e);
        }
        Release() {
          this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C33.clearArray(this._queuedTriggers), C33.clearArray(this._queuedDebugTriggers), this._runtime = null, C33.clearArray(this._allSheets), this._sheetsByName.clear();
        }
        Create(t) {
          const e = C33.New(C33.EventSheet, this, t);
          this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);
        }
        _AddTriggerToPostInit(t) {
          this._triggersToPostInit.push(t);
        }
        _PostInit() {
          for (const t of this._customActionBlocksMap.values()) t._CheckOverrideState();
          for (const e of this._functionBlocksByName.values()) e._PostInit();
          for (const s of this._customActionBlocksMap.values()) s._PostInit();
          for (const n of this._allSheets) n._PostInit();
          for (const i of this._allSheets) i._UpdateDeepIncludes();
          for (const r of this._triggersToPostInit) r._PostInit(false);
          C33.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);
        }
        GetRuntime() {
          return this._runtime;
        }
        GetEventSheetByName(t) {
          return this._sheetsByName.get(t.toLowerCase()) || null;
        }
        _RegisterGroup(t) {
          this._allGroups.push(t), this._groupsByName.set(t.GetGroupName(), t);
        }
        _RegisterEventBlock(t) {
          this._blocksBySid.set(t.GetSID(), t);
        }
        _RegisterCondition(t) {
          this._cndsBySid.set(t.GetSID(), t);
        }
        _RegisterAction(t) {
          this._actsBySid.set(t.GetSID(), t);
        }
        _RegisterFunctionBlock(t) {
          switch (t.GetFunctionType()) {
            case 0:
              this._functionBlocksByName.set(t.GetFunctionName().toLowerCase(), t);
              break;
            case 1:
              this._customActionBlocksMap.set(t.GetFunctionName().toLowerCase(), t);
          }
        }
        _RegisterEventVariable(t) {
          this._eventVarsBySid.set(t.GetSID(), t), (t.IsGlobal() ? this._allGlobalVars : this._allLocalVars).push(t);
        }
        _DeduplicateSolModifierList(s) {
          2 <= s.length && s.sort(SortSolArray2);
          let n = this._allUniqueSolModifiers.get(s.length);
          n || (n = [], this._allUniqueSolModifiers.set(s.length, n));
          for (let t = 0, e = n.length; t < e; ++t) {
            const i = n[t];
            if (IsSolArrayIdentical2(s, i)) return i;
          }
          return n.push(s), s;
        }
        _GetNextLocalVarIndex(t) {
          return this._localVarInitialValues.push(t.GetInitialValue()), this._nextLocalVarIndex++;
        }
        GetEventStack() {
          return this._eventStack;
        }
        GetCurrentEventStackFrame() {
          return this.GetEventStack().GetCurrentStackFrame();
        }
        GetCurrentEvent() {
          return this.GetCurrentEventStackFrame().GetCurrentEvent();
        }
        GetCurrentCondition() {
          const t = this.GetCurrentEventStackFrame(), e = t.GetCurrentEvent();
          return e.GetConditionAt(t.GetConditionIndex());
        }
        GetCurrentAction() {
          const t = this.GetCurrentEventStackFrame(), e = t.GetCurrentEvent();
          return e.GetActionAt(t.GetActionIndex());
        }
        GetLocalVarStack() {
          return this._localVarStack;
        }
        GetLoopStack() {
          return this._loopStack;
        }
        GetAllLocalVariablesInScope(t) {
          const e = [];
          for (t = t.GetScopeParent(); t; ) C33.appendArray(e, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();
          return e;
        }
        _GetLocalVariablesScriptInterface(t) {
          const e = {};
          for (const s of this.GetAllLocalVariablesInScope(t)) e[s.GetJsPropName()] = s._GetScriptInterfaceDescriptor();
          return Object.create(Object.prototype, e);
        }
        GetEventVariableBySID(t) {
          return this._eventVarsBySid.get(t) || null;
        }
        GetEventBlockBySID(t) {
          return this._blocksBySid.get(t) || null;
        }
        GetConditionBySID(t) {
          return this._cndsBySid.get(t) || null;
        }
        GetActionBySID(t) {
          return this._actsBySid.get(t) || null;
        }
        GetFunctionBlockByName(t) {
          return this._functionBlocksByName.get(t.toLowerCase()) || null;
        }
        GetCustomActionBlockByName(t, e) {
          let s = this._customActionBlocksMap.get((t.GetName() + "." + e).toLowerCase());
          if (s) return s;
          if (!t.IsFamily()) {
            for (const n of t.GetFamilies()) if (s = this._customActionBlocksMap.get((n.GetName() + "." + e).toLowerCase())) return s;
          }
          return null;
        }
        GetAllGlobalVariables() {
          return this._allGlobalVars;
        }
        GetAllLocalVariables() {
          return this._allLocalVars;
        }
        ResetAllGlobalsToInitialValue(t) {
          for (const e of this._allGlobalVars) e.ResetToInitialValue();
          if (t) for (const s of this._allLocalVars) s.IsStatic() && s.ResetToInitialValue();
        }
        GetEventGroupByName(t) {
          return this._groupsByName.get(t.toLowerCase()) || null;
        }
        GetEventGroupBySID(t) {
          const e = this._blocksBySid.get(t);
          return e && e.IsGroup() ? e : null;
        }
        GetAllGroups() {
          return this._allGroups;
        }
        ResetAllGroupsInitialActivation() {
          for (const t of this._allGroups) t.ResetInitialActivation();
        }
        _ResetAllHasRunFlags() {
          for (const t of this._allSheets) t._ResetHasRunFlag();
        }
        RunEvents(t) {
          this._ResetAllHasRunFlags(), this._runningEventsDepth++;
          for (const e of t.runningLayouts()) {
            const s = e.GetEventSheet();
            s && (this._runtime.PushCurrentLayout(e), s.Run(), this._runtime.PopCurrentLayout());
          }
          this._runningEventsDepth--;
        }
        async DebugRunEvents(t) {
          this._ResetAllHasRunFlags(), this._runningEventsDepth++;
          for (const e of this._DebugRunEventsGen(t)) await this._runtime.DebugBreak(e);
          this._runningEventsDepth--;
        }
        *_DebugRunEventsGen(t) {
          for (const e of t.runningLayouts()) {
            const s = e.GetEventSheet();
            s && (this._runtime.PushCurrentLayout(e), yield* s.DebugRun(), this._runtime.PopCurrentLayout());
          }
        }
        _Trigger(t, e, s, n) {
          let i = false;
          if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
          this._executingTriggerDepth++;
          for (const r of t.runningLayouts()) {
            const o = r.GetEventSheet();
            if (o) {
              this._runtime.PushCurrentLayout(r);
              for (const l of o.deepIncludes()) {
                const u = l._Trigger(e, s, n);
                i = i || u;
              }
              const a = o._Trigger(e, s, n);
              i = i || a, this._runtime.PopCurrentLayout();
            }
          }
          return this._executingTriggerDepth--, i;
        }
        *_DebugTrigger(t, e, s, n) {
          let i = false;
          if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
          this._executingTriggerDepth++;
          for (const r of t.runningLayouts()) {
            const o = r.GetEventSheet();
            if (o) {
              this._runtime.PushCurrentLayout(r);
              for (const l of o.deepIncludes()) {
                const u = yield* l._DebugTrigger(e, s, n);
                i = i || u;
              }
              const a = yield* o._DebugTrigger(e, s, n);
              i = i || a, this._runtime.PopCurrentLayout();
            }
          }
          return this._executingTriggerDepth--, i;
        }
        QueueTrigger(t, e, s) {
          return this._queuedTriggers.push([t, e, s]), false;
        }
        QueueDebugTrigger(t, e, s) {
          let n = null;
          const i = new Promise((t2) => n = t2);
          return this._queuedDebugTriggers.push([t, e, s, n]), i;
        }
        *_RunQueuedDebugTriggersGen() {
          if (this._runtime.HitBreakpoint()) throw new Error("should not be in breakpoint");
          const t = this._runtime.GetLayoutManager();
          for (; this._queuedDebugTriggers.length; ) {
            const [e, s, n, i] = this._queuedDebugTriggers.shift(), r = yield* this._DebugTrigger(t, e, s, n);
            i(r);
          }
        }
        async RunQueuedDebugTriggersAsync() {
          for (const t of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t);
        }
        _FastTrigger(t, s, n, i) {
          let r = false;
          const e = t.GetMainRunningLayout(), o = e.GetEventSheet();
          if (o) {
            this._executingTriggerDepth++, this._runtime.PushCurrentLayout(e);
            const a = o.deepIncludes();
            for (let t2 = 0, e2 = a.length; t2 < e2; ++t2) {
              const u = a[t2]._FastTrigger(s, n, i);
              r = r || u;
            }
            const l = o._FastTrigger(s, n, i);
            return r = r || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, r;
          }
        }
        *_DebugFastTrigger(t, s, n, i) {
          let r = false;
          const e = t.GetMainRunningLayout(), o = e.GetEventSheet();
          if (o) {
            this._executingTriggerDepth++, this._runtime.PushCurrentLayout(e);
            const a = o.deepIncludes();
            for (let t2 = 0, e2 = a.length; t2 < e2; ++t2) {
              const u = yield* a[t2]._DebugFastTrigger(s, n, i);
              r = r || u;
            }
            const l = yield* o._DebugFastTrigger(s, n, i);
            return r = r || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, r;
          }
        }
        GetTriggerDepth() {
          return this._executingTriggerDepth;
        }
        IsInTrigger() {
          return 0 < this.GetTriggerDepth();
        }
        _IncTriggerDepth() {
          return ++this._executingTriggerDepth;
        }
        _DecTriggerDepth() {
          --this._executingTriggerDepth;
        }
        IsRunningEvents() {
          return 0 < this._runningEventsDepth;
        }
        IsInEventEngine() {
          return this.IsRunningEvents() || this.IsInTrigger();
        }
        _RunQueuedTriggers(t) {
          for (const [e, s, n] of this._queuedTriggers) this._Trigger(t, e, s, n);
          C33.clearArray(this._queuedTriggers);
        }
        BlockFlushingInstances(t) {
          t ? this._blockFlushingDepth++ : this._blockFlushingDepth--;
        }
        IsFlushingBlocked() {
          return 0 < this._blockFlushingDepth;
        }
        ClearSol(s) {
          for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().Clear();
        }
        PushCleanSol(s) {
          for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().PushClean();
        }
        PushCopySol(s) {
          for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().PushCopy();
        }
        PopSol(s) {
          for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().Pop();
        }
        GetDynamicSolModifiersSet(e) {
          const s = /* @__PURE__ */ new Set(), n = this._eventStack.GetAllStackFrames(), i = this._eventStack.GetCurrentStackFrameIndex();
          for (let t = 0; t <= i; ++t) {
            const r = n[t].GetDynamicSolModifiers();
            if (r) for (const o of r) e && e.has(o) || s.add(o);
          }
          return s;
        }
        PushCleanSolDynamic(t) {
          const e = /* @__PURE__ */ new Set([...t]), s = this.GetDynamicSolModifiersSet(e);
          if (0 < s.size) {
            for (const n of s) n.GetSolStack().PushClean();
            return [...s];
          }
          return null;
        }
        AddScheduledWait() {
          const t = C33.New(C33.ScheduledWait, this);
          return this._scheduledWaits.push(t), t;
        }
        scheduledWaits() {
          return this._scheduledWaits;
        }
        RunScheduledWaits() {
          if (this._scheduledWaits.length) {
            const n = this.GetCurrentEventStackFrame();
            let s = false;
            this._runningEventsDepth++;
            for (let t = 0, e = this._scheduledWaits.length; t < e; ++t) {
              const i = this._scheduledWaits[t];
              i._ShouldRun() && i._Run(n), i.ShouldRelease() && (s = true);
            }
            s && (this._FilterScheduledWaitsToRelease(), n.Reset(null)), this._runningEventsDepth--;
          }
        }
        async DebugRunScheduledWaits() {
          if (this._scheduledWaits.length) {
            const n = this.GetCurrentEventStackFrame();
            let s = false;
            this._runningEventsDepth++;
            for (let t = 0, e = this._scheduledWaits.length; t < e; ++t) {
              const i = this._scheduledWaits[t];
              i._ShouldRun() && await i._DebugRun(n), i.ShouldRelease() && (s = true);
            }
            s && (this._FilterScheduledWaitsToRelease(), n.Reset(null)), this._runningEventsDepth--;
          }
        }
        _FilterScheduledWaitsToRelease() {
          const t = C33.arrayFilterOut(this._scheduledWaits, (t2) => t2.ShouldRelease());
          for (const e of t) e.Release();
        }
        ClearAllScheduledWaits() {
          for (const t of this._scheduledWaits) t.Release();
          C33.clearArray(this._scheduledWaits);
        }
        _OnInstancesReleased(t) {
          for (const e of this._scheduledWaits) e.RemoveInstances(t);
          for (const s of t) {
            const n = this._instSignals.get(s);
            if (this._instSignals.delete(s), n) for (const { resolve: i } of n.signalPromises.values()) i(true);
          }
        }
        AddAsyncActionPromise(t) {
          this._asyncActionPromises.push({ promise: t, triggerDepth: this.GetTriggerDepth() });
        }
        ClearAsyncActionPromises() {
          C33.clearArray(this._asyncActionPromises);
        }
        ClearNestedAsyncActionPromises() {
          const e = this.GetTriggerDepth();
          this._asyncActionPromises = this._asyncActionPromises.filter((t) => t.triggerDepth <= e);
        }
        GetPromiseForAllAsyncActions() {
          const t = Promise.all(this._asyncActionPromises.map((t2) => t2.promise));
          return this._asyncActionPromises = [], t;
        }
        Signal(t) {
          const e = t.toLowerCase();
          this._signalTags.push(e), this._runtime.Trigger(C33.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();
          for (const n of this._runtime.GetEventSheetManager().scheduledWaits()) n.IsSignal() && n.GetSignalTag() === e && n.SetSignalled();
          const s = this._signalPromises.get(e);
          s && (s.resolve(), this._signalPromises.delete(e));
        }
        WaitForSignal(t) {
          const s = t.toLowerCase(), e = this._signalPromises.get(s);
          if (e) return e.promise;
          {
            let e2 = null;
            const n = new Promise((t2) => e2 = t2);
            return this._signalPromises.set(s, { promise: n, resolve: e2 }), n;
          }
        }
        GetCurrentSignalTag() {
          if (0 === this._signalTags.length) throw new Error("not in a signal");
          return this._signalTags.at(-1);
        }
        _GetInstanceSignalState(t) {
          let e = this._instSignals.get(t);
          return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t, e)), e;
        }
        InstanceSignal(t, e) {
          const s = this._GetInstanceSignalState(t), n = e.toLowerCase();
          s.signalTags.push(n), this._runtime.Trigger(t.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t), s.signalTags.pop();
          for (const r of this._runtime.GetEventSheetManager().scheduledWaits()) r.IsInstanceSignals() && r.GetSignalTag() === n && r.SetInstanceSignalled(t);
          const i = s.signalPromises.get(n);
          i && (i.resolve(false), s.signalPromises.delete(n)), 0 === s.signalTags.length && 0 === s.signalPromises.size && this._instSignals.delete(t);
        }
        WaitForInstanceSignal(t, e) {
          const s = this._GetInstanceSignalState(t), n = e.toLowerCase(), i = s.signalPromises.get(n);
          if (i) return i.promise;
          {
            let e2 = null;
            const r = new Promise((t2) => e2 = t2);
            return s.signalPromises.set(n, { promise: r, resolve: e2 }), r;
          }
        }
        GetCurrentInstanceSignalTag(t) {
          const e = this._GetInstanceSignalState(t);
          if (e && 0 !== e.signalTags.length) return e.signalTags.at(-1);
          throw new Error("not in a signal");
        }
        _SaveToJson() {
          return { "groups": this._SaveGroupsToJson(), "cnds": this._SaveCndsToJson(), "acts": this._SaveActsToJson(), "vars": this._SaveVarsToJson(), "waits": this._SaveScheduledWaitsToJson() };
        }
        _LoadFromJson(t) {
          this._LoadGroupsFromJson(t["groups"]), this._LoadCndsFromJson(t["cnds"]), this._LoadActsFromJson(t["acts"]), this._LoadVarsFromJson(t["vars"]), this._LoadScheduledWaitsFromJson(t["waits"]);
        }
        _SaveGroupsToJson() {
          const t = {};
          for (const e of this.GetAllGroups()) t[e.GetSID().toString()] = e.IsGroupActive();
          return t;
        }
        _LoadGroupsFromJson(t) {
          for (const [e, s] of Object.entries(t)) {
            const n = parseInt(e, 10), i = this.GetEventGroupBySID(n);
            i && i.SetGroupActive(s);
          }
        }
        _SaveCndsToJson() {
          const t = {};
          for (const [e, s] of this._cndsBySid) {
            const n = s._SaveToJson();
            n && (t[e.toString()] = n);
          }
          return t;
        }
        _LoadCndsFromJson(t) {
          const e = /* @__PURE__ */ new Map();
          for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);
          for (const [i, r] of this._cndsBySid) r._LoadFromJson(e.get(i) || null);
        }
        _SaveActsToJson() {
          const t = {};
          for (const [e, s] of this._actsBySid) {
            const n = s._SaveToJson();
            n && (t[e.toString()] = n);
          }
          return t;
        }
        _LoadActsFromJson(t) {
          const e = /* @__PURE__ */ new Map();
          for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);
          for (const [i, r] of this._actsBySid) r._LoadFromJson(e.get(i) || null);
        }
        _SaveVarsToJson() {
          const t = {};
          for (const [e, s] of this._eventVarsBySid) s.IsConstant() || !s.IsGlobal() && !s.IsStatic() || (t[e.toString()] = s.GetValue());
          return t;
        }
        _LoadVarsFromJson(t) {
          for (const [e, s] of Object.entries(t)) {
            const n = parseInt(e, 10), i = this.GetEventVariableBySID(n);
            i && i.SetValue(s);
          }
        }
        _SaveScheduledWaitsToJson() {
          return this._scheduledWaits.filter((t) => !t.IsPromise()).map((t) => t._SaveToJson());
        }
        _LoadScheduledWaitsFromJson(t) {
          this.ClearAllScheduledWaits();
          for (const e of t) {
            const s = C33.ScheduledWait._CreateFromJson(this, e);
            s && this._scheduledWaits.push(s);
          }
        }
        _GetPerfRecords() {
          return [...this._runtime.GetLayoutManager().runningLayouts()].map((t) => t.GetEventSheet()).filter((t) => t).map((t) => t._GetPerfRecord());
        }
        FindFirstFunctionBlockParent(t) {
          for (; t; ) {
            const e = t.GetScopeParent();
            if (e instanceof C33.FunctionBlock) return e;
            t = e;
          }
          return null;
        }
        _InvokeFunctionFromJS(t, e) {
          Array.isArray(e) || (e = []);
          const s = this.GetFunctionBlockByName(t.toLowerCase());
          if (!s) return null;
          if (!s.IsEnabled()) return s.GetDefaultReturnValue();
          const n = s.GetFunctionParameters();
          if (e.length < n.length) for (e = e.slice(0); e.push(n[e.length].GetInitialValue()), e.length < n.length; ) ;
          const i = s.GetEventBlock();
          return i.RunAsExpressionFunctionCall(i.GetSolModifiersIncludingParents(), false, s.GetReturnType(), s.GetDefaultReturnValue(), ...e);
        }
      };
    }
    var SortSolArray;
    var IsSolArrayIdentical;
    {
      const C33 = self.C3;
      C33.EventSheet = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();
          for (const s of t[1]) this._CreateEvent(s, null, this._events);
          this._perfRecord = this._runtime.IsDebug() ? { type: "sheet", name: this._name, totalTimeCounter: 0, children: [] } : null;
        }
        Release() {
          this._eventSheetManager = null, this._runtime = null;
        }
        _CreateEvent(e, t, s) {
          switch (e[0]) {
            case 0:
            case 3:
              this._CreateEventBlock(e, t, s);
              break;
            case 1:
              this._CreateEventVariable(e, t, s);
              break;
            case 2:
              this._CreateInclude(e, t, s);
              break;
            case 4:
              this._CreateFunctionBlock(e, t);
              break;
            case 5:
              this._CreateScriptBlock(e, t, s);
              break;
            case 6:
              this._CreateCustomACEBlock(e, t);
              break;
            default:
              throw new Error("invalid event type");
          }
        }
        _CreateEventBlock(e, t, s) {
          const n = C33.EventBlock.Create(this, t, e);
          if (n.IsOrBlock()) {
            s.push(n);
            const r = n.GetConditions();
            for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) r[e2].IsTrigger() && this._InitTrigger(n, e2);
          } else n.IsTrigger() ? this._InitTrigger(n, 0) : s.push(n);
        }
        _CreateFunctionBlock(e, t) {
          const s = C33.FunctionBlock.CreateFunctionBlock(this, t, e);
          this._eventSheetManager._RegisterFunctionBlock(s);
        }
        _CreateCustomACEBlock(e, t) {
          const s = C33.FunctionBlock.CreateCustomACEBlock(this, t, e);
          this._eventSheetManager._RegisterFunctionBlock(s);
        }
        _CreateEventVariable(e, t, s) {
          const n = C33.EventVariable.Create(this, t, e);
          s.push(n);
        }
        _CreateInclude(e, t, s) {
          const n = C33.EventInclude.Create(this, t, e);
          s.push(n);
        }
        _CreateScriptBlock(e, t, s) {
          const n = C33.EventScript.Create(this, t, e);
          s.push(n);
        }
        _InitTrigger(n, r) {
          n.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(n);
          const i = n.GetConditionAt(r), l = i._GetFunc(), o = i.GetObjectClass();
          if (i.IsFastTrigger()) {
            let e = this._fastTriggers.get(o);
            e || (e = /* @__PURE__ */ new Map(), this._fastTriggers.set(o, e));
            const a = i.GetFastTriggerValue().toLowerCase();
            let t = e.get(l), s = (t || (t = /* @__PURE__ */ new Map(), e.set(l, t)), t.get(a));
            s || (s = [], t.set(a, s)), s.push([n, r]);
          } else {
            let e = this._triggers.get(o);
            e || (e = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(o, e));
            const c = i.GetBehaviorType();
            let t, s = (c ? (t = e.behaviors.get(c)) || (t = /* @__PURE__ */ new Map(), e.behaviors.set(c, t)) : t = e.methodMap, t.get(l));
            s || (s = [], t.set(l, s)), s.push([n, r]);
          }
        }
        _PostInit() {
          const s = this._events;
          for (let e = 0, t = s.length; e < t; ++e) {
            const n = e < t - 1 && s[e + 1] instanceof C33.EventBlock && s[e + 1].IsElseBlock();
            s[e]._PostInit(n);
          }
        }
        _AddShallowInclude(e) {
          this._shallowIncludes.push(e);
        }
        _UpdateDeepIncludes() {
          C33.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();
        }
        _AddDeepIncludes(e) {
          const t = e._deepIncludes, s = e._alreadyIncludedSheets;
          for (const n of this._shallowIncludes) {
            const r = n.GetIncludeSheet();
            n.IsActive() && e !== r && !s.has(r) && (s.add(r), r._AddDeepIncludes(e), t.push(r));
          }
        }
        deepIncludes() {
          return this._deepIncludes;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetName() {
          return this._name;
        }
        _RegisterEventByDisplayNumber(e, t) {
          this._eventsByDisplayNumber.set(t, e);
        }
        _GetEventByDisplayNumber(e) {
          return this._eventsByDisplayNumber.get(e) || null;
        }
        _ResetHasRunFlag() {
          this._hasRun = false;
        }
        Run() {
          if (!this._hasRun) {
            const e = this._runtime, t = e.IsCPUProfiling(), s = t ? performance.now() : 0, n = (this._hasRun = true, this.GetEventSheetManager()), r = n.GetCurrentEventStackFrame();
            for (const i of this._events) i.Run(r), n.ClearSol(i.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();
            r.Reset(null), t && (this._perfRecord.totalTimeCounter += performance.now() - s);
          }
        }
        *DebugRun() {
          if (!this._hasRun) {
            this._hasRun = true;
            const e = this._runtime, t = this.GetEventSheetManager(), s = t.GetCurrentEventStackFrame();
            for (const n of this._events) yield* n.DebugRun(s), t.ClearSol(n.GetSolModifiers()), t.ClearAsyncActionPromises(), e.FlushPendingInstances();
            s.Reset(null);
          }
        }
        _Trigger(s, n, r) {
          if (!n) return this._TriggerForClass(s, n, null, null);
          {
            const i = n.GetObjectClass();
            let e = false, t = this._TriggerForClass(s, n, i, r);
            e = e || t;
            for (const l of i.GetFamilies()) t = this._TriggerForClass(s, n, l, r), e = e || t;
          }
        }
        _TriggerForClass(e, t, s, n) {
          const r = this._triggers.get(s);
          if (!r) return false;
          const i = n ? r.behaviors.get(n) : r.methodMap;
          if (!i) return false;
          const l = i.get(e);
          if (!l) return false;
          let o = false;
          for (const [a, c] of l) {
            const u = this._ExecuteTrigger(t, a, c);
            o = o || u;
          }
          return o;
        }
        *_DebugTrigger(s, n, r) {
          if (!n) return yield* this._DebugTriggerForClass(s, n, null, null);
          {
            const i = n.GetObjectClass();
            let e = false, t = yield* this._DebugTriggerForClass(s, n, i, r);
            e = e || t;
            for (const l of i.GetFamilies()) t = yield* this._DebugTriggerForClass(s, n, l, r), e = e || t;
          }
        }
        *_DebugTriggerForClass(e, t, s, n) {
          const r = this._triggers.get(s);
          if (!r) return false;
          const i = n ? r.behaviors.get(n) : r.methodMap;
          if (!i) return false;
          const l = i.get(e);
          if (!l) return false;
          let o = false;
          for (const [a, c] of l) {
            let e2;
            e2 = a.DebugCanRunFast() ? this._ExecuteTrigger(t, a, c) : yield* this._DebugExecuteTrigger(t, a, c), o = o || e2;
          }
          return o;
        }
        _FastTrigger(e, t, s) {
          const n = t.GetObjectClass(), r = this._fastTriggers.get(n);
          if (!r) return false;
          const i = r.get(e);
          if (!i) return false;
          const l = i.get(s);
          if (!l) return false;
          let o = false;
          for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {
            const a = l[e2], c = this._ExecuteTrigger(null, a[0], a[1]);
            o = o || c;
          }
          return o;
        }
        *_DebugFastTrigger(e, t, s) {
          const n = t.GetObjectClass(), r = this._fastTriggers.get(n);
          if (!r) return false;
          const i = r.get(e);
          if (!i) return false;
          const l = i.get(s);
          if (!l) return false;
          let o = false;
          for (let t2 = 0, e2 = l.length; t2 < e2; ++t2) {
            const a = l[t2], c = a[0], u = a[1];
            let e3;
            e3 = c.DebugCanRunFast() ? this._ExecuteTrigger(null, c, u) : yield* this._DebugExecuteTrigger(null, c, u), o = o || e3;
          }
          return o;
        }
        _ExecuteTrigger(e, t, s) {
          const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();
          let a = false;
          i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());
          const c = 1 < o, u = (c && r.GetLocalVarStack().Push(), l.Push(t));
          if (e) {
            const h = t.GetConditions()[s].GetObjectClass(), _ = h.GetCurrentSol();
            _.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
          }
          let g = true;
          if (t.GetParent()) {
            const d = t.GetTriggerParents();
            for (let e2 = 0, t2 = d.length; e2 < t2; ++e2) if (!d[e2].RunPreTrigger(u)) {
              g = false;
              break;
            }
          }
          return g && (t.IsOrBlock() ? t.RunOrBlockTrigger(u, s) : t.Run(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked()) || n.FlushPendingInstances(), a;
        }
        *_DebugExecuteTrigger(e, t, s) {
          const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();
          let a = false;
          i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());
          const c = 1 < o, u = (c && r.GetLocalVarStack().Push(), l.Push(t));
          if (e) {
            const h = t.GetConditions()[s].GetObjectClass(), _ = h.GetCurrentSol();
            _.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
          }
          let g = true;
          if (t.GetParent()) {
            const d = t.GetTriggerParents();
            for (let e2 = 0, t2 = d.length; e2 < t2; ++e2) if (!(yield* d[e2].DebugRunPreTrigger(u))) {
              g = false;
              break;
            }
          }
          return g && (t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(u, s) : yield* t.DebugRun(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked()) || n.FlushPendingInstances(), a;
        }
        _GetPerfRecord() {
          return this._perfRecord;
        }
      };
    }
    {
      let NoActions2 = function(t, e) {
        return true;
      };
      NoActions = NoActions2;
      const C33 = self.C3, EMPTY_ARRAY = [];
      function* DebugNoActions(t, e) {
        return true;
      }
      C33.EventBlock = class extends C33.DefendedBase {
        constructor(t, e, n) {
          super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions2, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = "", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);
          let s = 0;
          for (const i of n[6]) {
            const o = C33.Condition.Create(this, i, s++);
            this._conditions.push(o), this._AddSolModifier(o.GetObjectClass());
          }
          s = 0;
          for (const r of n[7]) {
            const u = C33.Action.Create(this, r, s++);
            this._actions.push(u);
          }
          if (9 === n.length) {
            const l = n[8];
            for (const a of l) this._eventSheet._CreateEvent(a, this, this._subEvents);
          }
          this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C33.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);
        }
        static Create(t, e, n) {
          return C33.New(C33.EventBlock, t, e, n);
        }
        _InitGroup(t) {
          this._isGroup = true, this._isInitiallyActive = !!t[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: "group", name: t[1], totalTimeCounter: 0, children: [] });
        }
        _AddContainedInclude(t) {
          this._containedIncludes.push(t);
        }
        _AddContainerSolModifierToList(t, e) {
          for (const n of t.GetContainer().objectTypes()) e.includes(n) || e.push(n);
        }
        _AddSolModifierToList(t, e) {
          if (t) if (e.includes(t) || e.push(t), t.IsFamily()) for (const n of t.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);
          else t.IsInContainer() && this._AddContainerSolModifierToList(t, e);
        }
        _AddSolModifier(t) {
          this._AddSolModifierToList(t, this._solModifiers);
        }
        _AddParentSolModifier(t) {
          this._AddSolModifierToList(t, this._solModifiersIncludingParents);
        }
        SetAllSolModifiers() {
          this._solModifiers = this._runtime.GetAllObjectClasses();
        }
        _PostInit(t) {
          this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();
          for (const e of this._conditions) e._PostInit();
          if (0 < this._actions.length) {
            let t2 = false;
            for (const s of this._actions) s._PostInit(), s.HasReturnType() && (t2 = true);
            t2 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);
          }
          const n = this._subEvents;
          for (let t2 = 0, e = n.length; t2 < e; ++t2) {
            const i = t2 < e - 1 && n[t2 + 1] instanceof C33.EventBlock && n[t2 + 1].IsElseBlock();
            n[t2]._PostInit(i);
          }
          this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);
        }
        _GetPerfRecord() {
          return this._perfRecord;
        }
        _GetPerfRecordParent() {
          let t = this.GetParent();
          for (; t; ) {
            if (t.IsGroup()) return t;
            t = t.GetParent();
          }
          return this._eventSheet;
        }
        _UpdateCanRunFast() {
          const t = this._debugData;
          t.canRunAllConditionsFast = this._conditions.every((t2) => t2.DebugCanRunFast()), t.canRunAllActionsFast = this._actions.every((t2) => t2.DebugCanRunFast()), t.canRunAllSubEventsFast = this._subEvents.every((t2) => t2.DebugCanRunFast()), t.canRunSelfFast = t.canRunAllConditionsFast && t.canRunAllActionsFast && t.canRunAllSubEventsFast;
        }
        _UpdateCanRunFastRecursive() {
          let t = this;
          for (; t._UpdateCanRunFast(), t = t.GetParent(); ) ;
        }
        _IdentifyTopLevelGroup() {
          if (this.IsGroup()) {
            let t = this.GetParent();
            for (this._isTopLevelGroup = true; t; ) {
              if (!t.IsGroup()) {
                this._isTopLevelGroup = false;
                break;
              }
              t = t.GetParent();
            }
          }
        }
        _IdentifySolModifiersIncludingParents() {
          const t = this._runtime.GetAllObjectClasses();
          if (this._solModifiers === t) this._solModifiersIncludingParents = t;
          else {
            this._solModifiersIncludingParents = C33.cloneArray(this._solModifiers);
            let t2 = this.GetParent();
            for (; t2; ) {
              for (const n of t2._solModifiers) this._AddParentSolModifier(n);
              t2 = t2.GetParent();
            }
            const e = this.GetEventSheetManager();
            this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);
          }
        }
        _IdentifyTriggerParents() {
          if (this.HasAnyTriggeredCondition()) {
            this._triggerParents = [];
            let t = this.GetParent();
            for (; t; ) this._triggerParents.push(t), t = t.GetParent();
            this._triggerParents.reverse();
          }
        }
        SetSolWriterAfterCnds() {
          this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();
        }
        IsSolWriterAfterCnds() {
          return this._isSolWriterAfterCnds;
        }
        GetSolModifiers() {
          return this._solModifiers;
        }
        GetSolModifiersIncludingParents() {
          return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;
        }
        HasSolModifier(t) {
          return this._solModifiers.includes(t);
        }
        GetTriggerParents() {
          return this._triggerParents;
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        GetEventSheetManager() {
          return this._eventSheet.GetEventSheetManager();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetParent() {
          return this._parent;
        }
        _SetScopeParent(t) {
          this._scopeParent = t;
        }
        GetScopeParent() {
          return this._scopeParent || this._parent;
        }
        GetDisplayNumber() {
          return this._displayNumber;
        }
        IsDebugBreakable() {
          return this._debugData && this._debugData.isBreakable;
        }
        IsDebugBreakpoint() {
          return this.IsDebugBreakable() && this._debugData.isBreakpoint;
        }
        _SetDebugBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._UpdateCanRunFastRecursive();
        }
        IsGroup() {
          return this._isGroup;
        }
        IsTopLevelGroup() {
          return this._isTopLevelGroup;
        }
        IsElseBlock() {
          return this._isElseBlock;
        }
        HasElseBlock() {
          return this._hasElseBlock;
        }
        GetGroupName() {
          return this._groupName;
        }
        IsGroupActive() {
          return this._isGroupActive;
        }
        ResetInitialActivation() {
          this.SetGroupActive(this._isInitiallyActive);
        }
        SetGroupActive(t) {
          if (t = !!t, !this._isGroup) throw new Error("not a group");
          if (this._isGroupActive !== t) {
            this._isGroupActive = t;
            for (const e of this._containedIncludes) e.UpdateActive();
            if (this._containedIncludes.length) {
              const n = this._runtime.GetCurrentLayout(), s = n.GetEventSheet();
              s && s._UpdateDeepIncludes();
            }
          }
        }
        GetSID() {
          return this._sid;
        }
        IsOrBlock() {
          return this._isOrBlock;
        }
        IsTrigger() {
          return this._conditions.length && this._conditions[0].IsTrigger();
        }
        IsForFunctionBlock() {
          return this._scopeParent && this._scopeParent instanceof C33.FunctionBlock;
        }
        HasAnyTriggeredCondition() {
          return this.IsForFunctionBlock() || this._conditions.some((t) => t.IsTrigger());
        }
        GetConditions() {
          return this._conditions;
        }
        GetConditionCount() {
          return this._conditions.length;
        }
        GetConditionAt(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._conditions.length) throw new RangeError("invalid condition index");
          return this._conditions[t];
        }
        GetConditionByDebugIndex(t) {
          return this.GetConditionAt(t);
        }
        IsFirstConditionOfType(t) {
          let e = t.GetIndex();
          if (0 !== e) {
            --e;
            const n = t.IsSystemOrSingleGlobalCondition() ? t.GetFirstObjectParameterObjectClass() : t.GetObjectClass();
            for (; 0 <= e; --e) {
              const s = this._conditions[e];
              if (n === s.GetObjectClass() || s.IsSystemOrSingleGlobalCondition() && s.GetFirstObjectParameterObjectClass() === n) return false;
            }
          }
          return true;
        }
        GetActions() {
          return this._actions;
        }
        GetActionCount() {
          return this._actions.length;
        }
        GetActionAt(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._actions.length) throw new RangeError("invalid action index");
          return this._actions[t];
        }
        GetActionByDebugIndex(e) {
          e = Math.floor(e);
          const t = this._actions.find((t2) => t2.GetDebugIndex() === e);
          if (t) return t;
          throw new RangeError("invalid action debug index");
        }
        _HasActionIndex(t) {
          return 0 <= (t = Math.floor(t)) && t < this._actions.length;
        }
        GetSubEvents() {
          return this._subEvents;
        }
        _GetAllLocalVariablesInScope() {
          return this._subEvents.filter((t) => t instanceof C33.EventVariable);
        }
        RunPreTrigger(n) {
          n.SetCurrentEvent(this);
          const s = this._conditions;
          let i = 0 === s.length;
          for (let t = 0, e = s.length; t < e; ++t) {
            const o = s[t];
            if (n.SetConditionIndex(t), o.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
            if (o.Run()) i = true;
            else if (!this._isOrBlock) return false;
          }
          return !this._isOrBlock || i;
        }
        RunOrBlockTrigger(t, e) {
          t.SetCurrentEvent(this), t.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t, 0) && this._RunSubEvents(t), t.SetLastEventTrue(true));
        }
        *DebugRunPreTrigger(n) {
          n.SetCurrentEvent(this);
          const s = this._conditions;
          let i = 0 === s.length;
          for (let e = 0, t = s.length; e < t; ++e) {
            const o = s[e];
            if (n.SetConditionIndex(e), o.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
            let t2;
            if (t2 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun()) i = true;
            else if (!this._isOrBlock) return false;
          }
          return !this._isOrBlock || i;
        }
        *DebugRunOrBlockTrigger(e, t) {
          e.SetCurrentEvent(this), e.SetConditionIndex(t);
          const n = this._conditions[t];
          let s;
          if (s = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun()) {
            let t2;
            (t2 = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), e.SetLastEventTrue(true);
          }
        }
        Run(t) {
          t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t) : this._RunAndBlock(t);
        }
        *DebugRun(t) {
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t) : yield* this._DebugRunAndBlock(t);
        }
        _RunOrBlock(n) {
          const s = this._conditions;
          let i = 0 === s.length;
          for (let t = 0, e = s.length; t < e; ++t) {
            const o = s[t];
            if (!o.IsTrigger()) {
              n.SetConditionIndex(t);
              const r = o.Run();
              i = i || r;
            }
          }
          n.SetLastEventTrue(i), i && (this._RunActions(n, 0) && this._RunSubEvents(n), this._hasElseBlock) && n.SetElseBranchRan(true);
        }
        *_DebugRunOrBlock(n) {
          const s = this._conditions;
          let i = 0 === s.length;
          for (let e = 0, t = s.length; e < t; ++e) {
            const o = s[e];
            if (!o.IsTrigger()) {
              n.SetConditionIndex(e);
              let t2;
              t2 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun(), i = i || t2;
            }
          }
          if (n.SetLastEventTrue(i), i) {
            let t;
            (t = this.DebugCanRunActionsFast() ? this._RunActions(n, 0) : yield* this._DebugRunActions(n, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && n.SetElseBranchRan(true);
          }
        }
        _RunAndBlock(n) {
          const s = this._conditions;
          for (let t = 0, e = s.length; t < e; ++t) {
            const i = s[t], o = (n.SetConditionIndex(t), i.Run());
            if (!o) return void n.SetLastEventTrue(false);
          }
          n.SetLastEventTrue(true), this._RunActions(n, 0) && this._RunSubEvents(n), n.GetLastEventTrue() && this._hasElseBlock && n.SetElseBranchRan(true);
        }
        *_DebugRunAndBlock(n) {
          const s = this._conditions;
          for (let e = 0, t2 = s.length; e < t2; ++e) {
            const i = s[e];
            n.SetConditionIndex(e);
            let t3;
            if (!(t3 = i.DebugCanRunFast() ? i.Run() : yield* i.DebugRun())) return void n.SetLastEventTrue(false);
          }
          n.SetLastEventTrue(true);
          let t;
          (t = this.DebugCanRunActionsFast() ? this._RunActions(n, 0) : yield* this._DebugRunActions(n, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), n.GetLastEventTrue() && this._hasElseBlock && n.SetElseBranchRan(true);
        }
        _RunActions_Fast(n, s) {
          const i = this._actions;
          for (let t = s, e = i.length; t < e; ++t) {
            const o = i[t];
            n.SetActionIndex(t), o.Run();
          }
          return true;
        }
        *_DebugRunActions_Fast(n, s) {
          const i = this._actions;
          for (let t = s, e = i.length; t < e; ++t) {
            const o = i[t];
            n.SetActionIndex(t), o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun();
          }
          return true;
        }
        _RunActions_ReturnValue(n, s) {
          const i = this.GetEventSheetManager(), o = this._actions;
          for (let t = s, e = o.length; t < e; ++t) {
            const r = o[t], u = (n.SetActionIndex(t), r.Run());
            if (r.CanBailOut() && true === u) return false;
            r.IsAsync() && u instanceof Promise && i.AddAsyncActionPromise(u);
          }
          return true;
        }
        *_DebugRunActions_ReturnValue(n, s) {
          const i = this.GetEventSheetManager(), o = this._actions;
          for (let e = s, t = o.length; e < t; ++e) {
            const r = o[e];
            n.SetActionIndex(e);
            let t2;
            if (t2 = r.DebugCanRunFast() ? r.Run() : yield* r.DebugRun(), r.CanBailOut() && true === t2) return false;
            r.IsAsync() && t2 instanceof Promise && i.AddAsyncActionPromise(t2);
          }
          return true;
        }
        _ResumeActionsAndSubEvents(t) {
          this._RunActions(t, t.GetActionIndex()) && this._RunSubEvents();
        }
        *_DebugResumeActionsAndSubEvents(t) {
          (yield* this._DebugRunActions(t, t.GetActionIndex())) && (yield* this._DebugRunSubEvents());
        }
        _RunSubEvents() {
          if (this._subEvents.length) {
            const t = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t ? performance.now() : 0, n = this._eventStack, s = n.Push(this);
            this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s) : this._RunSubEvents_Fast(s), n.Pop(), t && (this._perfRecord.totalTimeCounter += performance.now() - e);
          }
        }
        _RunSubEvents_SolWriterAfterCnds(s) {
          const i = this._isGroup, o = this._isTopLevelGroup, r = this.GetEventSheetManager(), u = this._subEvents;
          for (let t = 0, e = u.length, n = e - 1; t < e; ++t) {
            const l = u[t], a = l.GetSolModifiers(), h = !o || !i && t < n;
            h && r.PushCopySol(a), l.Run(s), h ? r.PopSol(a) : r.ClearSol(a);
          }
        }
        _RunSubEvents_Fast(n) {
          const s = this._subEvents;
          for (let t = 0, e = s.length; t < e; ++t) s[t].Run(n);
        }
        *_DebugRunSubEvents() {
          if (this._subEvents.length) {
            const t = this._eventStack, e = t.Push(this);
            this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t.Pop();
          }
        }
        *_DebugRunSubEvents_SolWriterAfterCnds(s) {
          const i = this._isGroup, o = this._isTopLevelGroup, r = this.GetEventSheetManager(), u = this._subEvents;
          for (let t = 0, e = u.length, n = e - 1; t < e; ++t) {
            const l = u[t], a = l.GetSolModifiers(), h = !o || !i && t < n;
            h && r.PushCopySol(a), yield* l.DebugRun(s), h ? r.PopSol(a) : r.ClearSol(a);
          }
        }
        *_DebugRunSubEvents_Fast(n) {
          const s = this._subEvents;
          for (let t = 0, e = s.length; t < e; ++t) yield* s[t].DebugRun(n);
        }
        Retrigger(n, s) {
          s.ResetQuick();
          const i = this._conditions;
          if (!this.IsOrBlock()) for (let t = n.GetConditionIndex() + 1, e = i.length; t < e; ++t) {
            const o = i[t], r = (s.SetConditionIndex(t), o.Run());
            if (!r) return false;
          }
          return this._RunActions(s, 0) && this._RunSubEvents(s), true;
        }
        *DebugRetrigger(n, s) {
          s.ResetQuick();
          const i = this._conditions;
          if (!this.IsOrBlock()) for (let e = n.GetConditionIndex() + 1, t2 = i.length; e < t2; ++e) {
            const o = i[e];
            s.SetConditionIndex(e);
            let t3;
            if (!(t3 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun())) return false;
          }
          let t;
          return (t = this.DebugCanRunActionsFast() ? this._RunActions(s, 0) : yield* this._DebugRunActions(s, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;
        }
        DebugCanRunFast() {
          return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;
        }
        DebugCanRunActionsFast() {
          return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;
        }
        DebugCanRunSubEventsFast() {
          return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;
        }
        _CheckParentsOKToRun(n) {
          if (this.GetParent()) {
            const s = this.GetTriggerParents();
            for (let t = 0, e = s.length; t < e; ++t) if (!s[t].RunPreTrigger(n)) return false;
          }
          return true;
        }
        *_DebugCheckParentsOKToRun(n) {
          if (this.GetParent()) {
            const s = this.GetTriggerParents();
            for (let t = 0, e = s.length; t < e; ++t) if (!(yield* s[t].DebugRunPreTrigger(n))) return false;
          }
          return true;
        }
        _EvaluateFunctionCallParameters(t, e, n) {
          if (0 < e.length) if (n) {
            const s = e.map((t2) => t2.Get(0));
            t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(s);
          } else this._scopeParent.EvaluateFunctionParameters(e);
          else n && t.GetLocalVarStack().Push();
        }
        RunAsFunctionCall(t, e, n, s) {
          let i, o;
          const r = 0 < t.length;
          let u = null;
          const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d;
          if (this._EvaluateFunctionCallParameters(h, e, g), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {
            if (s.copyFromObjectClass) {
              const b = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), R = s.copyToObjectClass.GetCurrentSol();
              R.SetArrayPicked(b.GetInstances()), R.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();
            } else if (s.pickObjectClass) {
              const C = s.pickObjectClass.GetCurrentSol();
              C.SetArrayPicked(s.pickInstances), C.ClearElseInstances();
            }
            s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));
          }
          const S = a.Push(this);
          return n && S.SetDynamicSolModifiers(t), this._CheckParentsOKToRun(S) && (S.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), this._RunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(o), a.Pop(), g && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), i;
        }
        *DebugRunAsFunctionCall(t, e, n, s) {
          let i, o;
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
          const r = 0 < t.length;
          let u = null;
          const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d;
          if (this._EvaluateFunctionCallParameters(h, e, g), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {
            if (s.copyFromObjectClass) {
              const b = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), R = s.copyToObjectClass.GetCurrentSol();
              R.SetArrayPicked(b.GetInstances()), R.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();
            } else if (s.pickObjectClass) {
              const C = s.pickObjectClass.GetCurrentSol();
              C.SetArrayPicked(s.pickInstances), C.ClearElseInstances();
            }
            s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));
          }
          const S = a.Push(this);
          return n && S.SetDynamicSolModifiers(t), (yield* this._DebugCheckParentsOKToRun(S)) && (S.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(o), a.Pop(), g && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), i;
        }
        RunAsMappedFunctionCall(t, e) {
          const n = this.GetSolModifiersIncludingParents(), s = 0 < n.length, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth(), l = 1 < u, a = (l && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n)), o.Push(this));
          this._CheckParentsOKToRun(a) && (a.SetCurrentEvent(this), this._RunAndBlock(a)), o.Pop(), l && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth(), r.ClearNestedAsyncActionPromises();
        }
        *DebugRunAsMappedFunctionCall(t, e) {
          (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
          const n = this.GetSolModifiersIncludingParents(), s = 0 < n.length, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth(), l = 1 < u, a = (l && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n)), o.Push(this));
          (yield* this._DebugCheckParentsOKToRun(a)) && (a.SetCurrentEvent(this), yield* this._DebugRunAndBlock(a)), o.Pop(), l && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth(), r.ClearNestedAsyncActionPromises();
        }
        RunAsExpressionFunctionCall(t, e, n, s, ...i) {
          let o, r;
          const u = 0 < t.length, l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d, S = (g && h.GetLocalVarStack().Push(), 0 < i.length && this._scopeParent.SetFunctionParameters(i), u && (e ? h.PushCopySol(t) : h.PushCleanSol(t)), a.Push(this));
          return S.InitCallFunctionExpression(n, s), a.PushExpFunc(S), l.SetDebuggingEnabled(false), this._CheckParentsOKToRun(S) && (S.SetCurrentEvent(this), _ && ([r, o] = c.StartAsyncFunctionCall()), this._RunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(r), l.SetDebuggingEnabled(true), a.Pop(), a.PopExpFunc(), g && h.GetLocalVarStack().Pop(), u && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), o || S.GetFunctionReturnValue();
        }
      };
    }
    var NoActions;
    {
      const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];
      let hadUserScriptException = false;
      C33.EventScript = class extends C33.DefendedBase {
        constructor(e, t, i) {
          super();
          const r = e.GetRuntime(), n = e.GetEventSheetManager(), s = (this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t, r.GetObjectReference(i[1]));
          this._func = s, this._displayNumber = i[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r.IsDebug() ? { isBreakpoint: i[3][0], isBreakable: i[3][1] } : null;
        }
        static Create(e, t, i) {
          return C33.New(C33.EventScript, e, t, i);
        }
        _PostInit() {
          const e = this._func, t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
          this._func = e.bind(null, this._runtime.GetIRuntime(), t);
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this._parent;
        }
        GetEventSheet() {
          return this._eventSheet;
        }
        GetDisplayNumber() {
          return this._displayNumber;
        }
        IsDebugBreakable() {
          return this._debugData && this._debugData.isBreakable;
        }
        IsDebugBreakpoint() {
          return this.IsDebugBreakable() && this._debugData.isBreakpoint;
        }
        _SetDebugBreakpoint(e) {
          this._debugData.isBreakpoint = !!e;
        }
        IsElseBlock() {
          return false;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        GetSolModifiersIncludingParents() {
          return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;
        }
        Run(e) {
          e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());
        }
        async _RunUserScript() {
          try {
            await this._func();
          } catch (e) {
            console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), hadUserScriptException = true);
          }
        }
        *DebugRun(e) {
          e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);
        }
        DebugCanRunFast() {
          return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();
        }
        static HadUserScriptException() {
          return hadUserScriptException;
        }
        static SetHadUserScriptException() {
          hadUserScriptException = true;
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert;
      C33.FunctionBlock = class extends C33.DefendedBase {
        constructor(t, e, s) {
          super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = "", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = "", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C33.EventBlock.Create(t, e, s), this._eventBlock._SetScopeParent(this);
        }
        InitFunctionBlock(t) {
          this._functionType = 0, this._functionName = t[0], this._returnType = t[1], this._functionParameters = t[2].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[3], this._isAsync = t[4], this._isCopyPicked = t[5];
        }
        InitCustomACEBlock(t) {
          this._functionType = 1, this._aceName = t[1], this._objectClass = this._runtime.GetObjectClassByIndex(t[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + "." + this._aceName, this._returnType = t[3], this._functionParameters = t[4].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[5], this._isAsync = t[6], this._isCopyPicked = t[7], this._objectClass.AddCustomAction(this);
        }
        static CreateFunctionBlock(t, e, s) {
          const n = C33.New(C33.FunctionBlock, t, e, s), i = s[1];
          return n.InitFunctionBlock(i), n;
        }
        static CreateCustomACEBlock(t, e, s) {
          const n = C33.New(C33.FunctionBlock, t, e, s), i = s[1];
          return n.InitCustomACEBlock(i), n;
        }
        _CheckOverrideState() {
          if (this._objectClass && this._objectClass.IsFamily()) {
            for (const t of this._objectClass.GetFamilyMembers()) if (t.HasOwnCustomActionByName(this._aceName)) {
              this._hasOverrides = true;
              break;
            }
          }
        }
        _PostInit() {
          for (const t of this._functionParameters) t._PostInit();
          this._eventBlock._PostInit(false);
        }
        GetFunctionType() {
          return this._functionType;
        }
        _GetAllLocalVariablesInScope() {
          return this._functionParameters;
        }
        GetFunctionParameters() {
          return this._functionParameters;
        }
        GetFunctionParameterCount() {
          return this._functionParameters.length;
        }
        _RegisterLocalVariable(t) {
          this._innerLocalVariables.push(t);
        }
        _GetAllInnerLocalVariables() {
          return this._innerLocalVariables;
        }
        EvaluateFunctionParameters(s) {
          const n = this._functionParameters;
          for (let t = 0, e = n.length; t < e; ++t) n[t].SetValue(s[t].Get(0));
        }
        SetFunctionParameters(s) {
          const n = this._functionParameters;
          for (let t = 0, e = n.length; t < e; ++t) n[t].SetValue(s[t]);
        }
        CaptureFunctionParameters() {
          return this._functionParameters.map((t) => t.GetValue());
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this._parent;
        }
        GetFunctionName() {
          return this._functionName;
        }
        GetACEName() {
          return this._aceName;
        }
        HasCustomACEOverrides() {
          return this._hasOverrides;
        }
        GetReturnType() {
          return this._returnType;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        IsEnabled() {
          return this._isEnabled;
        }
        GetDefaultReturnValue() {
          switch (this._returnType) {
            case 0:
              return null;
            case 2:
              return "";
            default:
              return 0;
          }
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        IsCopyPicked() {
          return this._isCopyPicked;
        }
        IsAsync() {
          return this._isAsync;
        }
        StartAsyncFunctionCall() {
          const t = this._nextAsyncId++;
          this._currentAsyncId = t;
          let e;
          const s = new Promise((t2) => e = t2);
          return this._asyncMap.set(t, { resolve: e, pauseCount: 0 }), [t, s];
        }
        MaybeFinishAsyncFunctionCall(t) {
          const e = this._asyncMap.get(t);
          0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t)), this._currentAsyncId = -1;
        }
        PauseCurrentAsyncFunction() {
          const t = this._asyncMap.get(this._currentAsyncId);
          return t.pauseCount++, this._currentAsyncId;
        }
        ResumeAsyncFunction(t) {
          this._currentAsyncId = t;
          const e = this._asyncMap.get(t);
          e.pauseCount--;
        }
        RunAsFamilyCustomActionWithOverrides(t, e) {
          const s = /* @__PURE__ */ new Map(), n = [];
          for (const i of this._objectClass.GetCurrentSol().GetInstances()) {
            const c = i.GetObjectClass();
            if (c.HasOwnCustomActionByName(this._aceName)) {
              const a = s.get(c);
              Array.isArray(a) ? a.push(i) : s.set(c, [i]);
            } else n.push(i);
          }
          if (0 < n.length && this._eventBlock.RunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), 0 < s.size) for (const [r, o] of s) {
            const u = r.GetOwnCustomActionByName(this._aceName).GetEventBlock(), h = [.../* @__PURE__ */ new Set([...t, ...u.GetSolModifiers()])];
            u.RunAsFunctionCall(h, e, this._isCopyPicked, { pickObjectClass: r, pickInstances: o });
          }
        }
        *DebugRunAsFamilyCustomActionWithOverrides(t, e) {
          const s = /* @__PURE__ */ new Map(), n = [];
          for (const i of this._objectClass.GetCurrentSol().GetInstances()) {
            const c = i.GetObjectClass();
            if (c.HasOwnCustomActionByName(this._aceName)) {
              const a = s.get(c);
              Array.isArray(a) ? a.push(i) : s.set(c, [i]);
            } else n.push(i);
          }
          if (0 < n.length && (yield* this._eventBlock.DebugRunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), 0 < s.size) for (const [r, o] of s) {
            const u = r.GetOwnCustomActionByName(this._aceName).GetEventBlock(), h = [.../* @__PURE__ */ new Set([...t, ...u.GetSolModifiers()])];
            yield* u.DebugRunAsFunctionCall(h, e, this._isCopyPicked, { pickObjectClass: r, pickInstances: o });
          }
        }
      };
    }
    {
      const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];
      C33.EventVariable = class extends C33.DefendedBase {
        constructor(t, e, s) {
          super();
          const i = t.GetEventSheetManager();
          this._eventSheet = t, this._eventSheetManager = i, this._runtime = t.GetRuntime(), this._parent = e, this._localVarStack = i.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = e instanceof C33.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = (t2) => this.SetValue(t2), this._scriptGetter = () => this.GetValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i._GetNextLocalVarIndex(this)), i._RegisterEventVariable(this);
        }
        static Create(t, e, s) {
          return C33.New(C33.EventVariable, t, e, s);
        }
        _PostInit() {
          if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
            const t = this._eventSheetManager.FindFirstFunctionBlockParent(this);
            t && t._RegisterLocalVariable(this);
          }
        }
        GetName() {
          return this._name;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
        GetParent() {
          return this._parent;
        }
        GetScopeParent() {
          return this.GetParent();
        }
        IsGlobal() {
          return !this.GetParent();
        }
        IsLocal() {
          return !this.IsGlobal();
        }
        IsFunctionParameter() {
          return this._isFunctionParameter;
        }
        IsStatic() {
          return this._isStatic;
        }
        IsConstant() {
          return this._isConstant;
        }
        IsNumber() {
          return 0 === this._type;
        }
        IsString() {
          return 1 === this._type;
        }
        IsBoolean() {
          return 2 === this._type;
        }
        IsElseBlock() {
          return false;
        }
        GetSID() {
          return this._sid;
        }
        GetInitialValue() {
          return this._initialValue;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        Run(t) {
          !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());
        }
        DebugCanRunFast() {
          return true;
        }
        *DebugRun(t) {
          this.Run(t);
        }
        SetValue(t) {
          this.IsNumber() ? "number" != typeof t && (t = parseFloat(t)) : this.IsString() ? "string" != typeof t && (t = t.toString()) : this.IsBoolean() && (t = t ? 1 : 0), this._hasSingleValue ? this._value = t : this._localVarStack.GetCurrent()[this._localIndex] = t;
        }
        GetValue() {
          return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];
        }
        GetTypedValue() {
          let t = this.GetValue();
          return t = this.IsBoolean() ? !!t : t;
        }
        ResetToInitialValue() {
          this._value = this._initialValue;
        }
        _GetScriptInterfaceDescriptor() {
          return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };
        }
      };
    }
    {
      const C33 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];
      C33.EventInclude = class extends C33.DefendedBase {
        constructor(e, t, n) {
          super();
          const s = e.GetEventSheetManager();
          this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;
        }
        static Create(e, t, n) {
          return C33.New(C33.EventInclude, e, t, n);
        }
        _PostInit() {
          this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);
          let e = this.GetParent();
          for (; e; ) e instanceof C33.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();
          this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());
        }
        GetParent() {
          return this._parent;
        }
        GetSolModifiers() {
          return EMPTY_SOL_MODIFIERS;
        }
        GetIncludeSheet() {
          return this._includeSheet;
        }
        Run(e) {
          const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
          t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n);
        }
        *DebugRun(e) {
          const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
          t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n);
        }
        DebugCanRunFast() {
          return false;
        }
        IsActive() {
          return this._isActive;
        }
        UpdateActive() {
          let e = this.GetParent();
          for (; e; ) {
            if (e instanceof C33.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);
            e = e.GetParent();
          }
          this._isActive = true;
        }
      };
    }
    {
      let WrapIndex2 = function(e, t) {
        return t <= e ? e % t : (e < 0 && (e <= -t && (e %= t), e < 0) && (e += t), e);
      };
      WrapIndex = WrapIndex2;
      const C33 = self.C3, assert = self.assert;
      C33.ExpNode = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._owner = e, this._runtime = e.GetRuntime();
        }
        _PostInit() {
        }
        static CreateNode(e, t) {
          const s = t[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];
          return C33.New(n[s], e, t);
        }
      };
      class SystemExpressionExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t[1]), this._func !== C33.Plugins.System.Exps.random && this._func !== C33.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();
        }
        GetBoundMethod() {
          return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);
        }
      }
      class CallFunctionExpressionExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance();
        }
        _PostInit() {
          const e = this._runtime.GetEventSheetManager(), t = (this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null, this._owner.GetEventBlock()), s = this._functionBlock.GetEventBlock();
          this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t.GetSolModifiersIncludingParents(), ...s.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);
        }
        GetBoundMethod() {
          const e = this._functionBlock;
          if (e.IsEnabled()) {
            const t = e.GetEventBlock();
            return C33.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue());
          }
          {
            const s = e.GetDefaultReturnValue();
            return () => s;
          }
        }
      }
      class ObjectExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
        }
        GetBoundMethod() {
          return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
        }
        ExpObject(...e) {
          const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;
          if (0 === n) return this._returnsString ? "" : 0;
          const r = WrapIndex2(this._owner.GetSolIndex(), n);
          return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), this._func.apply(s[r].GetSdkInstance(), e);
        }
        ExpObject_InstExpr(e, ...t) {
          const s = this._objectClass, n = s.GetInstances(), r = n.length;
          if (0 === r) return this._returnsString ? "" : 0;
          const i = WrapIndex2(e, r);
          return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), this._func.apply(n[i].GetSdkInstance(), t);
        }
      }
      class InstVarExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass);
        }
        ExpInstVar() {
          const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t = e.length;
          if (0 === t) return this._returnsString ? "" : 0;
          const s = WrapIndex2(this._owner.GetSolIndex(), t);
          return e[s]._GetInstanceVariableValueUnchecked(this._varIndex);
        }
        ExpInstVar_Family() {
          const e = this._objectClass, t = e.GetCurrentSol().GetExpressionInstances(), s = t.length;
          if (0 === s) return this._returnsString ? "" : 0;
          const n = WrapIndex2(this._owner.GetSolIndex(), s), r = t[n], i = r.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
          return r._GetInstanceVariableValueUnchecked(this._varIndex + i);
        }
        ExpInstVar_InstExpr(e) {
          const t = this._objectClass, s = t.GetInstances(), n = s.length;
          if (0 === n) return this._returnsString ? "" : 0;
          const r = WrapIndex2(e, n), i = s[r];
          let o = 0;
          return t.IsFamily() && (o = i.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), i._GetInstanceVariableValueUnchecked(this._varIndex + o);
        }
      }
      class BehaviorExpressionNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
        }
        ExpBehavior(...e) {
          const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;
          if (0 === n) return this._returnsString ? "" : 0;
          const r = WrapIndex2(this._owner.GetSolIndex(), n), i = (this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), s[r]);
          let o = 0;
          return t.IsFamily() && (o = i.GetObjectClass().GetFamilyBehaviorOffset(t.GetFamilyIndex())), this._func.apply(i.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), e);
        }
        ExpBehavior_InstExpr(e, ...t) {
          const s = this._objectClass, n = s.GetInstances(), r = n.length;
          if (0 === r) return this._returnsString ? "" : 0;
          const i = WrapIndex2(e, r), o = (this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), n[i]);
          let a = 0;
          return s.IsFamily() && (a = o.GetObjectClass().GetFamilyBehaviorOffset(s.GetFamilyIndex())), this._func.apply(o.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), t);
        }
      }
      class EventVarExpNode extends C33.ExpNode {
        constructor(e, t) {
          super(e), this._eventVar = null, this._eventVarSid = t[1];
        }
        _PostInit() {
          this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
        }
        GetVar() {
          return this._eventVar;
        }
      }
    }
    var WrapIndex;
    {
      let GetExpressionFunc2 = function(t) {
        const e = self.C3_ExpressionFuncs[t];
        if (e) return e;
        throw new Error("invalid expression number");
      };
      GetExpressionFunc = GetExpressionFunc2;
      const C33 = self.C3, assert = self.assert;
      C33.Parameter = class extends C33.DefendedBase {
        constructor(t, e, s) {
          super(), this._owner = t, this._index = s, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;
        }
        static Create(t, e, s) {
          const r = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];
          return C33.New(n[r], t, r, s, e);
        }
        _PostInit() {
        }
        SetVariesPerInstance() {
          this._variesPerInstance = true;
        }
        _MaybeVaryFor(t) {
          this._variesPerInstance || !t || t.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true);
        }
        VariesPerInstance() {
          return this._variesPerInstance;
        }
        GetIndex() {
          return this._index;
        }
        GetRuntime() {
          return this._owner.GetRuntime();
        }
        GetEventBlock() {
          return this._owner.GetEventBlock();
        }
        IsConstant() {
          return this._isConstant;
        }
        IsObjectParameter() {
          return 4 === this._type;
        }
      };
      class ExpressionParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._solIndex = 0;
          const n = r[1];
          this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;
          for (let t2 = 1, e2 = n.length; t2 < e2; ++t2) this._numberedNodes.push(C33.ExpNode.CreateNode(this, n[t2]));
          this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc2(this._expressionNumber), this._isConstant = true);
        }
        _GetNode(t) {
          if (t < 0 || t >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
          return this._numberedNodes[t];
        }
        _PostInit() {
          for (const e of this._numberedNodes) e._PostInit();
          const t = GetExpressionFunc2(this._expressionNumber);
          this._numberedNodes.length ? this._expressionFunc = t(this) : this._expressionFunc = t;
        }
        GetSolIndex() {
          return this._solIndex;
        }
        GetExpression(t) {
          return this._solIndex = t, this._expressionFunc();
        }
      }
      class StringExpressionParameter extends ExpressionParameter {
        constructor(t, e, s, r) {
          super(t, e, s, r), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C33.Action) && this.GetEventBlock().SetSolWriterAfterCnds();
        }
        GetStringExpression(t) {
          this._solIndex = t;
          const e = this._expressionFunc();
          return "string" == typeof e ? e : "";
        }
        _GetFastTriggerValue() {
          return GetExpressionFunc2(this._expressionNumber)();
        }
      }
      class LayerExpressionParameter extends ExpressionParameter {
        constructor(t, e, s, r) {
          super(t, e, s, r), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;
        }
        GetLayer(t) {
          this._solIndex = t;
          const e = this._expressionFunc(), s = this.GetRuntime().GetCurrentLayout();
          return s.GetLayer(e);
        }
        GetILayer(t) {
          const e = this.GetLayer(t);
          return e ? e.GetILayer() : null;
        }
      }
      class ComboParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._combo = r[1], this.Get = this.GetCombo, this._isConstant = true;
        }
        GetCombo() {
          return this._combo;
        }
      }
      class BooleanParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._bool = r[1], this.Get = this.GetBoolean, this._isConstant = true;
        }
        GetBoolean() {
          return this._bool;
        }
      }
      class ObjectParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
          const n = this.GetEventBlock();
          n._AddSolModifier(this._objectClass), this._owner instanceof C33.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetIObjectClass() {
          return this._objectClass ? this._objectClass.GetIObjectClass() : null;
        }
      }
      class LayoutParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;
        }
        GetLayout() {
          return this._layout;
        }
        GetILayout() {
          return this._layout ? this._layout.GetILayout() : null;
        }
      }
      class TimelineParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;
        }
        GetTimeline() {
          return this._timeline;
        }
        GetITimelineState() {
          return this._timeline ? this._timeline.GetITimelineState() : null;
        }
      }
      class FileParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._fileInfo = r[1], this.Get = this.GetFile, this._isConstant = true;
        }
        GetFile() {
          return this._fileInfo;
        }
      }
      class InstVarParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._instVarIndex = r[1];
          const n = this._owner.GetObjectClass();
          !(this._owner instanceof C33.Condition && this._owner.IsStatic()) && n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);
        }
        GetInstanceVariable() {
          return this._instVarIndex;
        }
        GetFamilyInstanceVariable(t) {
          t = t || 0;
          const e = this._owner.GetObjectClass(), s = e.GetCurrentSol(), r = s.GetInstances();
          let n = null;
          if (r.length) n = r[t % r.length].GetObjectClass();
          else if (s.HasAnyElseInstances()) {
            const i = s.GetElseInstances();
            n = i[t % i.length].GetObjectClass();
          } else {
            if (!(0 < e.GetInstanceCount())) return 0;
            {
              const a = e.GetInstances();
              n = a[t % a.length].GetObjectClass();
            }
          }
          return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
        }
      }
      class EventVarParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._eventVarSid = r[1], this._eventVar = null, 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;
        }
        _PostInit() {
          this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
        }
        GetEventVariable() {
          return this._eventVar;
        }
        GetIEventVariable() {
          return null;
        }
      }
      class FunctionParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._functionBlockName = r[1], this._functionBlock = null, 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;
        }
        _PostInit() {
          this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;
        }
        GetFunction() {
          return this._functionBlock;
        }
        GetIFunction() {
          return null;
        }
      }
      class VariadicParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._subParams = [], this._variadicRet = [], this._isConstant = true;
          for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {
            const n = C33.Parameter.Create(this._owner, r[t2], 0);
            this._subParams.push(n), this._variadicRet.push(0), n.IsConstant() || (this._isConstant = false);
          }
          this.Get = this.GetVariadic;
        }
        _PostInit() {
          for (const t of this._subParams) t._PostInit();
        }
        GetVariadic() {
          const s = this._subParams, r = this._variadicRet;
          for (let t = 0, e = s.length; t < e; ++t) r[t] = s[t].Get(0);
          return r;
        }
      }
      class EaseParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._easeIndex = r[1], this.Get = this.GetEase, this._isConstant = true;
        }
        GetEase() {
          return this._easeIndex;
        }
      }
      class TilemapBrushParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._brushIndex = r[1], this.Get = this.GetTilemapBrush, this._isConstant = true;
        }
        GetTilemapBrush() {
          return this._brushIndex;
        }
      }
      class TemplateExpressionParameter extends ExpressionParameter {
        constructor(t, e, s, r) {
          super(t, e, s, r), this.Get = this.GetTemplateName, this._isConstant = false;
        }
        GetTemplateName() {
          return this._expressionFunc();
        }
      }
      class FlowchartParameter extends C33.Parameter {
        constructor(t, e, s, r) {
          super(t, e, s), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r[1]), this.Get = this.GetFlowchartName, this._isConstant = true;
        }
        GetFlowchartName() {
          return this._flowchartDataItem.GetName();
        }
      }
    }
    var GetExpressionFunc;
    {
      let EvalParams2 = function(s, n) {
        for (let t = 0, e = s.length; t < e; ++t) n[t] = s[t].Get(0);
      };
      EvalParams = EvalParams2;
      const C33 = self.C3, assert = self.assert;
      const EMPTY_PARAMS_ARRAY = [], noop = function() {
      };
      C33.Condition = class extends C33.DefendedBase {
        constructor(t, s, e) {
          if (super(), this._eventBlock = t, this._runtime = t.GetRuntime(), this._index = e, this._func = this._runtime.GetObjectReference(s[1]), this._isTrigger = 0 < s[3], this._isFastTrigger = 2 === s[3], this._isLooping = !!s[4], this._isInverted = !!s[5], this._isStatic = !!s[6], this._sid = s[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: s[8][0], canDebug: s[8][1] } : null, -1 === s[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(s[0]), s[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(s[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(s[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === s.length) {
            let e2 = s[9];
            for (let t2 of e2) this._parameters.push(C33.Parameter.Create(this, t2, this._parameters.length)), this._results.push(0);
          }
          0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);
        }
        static Create(t, e, s) {
          return C33.New(C33.Condition, t, e, s);
        }
        _PostInit() {
          for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
          this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);
        }
        _SetSystemRunMethod() {
          const t = this._systemPlugin, e = this._systemPlugin;
          this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
        }
        _SetSingleGlobalRunMethod() {
          const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
          this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
        }
        _SetRunMethodForBoundFunc(t, e, s) {
          const n = this._func, i = this._isInverted, r = this._parameters;
          if (0 === r.length) {
            const a = t._GetBoundACEMethod(n, e);
            i ? this.Run = function() {
              return C33.xor(a(), i);
            } : this.Run = a;
          } else if (1 === r.length) {
            const h = r[0];
            if (!i && h.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, h.Get(0));
            else {
              const o = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(o(h.Get(0)), i);
              };
            }
          } else if (2 === r.length) {
            const l = r[0], u = r[1];
            if (!i && l.IsConstant() && u.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, l.Get(0), u.Get(0));
            else {
              const _ = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(_(l.Get(0), u.Get(0)), i);
              };
            }
          } else if (3 === r.length) {
            const c = r[0], d = r[1], g = r[2];
            if (!i && c.IsConstant() && d.IsConstant() && g.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, c.Get(0), d.Get(0), g.Get(0));
            else {
              const I = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return C33.xor(I(c.Get(0), d.Get(0), g.Get(0)), i);
              };
            }
          } else this.Run = s;
        }
        GetSID() {
          return this._sid;
        }
        _GetFunc() {
          return this._func;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetImplementationAddon() {
          return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
        }
        GetImplementationSdkVersion() {
          const t = this.GetImplementationAddon();
          return t ? t.GetSdkVersion() : 1;
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetIndex() {
          return this._index;
        }
        GetDebugIndex() {
          return this.GetIndex();
        }
        IsTrigger() {
          return this._isTrigger;
        }
        IsFastTrigger() {
          return this._isFastTrigger;
        }
        IsInverted() {
          return this._isInverted;
        }
        IsLooping() {
          return this._isLooping;
        }
        IsStatic() {
          return this._isStatic;
        }
        IsBreakpoint() {
          return this._debugData.isBreakpoint;
        }
        IsSystemCondition() {
          return !!this._systemPlugin;
        }
        IsSystemOrSingleGlobalCondition() {
          return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();
        }
        GetFirstObjectParameterObjectClass() {
          for (const t of this._parameters) if (t.IsObjectParameter()) return t.GetObjectClass();
          return null;
        }
        _SetBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
        }
        _DebugReturnsGenerator() {
          return this._debugData.canDebug;
        }
        DebugCanRunFast() {
          return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        _RunSystem() {
          const t = this._results;
          return EvalParams2(this._parameters, t), C33.xor(this._func.apply(this._systemPlugin, t), this._isInverted);
        }
        *_DebugRunSystem() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const e = this._results;
            EvalParams2(this._parameters, e);
            let t = this._func.apply(this._systemPlugin, e);
            return C33.IsIterator(t) && (t = yield* t), C33.xor(t, this._isInverted);
          }
          return this.Run();
        }
        _RunSingleGlobal() {
          const t = this._results, e = (EvalParams2(this._parameters, t), this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
          return C33.xor(this._func.apply(e, t), this._isInverted);
        }
        *_DebugRunSingleGlobal() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const e = this._results, s = (EvalParams2(this._parameters, e), this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
            let t = this._func.apply(s, e);
            return C33.IsIterator(t) && (t = yield* t), C33.xor(t, this._isInverted);
          }
          return this.Run();
        }
        _RunFastTrigger() {
          return true;
        }
        *_DebugRunFastTrigger() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;
        }
        _GetStaticConditionThis() {
          if (this._behaviorType) {
            if (2 <= this._behaviorType.GetBehavior().GetSdkVersion()) throw new Error("not yet implemented");
            return this._behaviorType;
          }
          return 2 <= this._objectClass.GetPlugin().GetSdkVersion() ? this._objectClass.GetIObjectClass() : this._objectClass;
        }
        _RunStatic() {
          const t = this._results, e = (EvalParams2(this._parameters, t), this._func.apply(this._GetStaticConditionThis(), t));
          return this._objectClass.ApplySolToContainer(), e;
        }
        *_DebugRunStatic() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const e = this._results;
            EvalParams2(this._parameters, e);
            let t = this._func.apply(this._GetStaticConditionThis(), e);
            return C33.IsIterator(t) && (t = yield* t), this._objectClass.ApplySolToContainer(), t;
          }
          return this.Run();
        }
        _RunObject() {
          const s = this._parameters, n = this._results, t = this._objectClass.GetCurrentSol();
          for (let t2 = 0, e = s.length; t2 < e; ++t2) {
            const i = s[t2];
            i.VariesPerInstance() || (n[t2] = i.Get(0));
          }
          return t.IsSelectAll() ? this._RunObject_FirstFilter(t) : this._RunObject_NextFilter(t);
        }
        *_DebugRunObject() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();
        }
        _EvaluateVaryingParameters(s) {
          const n = this._parameters, i = this._results;
          for (let t = 0, e = n.length; t < e; ++t) {
            const r = n[t];
            r.VariesPerInstance() && (i[t] = r.Get(s));
          }
        }
        _RunObject_FirstFilter(s) {
          const t = this._objectClass, n = t.IsFamily(), i = t.GetFamilyIndex(), r = this._behaviorIndex, a = 0 <= r, h = t.GetInstances(), o = this._anyParamVariesPerInstance, l = this._results, u = this._func, _ = this._isInverted, c = this._isInOrBlock && !this._isTrigger;
          s.ClearArrays();
          for (let e = 0, t2 = h.length; e < t2; ++e) {
            const d = h[e];
            o && this._EvaluateVaryingParameters(e);
            let t3;
            if (a) {
              const g = n ? d.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;
              t3 = u.apply(d.GetBehaviorInstances()[r + g].GetSdkInstance(), l);
            } else t3 = u.apply(d.GetSdkInstance(), l);
            C33.xor(t3, _) ? s._PushInstance(d) : c && s._PushElseInstance(d);
          }
          return t.FinishCondition(true), s._SetSelectAll(false), t.ApplySolToContainer(), s.HasAnyInstances();
        }
        _RunObject_NextFilter(t) {
          const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = e.IsInContainer(), r = this._behaviorIndex, a = 0 <= r, h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger, c = t._GetOwnInstances(), d = t._GetOwnElseInstances(), g = _ && !this._eventBlock.IsFirstConditionOfType(this), I = g ? d : c;
          let G = 0, b = false;
          for (let e2 = 0, t2 = I.length; e2 < t2; ++e2) {
            const p = I[e2];
            h && this._EvaluateVaryingParameters(e2);
            let t3;
            if (a) {
              const C = s ? p.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              t3 = l.apply(p.GetBehaviorInstances()[r + C].GetSdkInstance(), o);
            } else t3 = l.apply(p.GetSdkInstance(), o);
            C33.xor(t3, u) ? (b = true, g ? (c.push(p), i && p._PushSiblingsToSolInstances()) : (I[G] = p, i && p._SetSiblingsToSolInstancesIndex(G), ++G)) : g ? (I[G] = p, i && p._SetSiblingsToSolElseInstancesIndex(G), ++G) : _ && (d.push(p), i) && p._PushSiblingsToSolElseInstances();
          }
          C33.truncateArray(I, G), i && e._TruncateContainerSols(g, G);
          const m = b;
          return g && !b && (b = this._OrBlockCheckInstances(c)), e.FinishCondition(m || _), _ ? b : t.HasAnyInstances();
        }
        _OrBlockCheckInstances(s) {
          const t = this._objectClass, n = t.IsFamily(), i = t.GetFamilyIndex(), r = this._anyParamVariesPerInstance, a = this._behaviorIndex, h = 0 <= a, o = this._results, l = this._func, u = this._isInverted;
          for (let e = 0, t2 = s.length; e < t2; ++e) {
            const _ = s[e];
            r && this._EvaluateVaryingParameters(e);
            let t3;
            if (h) {
              const c = n ? _.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;
              t3 = l.apply(_.GetBehaviorInstances()[a + c].GetSdkInstance(), o);
            } else t3 = l.apply(_.GetSdkInstance(), o);
            if (C33.xor(t3, u)) return true;
          }
          return false;
        }
        ReevaluateParameter(t, e) {
          return this._parameters[t].Get(e);
        }
        GetFastTriggerValue() {
          const t = this._parameters;
          if (t.length) return t[0]._GetFastTriggerValue();
          throw new Error("no parameters");
        }
        _SaveToJson() {
          if (!this._savedData || !this._savedData.size) return null;
          const e = {};
          for (const [s, n] of this._savedData.entries()) {
            let t = n;
            "collmemory" === s && (t = [...n.entries()].map((t2) => [t2[0].GetUID(), t2[1].GetUID(), t2[2]])), e[s] = t;
          }
          return { "ex": e };
        }
        _LoadFromJson(t) {
          if (this._savedData && (this._savedData.clear(), this._savedData = null), t) {
            const e = this._runtime, s = t["ex"];
            if (s) {
              const n = this.GetSavedDataMap();
              n.clear();
              for (const [i, r] of Object.entries(s)) {
                let t2 = r;
                "collmemory" === i && (t2 = C33.New(C33.PairMap, r.map((t3) => [e.GetInstanceByUID(t3[0]), e.GetInstanceByUID(t3[1]), t3[2]]).filter((t3) => t3[0] && t3[1]))), n.set(i, t2);
              }
            }
          }
        }
      };
    }
    var EvalParams;
    {
      let EvalParams2 = function(s, n) {
        for (let t = 0, e = s.length; t < e; ++t) n[t] = s[t].Get(0);
      };
      EvalParams = EvalParams2;
      const C33 = self.C3, assert = self.assert;
      const EMPTY_PARAMS_ARRAY = [], noop = function() {
      }, noopGenerator = function* () {
      }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;
      C33.Action = class extends C33.DefendedBase {
        constructor(t, e, s) {
          super();
          const n = (this._eventBlock = t).GetRuntime(), i = (this._runtime = n, this._index = s, this._sid = 4 <= e.length ? e[3] : -1, this._actionType = 5 <= e.length ? 255 & e[4] : 0, this._flags = 5 <= e.length ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = "", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, -3 === e[0]), a = i ? e[2] : e[5];
          if (this._debugData = n.IsDebug() || i ? { isBreakpoint: a[0], canDebug: a[1], index: a[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);
          else if (-2 === e[0]) this._callFunctionName = e[1];
          else if (i) {
            const r = n.GetObjectReference(e[1]);
            this._func = r, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= FLAG_IS_ASYNC;
          } else this._objectClass = n.GetObjectClassByIndex(e[0]), this._flags & FLAG_CUSTOM_ACE ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));
          if (7 === e.length) {
            const l = e[6];
            for (const e2 of l) this._parameters.push(C33.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
          }
          0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);
        }
        static Create(t, e, s) {
          return C33.New(C33.Action, t, e, s);
        }
        _PostInit() {
          for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
          if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
          else if (this._callFunctionName) this._flags & FLAG_CUSTOM_ACE ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = "", this._callCustomAceObjectClass = null;
          else if (this.Run === this.RunUserScript) {
            const e = this._func, s = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
            this._func = e.bind(null, this._runtime.GetIRuntime(), s);
          } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t) => t.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t) => t.IsConstant()) ? (EvalParams2(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);
        }
        _SetSystemRunMethod() {
          const t = this._systemPlugin, e = this._systemPlugin;
          this._SetRunMethodForBoundFunc(t, e, this._RunSystem);
        }
        _SetSingleGlobalRunMethod() {
          const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
          this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);
        }
        _SetCallFunctionRunMethod() {
          const t = this._eventBlock.GetEventSheetManager(), s = t.GetFunctionBlockByName(this._callFunctionName);
          if (s.IsEnabled()) {
            const n = 0 != (this._flags & FLAG_COPYPICKED);
            this._callEventBlock = s.GetEventBlock();
            let e = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];
            e = t._DeduplicateSolModifierList(e);
            const i = !s.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;
            if (this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, e, this._parameters, n, i), this._runtime.IsDebug()) {
              const a = this;
              this.DebugRun = function* () {
                (a.IsBreakpoint() || a._runtime.DebugBreakNext()) && (yield a);
                const t2 = yield* a._callEventBlock.DebugRunAsFunctionCall(e, a._parameters, n, i);
                return t2;
              };
            } else this.DebugRun = noopGenerator;
          } else this.Run = noop, this.DebugRun = noopGenerator;
        }
        _SetCallCustomActionRunMethod() {
          const t = this._eventBlock.GetEventSheetManager(), n = t.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
          if (n.IsEnabled()) {
            const i = 0 != (this._flags & FLAG_COPYPICKED);
            this._callEventBlock = n.GetEventBlock();
            let e = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, n.GetObjectClass()])];
            e = t._DeduplicateSolModifierList(e);
            const a = !this._objectClass.IsFamily() && !n.GetObjectClass().IsFamily(), r = !this._objectClass.IsFamily() && n.GetObjectClass().IsFamily(), l = this._objectClass.IsFamily();
            let s = null;
            if (!n.IsCopyPicked() && this._HasCopyPickedParent() && ((s = s || {}).pushCleanSolDynamic = true), !r && i || ((s = s || {}).copyFromObjectClass = this._objectClass, s.copyToObjectClass = n.GetObjectClass()), a || r || l && !n.HasCustomACEOverrides() ? this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, e, this._parameters, i, s) : l && (this.Run = C33.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(n, e, this._parameters)), this._runtime.IsDebug()) {
              const o = this;
              a || r || l && !n.HasCustomACEOverrides() ? this.DebugRun = function* () {
                (o.IsBreakpoint() || o._runtime.DebugBreakNext()) && (yield o);
                const t2 = yield* o._callEventBlock.DebugRunAsFunctionCall(e, o._parameters, i, s);
                return t2;
              } : l && (this.DebugRun = function* () {
                (o.IsBreakpoint() || o._runtime.DebugBreakNext()) && (yield o);
                const t2 = yield* n.DebugRunAsFamilyCustomActionWithOverrides(e, o._parameters);
                return t2;
              });
            } else this.DebugRun = noopGenerator;
          } else this.Run = noop, this.DebugRun = noopGenerator;
        }
        _SetRunMethodForBoundFunc(t, e, s) {
          const n = this._func, i = this._parameters;
          if (0 === i.length) this.Run = t._GetBoundACEMethod(n, e);
          else if (1 === i.length) {
            const a = i[0];
            if (a.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, a.Get(0));
            else {
              const r = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return r(a.Get(0));
              };
            }
          } else if (2 === i.length) {
            const l = i[0], o = i[1];
            if (l.IsConstant() && o.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, l.Get(0), o.Get(0));
            else {
              const h = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return h(l.Get(0), o.Get(0));
              };
            }
          } else if (3 === i.length) {
            const u = i[0], c = i[1], _ = i[2];
            if (u.IsConstant() && c.IsConstant() && _.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, u.Get(0), c.Get(0), _.Get(0));
            else {
              const b = t._GetBoundACEMethod(n, e);
              this.Run = function() {
                return b(u.Get(0), c.Get(0), _.Get(0));
              };
            }
          } else this.Run = s;
        }
        GetSID() {
          return this._sid;
        }
        IsAsync() {
          return 0 != (this._flags & FLAG_IS_ASYNC);
        }
        CanBailOut() {
          return 0 != (this._flags & FLAG_CAN_BAIL_OUT);
        }
        CallBeforeAfterHooks() {
          return 1 === this._actionType;
        }
        IsStatic() {
          return 2 === this._actionType;
        }
        CanPickAnyObjectClass() {
          return 0 != (this._flags & FLAG_CANPICKANYOBJECTCLASS);
        }
        HasReturnType() {
          return this.IsAsync() || this.CanBailOut();
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetImplementationAddon() {
          return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
        }
        GetImplementationSdkVersion() {
          const t = this.GetImplementationAddon();
          return t ? t.GetSdkVersion() : 1;
        }
        GetEventBlock() {
          return this._eventBlock;
        }
        _HasCopyPickedParent() {
          let t = this._eventBlock;
          do {
            if (t instanceof C33.FunctionBlock && t.IsCopyPicked()) return true;
          } while (t = t.GetScopeParent());
          return false;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetIndex() {
          return this._index;
        }
        GetDebugIndex() {
          return this._debugData.index;
        }
        IsBreakpoint() {
          return this._debugData.isBreakpoint;
        }
        _SetBreakpoint(t) {
          this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();
        }
        _DebugReturnsGenerator() {
          return this._debugData.canDebug;
        }
        DebugCanRunFast() {
          return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        _RunSystem() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._systemPlugin, t);
        }
        *_DebugRunSystem() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results, e = (EvalParams2(this._parameters, t), yield* this._func.apply(this._systemPlugin, t));
            return e;
          }
          return this.Run();
        }
        _RunSingleGlobal() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
        }
        *_DebugRunSingleGlobal() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._results, e = (EvalParams2(this._parameters, t), yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t));
            return e;
          }
          return this.Run();
        }
        _RunObject_ParamsConst() {
          const s = this._results, n = this._objectClass.GetCurrentSol().GetInstances();
          for (let t = 0, e = n.length; t < e; ++t) this._func.apply(n[t].GetSdkInstance(), s);
        }
        *_DebugRunObject_ParamsConst() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const s = this._results, n = this._objectClass.GetCurrentSol().GetInstances();
            for (let t = 0, e = n.length; t < e; ++t) yield* this._func.apply(n[t].GetSdkInstance(), s);
          } else this._RunObject_ParamsConst();
        }
        _RunObject_ParamsDontVary() {
          const s = this._results, n = (EvalParams2(this._parameters, s), this._objectClass.GetCurrentSol().GetInstances());
          for (let t = 0, e = n.length; t < e; ++t) this._func.apply(n[t].GetSdkInstance(), s);
        }
        *_DebugRunObject_ParamsDontVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const s = this._results, n = (EvalParams2(this._parameters, s), this._objectClass.GetCurrentSol().GetInstances());
            for (let t = 0, e = n.length; t < e; ++t) yield* this._func.apply(n[t].GetSdkInstance(), s);
          } else this._RunObject_ParamsDontVary();
        }
        _RunObject_AllParamsVary() {
          const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();
          for (let s = 0, t = a.length; s < t; ++s) {
            const r = a[s];
            for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);
            e.apply(r.GetSdkInstance(), i);
          }
        }
        *_DebugRunObject_AllParamsVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();
            for (let s = 0, t = a.length; s < t; ++s) {
              const r = a[s];
              for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);
              yield* e.apply(r.GetSdkInstance(), i);
            }
          } else this._RunObject_AllParamsVary();
        }
        _RunObject_SomeParamsVary() {
          const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();
          for (let t = 0, e2 = n.length; t < e2; ++t) {
            const s = n[t];
            s.VariesPerInstance() || (i[t] = s.Get(0));
          }
          for (let s = 0, t = a.length; s < t; ++s) {
            const r = a[s];
            for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
              const l = n[t2];
              l.VariesPerInstance() && (i[t2] = l.Get(s));
            }
            e.apply(r.GetSdkInstance(), i);
          }
        }
        *_DebugRunObject_SomeParamsVary() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();
            for (let t = 0, e2 = n.length; t < e2; ++t) {
              const s = n[t];
              s.VariesPerInstance() || (i[t] = s.Get(0));
            }
            for (let s = 0, t = a.length; s < t; ++s) {
              const r = a[s];
              for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {
                const l = n[t2];
                l.VariesPerInstance() && (i[t2] = l.Get(s));
              }
              yield* e.apply(r.GetSdkInstance(), i);
            }
          } else this._RunObject_SomeParamsVary();
        }
        _RunObject_BeforeAfterHooks() {
          const n = this._parameters, i = this._results, e = this._func, t = this._objectClass, s = t.GetSdkType(), a = t.GetCurrentSol().GetInstances();
          s.BeforeRunAction(e);
          for (let s2 = 0, t2 = a.length; s2 < t2; ++s2) {
            const r = a[s2];
            for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) i[t3] = n[t3].Get(s2);
            e.apply(r.GetSdkInstance(), i);
          }
          s.AfterRunAction(e);
        }
        *_DebugRunObject_BeforeAfterHooks() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const n = this._parameters, i = this._results, e = this._func, t = this._objectClass, s = t.GetSdkType(), a = t.GetCurrentSol().GetInstances();
            s.BeforeRunAction(e);
            for (let s2 = 0, t2 = a.length; s2 < t2; ++s2) {
              const r = a[s2];
              for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) i[t3] = n[t3].Get(s2);
              yield* e.apply(r.GetSdkInstance(), i);
            }
            s.AfterRunAction(e);
          } else this._RunObject_BeforeAfterHooks();
        }
        _RunObject_Static() {
          const t = this._results;
          return EvalParams2(this._parameters, t), this._func.apply(this._behaviorType || this._objectClass, t);
        }
        *_DebugRunObject_Static() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const e = this._results;
            EvalParams2(this._parameters, e);
            let t = this._func.apply(this._behaviorType || this._objectClass, e);
            return t = C33.IsIterator(t) ? yield* t : t;
          }
          return this._RunObject_Static();
        }
        _RunBehavior() {
          const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._anyParamVariesPerInstance, r = this._results, l = this._func, o = this._behaviorIndex, h = t.GetCurrentSol().GetInstances();
          for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {
            const s = i[t2];
            s.VariesPerInstance() || (r[t2] = s.Get(0));
          }
          for (let s = 0, t2 = h.length; s < t2; ++s) {
            const u = h[s];
            if (a) for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) {
              const _ = i[t3];
              _.VariesPerInstance() && (r[t3] = _.Get(s));
            }
            const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
            l.apply(u.GetBehaviorInstances()[o + c].GetSdkInstance(), r);
          }
        }
        *_DebugRunBehavior() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._anyParamVariesPerInstance, r = this._results, l = this._func, o = this._behaviorIndex, h = t.GetCurrentSol().GetInstances();
            for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {
              const s = i[t2];
              s.VariesPerInstance() || (r[t2] = s.Get(0));
            }
            for (let s = 0, t2 = h.length; s < t2; ++s) {
              const u = h[s];
              if (a) for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) {
                const _ = i[t3];
                _.VariesPerInstance() && (r[t3] = _.Get(s));
              }
              const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              yield* l.apply(u.GetBehaviorInstances()[o + c].GetSdkInstance(), r);
            }
          } else this._RunBehavior();
        }
        _RunObject_Async() {
          const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances(), r = [];
          for (let s = 0, t = a.length; s < t; ++s) {
            const l = a[s];
            for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);
            r.push(e.apply(l.GetSdkInstance(), i));
          }
          return Promise.all(r);
        }
        *_DebugRunObject_Async() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances(), r = [];
            for (let s = 0, t = a.length; s < t; ++s) {
              const l = a[s];
              for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);
              r.push(yield* e.apply(l.GetSdkInstance(), i));
            }
            return Promise.all(r);
          }
          return this._RunObject_Async();
        }
        _RunBehavior_Async() {
          const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._results, r = this._func, l = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), h = [];
          for (let s = 0, t2 = o.length; s < t2; ++s) {
            const u = o[s];
            for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) a[t3] = i[t3].Get(s);
            const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
            h.push(r.apply(u.GetBehaviorInstances()[l + c].GetSdkInstance(), a));
          }
          return Promise.all(h);
        }
        *_DebugRunBehavior_Async() {
          if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
            const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._results, r = this._func, l = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), h = [];
            for (let s = 0, t2 = o.length; s < t2; ++s) {
              const u = o[s];
              for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) a[t3] = i[t3].Get(s);
              const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
              h.push(yield* r.apply(u.GetBehaviorInstances()[l + c].GetSdkInstance(), a));
            }
            return Promise.all(h);
          }
          return this._RunBehavior_Async();
        }
        async RunUserScript() {
          try {
            await this._func();
          } catch (t) {
            console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C33.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), C33.EventScript.SetHadUserScriptException());
          }
        }
        *DebugRunUserScript() {
          return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();
        }
        _SaveToJson() {
          return this._savedData && this._savedData.size ? { "ex": C33.ToSuperJSON(this._savedData) } : null;
        }
        _LoadFromJson(t) {
          if (this._savedData && (this._savedData.clear(), this._savedData = null), t) {
            const e = t["ex"];
            e && (this._savedData = C33.FromSuperJSON(e));
          }
        }
      };
    }
    var EvalParams;
    {
      let GetInst2 = function(t) {
        return t instanceof IInstance ? runtime._UnwrapScriptInterface(t) : t.GetInstance();
      }, GetWorldInfo2 = function(t) {
        return GetInst2(t).GetWorldInfo();
      }, GetInst_SDKv22 = function(t) {
        return runtime._UnwrapScriptInterface(t);
      }, GetWorldInfo_SDKv22 = function(t) {
        return GetInst_SDKv22(t).GetWorldInfo();
      }, CollMemory_Add2 = function(t, e, n, o) {
        const i = e.GetUID(), s = n.GetUID();
        i < s ? t.Set(e, n, o) : t.Set(n, e, o);
      }, CollMemory_Remove2 = function(t, e, n) {
        const o = e.GetUID(), i = n.GetUID();
        o < i ? t.Delete(e, n) : t.Delete(n, e);
      }, CollMemory_RemoveInstance2 = function(t, e) {
        t.DeleteEither(e);
      }, CollMemory_Get2 = function(t, e, n) {
        const o = e.GetUID(), i = n.GetUID();
        return o < i ? t.Get(e, n) : t.Get(n, e);
      }, DoOverlapCondition2 = function(t, e, n, o) {
        if (!e) return false;
        const i = 0 !== n || 0 !== o, s = t.GetWorldInfo(), r = runtime.GetCollisionEngine(), a = runtime.GetCurrentCondition(), l = a.GetEventBlock().IsOrBlock(), c = a.GetObjectClass(), u = a.IsInverted(), S = e.GetCurrentSol(), f = c !== e;
        rPickType = e, needsCollisionFinish = f && !u;
        let d, G = 0, I = 0, h = rPickFromElseInstances = false;
        S.IsSelectAll() ? (tempRect.copy(s.GetBoundingBox()), tempRect.offset(n, o), r.GetCollisionCandidates(s.GetLayer(), e, tempRect, tempCandidates2), d = tempCandidates2) : !l || runtime.IsCurrentConditionFirst() && !S._GetOwnElseInstances().length && S._GetOwnInstances().length ? d = S._GetOwnInstances() : (d = S._GetOwnElseInstances(), rPickFromElseInstances = true), i && (G = s.GetX(), I = s.GetY(), s.OffsetXY(n, o), s.SetBboxChanged());
        for (const C of d) if (r.TestOverlap(t, C)) {
          if (h = true, u) break;
          f && rToPick.add(C);
        }
        return i && (s.SetXY(G, I), s.SetBboxChanged()), C33.clearArray(tempCandidates2), h;
      }, FinishCollisionConditionPicking2 = function(t) {
        const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o = n._GetOwnInstances(), i = n._GetOwnElseInstances();
        n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C33.clearArray(i), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();
      }, FinishCollisionCondition2 = function(t, e) {
        needsCollisionFinish && (e && FinishCollisionConditionPicking2(t), rToPick.clear(), rPickType = null, needsCollisionFinish = false);
      }, PickByUID_Normal2 = function(t, e) {
        const n = runtime.GetInstanceByUID(e);
        if (n) {
          const o = t.GetCurrentSol();
          if (o.IsSelectAll() || o._GetOwnInstances().includes(n)) {
            if (t.IsFamily()) {
              if (n.GetObjectClass().BelongsToFamily(t)) return o.PickOne(n), t.ApplySolToContainer(), true;
            } else if (n.GetObjectClass() === t) return o.PickOne(n), t.ApplySolToContainer(), true;
          }
        }
        return false;
      }, PickByUID_Inverted2 = function(t, o) {
        const i = t.GetCurrentSol();
        if (i.IsSelectAll()) {
          i._SetSelectAll(false), i.ClearArrays();
          const n = t.GetInstances();
          for (let t2 = 0, e = n.length; t2 < e; ++t2) {
            const s = n[t2];
            s.GetUID() === o ? i._PushElseInstance(s) : i._PushInstance(s);
          }
          return t.ApplySolToContainer(), !!i._GetOwnInstances().length;
        }
        {
          const r = i._GetOwnInstances();
          let n = 0;
          for (let t2 = 0, e = r.length; t2 < e; ++t2) {
            const a = r[t2];
            (r[n] = a).GetUID() === o ? i._PushElseInstance(a) : ++n;
          }
          return C33.truncateArray(r, n), t.ApplySolToContainer(), !!r.length;
        }
      };
      GetInst = GetInst2, GetWorldInfo = GetWorldInfo2, GetInst_SDKv2 = GetInst_SDKv22, GetWorldInfo_SDKv2 = GetWorldInfo_SDKv22, CollMemory_Add = CollMemory_Add2, CollMemory_Remove = CollMemory_Remove2, CollMemory_RemoveInstance = CollMemory_RemoveInstance2, CollMemory_Get = CollMemory_Get2, DoOverlapCondition = DoOverlapCondition2, FinishCollisionConditionPicking = FinishCollisionConditionPicking2, FinishCollisionCondition = FinishCollisionCondition2, PickByUID_Normal = PickByUID_Normal2, PickByUID_Inverted = PickByUID_Inverted2;
      const C33 = self.C3, tempColor = new C33.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};
      let runtime = null;
      C33.CommonACES_SetRuntime = function(t) {
        runtime = t;
      };
      const IInstance = self.IInstance;
      SDKv1.CompareX = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetX(), t, e);
      }, SDKv2.CompareX = function(t, e) {
        return C33.compare(this.x, t, e);
      }, SDKv1.CompareY = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetY(), t, e);
      }, SDKv2.CompareY = function(t, e) {
        return C33.compare(this.y, t, e);
      }, SDKv1.IsOnScreen = function() {
        return this.GetWorldInfo().IsInViewport2();
      }, SDKv2.IsOnScreen = function() {
        return this.isOnScreen();
      }, AnySDK.IsOutsideLayout = function() {
        const t = GetWorldInfo2(this), e = t.GetLayout(), n = t.GetBoundingBox();
        return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();
      }, AnySDK.PickDistance = function(n, o, i) {
        const t = this.GetCurrentSol(), s = t.GetInstances();
        if (!s.length) return false;
        let r = s[0], a = r.GetWorldInfo(), l = r, c = C33.distanceSquared(a.GetX(), a.GetY(), o, i);
        for (let t2 = 1, e = s.length; t2 < e; ++t2) {
          r = s[t2], a = r.GetWorldInfo();
          const u = C33.distanceSquared(a.GetX(), a.GetY(), o, i);
          (0 === n && u < c || 1 === n && u > c) && (c = u, l = r);
        }
        return t.PickOne(l), true;
      }, SDKv1.SetX = function(t) {
        const e = this.GetWorldInfo();
        e.GetX() !== t && (e.SetX(t), e.SetBboxChanged());
      }, SDKv2.SetX = function(t) {
        this.x = +t;
      }, SDKv1.SetY = function(t) {
        const e = this.GetWorldInfo();
        e.GetY() !== t && (e.SetY(t), e.SetBboxChanged());
      }, SDKv2.SetY = function(t) {
        this.y = +t;
      }, SDKv1.SetPos = function(t, e) {
        const n = this.GetWorldInfo();
        n.EqualsXY(t, e) || (n.SetXY(t, e), n.SetBboxChanged());
      }, SDKv2.SetPos = function(t, e) {
        this.setPosition(t, e);
      }, AnySDK.SetPosToObject = function(t, e) {
        if (t) {
          const n = GetInst2(this), o = t.GetPairedInstance(n);
          if (o) {
            const [i, s] = o.GetImagePoint(e), r = n.GetWorldInfo();
            r.GetX() === i && r.GetY() === s || (r.SetXY(i, s), r.SetBboxChanged());
          }
        }
      }, AnySDK.MoveForward = function(t) {
        if (0 !== t) {
          const e = GetWorldInfo2(this);
          e.OffsetXY(e.GetCosAngle() * t, e.GetSinAngle() * t), e.SetBboxChanged();
        }
      }, SDKv1.MoveAtAngle = function(t, e) {
        if (0 !== e) {
          const n = this.GetWorldInfo();
          t = C33.toRadians(t), n.OffsetXY(Math.cos(t) * e, Math.sin(t) * e), n.SetBboxChanged();
        }
      }, SDKv2.MoveAtAngle = function(t, e) {
        0 !== e && (t = C33.toRadians(t), this.offsetPosition(Math.cos(t) * e, Math.sin(t) * e));
      }, SDKv1.GetX = function() {
        return this.GetWorldInfo().GetX();
      }, SDKv2.GetX = function() {
        return this.x;
      }, SDKv1.GetY = function() {
        return this.GetWorldInfo().GetY();
      }, SDKv2.GetY = function() {
        return this.y;
      }, AnySDK.GetDt = function() {
        return runtime.GetDt(GetInst2(this));
      }, SDKv1.CompareWidth = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetWidth(), t, e);
      }, SDKv2.CompareWidth = function(t, e) {
        return C33.compare(this.width, t, e);
      }, SDKv1.CompareHeight = function(t, e) {
        return C33.compare(this.GetWorldInfo().GetHeight(), t, e);
      }, SDKv2.CompareHeight = function(t, e) {
        return C33.compare(this.height, t, e);
      }, SDKv1.SetWidth = function(t) {
        const e = this.GetWorldInfo();
        e.GetWidth() !== t && (e.SetWidth(t), e.SetBboxChanged());
      }, SDKv2.SetWidth = function(t) {
        this.width = t;
      }, SDKv1.SetHeight = function(t) {
        const e = this.GetWorldInfo();
        e.GetHeight() !== t && (e.SetHeight(t), e.SetBboxChanged());
      }, SDKv2.SetHeight = function(t) {
        this.height = t;
      }, SDKv1.SetSize = function(t, e) {
        const n = GetWorldInfo2(this);
        n.GetWidth() === t && n.GetHeight() === e || (n.SetSize(t, e), n.SetBboxChanged());
      }, SDKv2.SetSize = function(t, e) {
        this.setSize(t, e);
      }, SDKv1.GetWidth = function() {
        return this.GetWorldInfo().GetWidth();
      }, SDKv2.GetWidth = function() {
        return this.width;
      }, SDKv1.GetHeight = function() {
        return this.GetWorldInfo().GetHeight();
      }, SDKv2.GetHeight = function() {
        return this.height;
      }, AnySDK.GetBboxLeft = function() {
        return GetWorldInfo2(this).GetBoundingBox().getLeft();
      }, AnySDK.GetBboxTop = function() {
        return GetWorldInfo2(this).GetBoundingBox().getTop();
      }, AnySDK.GetBboxRight = function() {
        return GetWorldInfo2(this).GetBoundingBox().getRight();
      }, AnySDK.GetBboxBottom = function() {
        return GetWorldInfo2(this).GetBoundingBox().getBottom();
      }, AnySDK.GetBboxMidX = function() {
        const t = GetWorldInfo2(this).GetBoundingBox();
        return (t.getLeft() + t.getRight()) / 2;
      }, AnySDK.GetBboxMidY = function() {
        const t = GetWorldInfo2(this).GetBoundingBox();
        return (t.getTop() + t.getBottom()) / 2;
      }, AnySDK.IsAngleWithin = function(t, e) {
        return C33.angleDiff(GetWorldInfo2(this).GetAngle(), C33.toRadians(e)) <= C33.toRadians(t);
      }, AnySDK.IsAngleClockwiseFrom = function(t) {
        return C33.angleClockwise(GetWorldInfo2(this).GetAngle(), C33.toRadians(t));
      }, AnySDK.IsBetweenAngles = function(t, e) {
        const n = C33.toRadians(t), o = C33.toRadians(e), i = GetWorldInfo2(this).GetAngle(), s = !C33.angleClockwise(o, n);
        return s ? !(!C33.angleClockwise(i, n) && C33.angleClockwise(i, o)) : C33.angleClockwise(i, n) && !C33.angleClockwise(i, o);
      }, SDKv1.SetAngle = function(t) {
        const e = this.GetWorldInfo(), n = C33.clampAngle(C33.toRadians(t));
        isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());
      }, SDKv2.SetAngle = function(t) {
        this.angleDegrees = t;
      }, AnySDK.RotateClockwise = function(t) {
        if (!isNaN(t) && 0 !== t) {
          const e = GetWorldInfo2(this);
          e.SetAngle(e.GetAngle() + C33.toRadians(t)), e.SetBboxChanged();
        }
      }, AnySDK.RotateCounterclockwise = function(t) {
        if (!isNaN(t) && 0 !== t) {
          const e = GetWorldInfo2(this);
          e.SetAngle(e.GetAngle() - C33.toRadians(t)), e.SetBboxChanged();
        }
      }, AnySDK.RotateTowardAngle = function(t, e) {
        const n = GetWorldInfo2(this), o = n.GetAngle(), i = C33.angleRotate(o, C33.toRadians(e), C33.toRadians(t));
        isNaN(i) || o === i || (n.SetAngle(i), n.SetBboxChanged());
      }, AnySDK.RotateTowardPosition = function(t, e, n) {
        const o = GetWorldInfo2(this), i = o.GetAngle(), s = e - o.GetX(), r = n - o.GetY(), a = Math.atan2(r, s), l = C33.angleRotate(i, a, C33.toRadians(t));
        isNaN(l) || i === l || (o.SetAngle(l), o.SetBboxChanged());
      }, AnySDK.SetTowardPosition = function(t, e) {
        const n = GetWorldInfo2(this), o = n.GetAngle(), i = t - n.GetX(), s = e - n.GetY(), r = Math.atan2(s, i);
        isNaN(r) || o === r || (n.SetAngle(r), n.SetBboxChanged());
      }, SDKv1.GetAngle = function() {
        return C33.toDegrees(this.GetWorldInfo().GetAngle());
      }, SDKv2.GetAngle = function() {
        return this.angleDegrees;
      }, AnySDK.CompareOpacity = function(t, e) {
        return C33.compare(C33.roundToDp(100 * GetWorldInfo2(this).GetOpacity(), 6), t, e);
      }, SDKv1.IsVisible = function() {
        return this.GetWorldInfo().IsVisible();
      }, SDKv2.IsVisible = function() {
        return this.isVisible;
      }, AnySDK.SetVisible = function(t) {
        const e = GetWorldInfo2(this);
        t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && (e.SetVisible(t), runtime.UpdateRender());
      }, AnySDK.SetOpacity = function(t) {
        const e = C33.clamp(t / 100, 0, 1), n = GetWorldInfo2(this);
        if (n.GetTransformWithParentOpacity()) {
          if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;
        } else if (n.GetOpacity() === e) return;
        n.SetOpacity(e), runtime.UpdateRender();
      }, AnySDK.SetDefaultColor = function(t) {
        tempColor.setFromRgbValue(t);
        const e = GetWorldInfo2(this);
        e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());
      }, AnySDK.GetColor = function() {
        const t = GetWorldInfo2(this).GetUnpremultipliedColor();
        return C33.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA());
      }, AnySDK.GetOpacity = function() {
        return C33.roundToDp(100 * GetWorldInfo2(this).GetOpacity(), 6);
      }, AnySDK.IsOnLayer = function(t) {
        return !!t && GetWorldInfo2(this).GetLayer() === t;
      }, AnySDK.PickTopBottom = function(n) {
        const t = this.GetCurrentSol(), o = t.GetInstances();
        if (!o.length) return false;
        let i = o[0], s = i;
        for (let t2 = 1, e = o.length; t2 < e; ++t2) {
          const i2 = o[t2], r = i2.GetWorldInfo(), a = s.GetWorldInfo(), l = r.GetLayer().GetIndex(), c = a.GetLayer().GetIndex();
          0 === n ? (c < l || l === c && r.GetZIndex() > a.GetZIndex()) && (s = i2) : (l < c || l === c && r.GetZIndex() < a.GetZIndex()) && (s = i2);
        }
        return t.PickOne(s), true;
      }, SDKv1.CompareZElevation = function(t, e, n) {
        const o = this.GetWorldInfo(), i = 0 === t ? o.GetZElevation() : o.GetTotalZElevation();
        return C33.compare(i, e, n);
      }, SDKv2.CompareZElevation = function(t, e, n) {
        const o = 0 === t ? this.zElevation : this.totalZElevation;
        return C33.compare(o, e, n);
      }, SDKv1.MoveToTop = function() {
        this.GetWorldInfo().ZOrderMoveToTop();
      }, SDKv2.MoveToTop = function() {
        this.moveToTop();
      }, SDKv1.MoveToBottom = function() {
        this.GetWorldInfo().ZOrderMoveToBottom();
      }, SDKv2.MoveToBottom = function() {
        this.moveToBottom();
      }, AnySDK.MoveToLayer = function(t) {
        t && GetWorldInfo2(this).ZOrderMoveToLayer(t);
      }, AnySDK.ZMoveToObject = function(t, e) {
        const n = 0 === t;
        if (e) {
          const o = GetInst2(this), i = e.GetFirstPicked(o);
          i && o.GetWorldInfo().ZOrderMoveAdjacentToInstance(i, n);
        }
      }, SDKv1.SetZElevation = function(t) {
        const e = this.GetWorldInfo();
        e.GetZElevation() !== t && (e.SetZElevation(t), runtime.UpdateRender());
      }, SDKv2.SetZElevation = function(t) {
        this.zElevation = t;
      }, AnySDK.LayerNumber = function() {
        return GetWorldInfo2(this).GetLayer().GetIndex();
      }, AnySDK.LayerName = function() {
        return GetWorldInfo2(this).GetLayer().GetName();
      }, SDKv1.ZIndex = function() {
        return this.GetWorldInfo().GetZIndex();
      }, SDKv2.ZIndex = function() {
        return this.zIndex;
      }, SDKv1.ZElevation = function() {
        return this.GetWorldInfo().GetZElevation();
      }, SDKv2.ZElevation = function() {
        return this.zElevation;
      }, SDKv1.TotalZElevation = function() {
        return this.GetWorldInfo().GetTotalZElevation();
      }, SDKv2.TotalZElevation = function() {
        return this.totalZElevation;
      }, AnySDK.IsEffectEnabled = function(t) {
        const e = GetInst2(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
        if (n) {
          const o = n.GetIndex(), i = e.GetWorldInfo().GetInstanceEffectList();
          return i.IsEffectIndexActive(o);
        }
      }, AnySDK.SetEffectEnabled = function(t, e) {
        const n = GetInst2(this), o = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
        if (o) {
          const i = o.GetIndex(), s = 1 === t, r = n.GetWorldInfo().GetInstanceEffectList();
          r.IsEffectIndexActive(i) !== s && (r.SetEffectIndexActive(i, s), r.UpdateActiveEffects(), runtime.UpdateRender());
        }
      }, AnySDK.SetEffectParam = function(t, e, n) {
        const o = GetInst2(this), i = o.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
        if (i) {
          e = Math.floor(e);
          const s = i.GetShaderProgram().GetParameterType(e);
          if (s) {
            "color" === s ? (tempColor.setFromRgbValue(n), n = tempColor) : "percent" === s && (n /= 100);
            const r = i.GetIndex(), a = o.GetWorldInfo().GetInstanceEffectList(), l = a.SetEffectParameter(r, e, n);
            l && a.IsEffectIndexActive(r) && runtime.UpdateRender();
          }
        }
      };
      const tempRect = C33.New(C33.Rect), tempCandidates1 = [], tempCandidates2 = [];
      let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;
      const rToPick = /* @__PURE__ */ new Set();
      function* DebugOnCollision(o) {
        if (o) {
          const t = this._runtime, i = t.GetCollisionEngine(), s = t.GetEventSheetManager(), r = s.GetEventStack(), a = s.GetCurrentCondition(), l = a.GetObjectClass(), c = a.GetSavedDataMap(), u = a.GetUnsavedDataMap(), S = r.GetCurrentStackFrame(), f = t.GetTickCount(), d = f - 1, G = S.GetCurrentEvent(), I = r.Push(G);
          let n = c.get("collmemory");
          n || (n = C33.New(C33.PairMap), c.set("collmemory", n)), u.get("collisionCreatedDestroyCallback") || (u.set("collisionCreatedDestroyCallback", true), t.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance2(n, t2.instance)));
          const h = l.GetCurrentSol(), C = o.GetCurrentSol(), m = h.GetInstances();
          let e = null;
          for (let t2 = 0; t2 < m.length; ++t2) {
            const g = m[t2];
            C.IsSelectAll() ? (i.GetCollisionCandidates(g.GetWorldInfo().GetLayer(), o, g.GetWorldInfo().GetBoundingBox(), tempCandidates1), e = tempCandidates1, i.AddRegisteredCollisionCandidates(g, o, e)) : e = C.GetInstances();
            for (let t3 = 0; t3 < e.length; ++t3) {
              const p = e[t3];
              if (i.TestOverlap(g, p) || i.CheckRegisteredCollision(g, p)) {
                const y = CollMemory_Get2(n, g, p);
                let t4 = false, e2 = -2;
                "number" == typeof y && (t4 = true, e2 = y);
                const D = !t4 || e2 < d;
                if (CollMemory_Add2(n, g, p, f), D) {
                  const A = G.GetSolModifiers(), v = (s.PushCopySol(A), l.GetCurrentSol()), K = o.GetCurrentSol();
                  if (v._SetSelectAll(false), K._SetSelectAll(false), l === o) {
                    const b = v._GetOwnInstances();
                    C33.clearArray(b), b.push(g), b.push(p), l.ApplySolToContainer();
                  } else {
                    const E = v._GetOwnInstances(), T = K._GetOwnInstances();
                    C33.clearArray(E), C33.clearArray(T), E.push(g), T.push(p), l.ApplySolToContainer(), o.ApplySolToContainer();
                  }
                  yield* G.DebugRetrigger(S, I), s.PopSol(A);
                }
              } else CollMemory_Remove2(n, g, p);
            }
            C33.clearArray(tempCandidates1);
          }
          r.Pop();
        }
        return false;
      }
      AnySDK.OnCollision = function(o) {
        if (this._runtime.IsDebugging()) return DebugOnCollision.call(this, o);
        if (o) {
          const t = this._runtime, i = t.GetCollisionEngine(), s = t.GetEventSheetManager(), r = s.GetEventStack(), a = s.GetCurrentCondition(), l = a.GetObjectClass(), c = a.GetSavedDataMap(), u = a.GetUnsavedDataMap(), S = r.GetCurrentStackFrame(), f = t.GetTickCount(), d = f - 1, G = S.GetCurrentEvent(), I = r.Push(G);
          let n = c.get("collmemory");
          n || (n = C33.New(C33.PairMap), c.set("collmemory", n)), u.get("collisionCreatedDestroyCallback") || (u.set("collisionCreatedDestroyCallback", true), t.Dispatcher().addEventListener("instancedestroy", (t2) => CollMemory_RemoveInstance2(n, t2.instance)));
          const h = l.GetCurrentSol(), C = o.GetCurrentSol(), m = h.GetInstances();
          let e = null;
          for (let t2 = 0; t2 < m.length; ++t2) {
            const g = m[t2];
            C.IsSelectAll() ? (i.GetCollisionCandidates(g.GetWorldInfo().GetLayer(), o, g.GetWorldInfo().GetBoundingBox(), tempCandidates1), e = tempCandidates1, i.AddRegisteredCollisionCandidates(g, o, e)) : e = C.GetInstances();
            for (let t3 = 0; t3 < e.length; ++t3) {
              const p = e[t3];
              if (i.TestOverlap(g, p) || i.CheckRegisteredCollision(g, p)) {
                const y = CollMemory_Get2(n, g, p);
                let t4 = false, e2 = -2;
                "number" == typeof y && (t4 = true, e2 = y);
                const D = !t4 || e2 < d;
                if (CollMemory_Add2(n, g, p, f), D) {
                  const A = G.GetSolModifiers(), v = (s.PushCopySol(A), l.GetCurrentSol()), K = o.GetCurrentSol();
                  if (v._SetSelectAll(false), K._SetSelectAll(false), l === o) {
                    const b = v._GetOwnInstances();
                    C33.clearArray(b), b.push(g), b.push(p), l.ApplySolToContainer();
                  } else {
                    const E = v._GetOwnInstances(), T = K._GetOwnInstances();
                    C33.clearArray(E), C33.clearArray(T), E.push(g), T.push(p), l.ApplySolToContainer(), o.ApplySolToContainer();
                  }
                  G.Retrigger(S, I), s.PopSol(A);
                }
              } else CollMemory_Remove2(n, g, p);
            }
            C33.clearArray(tempCandidates1);
          }
          r.Pop();
        }
        return false;
      }, AnySDK.IsOverlapping = function(t) {
        return DoOverlapCondition2(GetInst2(this), t, 0, 0);
      }, AnySDK.IsOverlappingOffset = function(t, e, n) {
        return DoOverlapCondition2(GetInst2(this), t, e, n);
      }, AnySDK.HasParent = function() {
        return GetWorldInfo2(this).HasParent();
      }, AnySDK.HasChildren = function() {
        return GetWorldInfo2(this).HasChildren();
      }, AnySDK.PickParent = function(n, o) {
        const t = this.GetCurrentSol(), i = t.GetInstances();
        if (0 === i.length) return false;
        const e = n.GetCurrentSol();
        let s = e.GetInstances();
        if (e.IsSelectAll()) {
          const l = [...this._runtime.instancesPendingCreateForObjectClass(n)];
          0 < l.length && (s = s.concat(l));
        }
        if (0 === s.length) return false;
        const r = e.IsSelectAll() ? null : new Set(s), a = /* @__PURE__ */ new Set();
        for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {
          const c = i[t2];
          if (1 === o) for (const u of c.parents()) u.BelongsToObjectClass(n) && (null === r || r.has(u)) && a.add(u);
          else {
            let t3;
            if (0 === o) {
              if (null === (t3 = c.GetParent())) continue;
            } else t3 = c.GetTopParent();
            t3.BelongsToObjectClass(n) && (null === r || r.has(t3)) && a.add(t3);
          }
        }
        return 0 !== a.size && (e.SetSetPicked(a), n.ApplySolToContainer(), true);
      }, AnySDK.PickChildren = function(n, o) {
        const t = this.GetCurrentSol(), i = t.GetInstances();
        if (0 === i.length) return false;
        const e = n.GetCurrentSol();
        let s = e.GetInstances();
        if (e.IsSelectAll()) {
          const l = [...this._runtime.instancesPendingCreateForObjectClass(n)];
          0 < l.length && (s = s.concat(l));
        }
        if (0 === s.length) return false;
        const r = e.IsSelectAll() ? null : new Set(s), a = /* @__PURE__ */ new Set();
        for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {
          const c = i[t2];
          2 !== o || c.HasChildren() || !c.BelongsToObjectClass(n) || null !== r && !r.has(c) || a.add(c);
          for (const u of 0 === o ? c.children() : c.allChildren()) 2 === o && u.HasChildren() || u.BelongsToObjectClass(n) && (null === r || r.has(u)) && a.add(u);
        }
        return 0 !== a.size && (e.SetSetPicked(a), n.ApplySolToContainer(), true);
      }, AnySDK.PickNthChild = function(n, o, i) {
        const t = this.GetCurrentSol(), s = t.GetInstances();
        if (0 === s.length) return false;
        const e = n.GetCurrentSol();
        let r = e.GetInstances();
        if (e.IsSelectAll()) {
          const c = [...this._runtime.instancesPendingCreateForObjectClass(n)];
          0 < c.length && (r = r.concat(c));
        }
        if (0 === r.length) return false;
        const a = e.IsSelectAll() ? null : new Set(r), l = [];
        for (let t2 = 0, e2 = s.length; t2 < e2; ++t2) {
          const u = s[t2];
          if (0 === o) {
            const S = u.GetChildAt(i);
            null !== S && S.BelongsToObjectClass(n) && (null === a || a.has(S)) && l.push(S);
          } else if (1 === o) {
            for (const f of u.children()) if (f.BelongsToObjectClass(n)) {
              if (0 === i) {
                null !== a && !a.has(f) || l.push(f);
                break;
              }
              --i;
            }
          }
        }
        return 0 !== l.length && (e.SetArrayPicked(l), n.ApplySolToContainer(), true);
      }, AnySDK.CompareChildCount = function(t, e, n) {
        const o = GetInst2(this);
        switch (t) {
          case 0:
          default:
            return C33.compare(o.GetChildCount(), e, n);
          case 1:
            return C33.compare(o.GetAllChildCount(), e, n);
        }
      }, AnySDK.AddChild = function(t, e, n, o, i, s, r, a, l, c) {
        const u = GetInst2(this), S = runtime.GetCurrentAction().GetObjectClass();
        for (const f of t.allCorrespondingInstances(u, S)) {
          if (!f.GetPlugin().SupportsSceneGraph()) return;
          u.AddChild(f, { transformX: e, transformY: n, transformWidth: o, transformHeight: i, transformAngle: s, transformOpacity: r, transformZElevation: a, transformVisibility: l, destroyWithParent: c });
        }
      }, AnySDK.RemoveChild = function(t) {
        const e = GetInst2(this), n = runtime.GetCurrentAction().GetObjectClass();
        for (const o of t.allCorrespondingInstances(e, n)) e.RemoveChild(o);
      }, AnySDK.RemoveFromParent = function() {
        const t = GetInst2(this);
        if (t.HasParent()) {
          const e = t.GetParent();
          e.RemoveChild(t);
        }
      }, AnySDK.ChildCount = function() {
        return GetInst2(this).GetChildCount();
      }, AnySDK.AllChildCount = function() {
        return GetInst2(this).GetAllChildCount();
      }, AnySDK.SetMeshSize = function(t, e) {
        t = Math.floor(t), e = Math.floor(e);
        const n = GetWorldInfo2(this);
        t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t, e);
      }, AnySDK.SetMeshPoint = function(t, e, n, o, i, s, r, a) {
        const l = GetWorldInfo2(this), c = l.SetMeshPoint(t, e, { mode: 0 === n ? "absolute" : "relative", x: o, y: i, zElevation: s, u: r, v: a });
        c && l.SetBboxChanged();
      }, AnySDK.MeshColumns = function() {
        const t = GetWorldInfo2(this);
        return t.HasMesh() ? t.GetSourceMesh().GetHSize() : 0;
      }, AnySDK.MeshRows = function() {
        const t = GetWorldInfo2(this);
        return t.HasMesh() ? t.GetSourceMesh().GetVSize() : 0;
      }, AnySDK.SetElementVisible = function(t) {
        const e = GetWorldInfo2(this);
        t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && e.SetVisible(t);
      }, AnySDK.SetElementCSSStyle = function(t, e) {
        this instanceof self.IInstance ? this.setElementCSSStyle(t, e) : this.SetElementCSSStyle(t, e);
      }, AnySDK.SetElementAttribute = function(t, e) {
        this instanceof self.IInstance ? this.setElementAttribute(t, "" + e) : this.SetElementAttribute(t, "" + e);
      }, AnySDK.RemoveElementAttribute = function(t) {
        this instanceof self.IInstance ? this.removeElementAttribute(t) : this.RemoveElementAttribute(t);
      }, AnySDK.SetElementFocus = function() {
        this instanceof self.IInstance ? this.focusElement() : this.FocusElement();
      }, AnySDK.SetElementBlur = function() {
        this instanceof self.IInstance ? this.blurElement() : this.BlurElement();
      }, AnySDK.IsElementFocused = function() {
        return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();
      }, AnySDK.SetElementEnabled = function(t) {
        this instanceof self.IInstance ? this._setEnabled(0 !== t) : this._SetEnabled(0 !== t);
      }, AnySDK.IsElementEnabled = function() {
        return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();
      }, SDKv1.CompareInstanceVar = function(t, e, n) {
        return C33.compare(this.GetInstance().GetInstanceVariableValue(t), e, n);
      }, SDKv2.CompareInstanceVar = function(t, e, n) {
        return C33.compare(GetInst_SDKv22(this).GetInstanceVariableValue(t), e, n);
      }, SDKv1.IsBoolInstanceVarSet = function(t) {
        return !!this.GetInstance().GetInstanceVariableValue(t);
      }, SDKv2.IsBoolInstanceVarSet = function(t) {
        return !!GetInst_SDKv22(this).GetInstanceVariableValue(t);
      }, AnySDK.PickInstVarHiLow = function(n, o) {
        const t = this.GetCurrentSol(), i = t.GetInstances();
        if (!i.length) return false;
        const s = this.IsFamily();
        let r = null, a = 0;
        for (let t2 = 0, e = i.length; t2 < e; ++t2) {
          const l = i[t2], c = s ? l.GetObjectClass().GetFamilyInstanceVariableOffset(this.GetFamilyIndex()) : 0, u = l.GetInstanceVariableValue(c + o);
          (null === r || 0 === n && u < a || 1 === n && u > a) && (a = u, r = l);
        }
        return t.PickOne(r), true;
      }, AnySDK.PickByUID = function(t) {
        return (this._runtime.GetCurrentCondition().IsInverted() ? PickByUID_Inverted2 : PickByUID_Normal2)(this, t);
      }, AnySDK.HasTags = function(t) {
        const e = new Set(C33.splitStringAndNormalize(t)), n = GetInst2(this).GetTagsSet();
        return e.isSubsetOf(n);
      }, AnySDK.Tags = function() {
        return GetInst2(this).GetTagsString();
      }, AnySDK.TagsCount = function() {
        return GetInst2(this).GetTagsSet().size;
      }, AnySDK.TagAt = function(t) {
        return GetInst2(this).GetTagAt(t);
      }, AnySDK.ChangeTags = function(t, e) {
        const n = C33.splitStringAndNormalize(e);
        if (0 !== n.length) {
          const o = GetInst2(this), i = new Set(o.GetTagsSet());
          if (0 === t) for (const s of n) i.add(s);
          else if (1 === t) for (const r of n) i.delete(r);
          o.SetTagsSet(i);
        }
      }, AnySDK.Destroy = function() {
        runtime.DestroyInstance(GetInst2(this));
      }, AnySDK.OnCreated = function() {
        return true;
      }, AnySDK.OnDestroyed = function() {
        return true;
      }, SDKv1.SetInstanceVar = function(t, e) {
        this.GetInstance().SetInstanceVariableValue(t, e);
      }, SDKv2.SetInstanceVar = function(t, e) {
        GetInst_SDKv22(this).SetInstanceVariableValue(t, e);
      }, SDKv1.AddInstanceVar = function(t, e) {
        const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);
        "number" == typeof o && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);
      }, SDKv2.AddInstanceVar = function(t, e) {
        const n = GetInst_SDKv22(this), o = n.GetInstanceVariableValue(t);
        "number" == typeof o && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);
      }, SDKv1.SubInstanceVar = function(t, e) {
        const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);
        "number" == typeof o && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));
      }, SDKv2.SubInstanceVar = function(t, e) {
        const n = GetInst_SDKv22(this), o = n.GetInstanceVariableValue(t);
        "number" == typeof o && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));
      }, SDKv1.SetBoolInstanceVar = function(t, e) {
        this.GetInstance().SetInstanceVariableValue(t, e ? 1 : 0);
      }, SDKv2.SetBoolInstanceVar = function(t, e) {
        GetInst_SDKv22(this).SetInstanceVariableValue(t, e ? 1 : 0);
      }, SDKv1.ToggleBoolInstanceVar = function(t) {
        const e = this.GetInstance();
        e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
      }, SDKv2.ToggleBoolInstanceVar = function(t) {
        const e = GetInst_SDKv22(this);
        e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);
      }, AnySDK.LoadFromJsonString = function(t) {
        let e;
        try {
          e = JSON.parse(t);
        } catch (t2) {
          return void console.error("Failed to load from JSON string: ", t2);
        }
        const n = GetInst2(this), o = "state";
        runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o), n.LoadFromJson(e, o), runtime.DoAfterLoad(o, { setFromJson: true });
      }, AnySDK.AsJSON = function() {
        return JSON.stringify(GetInst2(this).SaveToJson("state"));
      }, AnySDK.ObjectTypeName = function() {
        return GetInst2(this).GetObjectClass().GetName();
      }, AnySDK.Count = function() {
        const t = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let e = t.GetInstanceCount();
        for (const n of runtime.instancesPendingCreateForObjectClass(t)) ++e;
        return e;
      }, AnySDK.PickedCount = function() {
        return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;
      }, SDKv1.GetIID = function() {
        return this.GetInstance().GetIID();
      }, SDKv2.GetIID = function() {
        return GetInst_SDKv22(this).GetIID();
      }, SDKv1.GetUID = function() {
        return this.GetInstance().GetUID();
      }, SDKv2.GetUID = function() {
        return GetInst_SDKv22(this).GetUID();
      }, AnySDK.OnInstanceSignal = function(t) {
        const e = GetInst2(this);
        return t.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);
      }, AnySDK.InstanceSignal = function(t) {
        const e = GetInst2(this);
        runtime.GetEventSheetManager().InstanceSignal(e, t);
      }, AnySDK.InstanceWaitForSignal = function(t) {
        return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(this.GetCurrentSol().GetInstances(), t), true;
      }, AnySDK.TemplateName = function() {
        return GetInst2(this).GetTemplateName();
      }, C33.AddCommonACEs = function(t, e, n) {
        const o = t[1], i = t[3], s = t[4], r = t[5], a = t[6], l = t[7], c = t[8], u = t[10], S = t[11], f = t[12], d = t[13], G = t[14], I = t[15], h = t[16], C = e.Cnds, m = e.Acts, g = e.Exps, p = Object.assign({}, AnySDK, 2 <= n ? SDKv2 : SDKv1);
        i && (C.CompareX = p.CompareX, C.CompareY = p.CompareY, C.IsOnScreen = p.IsOnScreen, C.IsOutsideLayout = p.IsOutsideLayout, C.PickDistance = p.PickDistance, m.SetX = p.SetX, m.SetY = p.SetY, m.SetPos = p.SetPos, m.SetPosToObject = p.SetPosToObject, m.MoveForward = p.MoveForward, m.MoveAtAngle = p.MoveAtAngle, g.X = p.GetX, g.Y = p.GetY, g.dt = p.GetDt), s && (C.CompareWidth = p.CompareWidth, C.CompareHeight = p.CompareHeight, m.SetWidth = p.SetWidth, m.SetHeight = p.SetHeight, m.SetSize = p.SetSize, g.Width = p.GetWidth, g.Height = p.GetHeight, g.BBoxLeft = p.GetBboxLeft, g.BBoxTop = p.GetBboxTop, g.BBoxRight = p.GetBboxRight, g.BBoxBottom = p.GetBboxBottom, g.BBoxMidX = p.GetBboxMidX, g.BBoxMidY = p.GetBboxMidY), r && (C.AngleWithin = p.IsAngleWithin, C.IsClockwiseFrom = p.IsAngleClockwiseFrom, C.IsBetweenAngles = p.IsBetweenAngles, m.SetAngle = p.SetAngle, m.RotateClockwise = p.RotateClockwise, m.RotateCounterclockwise = p.RotateCounterclockwise, m.RotateTowardAngle = p.RotateTowardAngle, m.RotateTowardPosition = p.RotateTowardPosition, m.SetTowardPosition = p.SetTowardPosition, g.Angle = p.GetAngle), a && (C.IsVisible = p.IsVisible, C.CompareOpacity = p.CompareOpacity, m.SetVisible = p.SetVisible, m.SetOpacity = p.SetOpacity, m.SetDefaultColor = p.SetDefaultColor, g.Opacity = p.GetOpacity, g.ColorValue = p.GetColor), l && (C.IsOnLayer = p.IsOnLayer, C.PickTopBottom = p.PickTopBottom, C.CompareZElevation = p.CompareZElevation, m.MoveToTop = p.MoveToTop, m.MoveToBottom = p.MoveToBottom, m.MoveToLayer = p.MoveToLayer, m.ZMoveToObject = p.ZMoveToObject, m.SetZElevation = p.SetZElevation, g.LayerNumber = p.LayerNumber, g.LayerName = p.LayerName, g.ZIndex = p.ZIndex, g.ZElevation = p.ZElevation, g.TotalZElevation = p.TotalZElevation), c && (C.IsEffectEnabled = p.IsEffectEnabled, m.SetEffectEnabled = p.SetEffectEnabled, m.SetEffectParam = p.SetEffectParam), d && (C.HasParent = p.HasParent, C.HasChildren = p.HasChildren, C.PickParent = p.PickParent, C.PickChildren = p.PickChildren, C.PickNthChild = p.PickNthChild, C.CompareChildCount = p.CompareChildCount, m.AddChild = p.AddChild, m.RemoveChild = p.RemoveChild, m.RemoveFromParent = p.RemoveFromParent, g.ChildCount = p.ChildCount, g.AllChildCount = p.AllChildCount), G && (m.SetMeshSize = p.SetMeshSize, m.SetMeshPoint = p.SetMeshPoint, g.MeshColumns = p.MeshColumns, g.MeshRows = p.MeshRows), u && (C.IsVisible = p.IsVisible, m.SetVisible = p.SetElementVisible, m.SetCSSStyle = p.SetElementCSSStyle, m.SetElemAttribute = p.SetElementAttribute, m.RemoveElemAttribute = p.RemoveElementAttribute), S && (C.IsFocused = p.IsElementFocused, m.SetFocus = p.SetElementFocus, m.SetBlur = p.SetElementBlur), f && (C.IsEnabled = p.IsElementEnabled, m.SetEnabled = p.SetElementEnabled), I && (C.OnCollision = p.OnCollision, C.IsOverlapping = p.IsOverlapping, C.IsOverlappingOffset = p.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition2), o || (C.CompareInstanceVar = p.CompareInstanceVar, C.IsBoolInstanceVarSet = p.IsBoolInstanceVarSet, C.PickInstVarHiLow = p.PickInstVarHiLow, C.PickByUID = p.PickByUID, C.HasTags = p.HasTags, m.SetInstanceVar = p.SetInstanceVar, m.AddInstanceVar = p.AddInstanceVar, m.SubInstanceVar = p.SubInstanceVar, m.SetBoolInstanceVar = p.SetBoolInstanceVar, m.ToggleBoolInstanceVar = p.ToggleBoolInstanceVar, m.ChangeTags = p.ChangeTags, C.OnCreated = p.OnCreated, C.OnDestroyed = p.OnDestroyed, m.Destroy = p.Destroy, m.LoadFromJsonString || (m.LoadFromJsonString = p.LoadFromJsonString), g.AsJSON || (g.AsJSON = p.AsJSON), g.Count = p.Count, g.PickedCount = p.PickedCount, g.IID = p.GetIID, g.UID = p.GetUID, g.ObjectTypeName = p.ObjectTypeName, g.Tags = p.Tags, g.TagsCount = p.TagsCount, g.TagAt = p.TagAt, C.OnInstanceSignal = p.OnInstanceSignal, m.InstanceSignal = p.InstanceSignal, m.InstanceWaitForSignal = p.InstanceWaitForSignal), h && (g.TemplateName = p.TemplateName);
      };
    }
    var GetInst;
    var GetWorldInfo;
    var GetInst_SDKv2;
    var GetWorldInfo_SDKv2;
    var CollMemory_Add;
    var CollMemory_Remove;
    var CollMemory_RemoveInstance;
    var CollMemory_Get;
    var DoOverlapCondition;
    var FinishCollisionConditionPicking;
    var FinishCollisionCondition;
    var PickByUID_Normal;
    var PickByUID_Inverted;
    {
      const C33 = self.C3;
      C33.ScheduledWait = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._eventSheetManager = t, this._type = "", this._time = -1, this._signalTag = "", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;
        }
        Release() {
          this._type = "", this._time = -1, this._signalTag = "", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C33.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);
          for (const t of this._sols.values()) t.Release();
          this._sols.clear(), this._pendingInstances = null;
        }
        _Init() {
          const t = this._eventSheetManager, e = t.GetRuntime().GetAllObjectClasses(), s = t.GetCurrentEventStackFrame(), n = (this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1, t.FindFirstFunctionBlockParent(this._event));
          n && (this._callingFunctionBlock = n, this._functionParameters = n.CaptureFunctionParameters(), this._functionInnerLocalVars = n._GetAllInnerLocalVariables().map((t2) => t2.GetValue()), n.IsAsync()) && (this._asyncId = n.PauseCurrentAsyncFunction());
          for (const a of e) {
            const l = a.GetCurrentSol();
            l.IsSelectAll() && !this._event.HasSolModifier(a) || (this._solModifiers.push(a), this._sols.set(a, C33.New(C33.SolState, l)));
          }
          const i = t.GetDynamicSolModifiersSet();
          this._dynamicSolModifiers = 0 < i.size ? i : null;
        }
        InitTimer(t) {
          this._type = "timer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t;
        }
        InitSignal(t) {
          this._type = "signal", this._Init(), this._signalTag = t.toLowerCase();
        }
        InitInstanceSignals(t, e) {
          this._type = "instance-signals", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t);
        }
        InitPromise(t) {
          this._type = "promise", this._Init(), t.then(() => this.SetSignalled()).catch((t2) => {
            console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t2), this.SetSignalled();
          });
        }
        IsTimer() {
          return "timer" === this._type;
        }
        IsSignal() {
          return "signal" === this._type;
        }
        IsInstanceSignals() {
          return "instance-signals" === this._type;
        }
        IsPromise() {
          return "promise" === this._type;
        }
        GetSignalTag() {
          return this._signalTag;
        }
        IsSignalled() {
          return this._isSignalled;
        }
        SetSignalled() {
          this._isSignalled = true;
        }
        SetInstanceSignalled(t) {
          this._pendingInstances.delete(t), 0 === this._pendingInstances.size && this.SetSignalled();
        }
        _ShouldRun() {
          return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled();
        }
        _RestoreState(t) {
          t._Restore(this._event, this._actIndex);
          for (const [s, n] of this._sols.entries()) {
            const i = s.GetCurrentSol();
            n._Restore(i);
          }
          this._dynamicSolModifiers && t.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
          const e = this._callingFunctionBlock;
          e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t2, e2) => t2.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync()) && e.ResumeAsyncFunction(this._asyncId);
        }
        _Run(t) {
          this._RestoreState(t), this._event._ResumeActionsAndSubEvents(t), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
        }
        async _DebugRun(t) {
          this._RestoreState(t);
          for (const e of this._event._DebugResumeActionsAndSubEvents(t)) await this._eventSheetManager.GetRuntime().DebugBreak(e);
          this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
        }
        ShouldRelease() {
          return this._shouldRelease;
        }
        RemoveInstances(t) {
          for (const e of this._sols.values()) e.RemoveInstances(t);
          if ("instance-signals" === this._type) {
            for (const s of t) this._pendingInstances.delete(s);
            0 === this._pendingInstances.size && this.SetSignalled();
          }
        }
        _SaveToJson() {
          const t = {}, e = { "wt": this._type, "t": this._time, "st": this._signalTag, "s": this._isSignalled, "ev": this._event.GetSID(), "sm": this._solModifiers.map((t2) => t2.GetSID()), "dsm": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t2) => t2.GetSID()) : null, "sols": t };
          this._event._HasActionIndex(this._actIndex) && (e["act"] = this._event.GetActionAt(this._actIndex).GetSID());
          for (const [s, n] of this._sols) t[s.GetSID().toString()] = n._SaveToJson();
          return "instance-signals" === this._type && (e["pi"] = [...this._pendingInstances].map((t2) => t2.GetUID())), e;
        }
        static _CreateFromJson(t, e) {
          const s = t.GetRuntime(), n = t.GetEventBlockBySID(e["ev"]);
          if (!n) return null;
          let i = 0;
          if (e.hasOwnProperty("act")) {
            const l = t.GetActionBySID(e["act"]);
            if (!l) return null;
            i = l.GetIndex();
          }
          const a = C33.New(C33.ScheduledWait, t);
          a._time = e["t"], e.hasOwnProperty("wt") ? a._type = e["wt"] : a._type = -1 === a._time ? "signal" : "timer", a._signalTag = e["st"], a._isSignalled = e["s"], a._event = n, a._actIndex = i;
          for (const o of e["sm"]) {
            const c = s.GetObjectClassBySID(o);
            c && a._solModifiers.push(c);
          }
          if (Array.isArray(e["dsm"])) for (const r of e["dsm"]) {
            const _ = s.GetObjectClassBySID(r);
            _ && (a._dynamicSolModifiers || (a._dynamicSolModifiers = /* @__PURE__ */ new Set()), a._dynamicSolModifiers.add(_));
          }
          for (const [h, d] of Object.entries(e["sols"])) {
            const u = parseInt(h, 10), S = s.GetObjectClassBySID(u);
            if (S) {
              const g = C33.New(C33.SolState, null);
              g._LoadFromJson(t, d), a._sols.set(S, g);
            }
          }
          if ("instance-signals" === a._type) {
            a._pendingInstances = /* @__PURE__ */ new Set();
            for (const I of e["pi"]) {
              const m = s.GetInstanceByUID(I);
              m && a._pendingInstances.add(m);
            }
          }
          return a;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SolState = class extends C33.DefendedBase {
        constructor(s) {
          super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s && (this._objectClass = s.GetObjectClass(), this._isSelectAll = s.IsSelectAll(), C33.shallowAssignArray(this._instances, s._GetOwnInstances()));
        }
        Release() {
          this._objectClass = null, C33.clearArray(this._instances);
        }
        _Restore(s) {
          s._SetSelectAll(this._isSelectAll), C33.shallowAssignArray(s._GetOwnInstances(), this._instances);
        }
        RemoveInstances(s) {
          C33.arrayRemoveAllInSet(this._instances, s);
        }
        _SaveToJson() {
          return { "sa": this._isSelectAll, "insts": this._instances.map((s) => s.GetUID()) };
        }
        _LoadFromJson(s, e) {
          const t = s.GetRuntime();
          this._isSelectAll = !!e["sa"], C33.clearArray(this._instances);
          for (const n of e["insts"]) {
            const l = t.GetInstanceByUID(n);
            l && this._instances.push(l);
          }
        }
      };
    }
    {
      let GetNextParamMap2 = function(e, t) {
        let s = e.get(t);
        return s || (s = /* @__PURE__ */ new Map(), e.set(t, s)), s;
      };
      GetNextParamMap = GetNextParamMap2;
      const C33 = self.C3;
      C33.SDKPluginBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e.runtime, this._isSingleGlobal = !!e.isSingleGlobal, this._isWorldType = !!e.isWorld, this._isRotatable = !!e.isRotatable, this._mustPredraw = !!e.mustPredraw, this._hasEffects = !!e.hasEffects, this._supportsSceneGraph = !!e.supportsSceneGraph, this._supportsMesh = !!e.supportsMesh, this._isHTMLElementType = !!e.isHTMLElementType, this._is3d = !!e.is3d, this._sdkVersion = e.sdkVersion, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = e.scriptInterfaceClass, this._iPlugin = null;
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        OnCreate() {
        }
        GetConstructor() {
          return (2 <= this.GetSdkVersion() ? this._iPlugin : this).constructor;
        }
        GetSdkVersion() {
          return this._sdkVersion;
        }
        GetScriptInterfaceClass(e = false) {
          let t = this._scriptInterfaceClass;
          return t = e && "function" != typeof t && 2 <= this.GetSdkVersion() ? globalThis.ISDKPluginBase : t;
        }
        IsSingleGlobal() {
          return this._isSingleGlobal;
        }
        IsWorldType() {
          return this._isWorldType;
        }
        IsHTMLElementType() {
          return this._isHTMLElementType;
        }
        Is3D() {
          return this._is3d;
        }
        IsRotatable() {
          return this._isRotatable;
        }
        MustPreDraw() {
          return this._mustPredraw;
        }
        HasEffects() {
          return this._hasEffects;
        }
        SupportsSceneGraph() {
          return this._supportsSceneGraph;
        }
        SupportsMesh() {
          return this._supportsMesh;
        }
        _GetBoundACEMethod(e, t) {
          if (!t) throw new Error("missing 'this' binding");
          let s = this._boundACEMethodCache.get(e);
          return s || (s = e.bind(t), this._boundACEMethodCache.set(e, s)), s;
        }
        _GetBoundACEMethod_1param(e, t, s) {
          if (!t) throw new Error("missing 'this' binding");
          const i = GetNextParamMap2(this._boundACEMethodCache_1param, e);
          let n = i.get(s);
          return n || (n = e.bind(t, s), i.set(s, n)), n;
        }
        _GetBoundACEMethod_2params(e, t, s, i) {
          if (!t) throw new Error("missing 'this' binding");
          const n = GetNextParamMap2(this._boundACEMethodCache_2params, e), r = GetNextParamMap2(n, s);
          let a = r.get(i);
          return a || (a = e.bind(t, s, i), r.set(i, a)), a;
        }
        _GetBoundACEMethod_3params(e, t, s, i, n) {
          if (!t) throw new Error("missing 'this' binding");
          const r = GetNextParamMap2(this._boundACEMethodCache_3params, e), a = GetNextParamMap2(r, s), l = GetNextParamMap2(a, i);
          let o = l.get(n);
          return o || (o = e.bind(t, s, i, n), l.set(n, o)), o;
        }
        _SetSingleGlobalObjectClass(e) {
          if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
          this._singleGlobalObjectClass = e;
        }
        GetSingleGlobalObjectClass() {
          if (this.IsSingleGlobal()) return this._singleGlobalObjectClass;
          throw new Error("must be single-global plugin");
        }
        GetSingleGlobalInstance() {
          if (this.IsSingleGlobal()) return this._singleGlobalObjectClass.GetSingleGlobalInstance();
          throw new Error("must be single-global plugin");
        }
        _InitScriptInterface() {
          const e = this.GetSdkVersion(), t = (C33.AddonManager._PushInitObject(this, e), this.GetScriptInterfaceClass(true));
          if (t) {
            if (this._iPlugin = new t(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError("plugin class must derive from IPlugin");
          } else this._iPlugin = new self.IPlugin();
          C33.AddonManager._PopInitObject(e);
        }
        GetIPlugin() {
          return this._iPlugin;
        }
      };
    }
    var GetNextParamMap;
    {
      const C33 = self.C3;
      C33.SDKDOMPluginBase = class extends C33.SDKPluginBase {
        constructor(e, s) {
          super(e), this._domComponentId = s, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler("elem-focused", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler("elem-blurred", (e2) => {
            e2 && e2._OnElemBlurred();
          });
        }
        Release() {
          super.Release();
        }
        _AddElement(e) {
          const s = this._nextElementId++;
          return this._instMap.set(s, e), s;
        }
        _RemoveElement(e) {
          this._instMap.delete(e);
        }
        AddElementMessageHandler(e, t) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {
            const s = this._instMap.get(e2["elementId"]);
            t(s, e2);
          });
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKTypeBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
        }
        Release() {
          this._objectClass = null, this._runtime = null, this._plugin = null;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetPlugin() {
          return this._plugin;
        }
        GetImageInfo() {
          return this._objectClass.GetImageInfo();
        }
        OnCreate() {
        }
        FinishCondition(e) {
        }
        BeforeRunAction(e) {
        }
        AfterRunAction(e) {
        }
        LoadTextures(e) {
        }
        ReleaseTextures() {
        }
        OnDynamicTextureLoadComplete() {
        }
        PreloadTexturesWithInstances(e) {
        }
        LoadTilemapData() {
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(e, t, s) {
          const n = C33.New(C33.Event, e, t);
          n.objectClass = this, s && Object.assign(n, s), this.GetObjectClass().DispatchUserScriptEvent(n);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKInstanceBase = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._inst = e, this._domComponentId = t, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;
        }
        Release() {
          this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;
        }
        WasReleased() {
          return this._wasReleased;
        }
        GetInstance() {
          return this._inst;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetPlugin() {
          return this._sdkType.GetPlugin();
        }
        GetSdkType() {
          return this._sdkType;
        }
        GetScriptInterface() {
          return this._inst.GetInterfaceClass();
        }
        Trigger(e) {
          return this._runtime.Trigger(e, this._inst, null);
        }
        DebugTrigger(e) {
          return this._runtime.DebugTrigger(e, this._inst, null);
        }
        TriggerAsync(e) {
          return this._runtime.TriggerAsync(e, this._inst, null);
        }
        FastTrigger(e, t) {
          return this._runtime.FastTrigger(e, this._inst, t);
        }
        DebugFastTrigger(e, t) {
          return this._runtime.DebugFastTrigger(e, this._inst, t);
        }
        ScheduleTriggers(e) {
          return this._runtime.ScheduleTriggers(e);
        }
        AddDOMMessageHandler(e, t) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t);
        }
        AddDOMMessageHandlers(e) {
          for (const [t, s] of e) this.AddDOMMessageHandler(t, s);
        }
        PostToDOM(e, t) {
          this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t);
        }
        PostToDOMAsync(e, t) {
          return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t);
        }
        _PostToDOMMaybeSync(e, t) {
          if (!this._runtime.IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this._domComponentId, "handler": e, "data": t, "responseId": null });
          this.PostToDOM(e, t);
        }
        SetWrapperExtensionComponentId(e) {
          if (!e) throw new Error("cannot set empty component id");
          this._wrapperComponentId = e;
        }
        IsWrapperExtensionAvailable() {
          if (this._wrapperComponentId) return this._runtime.HasWrapperComponentId(this._wrapperComponentId);
          throw new Error("wrapper extension component id not set");
        }
        AddWrapperExtensionMessageHandler(e, t) {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t);
        }
        AddWrapperExtensionMessageHandlers(e) {
          for (const [t, s] of e) this.AddWrapperExtensionMessageHandler(t, s);
        }
        SendWrapperExtensionMessage(e, t) {
          if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
          this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t);
        }
        SendWrapperExtensionMessageAsync(e, t) {
          if (this._wrapperComponentId) return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t);
          throw new Error("wrapper extension component id not set");
        }
        Tick() {
        }
        Tick2() {
        }
        _StartTicking() {
          this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = true);
        }
        _StopTicking() {
          this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = false);
        }
        IsTicking() {
          return this._isTicking;
        }
        _StartTicking2() {
          this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = true);
        }
        _StopTicking2() {
          this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = false);
        }
        IsTicking2() {
          return this._isTicking2;
        }
        GetDebuggerProperties() {
          return [];
        }
        SaveToJson() {
          return null;
        }
        LoadFromJson(e) {
        }
        GetPropertyValueByIndex(e) {
        }
        SetPropertyValueByIndex(e, t) {
        }
        OffsetPropertyValueByIndex(e, t, s) {
          if (0 !== t) {
            const i = this.GetPropertyValueByIndex(e);
            if ("number" != typeof i) throw new Error("expected number");
            this.SetPropertyValueByIndex(e, i + t, s);
          }
        }
        SetPropertyColorOffsetValueByIndex(e, t, s, i) {
        }
        CallAction(e, ...t) {
          e.call(this, ...t);
        }
        CallExpression(e, ...t) {
          return e.call(this, ...t);
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(e, t, s) {
          if (this._inst.HasScriptInterface()) {
            const i = this.GetScriptInterface(), n = C33.New(C33.Event, e, t);
            n.instance = i, s && Object.assign(n, s), i.dispatchEvent(n);
          }
        }
        MustPreDraw() {
          return false;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKWorldInstanceBase = class extends C33.SDKInstanceBase {
        constructor(e, t) {
          super(e, t), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
        }
        Release() {
          if (this._renderercontextlost_handler) {
            const e = this._runtime.Dispatcher();
            e.removeEventListener("renderercontextlost", this._renderercontextlost_handler), e.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
          }
          this._worldInfo = null, super.Release();
        }
        HandleWebGLContextLoss() {
          this.HandleRendererContextLoss();
        }
        OnWebGLContextLost() {
        }
        OnWebGLContextRestored() {
        }
        HandleRendererContextLoss() {
          if (!this._renderercontextlost_handler) {
            this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
            const e = this._runtime.Dispatcher();
            e.addEventListener("renderercontextlost", this._renderercontextlost_handler), e.addEventListener("renderercontextrestored", this._renderercontextrestored_handler);
          }
        }
        OnRendererContextLost() {
          this.OnWebGLContextLost();
        }
        OnRendererContextRestored() {
          this.OnWebGLContextRestored();
        }
        GetWorldInfo() {
          return this._worldInfo;
        }
        IsOriginalSizeKnown() {
          return false;
        }
        GetOriginalWidth() {
          if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
          const e = this.GetCurrentImageInfo();
          if (e) return e.GetWidth();
        }
        GetOriginalHeight() {
          if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
          const e = this.GetCurrentImageInfo();
          if (e) return e.GetHeight();
        }
        GetCurrentImageInfo() {
          return null;
        }
        GetCurrentSurfaceSize() {
          const e = this.GetCurrentImageInfo();
          if (e) {
            const t = e.GetTexture();
            if (t) return [t.GetWidth(), t.GetHeight()];
          }
          return [100, 100];
        }
        GetCurrentTexRect() {
          const e = this.GetCurrentImageInfo();
          return e ? e.GetTexRect() : null;
        }
        GetCurrentTexQuad() {
          const e = this.GetCurrentImageInfo();
          return e ? e.GetTexQuad() : null;
        }
        IsCurrentTexRotated() {
          const e = this.GetCurrentImageInfo();
          return !!e && e.IsRotated();
        }
        GetImagePoint(e) {
          const t = this._inst.GetWorldInfo();
          return [t.GetX(), t.GetY(), t.GetTotalZElevation()];
        }
        LoadTilemapData(e, t, r) {
        }
        TestPointOverlapTile(e, t) {
        }
        RendersToOwnZPlane() {
          return true;
        }
      };
    }
    {
      const C33 = self.C3, tempRect = C33.New(C33.Rect);
      C33.SDKDOMInstanceBase = class extends C33.SDKWorldInstanceBase {
        constructor(e, t) {
          super(e, t), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C33.New(C33.Rect, 0, 0, -1, -1);
          const s = this._runtime.GetCanvasManager();
          this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();
        }
        Release() {
          this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement("destroy"), this._elementId = -1, super.Release();
        }
        _GetElementInDOMMode() {
          if (this._runtime.IsInWorker()) throw new Error("not valid in worker mode");
          return this._PostToDOMElementMaybeSync("get-element");
        }
        PostToDOMElement(e, t) {
          (t = t || {})["elementId"] = this._elementId, this.PostToDOM(e, t);
        }
        _PostToDOMElementMaybeSync(e, t) {
          return (t = t || {})["elementId"] = this._elementId, this._PostToDOMMaybeSync(e, t);
        }
        PostToDOMElementAsync(e, t) {
          return (t = t || {})["elementId"] = this._elementId, this.PostToDOMAsync(e, t);
        }
        CreateElement(e) {
          e = e || {};
          const t = this.GetWorldInfo();
          e["elementId"] = this._elementId, e["isVisible"] = t.IsVisible(), e["htmlIndex"] = t.GetLayer().GetHTMLIndex(), e["htmlZIndex"] = t.GetHTMLZIndex(), Object.assign(e, this.GetElementState()), this._isElementShowing = !!e["isVisible"], this._PostToDOMMaybeSync("create", e), this._UpdatePosition(true);
        }
        SetElementVisible(e) {
          this._isElementShowing !== (e = !!e) && (this._isElementShowing = e, this.PostToDOMElement("set-visible", { "isVisible": e }));
        }
        Tick() {
          this._UpdatePosition(false);
        }
        _ShouldPreserveElement() {
          const e = this._runtime.GetCanvasManager().GetFullscreenMode();
          return "Android" === C33.Platform.OS && ("scale-inner" === e || "scale-outer" === e || "crop" === e);
        }
        _UpdatePosition(n) {
          if (!this.GetInstance().IsDestroyed()) {
            const l = this.GetWorldInfo(), o = l.GetLayer(), h = l.GetBoundingBox();
            let [e, t] = o.LayerToCanvasCss(h.getLeft(), h.getTop()), [s, i] = o.LayerToCanvasCss(h.getRight(), h.getBottom());
            const a = this._runtime.GetCanvasManager(), m = a.GetCssWidth(), d = a.GetCssHeight();
            if (l.IsVisible() && o.IsVisible()) if (!this._ShouldPreserveElement() && (s <= 0 || i <= 0 || m <= e || d <= t)) this.SetElementVisible(false);
            else {
              tempRect.set(e, t, s, i);
              const r = a.GetLastWidth(), _ = a.GetLastHeight(), c = o.GetHTMLIndex(), u = l.GetHTMLZIndex();
              if (!n && tempRect.equals(this._lastRect) && this._lastWindowWidth === r && this._lastWindowHeight === _ && this._lastHTMLIndex === c && this._lastHTMLZIndex === u) this.SetElementVisible(true);
              else {
                this._lastRect.copy(tempRect), this._lastWindowWidth = r, this._lastWindowHeight = _, this._lastHTMLIndex = c, this._lastHTMLZIndex = u, this.SetElementVisible(true);
                let e2 = null;
                this._autoFontSize && (e2 = o.GetDisplayScale() + this._autoFontSizeOffset), this.PostToDOMElement("update-position", { "left": Math.round(this._lastRect.getLeft()), "top": Math.round(this._lastRect.getTop()), "width": Math.round(this._lastRect.width()), "height": Math.round(this._lastRect.height()), "htmlIndex": c, "htmlZIndex": u, "fontSize": e2 });
              }
            }
            else this.SetElementVisible(false);
          }
        }
        FocusElement() {
          this._PostToDOMElementMaybeSync("focus", { "focus": true });
        }
        BlurElement() {
          this._PostToDOMElementMaybeSync("focus", { "focus": false });
        }
        _OnElemFocused() {
          this._elemHasFocus = true;
        }
        _OnElemBlurred() {
          this._elemHasFocus = false;
        }
        IsElementFocused() {
          return this._elemHasFocus;
        }
        SetElementCSSStyle(e, t) {
          this.PostToDOMElement("set-css-style", { "prop": C33.CSSToCamelCase(e), "val": t });
        }
        SetElementAttribute(e, t) {
          this.PostToDOMElement("set-attribute", { "name": e, "val": t });
        }
        RemoveElementAttribute(e) {
          this.PostToDOMElement("remove-attribute", { "name": e });
        }
        UpdateElementState() {
          this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {
            this._isPendingUpdateState = false, this.PostToDOMElement("update-state", this.GetElementState());
          }));
        }
        GetElementState() {
        }
        GetElementId() {
          return this._elementId;
        }
      };
    }
    {
      const C33 = self.C3, IBehavior = self.IBehavior;
      C33.SDKBehaviorBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e.runtime, this._myObjectClasses = C33.New(C33.ArraySet), this._myInstances = C33.New(C33.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;
        }
        Release() {
          this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        OnCreate() {
        }
        GetSdkVersion() {
          return this._sdkVersion;
        }
        GetScriptInterfaceClass(e = false) {
          let s = this._scriptInterfaceClass;
          return s = e && "function" != typeof s && 2 <= this.GetSdkVersion() ? globalThis.ISDKBehaviorBase : s;
        }
        _AddObjectClass(e) {
          this._myObjectClasses.Add(e);
        }
        GetObjectClasses() {
          return this._myObjectClasses.GetArray();
        }
        _AddInstance(e) {
          this._myInstances.Add(e);
        }
        _RemoveInstance(e) {
          this._myInstances.Delete(e);
        }
        GetInstances() {
          return this._myInstances.GetArray();
        }
        _InitScriptInterface() {
          const e = this.GetSdkVersion(), s = (C33.AddonManager._PushInitObject(this, e), this.GetScriptInterfaceClass(true));
          if (s) {
            if (this._iBehavior = new s(), !(this._iBehavior instanceof IBehavior)) throw new TypeError("behavior class must derive from IBehavior");
          } else this._iBehavior = new IBehavior();
          C33.AddonManager._PopInitObject(e);
        }
        GetIBehavior() {
          return this._iBehavior;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKBehaviorTypeBase = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);
        }
        Release() {
          this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;
        }
        OnCreate() {
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehavior() {
          return this._behavior;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SDKBehaviorInstanceBase = class extends C33.DefendedBase {
        constructor(t, i) {
          super(), this._behInst = t, this._domComponentId = i, this._inst = t.GetObjectInstance(), this._runtime = t.GetRuntime(), this._behaviorType = t.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;
        }
        Release() {
          this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;
        }
        GetBehavior() {
          return this._behaviorType.GetBehavior();
        }
        GetBehaviorInstance() {
          return this._behInst;
        }
        GetObjectInstance() {
          return this._inst;
        }
        GetObjectClass() {
          return this._inst.GetObjectClass();
        }
        GetWorldInfo() {
          return this._inst.GetWorldInfo();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetSdkType() {
          return this._sdkType;
        }
        GetScriptInterface() {
          return this._behInst.GetScriptInterface();
        }
        Trigger(t) {
          return this._runtime.Trigger(t, this._inst, this._behaviorType);
        }
        DebugTrigger(t) {
          return this._runtime.DebugTrigger(t, this._inst, this._behaviorType);
        }
        TriggerAsync(t) {
          return this._runtime.TriggerAsync(t, this._inst, this._behaviorType);
        }
        PostCreate() {
        }
        Tick() {
        }
        Tick2() {
        }
        PostTick() {
        }
        _StartTicking() {
          this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);
        }
        _StopTicking() {
          this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);
        }
        IsTicking() {
          return this._isTicking;
        }
        _StartTicking2() {
          this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);
        }
        _StopTicking2() {
          this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);
        }
        IsTicking2() {
          return this._isTicking2;
        }
        _StartPostTicking() {
          this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);
        }
        _StopPostTicking() {
          this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);
        }
        IsPostTicking() {
          return this._isPostTicking;
        }
        GetDebuggerProperties() {
          return [];
        }
        AddDOMMessageHandler(t, i) {
          this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t, i);
        }
        OnSpriteFrameChanged(t, i) {
        }
        SaveToJson() {
          return null;
        }
        LoadFromJson(t) {
        }
        GetPropertyValueByIndex(t) {
        }
        SetPropertyValueByIndex(t, i) {
        }
        OffsetPropertyValueByIndex(t, i) {
          if (0 !== i) {
            const e = this.GetPropertyValueByIndex(t);
            if ("number" != typeof e) throw new Error("expected number");
            this.SetPropertyValueByIndex(t, e + i);
          }
        }
        SetPropertyColorOffsetValueByIndex(t, i, e, s) {
        }
        CallAction(t, ...i) {
          t.call(this, ...i);
        }
        CallExpression(t, ...i) {
          return t.call(this, ...i);
        }
        GetScriptInterfaceClass() {
          return null;
        }
        DispatchScriptEvent(t, i, e) {
          if (this._behInst.HasScriptInterface()) {
            const s = this.GetScriptInterface(), n = C33.New(C33.Event, t, i);
            n.behaviorInstance = s, n.instance = s.instance, e && Object.assign(n, e), s.dispatchEvent(n);
          }
        }
      };
    }
    {
      let ValidateInternalAPIToken2 = function(t) {
        if (t !== internalApiToken) throw new Error("invalid internal API token");
      };
      ValidateInternalAPIToken = ValidateInternalAPIToken2;
      const C33 = self.C3, internalApiToken = (C33.Plugins = {}, C33.Behaviors = {}, C33._GetInternalAPIToken());
      let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;
      const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();
      C33.AddonManager = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._runtime = t, this._allPlugins = [], this._systemPlugin = null, this._allBehaviors = [], this._delayCreateBehaviors = /* @__PURE__ */ new Map(), this._solidBehavior = null, this._jumpthruBehavior = null, this._wrapperComponentIds = new Set(e);
        }
        CreatePlugin(t) {
          const e = t[19], i = this._runtime.GetObjectReference(t[0]);
          if (!i) throw new Error("missing plugin");
          C33.AddCommonACEs(t, i, e);
          const n = 2 <= e ? C33.SDKPluginBase : i, r = C33.New(n, { runtime: this._runtime, isSingleGlobal: t[1], isWorld: t[2], isRotatable: t[5], hasEffects: t[8], mustPredraw: t[9], supportsSceneGraph: t[13], supportsMesh: t[14], isHTMLElementType: t[17], is3d: t[18], sdkVersion: e, scriptInterfaceClass: 2 <= e ? i : null });
          r.OnCreate(), this._allPlugins.push(r), pluginsByCtor.set(i, r);
        }
        CreateSystemPlugin() {
          this._systemPlugin = C33.New(C33.Plugins.System, { runtime: this._runtime, isSingleGlobal: true }), this._systemPlugin.OnCreate();
        }
        CreateBehavior(t) {
          const i = t[1], n = this._runtime.GetObjectReference(t[0]);
          if (!n) throw new Error("missing behavior");
          this._delayCreateBehaviors.set(n, () => {
            const t2 = 2 <= i ? C33.SDKBehaviorBase : n, e = C33.New(t2, { runtime: this._runtime, sdkVersion: i, scriptInterfaceClass: 2 <= i ? n : null });
            e.OnCreate(), this._allBehaviors.push(e), behaviorsByCtor.set(n, e), !this._solidBehavior && C33.Behaviors.solid && e instanceof C33.Behaviors.solid ? this._solidBehavior = e : !this._jumpthruBehavior && C33.Behaviors.jumpthru && e instanceof C33.Behaviors.jumpthru && (this._jumpthruBehavior = e), e._InitScriptInterface();
          });
        }
        _DelayCreateBehavior(t) {
          const e = this._delayCreateBehaviors.get(t);
          e && (e(), this._delayCreateBehaviors.delete(t));
        }
        static _PushInitObject(t, e = 1) {
          if (C33.AddonManager._PushInitObject !== originalPushInitObject) throw new Error("invalid method");
          1 === e && initObjectStack.push(t), initObjectStack2.push(t);
        }
        static _PopInitObject(t = 1) {
          if (C33.AddonManager._PopInitObject !== originalPopInitObject) throw new Error("invalid method");
          1 === t && initObjectStack.pop(), initObjectStack2.pop();
        }
        static _GetInitObject() {
          if (C33.AddonManager._GetInitObject !== originalGetInitObject) throw new Error("invalid method");
          if (0 === initObjectStack.length) throw new Error("no init object set");
          return initObjectStack.at(-1);
        }
        static _GetInitObject2(t) {
          if (C33.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error("invalid method");
          if (ValidateInternalAPIToken2(t), 0 === initObjectStack2.length) throw new Error("no init object set");
          return initObjectStack2.at(-1);
        }
        static _PushInitProperties(t) {
          initPropertiesStack.push(t);
        }
        static _PopInitProperties() {
          initPropertiesStack.pop();
        }
        static _GetInitProperties() {
          if (0 === initPropertiesStack.length) throw new Error("no init properties set");
          return initPropertiesStack.at(-1);
        }
        _InitAddonScriptInterfaces() {
          for (const t of this._allPlugins) t._InitScriptInterface();
        }
        static GetPluginByConstructorFunction(t) {
          return pluginsByCtor.get(t) || null;
        }
        static GetBehaviorByConstructorFunction(t) {
          return behaviorsByCtor.get(t) || null;
        }
        GetSystemPlugin() {
          return this._systemPlugin;
        }
        GetSolidBehavior() {
          return this._solidBehavior;
        }
        GetJumpthruBehavior() {
          return this._jumpthruBehavior;
        }
        HasWrapperComponentId(t) {
          return this._wrapperComponentIds.has(t);
        }
      }, originalPushInitObject = C33.AddonManager._PushInitObject, originalPopInitObject = C33.AddonManager._PopInitObject, originalGetInitObject = C33.AddonManager._GetInitObject, originalGetInitObject2 = C33.AddonManager._GetInitObject2;
    }
    var ValidateInternalAPIToken;
    {
      const C33 = self.C3, allImageInfos = /* @__PURE__ */ new Set();
      C33.ImageInfo = class extends C33.DefendedBase {
        constructor() {
          super(), this._generation = 0, this._url = "", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = "", this._rcTex = C33.New(C33.Rect), this._quadTex = C33.New(C33.Quad), this._blobUrl = "", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);
        }
        Release() {
          this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();
        }
        static OnRendererContextLost() {
          for (const t of allImageInfos) t._textureState = "", t._rcTex.set(0, 0, 0, 0), t._quadTex.setFromRect(t._rcTex);
        }
        LoadData(t) {
          this._url = t[0], this._size = t[1], this._offsetX = t[2], this._offsetY = t[3], this._width = t[4], this._height = t[5], this._isRotated = t[6], this._hasMetaData = true;
        }
        LoadDynamicAsset(t, e) {
          if (this._imageAsset) throw new Error("already loaded asset");
          this._url = e;
          const s = {};
          return C33.IsAbsoluteURL(e) && (s.loadPolicy = "remote"), this.LoadAsset(t, s), this._imageAsset.Load();
        }
        LoadDynamicBlobAsset(t, e) {
          if (this._imageAsset) throw new Error("already loaded asset");
          this._url = "", this._size = e.size, this._imageAsset = C33.New(C33.ImageAsset, t.GetAssetManager(), { blob: e, size: this._size, loadPolicy: "local" });
        }
        ReplaceWith(t) {
          if (t === this) throw new Error("cannot replace with self");
          this._generation++, this.ReleaseTexture(), this._url = t._url, this._size = t._size, this._offsetX = t._offsetX, this._offsetY = t._offsetY, this._width = t._width, this._height = t._height, this._isRotated = t._isRotated, this._hasMetaData = t._hasMetaData, this._imageAsset = t._imageAsset, this._textureState = t._textureState, this._rcTex = t._rcTex, this._quadTex = t._quadTex, this.ReleaseBlobURL();
        }
        GetURL() {
          return this._url;
        }
        GetSize() {
          return this._size;
        }
        GetOffsetX() {
          return this._offsetX;
        }
        GetOffsetY() {
          return this._offsetY;
        }
        IsRotated() {
          return this._isRotated;
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetSheetWidth() {
          return this._imageAsset.GetWidth();
        }
        GetSheetHeight() {
          return this._imageAsset.GetHeight();
        }
        LoadAsset(t, e) {
          if (this._imageAsset) throw new Error("already got asset");
          e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t.LoadImage(e);
        }
        IsLoaded() {
          return this._imageAsset && this._imageAsset.IsLoaded();
        }
        async LoadStaticTexture(t, e) {
          if (!this._imageAsset) throw new Error("no asset");
          if (this._textureState) throw new Error("already loaded texture");
          const s = this._generation, i = (this._textureState = "loading", await this._imageAsset.LoadStaticTexture(t, e));
          if (this._generation !== s) return null;
          if (!i) return this._textureState = "", null;
          this._textureState = "loaded", this._hasMetaData || (this._width = i.GetWidth(), this._height = i.GetHeight(), this._hasMetaData = true);
          const h = this._isRotated ? this._height : this._width, a = this._isRotated ? this._width : this._height;
          return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h, this._offsetY + a), this._rcTex.divide(i.GetWidth(), i.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i;
        }
        ReleaseTexture() {
          this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));
        }
        GetTexture() {
          return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null;
        }
        GetTexRect() {
          return this._rcTex;
        }
        GetTexQuad() {
          return this._quadTex;
        }
        GetIImageInfo() {
          return this._iImageInfo;
        }
        GetImageAsset() {
          return this._imageAsset;
        }
        async ExtractImageToCanvas(t) {
          t = t || await this._imageAsset.LoadToDrawable();
          const e = C33.CreateCanvas(this._width, this._height), s = e.getContext("2d");
          return this._isRotated ? (s.rotate(Math.PI / -2), s.translate(-this._height, 0), s.drawImage(t, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s.drawImage(t, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;
        }
        async ExtractImageToBlobURL(t) {
          if (!this._blobUrl) {
            const e = await this.ExtractImageToCanvas(t), s = await C33.CanvasToBlob(e);
            this._blobUrl = URL.createObjectURL(s);
          }
          return this._blobUrl;
        }
        ReleaseBlobURL() {
          this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = "");
        }
      };
    }
    {
      const C33 = self.C3;
      C33.AnimationInfo = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C33.New(C33.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);
        }
        static CreateDynamic(e, t) {
          const r = C33.New(C33.AnimationInfo, [t, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);
          return r._frames.push(C33.AnimationFrameInfo.CreateDynamic(e)), r;
        }
        Release() {
          for (const e of this._frames) e.Release();
          C33.clearArray(this._frames);
        }
        LoadAllAssets(e) {
          for (const t of this._frames) t.GetImageInfo().LoadAsset(e);
        }
        LoadAllTextures(t, r) {
          return Promise.all(this._frames.map((e) => e.GetImageInfo().LoadStaticTexture(t, r)));
        }
        ReleaseAllTextures() {
          for (const e of this._frames) e.GetImageInfo().ReleaseTexture();
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetFrameCount() {
          return this._frames.length;
        }
        GetFrames() {
          return this._frames;
        }
        GetFrameAt(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
          return this._frames[e];
        }
        InsertFrameAt(e, t) {
          (t = Math.floor(t)) < 0 ? this._frames.unshift(e) : t >= this._frames.length ? this._frames.push(e) : this._frames.splice(t, 0, e);
        }
        RemoveFrameAt(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
          this._frames[e].Release(), this._frames.splice(e, 1);
        }
        GetFrameIndexByTag(r) {
          for (let e = 0, t = this._frames.length; e < t; ++e) if (C33.equalsNoCase(this._frames[e].GetTag(), r)) return e;
          return -1;
        }
        FrameTagOrIndexToIndex(e) {
          if ("string" != typeof e) return e;
          {
            const t = this.GetFrameIndexByTag(e);
            if (-1 === t) throw new Error("cannot find animation frame with tag " + e);
            return t;
          }
        }
        GetSpeed() {
          return this._speed;
        }
        IsLooping() {
          return this._isLooping;
        }
        GetRepeatCount() {
          return this._repeatCount;
        }
        GetRepeatTo() {
          return this._repeatTo;
        }
        IsPingPong() {
          return this._isPingPong;
        }
        GetIAnimation() {
          return this._iAnimation;
        }
      };
    }
    {
      const C33 = self.C3, EMPTY_IMAGE_BLOB = (() => {
        const e = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), n = new Uint8Array(e.length);
        for (let t = 0, i = e.length; t < i; ++t) n[t] = e.charCodeAt(t);
        return new Blob([n], { type: "image/png" });
      })();
      C33.AnimationFrameInfo = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(t), this._duration = t[7], this._origin = C33.New(C33.Vector2, t[8], t[9]), this._imagePoints = t[10].map((t2) => C33.New(C33.ImagePoint, this, t2)), this._imagePointsByName = /* @__PURE__ */ new Map();
          for (const e of this._imagePoints) this._imagePointsByName.set(e.GetName().toLowerCase(), e);
          this._collisionPoly = null;
          const i = t[11];
          6 <= i.length && (this._collisionPoly = C33.New(C33.CollisionPoly, i)), this._tag = t[12] || "", this._iAnimationFrame = new self.IAnimationFrame(this);
        }
        static CreateDynamic(t) {
          const i = C33.New(C33.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], ""]);
          return i._imageInfo.LoadDynamicBlobAsset(t, EMPTY_IMAGE_BLOB), i;
        }
        Release() {
          this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;
        }
        GetImageInfo() {
          return this._imageInfo;
        }
        GetDuration() {
          return this._duration;
        }
        GetOriginX() {
          return this._origin.getX();
        }
        GetOriginY() {
          return this._origin.getY();
        }
        GetCollisionPoly() {
          return this._collisionPoly;
        }
        GetImagePointByName(t) {
          return this._imagePointsByName.get(t.toLowerCase()) || null;
        }
        GetImagePointByIndex(t) {
          return (t = Math.floor(t)) < 0 || t >= this._imagePoints.length ? null : this._imagePoints[t];
        }
        GetImagePointCount() {
          return this._imagePoints.length;
        }
        GetTag() {
          return this._tag;
        }
        GetIAnimationFrame() {
          return this._iAnimationFrame;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.ImagePoint = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._afi = e, this._name = t[0], this._pos = C33.New(C33.Vector2, t[1], t[2]);
        }
        Release() {
        }
        GetName() {
          return this._name;
        }
        GetX() {
          return this._pos.getX();
        }
        GetY() {
          return this._pos.getY();
        }
        GetVec2() {
          return this._pos;
        }
      };
    }
    {
      const C33 = self.C3, C3Debugger = self.C3Debugger, IObjectClass = self.IObjectClass, assert = self.assert;
      C33.ObjectClass = class extends C33.DefendedBase {
        constructor(e, t, s) {
          super();
          const i = e.GetObjectReference(s[1]), [n, a] = (this._runtime = e, this._plugin = C33.AddonManager.GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = t, this._sid = s[11], this._name = s[0], this._jsPropName = this._runtime.GetJsPropName(s[14]), this._isGlobal = !!s[9], this._isFamily = !!s[2], this._isOnLoaderLayout = !!s[10], this._instVars = s[3].map((t2) => ({ sid: t2[0], type: t2[1], name: t2[2], jsPropName: e.GetJsPropName(t2[3]) })), this._behaviorsCount = s[4], this._effectsCount = s[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C33.New(C33.Event.Dispatcher), this._effectList = null, e.GetCollisionEngine().GetCollisionCellSize());
          if (this._collisionGrid = C33.New(C33.SparseGrid, n, a), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s[8].map((t2) => C33.BehaviorType.Create(this, t2)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C33.New(C33.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._unsavedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C33.New(C33.EffectList, this, s[12])), s[6] && (this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(s[6])), s[7]) {
            this._animations = s[7].map((t2) => C33.New(C33.AnimationInfo, t2)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();
            for (const h of this._animations) this._animationsByName.set(h.GetName().toLowerCase(), h), this._animationsBySid.set(h.GetSID(), h);
          }
          this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
          const r = this._plugin.GetSdkVersion();
          if (r < 2 && (this._sdkType = C33.New(i.Type, this, s[15]), !(this._sdkType instanceof C33.SDKTypeBase))) throw new Error("v1 sdk type must derive from SDKTypeBase");
          this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), C33.AddonManager._PushInitObject(this, r);
          let o;
          if (o = 2 <= r ? (o = i.Type) || globalThis.ISDKObjectTypeBase : this._sdkType.GetScriptInterfaceClass()) {
            if (this._iObjectClass = new o(r < 2 ? this : null), r < 2 && !(this._iObjectClass instanceof IObjectClass)) throw new TypeError("script interface class must derive from IObjectClass");
            if (2 <= r && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
          } else this._iObjectClass = new IObjectClass();
          if (C33.AddonManager._PopInitObject(r), s[13]) {
            const l = s[13];
            if (l) {
              const _ = l[0], c = l[1], u = l[2];
              this._sdkType.LoadTilemapData(_, c, u);
            }
          }
          this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s)), this._loadInstancesJson = null;
        }
        static Create(t, e, s) {
          return C33.New(C33.ObjectClass, t, e, s);
        }
        Release() {
          if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {
            for (const t of this._animations) t.Release();
            C33.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();
          }
          this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null;
        }
        _LoadFamily(s) {
          for (let t = 1, e = s.length; t < e; ++t) {
            const i = this._runtime.GetObjectClassByIndex(s[t]);
            this._familyMembers.push(i), this._familyMembersSet.add(i), i._families.push(this), i._familiesSet.add(this);
          }
        }
        _SetContainer(t) {
          this._isInContainer = true, this._container = t;
        }
        IsInContainer() {
          return this._isInContainer;
        }
        GetContainer() {
          return this._container;
        }
        _OnAfterCreate() {
          let t = 0;
          if (!this._isFamily) for (const e of this._families) for (const s of e.GetBehaviorTypes()) {
            const i = s.GetName().toLowerCase();
            this._behaviorsByName.set(i, s), this._behaviorNameToIndex.set(i, t), this._behaviorTypesIncludingInherited.push(s), ++t;
          }
          for (const n of this.GetBehaviorTypes()) {
            const a = n.GetName().toLowerCase();
            this._behaviorsByName.set(a, n), this._behaviorNameToIndex.set(a, t), this._behaviorTypesIncludingInherited.push(n), ++t;
          }
          for (const r of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(r.GetBehavior().constructor);
          if (!this._isFamily && this._families.length) {
            const o = this._runtime.GetFamilyCount(), h = (C33.extendArray(this._familyInstVarMap, o, 0), C33.extendArray(this._familyBehaviorMap, o, 0), C33.extendArray(this._familyEffectMap, o, 0), []);
            let t2 = 0, e = 0, s = 0;
            for (const l of this._families) {
              const _ = l.GetFamilyIndex(), c = (this._familyInstVarMap[_] = t2, t2 += l.GetInstanceVariablesCount(), this._familyBehaviorMap[_] = e, e += l.GetBehaviorTypesCount(), this._familyEffectMap[_] = s, s += l.GetEffectTypesCount(), l.GetEffectList());
              if (c && this._effectList) for (const u of c.GetAllEffectTypes()) h.push(u.Clone(this._effectList));
            }
            this._effectList && this._effectList.PrependEffectTypes(h);
          }
        }
        _CreateSingleGlobalInstance(t) {
          const e = this._runtime._GetNewUID(), s = C33.New(C33.Instance, { runtime: this._runtime, objectType: this, uid: e });
          s._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(e, s), this._instances.push(s);
        }
        GetSdkType() {
          return this._sdkType;
        }
        IsOnLoaderLayout() {
          return this._isOnLoaderLayout;
        }
        Dispatcher() {
          return this._dispatcher;
        }
        OnCreate() {
          this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());
        }
        HasLoadedTextures() {
          return 0 < this._textureRefCount;
        }
        async LoadTextures(t) {
          this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));
        }
        ReleaseTextures() {
          if (!this._isFamily) {
            if (this._textureRefCount--, this._textureRefCount < 0) throw new Error("released textures too many times");
            0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));
          }
        }
        OnDynamicTextureLoadComplete() {
          if (this._isFamily) throw new Error("not applicable to family");
          this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();
        }
        async PreloadTexturesWithInstances(t) {
          this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));
        }
        GetRuntime() {
          return this._runtime;
        }
        GetPlugin() {
          return this._plugin;
        }
        GetInstanceSdkCtor() {
          return this._instSdkCtor;
        }
        GetName() {
          return this._name;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
        GetIndex() {
          return this._index;
        }
        GetSID() {
          return this._sid;
        }
        IsFamily() {
          return this._isFamily;
        }
        IsGlobal() {
          return this._isGlobal;
        }
        IsWorldType() {
          return this._isWorldType;
        }
        GetFamilyIndex() {
          return this._familyIndex;
        }
        GetBehaviorTypes() {
          return this._behaviorTypes;
        }
        GetBehaviorTypesCount() {
          return this._behaviorsCount;
        }
        UsesBehaviorByCtor(t) {
          return t && this._usedBehaviorCtors.has(t);
        }
        GetInstanceVariablesCount() {
          return this._instVars.length;
        }
        GetInstanceVariableSIDs() {
          return this._instVars.map((t) => t.sid);
        }
        GetInstanceVariableIndexBySID(e) {
          return this._instVars.findIndex((t) => t.sid === e);
        }
        GetInstanceVariableIndexByName(e) {
          return this._instVars.findIndex((t) => t.name === e);
        }
        _GetAllInstanceVariableNames() {
          return this._instVars.map((t) => t.name);
        }
        _GetAllInstanceVariableJsPropNames() {
          return this._instVars.map((t) => t.jsPropName);
        }
        GetInstanceVariableType(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
          return this._instVars[t].type;
        }
        GetInstanceVariableName(t) {
          if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError("invalid instance variable index");
          return this._instVars[t].name;
        }
        GetEffectTypesCount() {
          return this._effectsCount;
        }
        GetBehaviorTypesIncludingInherited() {
          return this._behaviorTypesIncludingInherited;
        }
        GetBehaviorTypeByName(t) {
          return this._behaviorsByName.get(t.toLowerCase()) || null;
        }
        GetBehaviorIndexByName(t) {
          const e = this._behaviorNameToIndex.get(t.toLowerCase());
          return void 0 === e ? -1 : e;
        }
        GetEffectList() {
          return this._effectList;
        }
        HasEffects() {
          return this._plugin.HasEffects();
        }
        UsesEffects() {
          return this._effectList && this._effectList.HasAnyEffectType();
        }
        GetSolStack() {
          return this._solStack;
        }
        GetCurrentSol() {
          return this._solStack.GetCurrentSol();
        }
        GetImageInfo() {
          return this._imageInfo;
        }
        SetDefaultInstanceData(t) {
          this._defaultInstanceData = t;
        }
        GetDefaultInstanceData() {
          return this._defaultInstanceData;
        }
        _SetDefaultLayerIndex(t) {
          this._defaultLayerIndex = t;
        }
        GetDefaultLayerIndex() {
          return this._defaultLayerIndex;
        }
        GetAnimations() {
          return this._animations;
        }
        GetAnimationCount() {
          return this._animations.length;
        }
        GetFamilies() {
          return this._families;
        }
        BelongsToFamily(t) {
          return this._familiesSet.has(t);
        }
        GetFamilyMembers() {
          return this._familyMembers;
        }
        FamilyHasMember(t) {
          return this._familyMembersSet.has(t);
        }
        GetFamilyBehaviorOffset(t) {
          return this._familyBehaviorMap[t];
        }
        GetFamilyInstanceVariableOffset(t) {
          return this._familyInstVarMap[t];
        }
        AddCustomAction(t) {
          this._customActionMap.set(t.GetACEName().toLowerCase(), t);
        }
        HasOwnCustomActionByName(t) {
          return !!this.GetOwnCustomActionByName(t);
        }
        GetOwnCustomActionByName(t) {
          const e = this._customActionMap.get(t.toLowerCase());
          return e && e.IsEnabled() ? e : null;
        }
        GetAllAnimations() {
          return this._animations;
        }
        GetAnimationByName(t) {
          if (this._animations) return this._animationsByName.get(t.toLowerCase()) || null;
          throw new Error("no animations");
        }
        GetAnimationBySID(t) {
          if (this._animations) return this._animationsBySid.get(t) || null;
          throw new Error("no animations");
        }
        AddAnimation(t) {
          if (this.GetAnimationByName(t)) throw new Error(`animation name '${t}' already exists`);
          const e = C33.AnimationInfo.CreateDynamic(this.GetRuntime(), t);
          return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;
        }
        RemoveAnimation(t) {
          const e = this.GetAnimationByName(t);
          if (!e) throw new Error(`animation name '${t}' does not exist`);
          if (1 === this._animations.length) throw new Error("cannot remove last animation");
          const s = this._animations.indexOf(e);
          this._animations.splice(s, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();
        }
        GetFirstAnimation() {
          if (this._animations) return this._animations[0];
          throw new Error("no animations");
        }
        GetFirstAnimationFrame() {
          return this.GetFirstAnimation().GetFrameAt(0);
        }
        GetDefaultInstanceSize() {
          if (this._animations) {
            const t = this.GetFirstAnimationFrame().GetImageInfo();
            return [t.GetWidth(), t.GetHeight()];
          }
          return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];
        }
        GetSingleGlobalInstance() {
          if (this._plugin.IsSingleGlobal()) return this._instances[0];
          throw new Error("not a single-global plugin");
        }
        GetInstances() {
          return this._instances;
        }
        *instances() {
          yield* this._instances;
        }
        *instancesIncludingPendingCreate() {
          yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);
        }
        GetInstanceCount() {
          return this._instances.length;
        }
        _AddInstance(t) {
          this._instances.push(t);
        }
        _SetIIDsStale() {
          this._iidsStale = true;
        }
        _UpdateIIDs() {
          if (this._iidsStale && !this._isFamily) {
            const s = this._instances;
            let e = 0;
            for (let t2 = s.length; e < t2; ++e) s[e]._SetIID(e);
            const t = this._runtime._GetInstancesPendingCreate();
            for (const i of t) i.GetObjectClass() === this && i._SetIID(e++);
            this._iidsStale = false;
          }
        }
        GetInstanceByIID(t) {
          const e = this._instances;
          if (t < e.length) return e[t];
          t -= e.length;
          const s = this._runtime._GetInstancesPendingCreate();
          for (const i of s) if (i.GetObjectClass() === this) {
            if (0 === t) return i;
            --t;
          }
          return null;
        }
        GetFirstPicked(t) {
          if (t && t.IsInContainer() && t.GetObjectClass() !== this) {
            for (const s of t.siblings()) if (s.GetObjectClass() === this) return s;
          }
          const e = this.GetCurrentSol().GetInstances();
          return e.length ? e[0] : null;
        }
        GetPairedInstance(t) {
          const e = this.GetCurrentSol().GetInstances();
          return 0 < e.length ? e[t.GetIID() % e.length] : null;
        }
        *allCorrespondingInstances(t, e) {
          const s = this.GetCurrentSol().GetInstances(), i = s.length, n = e.GetCurrentSol(), a = e.GetCurrentSol().GetInstances(), r = a.length;
          let o = t.GetIID();
          !e.IsFamily() && n.IsSelectAll() || (o = a.indexOf(t));
          const h = Math.ceil(i / r), l = i % r;
          let _ = 0, c = 0;
          c = 0 == l || o < l ? (_ = o * h, h) : (_ = l * h + (o - l) * (h - 1), h - 1);
          for (let t2 = _, e2 = _ + c; t2 < e2; ++t2) yield s[t2];
        }
        FinishCondition(t) {
          this._sdkType?.FinishCondition(t);
        }
        ApplySolToContainer() {
          if (this._isInContainer && !this._isFamily) {
            this._UpdateIIDs();
            const t = this.GetCurrentSol(), e = t._GetOwnInstances(), s = t.IsSelectAll(), i = this._runtime.GetCurrentEventStackFrame(), n = i && i.GetCurrentEvent() && i.GetCurrentEvent().IsOrBlock();
            for (const a of this._container.objectTypes()) if (a !== this) {
              a._UpdateIIDs();
              const r = a.GetCurrentSol();
              if (r._SetSelectAll(s), !s) {
                const o = r._GetOwnInstances();
                C33.clearArray(o);
                for (const h of e) o.push(a.GetInstanceByIID(h.GetIID()));
                if (n) {
                  const l = t._GetOwnElseInstances(), _ = r._GetOwnElseInstances();
                  C33.clearArray(_);
                  for (const c of l) _.push(a.GetInstanceByIID(c.GetIID()));
                }
              }
            }
          }
        }
        _TruncateContainerSols(t, e) {
          for (const s of this.GetContainer().objectTypes()) {
            const i = s.GetCurrentSol();
            t ? C33.truncateArray(i._GetOwnElseInstances(), e) : C33.truncateArray(i._GetOwnInstances(), e);
          }
        }
        _GetCollisionCellGrid() {
          return this._collisionGrid;
        }
        _SetAnyCollisionCellChanged(t) {
          this._anyCollisionCellChanged = !!t;
        }
        _UpdateAllCollisionCells() {
          if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const t of this._instances) t.GetWorldInfo()._UpdateCollisionCell();
            for (const e of this._runtime._GetInstancesPendingCreate()) e.GetObjectClass() === this && e.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = false;
          }
        }
        _OnWorldInstanceLayerChanged(e, t, s) {
          if (t) {
            const i = this._worldInfosByLayer.get(t);
            i && (i.delete(e), 0 === i.size) && this._worldInfosByLayer.delete(t);
          }
          if (s) {
            let t2 = this._worldInfosByLayer.get(s);
            t2 || (t2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s, t2)), t2.add(e);
          }
        }
        layersHasInstancesOn() {
          if (this.IsFamily()) {
            const t = /* @__PURE__ */ new Set();
            for (const e of this._familyMembers) for (const s of e.layersHasInstancesOn()) t.add(s);
            return t.values();
          }
          return this._worldInfosByLayer.keys();
        }
        GetSavedDataMap() {
          return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
        }
        GetUnsavedDataMap() {
          return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
        }
        HasSolidBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.solid);
        }
        HasJumpthruBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.jumpthru);
        }
        HasNoSaveBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.NoSave);
        }
        HasPersistBehavior() {
          return this.UsesBehaviorByCtor(C33.Behaviors.Persist);
        }
        _SaveToJson() {
          const t = { "instances": this._instances.map((t2) => t2.SaveToJson()) };
          return this._savedData && this._savedData.size && (t["ex"] = C33.ToSuperJSON(this._savedData)), t;
        }
        _LoadFromJson(t, s) {
          this._savedData && (this._savedData.clear(), this._savedData = null);
          const e = t["ex"], i = (e && (this._savedData = C33.FromSuperJSON(e)), this._instances), n = t["instances"];
          for (let t2 = 0, e2 = Math.min(i.length, n.length); t2 < e2; ++t2) i[t2].LoadFromJson(n[t2]);
          for (let t2 = n.length, e2 = i.length; t2 < e2; ++t2) this._runtime.DestroyInstance(i[t2]);
          for (let e2 = i.length, t2 = n.length; e2 < t2; ++e2) {
            const a = n[e2];
            let t3 = null;
            if (!this.IsWorldType() || (t3 = this._runtime.GetMainRunningLayout().GetLayerBySID(a["w"]["l"]))) {
              const r = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, t3, false, 0, 0, true);
              r.LoadFromJson(a), s && s.add(r);
            }
          }
          this._loadInstancesJson = n, this._SetIIDsStale();
        }
        _GetLoadInstancesJson() {
          return this._loadInstancesJson;
        }
        _ClearLoadInstancesJson() {
          this._loadInstancesJson = null;
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          for (let t = 0, e = this._instances; t < e; ++t) this._instances[t]._SetupSceneGraphConnectionsOnChangeOfLayout();
        }
        GetIObjectClass() {
          return this._iObjectClass;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        _GetUserScriptInstanceClass() {
          return this._instanceUserScriptClass;
        }
        _SetUserScriptInstanceClass(t) {
          this._instanceUserScriptClass = t;
        }
        DispatchUserScriptEvent(t) {
          const e = this._runtime, s = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();
          s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t), s && C3Debugger.AddScriptTime();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.Container = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._runtime = e, this._objectTypes = t;
          for (const s of this._objectTypes) s._SetContainer(this);
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectTypes() {
          return this._objectTypes;
        }
        objectTypes() {
          return this._objectTypes;
        }
        HasAnyWorldType() {
          return this._objectTypes.some((e) => e.IsWorldType());
        }
      };
    }
    {
      const C33 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C33.AddonManager, EMPTY_ARRAY = [];
      let nextPuid = 0;
      const savedDataMaps = /* @__PURE__ */ new WeakMap(), unsavedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;
      C33.Instance = class extends C33.DefendedBase {
        constructor(t) {
          if (C33.AddonManager !== originalAddonManager) throw new Error("invalid addon manager");
          super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = nextPuid++, this._flags = 0, this._tagsSet = null;
          const e = C33.splitStringAndNormalize(t.tags), s = (0 < e.length && (this._tagsSet = new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY, this._objectType.GetBehaviorTypesIncludingInherited()), n = (0 < s.length && (this._behaviorInstances = s.map((t2, e2) => C33.New(C33.BehaviorInstance, { runtime: this._runtime, behaviorType: t2, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null, this.GetPlugin());
          if (n.MustPreDraw() && (this._flags |= FLAG_MUST_PREDRAW), n.IsWorldType()) if (this._worldInfo = C33.New(C33.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);
          else {
            this._worldInfo.InitNoData();
            const [i, r] = this._objectType.GetDefaultInstanceSize();
            this._worldInfo.SetSize(i, r), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();
          }
          t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables();
        }
        Release() {
          if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), 0 < this._behaviorInstances.length) {
            for (const s of this._behaviorInstances) s.Release();
            C33.clearArray(this._behaviorInstances);
          }
          this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);
          const t = savedDataMaps.get(this), e = (t && (t.clear(), savedDataMaps.delete(this)), unsavedDataMaps.get(this));
          e && (e.clear(), unsavedDataMaps.delete(this)), this._siblings && C33.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._tagsSet && this._tagsSet.clear(), this._tagsSet = null, this._runtime = null, this._objectType = null, 0 < this._instVarValues.length && C33.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);
        }
        _LoadInstanceVariableData(t) {
          0 < t.length && (this._instVarValues = [], C33.shallowAssignArray(this._instVarValues, t));
        }
        _LoadDefaultInstanceVariables() {
          const e = this._objectType.GetInstanceVariablesCount();
          if (0 !== e) {
            this._instVarValues = [];
            const s = [0, 0, ""];
            for (let t = 0; t < e; ++t) this._instVarValues.push(s[this._objectType.GetInstanceVariableType(t)]);
          }
        }
        _CreateSdkInstance(t, s) {
          if (this._sdkInst) throw new Error("already got sdk instance");
          for (let t2 = 0, e2 = this._behaviorInstances.length; t2 < e2; ++t2) {
            const n = this._behaviorInstances[t2];
            n._CreateSdkInstance(s ? s[t2] : null);
          }
          const e = this.GetPlugin().GetSdkVersion();
          if (e < 2) {
            if (this._sdkInst = C33.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKInstanceBase)) throw new Error("sdk type must derive from SDKInstanceBase");
            !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
          } else {
            const i = this.GetPlugin().GetScriptInterfaceClass();
            this._InitUserScriptInterface(i.Instance, t);
          }
        }
        GetSdkInstance() {
          return this._sdkInst ?? this._iScriptInterface;
        }
        GetWorldInfo() {
          return this._worldInfo;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetTimeScale() {
          return this._timeScale;
        }
        GetActiveTimeScale() {
          const t = this._timeScale;
          return -1 === t ? this.GetRuntime().GetTimeScale() : t;
        }
        SetTimeScale(t) {
          ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._timeScale = t, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);
        }
        RestoreTimeScale() {
          this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);
        }
        GetInstanceGameTime() {
          return this._runtime._GetInstanceGameTime(this);
        }
        Dispatcher() {
          return this._dispatcher || (this._dispatcher = C33.New(C33.Event.Dispatcher)), this._dispatcher;
        }
        Draw(t) {
          this._sdkInst ? this._sdkInst.Draw(t) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());
        }
        OnCreate(t) {
          this._sdkInst.OnCreate(t);
        }
        _SetHasTilemap() {
          this._flags |= FLAG_TILEMAP;
        }
        HasTilemap() {
          return 0 != (this._flags & FLAG_TILEMAP);
        }
        _MarkDestroyed() {
          this._flags |= FLAG_DESTROYED;
        }
        IsDestroyed() {
          return 0 != (this._flags & FLAG_DESTROYED);
        }
        MustPreDraw() {
          return 0 != (this._flags & FLAG_MUST_PREDRAW) || this._sdkInst.MustPreDraw();
        }
        SetMustMitigateZFighting() {
          this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING;
        }
        MustMitigateZFighting() {
          return 0 != (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING);
        }
        _IsSolidEnabled() {
          return 0 != (this._flags & FLAG_SOLID_ENABLED);
        }
        _SetSolidEnabled(t) {
          t ? this._flags |= FLAG_SOLID_ENABLED : this._flags &= ~FLAG_SOLID_ENABLED;
        }
        _IsJumpthruEnabled() {
          return 0 != (this._flags & FLAG_JUMPTHRU_ENABLED);
        }
        _SetJumpthruEnabled(t) {
          t ? this._flags |= FLAG_JUMPTHRU_ENABLED : this._flags &= ~FLAG_JUMPTHRU_ENABLED;
        }
        _IsDrawingWithEffects() {
          return 0 != (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS);
        }
        _SetIsDrawingWithEffects(t) {
          t ? this._flags |= FLAG_IS_DRAWING_WITH_EFFECTS : this._flags &= ~FLAG_IS_DRAWING_WITH_EFFECTS;
        }
        SetFlag(t, e) {
          t <<= 16, e ? this._flags |= t : this._flags &= ~t;
        }
        GetFlag(t) {
          return 0 != (this._flags & t << 16);
        }
        GetCurrentImageInfo() {
          return this._sdkInst.GetCurrentImageInfo();
        }
        GetCurrentSurfaceSize() {
          return this._sdkInst.GetCurrentSurfaceSize();
        }
        GetCurrentTexRect() {
          return this._sdkInst.GetCurrentTexRect();
        }
        GetCurrentTexQuad() {
          return this._sdkInst.GetCurrentTexQuad();
        }
        IsCurrentTexRotated() {
          return this._sdkInst.IsCurrentTexRotated();
        }
        GetImagePoint(t) {
          return this._sdkInst.GetImagePoint(t);
        }
        GetObjectClass() {
          return this._objectType;
        }
        RendersToOwnZPlane() {
          return this._sdkInst.RendersToOwnZPlane();
        }
        BelongsToObjectClass(t) {
          return t.IsFamily() ? t.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t;
        }
        CollectInstancesToPick(i, t, e) {
          const s = (t2, e2) => {
            const s2 = e2 || t2.GetObjectClass(), n = i.get(s2);
            n ? n.add(t2) : i.set(s2, /* @__PURE__ */ new Set([t2]));
          };
          if (s(this, t), this.IsInContainer()) for (const n of this.siblings()) s(n);
          if (e) for (const r of this.allChildren()) s(r);
        }
        VerifySupportsSceneGraph() {
          if (!this.GetPlugin().SupportsSceneGraph()) throw new Error("object does not support scene graph");
        }
        HasParent() {
          return null !== this.GetParent();
        }
        GetParent() {
          const t = this.GetWorldInfo();
          if (!t) return null;
          const e = t.GetParent();
          return e ? e.GetInstance() : null;
        }
        GetTopParent() {
          const t = this.GetWorldInfo();
          if (!t) return null;
          const e = t.GetTopParent();
          return e ? e.GetInstance() : null;
        }
        *parents() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.parents()) yield e.GetInstance();
        }
        HasChild(t) {
          if (t) {
            for (const e of this.children()) if (e === t) return true;
          }
          return false;
        }
        HasChildren() {
          const t = this.GetWorldInfo();
          return !!t && t.HasChildren();
        }
        GetChildrenOfObjectClass(t) {
          const e = this.GetWorldInfo();
          if (!e) return [];
          const s = t.GetName();
          return e.GetChildren().map((t2) => t2.GetInstance()).filter((t2) => t2.GetObjectClass().GetName() === s);
        }
        GetChildren() {
          const t = this.GetWorldInfo();
          return t ? t.GetChildren().map((t2) => t2.GetInstance()) : [];
        }
        *children() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.children()) yield e.GetInstance();
        }
        *allChildren() {
          const t = this.GetWorldInfo();
          if (t) for (const e of t.allChildren()) yield e.GetInstance();
        }
        GetChildCount() {
          const t = this.GetWorldInfo();
          return t ? t.GetChildCount() : 0;
        }
        GetParentCount() {
          return [...this.parents()].length;
        }
        GetAllChildCount() {
          const t = this.GetWorldInfo();
          return t ? t.GetAllChildCount() : 0;
        }
        GetChildAt(t) {
          const e = this.GetWorldInfo();
          if (!e) return null;
          const s = e.GetChildAt(t);
          return s ? s.GetInstance() : null;
        }
        GetIndexInParent() {
          const t = this.GetWorldInfo();
          if (!t) return NaN;
          const e = t.GetParent();
          return e ? e.GetChildIndex(t) : NaN;
        }
        HasChildWithUID(t) {
          for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t) return true;
          return false;
        }
        AddChild(t, e) {
          this.VerifySupportsSceneGraph(), t.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t.GetWorldInfo(), e || {});
        }
        RemoveChild(t) {
          const e = this.GetWorldInfo();
          e && e.RemoveChild(t.GetWorldInfo());
        }
        GetDestroyWithParent() {
          const t = this.GetWorldInfo();
          return !!t && t.GetDestroyWithParent();
        }
        SetupInitialSceneGraphConnections() {
          const t = this.GetWorldInfo();
          if (t) {
            const e = t.GetSceneGraphChildrenExportData();
            if (e) for (const s of e) {
              const n = this._runtime.GetInstanceByUID(s[2]);
              if (n) {
                const i = s[3];
                this.AddChild(n, { transformX: !!(i >> 0 & 1), transformY: !!(i >> 1 & 1), transformWidth: !!(i >> 2 & 1), transformHeight: !!(i >> 3 & 1), transformAngle: !!(i >> 4 & 1), destroyWithParent: !!(i >> 5 & 1), transformZElevation: !!(i >> 6 & 1), transformOpacity: !!(i >> 7 & 1), transformVisibility: !!(i >> 8 & 1) });
              }
            }
          }
        }
        SetupPersistedSceneGraphConnections(t, e) {
          const s = t.get(this);
          if (s) for (const n of s["sceneGraphJson"]["children"]) {
            const i = e.get(n["index"]);
            if (i) {
              const r = n["flags"];
              this.AddChild(i, { transformX: !!(r >> 0 & 1), transformY: !!(r >> 1 & 1), transformWidth: !!(r >> 2 & 1), transformHeight: !!(r >> 3 & 1), transformAngle: !!(r >> 4 & 1), destroyWithParent: !!(r >> 5 & 1), transformZElevation: !!(r >> 6 & 1), transformOpacity: !!(r >> 7 & 1), transformVisibility: !!(r >> 8 & 1) });
            }
          }
        }
        GetTemplateName() {
          const t = this._runtime.GetTemplateManager();
          return t ? t.GetInstanceTemplateName(this) : "";
        }
        IsInContainer() {
          return null !== this._siblings;
        }
        _AddSibling(t) {
          this._siblings.push(t);
        }
        GetSiblings() {
          return this._siblings;
        }
        HasSibling(t) {
          return !!this.GetSibling(t);
        }
        GetSibling(t) {
          const e = this.siblings();
          if (null === e || 0 === e.length) return false;
          for (const s of e) if (s.GetObjectClass() === t) return s;
          return null;
        }
        siblings() {
          return this._siblings;
        }
        SetSiblingsSinglePicked() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol().SetSinglePicked(t);
        }
        _PushSiblingsToSolInstances() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushInstance(t);
        }
        _SetSiblingsToSolInstancesIndex(t) {
          for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t] = e;
        }
        _PushSiblingsToSolElseInstances() {
          for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushElseInstance(t);
        }
        _SetSiblingsToSolElseInstancesIndex(t) {
          for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t] = e;
        }
        GetPlugin() {
          return this._objectType.GetPlugin();
        }
        _SetIID(t) {
          this._iid = t;
        }
        GetIID() {
          return this._objectType._UpdateIIDs(), this._iid;
        }
        GetUID() {
          return this._uid;
        }
        GetPUID() {
          return this._puid;
        }
        _SetTagsSetFromJson(t) {
          t ? this.SetTagsSet(new Set(t)) : this._tagsSet = null;
        }
        SetTagsSet(t) {
          if (0 === t.size) this._tagsSet = null;
          else {
            this._tagsSet ? this._tagsSet.clear() : this._tagsSet = /* @__PURE__ */ new Set();
            for (const e of t) this._tagsSet.add(e);
          }
        }
        GetTagsSet() {
          return this._tagsSet ?? /* @__PURE__ */ new Set();
        }
        GetTagsString() {
          return Array.from(this.GetTagsSet()).join(" ");
        }
        GetTagAt(t) {
          t = Math.floor(t);
          for (const e of this.GetTagsSet()) {
            if (0 === t) return e;
            --t;
          }
          return "";
        }
        GetBehaviorInstances() {
          return this._behaviorInstances;
        }
        GetBehaviorInstanceFromCtor(t) {
          if (t) {
            for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t) return e;
          }
          return null;
        }
        GetBehaviorSdkInstanceFromCtor(t) {
          if (!t) return null;
          const e = this.GetBehaviorInstanceFromCtor(t);
          return e ? e.GetSdkInstance() : null;
        }
        GetBehaviorIndexBySID(s) {
          const n = this._behaviorInstances;
          for (let t = 0, e = n.length; t < e; ++t) if (n[t].GetBehaviorType().GetSID() === s) return t;
          return -1;
        }
        GetAllInstanceVariableValues() {
          return this._instVarValues;
        }
        _GetAllInstanceVariableNames() {
          return this._objectType._GetAllInstanceVariableNames();
        }
        GetInstanceVariableCount() {
          return this._instVarValues.length;
        }
        GetInstanceVariableValue(t) {
          const e = this._instVarValues;
          if ((t |= 0) < 0 || t >= e.length) throw new RangeError("invalid instance variable");
          return e[t];
        }
        _GetInstanceVariableValueUnchecked(t) {
          return this._instVarValues[t];
        }
        _GetInstanceVariableTypedValue(t) {
          const e = this._instVarValues[t];
          return 0 === this._objectType.GetInstanceVariableType(t) ? !!e : e;
        }
        SetInstanceVariableValue(t, e) {
          const s = this._instVarValues;
          if ((t |= 0) < 0 || t >= s.length) throw new RangeError("invalid instance variable");
          const n = this._objectType.GetInstanceVariableType(t);
          switch (n) {
            case 0:
              s[t] = e ? 1 : 0;
              break;
            case 1:
              s[t] = "number" == typeof e ? e : parseFloat(e);
              break;
            case 2:
              s[t] = "string" == typeof e ? e : e.toString();
              break;
            default:
              throw new Error("unknown instance variable type");
          }
        }
        SetInstanceVariableOffset(t, e) {
          if (0 !== e) {
            const s = this._instVarValues;
            if ((t |= 0) < 0 || t >= s.length) throw new RangeError("invalid instance variable");
            const n = s[t];
            if ("number" != typeof n) throw "boolean" == typeof n ? new Error("can not set offset of boolean variable") : "string" == typeof n ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
            s[t] += "number" == typeof e ? e : parseFloat(e);
          }
        }
        GetSavedDataMap() {
          let t = savedDataMaps.get(this);
          return t || (t = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t)), t;
        }
        GetUnsavedDataMap() {
          let t = unsavedDataMaps.get(this);
          return t || (t = /* @__PURE__ */ new Map(), unsavedDataMaps.set(this, t)), t;
        }
        _HasAnyCreateDestroyHandler(t) {
          const e = this.GetObjectClass();
          if (e.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
          for (const s of e.GetFamilies()) if (s.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;
          return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t);
        }
        _TriggerOnCreatedOnSelfAndRelated() {
          const t = /* @__PURE__ */ new Set(), e = (t.add(this), this.GetWorldInfo());
          if (e && e.HasChildren()) {
            for (const s of this.allChildren()) if (t.add(s), s.IsInContainer()) for (const n of s.siblings()) t.add(n);
          }
          if (this.IsInContainer()) for (const i of this.siblings()) t.add(i);
          for (const r of t.values()) r._TriggerOnCreated();
        }
        _OnCreatedCommon() {
          this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
          for (const t of this._behaviorInstances) t.PostCreate();
        }
        _OnCreatedForLoadingSavegame() {
          this._OnCreatedCommon();
        }
        _TriggerOnCreated() {
          if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler("instancecreate")) {
            const t = this.GetObjectClass(), e = new C33.Event("instancecreate");
            e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);
            for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);
            this._runtime.DispatchUserScriptEvent(e);
          }
          this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);
        }
        _TriggerOnDestroyed() {
          this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);
        }
        _FireDestroyedScriptEvents(t) {
          if (this._iScriptInterface) {
            const e = new C33.Event("destroy");
            e.isEndingLayout = t, this.DispatchUserScriptEvent(e);
          }
          if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
            const s = this.GetObjectClass(), n = new C33.Event("instancedestroy");
            n.instance = this.GetInterfaceClass(), n.isEndingLayout = t, s.DispatchUserScriptEvent(n);
            for (const i of s.GetFamilies()) i.DispatchUserScriptEvent(n);
            this._runtime.DispatchUserScriptEvent(n);
          }
        }
        _GetDebuggerProperties() {
          return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
        }
        SaveToJson(t = "full", e = null) {
          const s = {}, n = ("full" === t ? s["uid"] = this.GetUID() : s["c3"] = true, this.GetTagsSet());
          if (0 < n.size && (s["tags"] = Array.from(n)), "visual-state" !== t) {
            const r = savedDataMaps.get(this);
            if (r && r.size && (s["ex"] = C33.ToSuperJSON(r)), -1 !== this.GetTimeScale() && (s["mts"] = this.GetTimeScale()), 0 < this._objectType.GetInstanceVariablesCount()) {
              const a = {}, o = this._objectType.GetInstanceVariableSIDs();
              for (let t2 = 0, e2 = this._instVarValues.length; t2 < e2; ++t2) a[o[t2].toString()] = this._instVarValues[t2];
              s["ivs"] = a;
            }
            if (this._behaviorInstances.length) {
              const l = {};
              for (const h of this._behaviorInstances) {
                const c = h.SaveToJson(t);
                c && (l[h.GetBehaviorType().GetSID().toString()] = c);
              }
              s["behs"] = l;
            }
          }
          this._worldInfo && (s["w"] = this._worldInfo._SaveToJson(t, e));
          const i = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();
          return i && (s["data"] = i), s;
        }
        _OnBeforeLoad(t = "full", e) {
          this._worldInfo && this._worldInfo._OnBeforeLoad(t);
        }
        _OnAfterLoad(t, e = "full", s = null) {
          this._worldInfo && this._worldInfo._OnAfterLoad(t, e, s);
        }
        _OnAfterLoad2(t, e = "full", s = null) {
          this._worldInfo && this._worldInfo._OnAfterLoad2(t, e, s);
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();
        }
        LoadFromJson(e, t = "full", s) {
          if ("full" === t) this._uid = e["uid"];
          else if (!e["c3"]) return;
          if (this._SetTagsSetFromJson(e["tags"]), "visual-state" !== t) {
            let t2 = savedDataMaps.get(this);
            t2 && (t2.clear(), savedDataMaps.delete(this));
            const i = e["ex"], r = (i && (t2 = C33.FromSuperJSON(i), savedDataMaps.set(this, t2)), this._timeScale = e.hasOwnProperty("mts") ? e["mts"] : -1, e["ivs"]);
            if (r) for (const [a, o] of Object.entries(r)) {
              const l = parseInt(a, 10), h = this._objectType.GetInstanceVariableIndexBySID(l);
              if (!(h < 0 || h >= this._instVarValues.length)) {
                let t3 = o;
                null === t3 && (t3 = NaN), this._instVarValues[h] = t3;
              }
            }
          }
          if (this.GetPlugin().IsWorldType()) {
            const c = e["w"];
            if (c) {
              const _ = c["l"];
              if (this._worldInfo.GetLayer().GetSID() !== _) {
                const f = this._worldInfo.GetLayer(), d = f.GetLayout().GetLayerBySID(_);
                d ? (this._worldInfo._SetLayer(d), f._RemoveInstance(this, true), d._AddInstance(this, true), d.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : "full" === t && this._runtime.DestroyInstance(this);
              }
              this._worldInfo._LoadFromJson(c, t);
            }
          }
          if ("visual-state" !== t) {
            const I = e["behs"];
            if (I) for (const [u, G] of Object.entries(I)) {
              const g = parseInt(u, 10), S = this.GetBehaviorIndexBySID(g);
              S < 0 || S >= this._behaviorInstances.length || this._behaviorInstances[S].LoadFromJson(G, t);
            }
          }
          const n = e["data"];
          n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, t) : this._iScriptInterface._loadFromJson(n));
        }
        GetInterfaceClass() {
          return this._iScriptInterface || this._InitUserScriptInterface();
        }
        HasScriptInterface() {
          return !!this._iScriptInterface;
        }
        _InitUserScriptInterface(t, e) {
          const s = this._worldInfo ? t ? self.ISDKWorldInstanceBase : self.IWorldInstance : t ? self.ISDKInstanceBase : self.IInstance, n = t || this._sdkInst.GetScriptInterfaceClass(), i = this._objectType._GetUserScriptInstanceClass(), r = i || n || s, a = this.GetPlugin().GetSdkVersion();
          if (C33.AddonManager._PushInitObject(this, a), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new r(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(a), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
          if (i) {
            const o = n || s;
            if (!(this._iScriptInterface instanceof o)) throw new TypeError(`setInstanceClass(): class '${i.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
          }
          return this._iScriptInterface;
        }
        _GetInstVarsScriptDescriptor(t) {
          if (0 !== this._instVarValues.length) {
            const s = {}, n = this._objectType._GetAllInstanceVariableJsPropNames();
            for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) s[n[t2]] = { configurable: false, enumerable: true, get: C33.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t2), set: C33.Instance.prototype.SetInstanceVariableValue.bind(this, t2) };
            const e = Object.create(Object.prototype, s);
            t.instVars = { value: e, writable: false };
          }
        }
        _GetBehaviorsScriptDescriptor(t) {
          const e = this._behaviorInstances;
          if (0 !== e.length) {
            const s = {};
            for (const i of e) s[i.GetBehaviorType().GetJsPropName()] = { value: i.GetScriptInterface(), writable: false };
            const n = Object.create(Object.prototype, s);
            t.behaviors = { value: n, writable: false };
          }
        }
        DispatchUserScriptEvent(t) {
          if (this.HasScriptInterface()) {
            const e = this.GetInterfaceClass(), s = (t.instance = e, this._runtime), n = s.IsDebug() && !s.GetEventSheetManager().IsInEventEngine();
            n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), n && C3Debugger.AddScriptTime();
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SceneGraphInfo = class extends C33.DefendedBase {
        constructor(s) {
          super(), this._owner = s, this._parent = null, this._children = [], this._startWidth = s.GetWidth(), this._startHeight = s.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = s.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (t) => {
            if (t.instance === this._parent.GetInstance()) {
              const e = s.GetRuntime(), n = (e.Dispatcher().removeEventListener("instancecreate", this._on_instance_create), this._parent.GetInstance().GetSdkInstance());
              this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;
            }
          };
        }
        Release() {
          this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C33.clearArray(this._children);
        }
        SetParent(t) {
          if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t, this._parentStartAngle = t ? t.GetAngle() : 0, this._parent) {
            const e = this._owner, n = e.GetRuntime(), s = this._parent.GetInstance().GetPlugin().GetSdkVersion();
            if (s < 2) {
              const i = this._parent.GetInstance().GetSdkInstance();
              i ? (this._originalSizeKnown = !!i.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? i.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? i.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || n.Dispatcher().addEventListener("instancecreate", this._on_instance_create);
            } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
          } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
        }
        GetParent() {
          return this._parent;
        }
        HasChildren() {
          return 0 < this._children.length;
        }
        GetChildren() {
          return this._children;
        }
        _MaybeSortChildren() {
          this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t, e) => {
            const n = this._tmpSceneGraphChildrenIndexes.get(t.GetInstance()), s = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());
            return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s) ? n - s : 0;
          }) : this._children.sort((t, e) => {
            const n = t._GetSceneGraphInfo()._GetIndexInParent(), s = e._GetSceneGraphInfo()._GetIndexInParent();
            return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s) ? n - s : 0;
          }));
        }
        _GetIndexInParent() {
          return this._indexInParent;
        }
        GetStartScaleX() {
          return this._startScaleX;
        }
        SetStartScaleX(t) {
          this._startScaleX = t;
        }
        GetStartScaleY() {
          return this._startScaleY;
        }
        SetStartScaleY(t) {
          this._startScaleY = t;
        }
        GetStartOpacity() {
          return this._startOpacity;
        }
        GetOwnOpacity() {
          return this._ownOpacity;
        }
        SetOwnOpacity(t) {
          this._ownOpacity = t;
        }
        _GetStartWidth() {
          return 0 === this._startWidth ? Number.EPSILON : this._startWidth;
        }
        _GetStartHeight() {
          return 0 === this._startHeight ? Number.EPSILON : this._startHeight;
        }
        GetParentScaleX() {
          if (this._owner.GetTransformWithParentWidth()) {
            const n = this._parent;
            let t = n.GetWidth(), e = n._GetSceneGraphInfo()._GetStartWidth();
            return 0 === t && (t = Number.EPSILON), e === Number.EPSILON && t === Number.EPSILON ? 1 : e === Number.EPSILON && t !== Number.EPSILON && this._originalSizeKnown ? 1 + t / this._originalWidth : t / e;
          }
          return 1;
        }
        GetParentScaleY() {
          if (this._owner.GetTransformWithParentHeight()) {
            const n = this._parent;
            let t = n.GetHeight(), e = n._GetSceneGraphInfo()._GetStartHeight();
            return 0 === t && (t = Number.EPSILON), e === Number.EPSILON && t === Number.EPSILON ? 1 : e === Number.EPSILON && t !== Number.EPSILON && this._originalSizeKnown ? 1 + t / this._originalHeight : t / e;
          }
          return 1;
        }
        GetParentStartAngle() {
          return 0;
        }
        _SaveToJsonProperties() {
          return { "sw": this._startWidth, "sh": this._startHeight, "sx": this._startScaleX, "sy": this._startScaleY, "psa": this._parentStartAngle, "oo": this._ownOpacity, "so": this._startOpacity, "pi": this._owner.GetInstance().GetIndexInParent() };
        }
        _SaveToJson(t, e = null) {
          const n = this._SaveToJsonProperties();
          return e && e["selfOnly"] ? Object.assign(n, { "p": null, "c": [] }) : Object.assign(n, { "p": this._GetParentJson(t), "c": this._GetChildrenJson(t) });
        }
        _GetFlagsString(t) {
          let e = "";
          return t.GetTransformWithParentX() && (e += "x"), t.GetTransformWithParentY() && (e += "y"), t.GetTransformWithParentWidth() && (e += "w"), t.GetTransformWithParentHeight() && (e += "h"), t.GetTransformWithParentAngle() && (e += "a"), t.GetTransformWithParentZElevation() && (e += "z"), t.GetDestroyWithParent() && (e += "d"), t.GetTransformWithParentOpacity() && (e += "o"), t.GetTransformWithParentVisibility() && (e += "v"), e;
        }
        _GetParentJson(t) {
          return !this._parent || !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t);
        }
        _GetChildrenJson(e) {
          return this._children.map((t) => this._GetInstanceJson(t, t, e)).filter((t) => t);
        }
        _GetInstanceJson(t, e, n) {
          const s = t.GetInstance();
          if (s && s.IsDestroyed()) return null;
          const i = {};
          return i["uid"] = s.GetUID(), i["f"] = this._GetFlagsString(e), i["offsets"] = e._SaveSceneGraphPropertiesToJson(), i["data"] = C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s), i["oci"] = s.GetObjectClass().GetIndex(), "state" === n ? (i["inst"] = s.SaveToJson("full", { "selfOnly": true }), i["instIndex"] = NaN) : (i["instIndex"] = s.GetObjectClass().GetInstances().indexOf(s), i["inst"] = null), i;
        }
        _LoadFromJson(t) {
          this._startWidth = t["sw"], this._startHeight = t["sh"], this._startScaleX = t["sx"], this._startScaleY = t["sy"], this._parentStartAngle = t["psa"], this._ownOpacity = t["oo"], this._startOpacity = t["so"], this._indexInParent = C33.IsFiniteNumber(t["pi"]) ? t["pi"] : NaN;
        }
        _SetTmpSceneGraphChildren(t, e) {
          if (!t && !e && this._tmpSceneGraphChildren) for (const n of this._tmpSceneGraphChildren) n.IsDestroyed() || n.HasParent() || n.GetRuntime().DestroyInstance(n);
          this._tmpSceneGraphChildren = t, this._tmpSceneGraphChildrenIndexes = e;
        }
        _OnAfterLoad(t, e) {
          const n = this._owner, s = n.GetRuntime(), i = /* @__PURE__ */ new Set();
          if (t["p"] && !this._parent) {
            const h = t["p"]["uid"], o = s.GetInstanceByUID(h);
            if (e?.setFromJson, o) {
              const c = o.GetWorldInfo();
              if (o.HasChild(n.GetInstance())) this._parent = c;
              else {
                o.HasChildWithUID(n.GetInstance().GetUID()) ? s.DestroyInstance(n.GetInstance()) : o.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), i.has(n) || (n._LoadSceneGraphPropertiesFromJson(t["p"]["offsets"]), this._LoadInstancePropertiesFromJson(o, t["p"], e)), i.add(n);
                const l = o.GetWorldInfo();
                l._GetSceneGraphInfo()._MaybeSortChildren();
              }
            } else if (C33.IsFiniteNumber(t["p"]["oci"])) {
              const d = s.GetObjectClassByIndex(t["p"]["oci"]), G = (s.GetSystemPlugin(), s.CreateInstance(d, n.GetLayer(), 0, 0, true));
              if (e?.setFromJson, G) {
                const _ = this._GetInstanceData(t["p"], s), I = (_ && G.LoadFromJson(_), G.GetWorldInfo()), p = (I.GetLayer().SortAndAddInstancesByZIndex(G), G.AddChild(n.GetInstance(), this._GetFlagsObj(t["p"]["f"])), G.GetWorldInfo());
                p._GetSceneGraphInfo()._MaybeSortChildren();
              }
            }
          }
          const r = [];
          for (const S of t["c"]) {
            const f = S["uid"], u = s.GetInstanceByUID(f);
            u && r.push(u);
          }
          let a = 0;
          for (const m of t["c"]) {
            const C = m["uid"], N = s.GetInstanceByUID(C);
            if (e?.setFromJson, N) {
              if (this._tmpSceneGraphChildren) {
                if (this._tmpSceneGraphChildren.includes(N)) {
                  const P = N;
                  if (P.GetObjectClass() !== N.GetObjectClass()) {
                    a++;
                    continue;
                  }
                  if (P.IsDestroyed()) {
                    a++;
                    continue;
                  }
                  const b = t["c"][a];
                  if (!e?.setFromJson && this._HasAllChildrenOfType(P, r, n)) {
                    this._UpdateInstance(a, b, n, i, e), a++;
                    continue;
                  }
                  if (P.HasParent() && P.GetParent() !== n.GetInstance()) {
                    const W = this._CreateNewChildInstance(b, e);
                    this._AddAndSetChildInstance(W, b, i, e), a++;
                    continue;
                  }
                  this._AddAndSetChildInstance(P.GetWorldInfo(), b, i, e, true), a++;
                  continue;
                }
                if (this._tmpSceneGraphChildren[a]) {
                  const w = this._tmpSceneGraphChildren[a];
                  if (w.GetObjectClass() !== N.GetObjectClass()) {
                    a++;
                    continue;
                  }
                  if (w.IsDestroyed()) {
                    a++;
                    continue;
                  }
                  const A = t["c"][a];
                  if (!e?.setFromJson && this._HasAllChildrenOfType(w, r, n)) {
                    this._UpdateInstance(a, A, n, i, e), a++;
                    continue;
                  }
                  if (w.HasParent() && w.GetParent() !== n.GetInstance()) {
                    const F = this._CreateNewChildInstance(A, e);
                    this._AddAndSetChildInstance(F, A, i, e), a++;
                    continue;
                  }
                  this._AddAndSetChildInstance(w.GetWorldInfo(), A, i, e, true), a++;
                  continue;
                }
              }
              const g = N.GetObjectClass(), O = this._GetInstancesOfObjectClassCount(r, g), y = n.GetInstance().GetChildrenOfObjectClass(g).length;
              if (O === y) {
                const J = n.GetInstance().GetChildAt(a);
                if (J) {
                  const L = J.GetWorldInfo();
                  L && (i.has(L) || (L._LoadSceneGraphPropertiesFromJson(m["offsets"]), this._LoadInstancePropertiesFromJson(J, m, e)), i.add(L));
                }
                a++;
                continue;
              }
              if (N.HasParent() && N.GetParent() !== n.GetInstance()) {
                const x = this._CreateNewChildInstance(m, e);
                this._AddAndSetChildInstance(x, m, i, e), a++;
                continue;
              }
              this._AddAndSetChildInstance(N.GetWorldInfo(), m, i, e);
            } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[a]) {
              const H = this._tmpSceneGraphChildren[a], j = s.GetObjectClassByIndex(this._GetObjectClassIndex(m));
              if (H.GetObjectClass() !== j) {
                a++;
                continue;
              }
              if (H.IsDestroyed()) {
                a++;
                continue;
              }
              const D = t["c"][a];
              if (!e?.setFromJson && this._HasAllChildrenOfType(H, r, n)) {
                this._UpdateInstance(a, D, n, i, e), a++;
                continue;
              }
              if (H.HasParent() && H.GetParent() !== n.GetInstance()) {
                const T = this._CreateNewChildInstance(D, e);
                this._AddAndSetChildInstance(T, D, i, e), a++;
                continue;
              }
              this._AddAndSetChildInstance(H.GetWorldInfo(), D, i, e);
            } else {
              const E = this._CreateNewChildInstance(m, e);
              this._AddAndSetChildInstance(E, m, i, e);
            }
            a++;
          }
        }
        _HasAllChildrenOfType(t, e, n) {
          const s = t.GetObjectClass(), i = this._GetInstancesOfObjectClassCount(e, s), r = n.GetInstance().GetChildrenOfObjectClass(s).length;
          return i === r;
        }
        _UpdateInstance(t, e, n, s, i) {
          const r = n.GetInstance().GetChildAt(t, e);
          if (r) {
            const a = r.GetWorldInfo();
            a && (s.has(a) || (a._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(r, e, i)), s.add(a));
          }
        }
        _GetFlagsObj(t) {
          const e = {};
          return e.transformX = t.includes("x"), e.transformY = t.includes("y"), e.transformWidth = t.includes("w"), e.transformHeight = t.includes("h"), e.transformAngle = t.includes("a"), e.transformZElevation = t.includes("z"), e.destroyWithParent = t.includes("d"), e.transformOpacity = t.includes("o"), e.transformVisibility = t.includes("v"), e;
        }
        _GetObjectClassIndex(t) {
          return C33.IsFiniteNumber(t["oci"]) ? t["oci"] : t[1];
        }
        _CreateNewChildInstance(e, n) {
          if (C33.IsFiniteNumber(e["oci"])) {
            const s = this._owner, i = s.GetRuntime();
            let t;
            if (e["data"]) t = i.CreateInstanceFromData(e["data"], s.GetLayer(), false, 0, 0, false, true);
            else {
              const r = i.GetObjectClassByIndex(e["oci"]);
              t = i.CreateInstance(r, s.GetLayer(), 0, 0, true);
            }
            if (n?.setFromJson, t) {
              const a = this._GetInstanceData(e, i), h = (a && t.LoadFromJson(a), t.GetWorldInfo());
              return h.GetLayer().SortAndAddInstancesByZIndex(t, true), h;
            }
          }
        }
        _AddAndSetChildInstance(t, e, n, s, i = true) {
          const r = this._owner, a = r.AddChild(t, this._GetFlagsObj(e["f"]));
          a && i && (n.has(t) || (t._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(t.GetInstance(), e, s)), n.add(t)), this._MaybeSortChildren();
        }
        _LoadInstancePropertiesFromJson(t, e, n) {
          let s = this._GetInstanceData(e, this._owner.GetRuntime());
          s && ((s = JSON.parse(JSON.stringify(s)))["w"] = null, t.LoadFromJson(s));
        }
        _GetInstancesOfObjectClassCount(t, e) {
          return t.filter((t2) => t2.GetObjectClass().GetName() === e.GetName()).length;
        }
        _GetInstanceData(t, e) {
          if (C33.IsFiniteNumber(t["instIndex"])) {
            const n = e.GetObjectClassByIndex(t["oci"]), s = n._GetLoadInstancesJson();
            return s ? s[t["instIndex"]] : null;
          }
          return C33.IsString(t["inst"]) ? JSON.parse(t["inst"]) : t["inst"] || void 0;
        }
        static GetSceneGraphInstanceDataFromInstance(t) {
          let e = t.GetWorldInfo().GetLayer().GetInitialInstanceData(t.GetUID());
          if (!e) return null;
          e = JSON.parse(JSON.stringify(e));
          const n = [];
          for (const s of [...t.GetChildren()]) {
            const i = s.GetWorldInfo();
            n.push([i.GetLayout().GetSID(), i.GetLayer().GetIndex(), s.GetUID(), C33.SceneGraphInfo._GetFlagsNumber(i), s.GetObjectClass().IsInContainer() ? 1 : 0, i.GetZIndex(), C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s)]);
          }
          return C33.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C33.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t.GetWorldInfo().GetZIndex()), e;
        }
        static _GetFlagsNumber(t) {
          let e = 0;
          return (e |= Number(t.GetTransformWithParentVisibility()) << 8) | Number(t.GetTransformWithParentOpacity()) << 7 | Number(t.GetTransformWithParentZElevation()) << 6 | Number(t.GetDestroyWithParent()) << 5 | Number(t.GetTransformWithParentAngle()) << 4 | Number(t.GetTransformWithParentHeight()) << 3 | Number(t.GetTransformWithParentWidth()) << 2 | Number(t.GetTransformWithParentY()) << 1 | Number(t.GetTransformWithParentX()) << 0;
        }
        static _GetDefaultFlagsNumber(t) {
          let e = 0;
          return (e |= 256) | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1, 511;
        }
      };
    }
    {
      const C33 = self.C3, glMatrix = self.glMatrix, vec32 = glMatrix.vec3, vec42 = glMatrix.vec4, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad), bboxChangeEvent = C33.New(C33.Event, "bboxchange", false), tempColor = C33.New(C33.Color, 0, 0, 0, 0), tempCollisionPoly = C33.New(C33.CollisionPoly), DEFAULT_COLOR = C33.New(C33.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set(["absolute", "relative"]), EMPTY_ARRAY = [];
      let enableUpdateRendererStateGroup = true;
      const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << FLAG_BLEND_MODE_BIT_OFFSET, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();
      C33.WorldInfo = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= FLAG_IS_ROTATABLE), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C33.New(C33.Rect), this._boundingQuad = C33.New(C33.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C33.New(C33.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;
        }
        _MarkDestroyed() {
          this._flags |= FLAG_DESTROYED;
        }
        Release() {
          if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {
            const t = [...this.GetChildren()];
            for (const e of t) this.RemoveChild(e);
          }
          this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;
        }
        Init(t) {
          if (enableUpdateRendererStateGroup = false, this.SetXY(t[0], t[1]), this.SetZElevation(t[2]), this.SetSize(t[3], t[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t[6]) : this._a = 0, tempColor.setFromJSON(t[7]), this._SetColor(tempColor), this.SetOriginX(t[8]), this.SetOriginY(t[9]), this.SetBlendMode(t[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t[12]), t[14] && sceneGraphExportDataMap.set(this, { childrenData: t[14][1], zIndexData: t[14][2] }), t[15]) {
            const e = t[15], i = (this.CreateMesh(e[0], e[1]), this.GetSourceMesh()), n = e[2];
            for (let s = 0, t2 = n.length; s < t2; ++s) {
              const r = n[s];
              for (let t3 = 0, e2 = r.length; t3 < e2; ++t3) {
                const h = r[t3], a = i.GetMeshPointAt(t3, s);
                a.SetX(h[0]), a.SetY(h[1]), a.SetZElevation(h[2]), a.SetU(h[3]), a.SetV(h[4]);
              }
            }
          }
          if (t[16]) {
            const s = t[16][0], o = t[16][1], l = !!o, _ = !l, G = this._runtime.GetTemplateManager();
            l && G && G.MapInstanceToTemplateName(this.GetInstance(), o), _ && G && G.MapInstanceToTemplateName(this.GetInstance(), s);
          }
          enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();
        }
        InitNoData() {
          this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetInstance() {
          return this._inst;
        }
        _GetParentOffsetAngle() {
          return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;
        }
        SetX(t) {
          if (t = +t, this.GetTransformWithParentX()) {
            const e = this._sceneGraphInfo, s = t - this.GetX(), i = -this._GetParentOffsetAngle();
            0 == i ? this._x += s / e.GetParentScaleX() : (this._x += Math.cos(i) * s / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i) * s / e.GetParentScaleY()));
          } else this._x = t;
        }
        OffsetX(t, e = false) {
          t = +t, !e && this.GetTransformWithParentX() ? this.SetX(this.GetX() + t) : this._x += t;
        }
        GetX() {
          if (this.GetTransformWithParentX()) {
            let t = this._x;
            const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
            return 0 === i ? t *= e.GetParentScaleX() : (t = t * e.GetParentScaleX() * Math.cos(i), this.GetTransformWithParentY() && (t -= this._y * e.GetParentScaleY() * Math.sin(i))), s.GetX() + t;
          }
          return this._x;
        }
        SetY(t) {
          if (t = +t, this.GetTransformWithParentY()) {
            const e = this._sceneGraphInfo, s = t - this.GetY(), i = -this._GetParentOffsetAngle();
            0 == i ? this._y += s / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i) * s / e.GetParentScaleX()), this._y += Math.cos(i) * s / e.GetParentScaleY());
          } else this._y = t;
        }
        OffsetY(t, e = false) {
          t = +t, !e && this.GetTransformWithParentY() ? this.SetY(this.GetY() + t) : this._y += t;
        }
        GetY() {
          if (this.GetTransformWithParentY()) {
            let t = this._y;
            const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
            return 0 === i ? t *= e.GetParentScaleY() : (t = t * e.GetParentScaleY() * Math.cos(i), this.GetTransformWithParentX() && (t += this._x * e.GetParentScaleX() * Math.sin(i))), s.GetY() + t;
          }
          return this._y;
        }
        SetXY(t, e) {
          if (t = +t, e = +e, this.GetTransformWithParentXOrY()) {
            const s = this.GetTransformWithParentX(), i = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r = t - this.GetX(), h = e - this.GetY(), a = -this._GetParentOffsetAngle();
            if (0 == a) s ? this._x += r / n.GetParentScaleX() : this._x = t, i ? this._y += h / n.GetParentScaleY() : this._y = e;
            else {
              const o = Math.sin(a), l = Math.cos(a);
              s ? this._x += i ? (l * r - o * h) / n.GetParentScaleX() : l * r / n.GetParentScaleX() : this._x = t, i ? this._y += s ? (o * r + l * h) / n.GetParentScaleY() : l * h / n.GetParentScaleY() : this._y = e;
            }
          } else this._x = t, this._y = e;
        }
        GetXY() {
          return [this.GetX(), this.GetY()];
        }
        OffsetXY(t, e) {
          t = +t, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t, this.GetY() + e) : (this._x += t, this._y += e);
        }
        EqualsXY(t, e) {
          return this.GetX() === t && this.GetY() === e;
        }
        SetZElevation(t) {
          if (t = +t, this.GetTransformWithParentZElevation() && (t -= this.GetParent().GetZElevation()), this._zElevation !== t) {
            this._zElevation = t, this._UpdateZElevation();
            const e = this.GetLayer();
            0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);
          }
        }
        _UpdateZElevation() {
          if (this._UpdateRendererStateGroup(), this.HasChildren()) {
            const s = this.GetChildren();
            for (let t = 0, e = s.length; t < e; t++) {
              const i = s[t];
              i.GetTransformWithParentZElevation() && i._UpdateZElevation();
            }
          }
        }
        OffsetZElevation(t) {
          this.SetZElevation(this.GetZElevation() + t);
        }
        GetZElevation() {
          return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;
        }
        GetTotalZElevation() {
          return this.GetLayer().GetZElevation() + this.GetZElevation();
        }
        IsOriginalSizeKnown() {
          const t = this.GetInstance().GetPlugin().GetSdkVersion();
          return t < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();
        }
        SetWidth(t) {
          if (t = +t, this.GetTransformWithParentWidth()) {
            const e = this.GetWidth();
            0 === e ? this._w = Number.EPSILON : this._w *= t / e;
          } else this._w = t;
          this._MarkSinCosAngleChanged();
        }
        OffsetWidth(t, e) {
          t = +t, !e && this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t) : this._w += t, this._MarkSinCosAngleChanged();
        }
        GetWidth() {
          if (this.GetTransformWithParentWidth()) {
            const t = this.GetParent(), e = t.GetWidth(), s = t._GetSceneGraphInfo()._GetStartWidth();
            return s === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;
          }
          return this._w;
        }
        SetHeight(t) {
          if (t = +t, this.GetTransformWithParentHeight()) {
            const e = this.GetHeight();
            0 === e ? this._h = Number.EPSILON : this._h *= t / e;
          } else this._h = t;
          this._MarkSinCosAngleChanged();
        }
        OffsetHeight(t, e) {
          t = +t, !e && this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t) : this._h += t, this._MarkSinCosAngleChanged();
        }
        GetHeight() {
          if (this.GetTransformWithParentHeight()) {
            const t = this.GetParent(), e = t.GetHeight(), s = t._GetSceneGraphInfo()._GetStartHeight();
            return s === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;
          }
          return this._h;
        }
        SetSize(t, e) {
          if (t = +t, e = +e, this.GetTransformWithParentWidth()) {
            const s = this.GetWidth();
            0 === s ? this._w = Number.EPSILON : this._w *= t / s;
          } else this._w = t;
          if (this.GetTransformWithParentHeight()) {
            const i = this.GetHeight();
            0 === i ? this._h = Number.EPSILON : this._h *= e / i;
          } else this._h = e;
          this._MarkSinCosAngleChanged();
        }
        GetSize() {
          return [this.GetWidth(), this.GetHeight()];
        }
        GetDepth() {
          return this._depth;
        }
        SetDepth(t) {
          if (t < 0) throw new RangeError("invalid depth");
          this._depth = t;
        }
        GetSceneGraphScale() {
          if (this.HasParent()) {
            const t = this._sceneGraphInfo;
            return Math.min(t.GetParentScaleX(), t.GetParentScaleY());
          }
          return 1;
        }
        IsRotatable() {
          return 0 != (this._flags & FLAG_IS_ROTATABLE);
        }
        SetAngle(t) {
          t = +t, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = C33.clampAngle(t), this._a !== t) && (this._a = t, this._MarkSinCosAngleChanged());
        }
        OffsetAngle(t) {
          0 !== (t = +t) && this.IsRotatable() && (this._a = C33.clampAngle(this._a + t), this._MarkSinCosAngleChanged());
        }
        _MarkSinCosAngleChanged() {
          if (this._flags |= FLAG_SIN_COS_ANGLE_CHANGED, this.HasChildren()) {
            const s = this.GetChildren();
            for (let t = 0, e = s.length; t < e; t++) s[t]._MarkSinCosAngleChanged();
          }
        }
        GetAngle() {
          return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;
        }
        _GetAngleNoReflect() {
          return this.GetTransformWithParentAngle() && this.IsRotatable() ? C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;
        }
        _MaybeReflectAngleForMirrorFlip(t) {
          return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t = C33.clampAngle(C33.angleReflect(t, this.GetTopParent().GetAngle() + Math.PI))), t = this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 ? C33.angleReflect(t, this.GetTopParent().GetAngle()) : t;
        }
        _NeedsReflectAngleForMirrorOrFlip() {
          const t = this.GetParent();
          return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t.GetHeight() < 0);
        }
        _NeedsReflectAngleForMirrorAndFlip() {
          const t = this.GetParent();
          return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0 && this.GetTransformWithParentHeight() && t.GetHeight() < 0);
        }
        _MaybeUpdateSinCosAngle() {
          const t = this._flags;
          if (0 != (t & FLAG_SIN_COS_ANGLE_CHANGED)) {
            const e = this.GetAngle();
            this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = t & ~FLAG_SIN_COS_ANGLE_CHANGED;
          }
        }
        GetSinAngle() {
          return this._MaybeUpdateSinCosAngle(), this._sinA;
        }
        GetCosAngle() {
          return this._MaybeUpdateSinCosAngle(), this._cosA;
        }
        SetOriginX(t) {
          this._ox = +t;
        }
        OffsetOriginX(t) {
          this._ox += +t;
        }
        GetOriginX() {
          return this._ox;
        }
        SetOriginY(t) {
          this._oy = +t;
        }
        OffsetOriginY(t) {
          this._oy += +t;
        }
        GetOriginY() {
          return this._oy;
        }
        _SetColor(t) {
          this._color.equals(t) || (this._color === DEFAULT_COLOR ? (this._color = C33.New(C33.Color, t), this._colorPremultiplied = C33.New(C33.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());
        }
        SetOpacity(t) {
          if (t = C33.clamp(+t, 0, 1), this.GetTransformWithParentOpacity()) {
            if (this._GetSceneGraphInfo().GetOwnOpacity() === t) return;
            this._GetSceneGraphInfo().SetOwnOpacity(t), t = this.GetOpacity();
          } else if (this._color.a === t) return;
          this._SetColorWithOpacity(t);
        }
        _SetOpacityOfChildren() {
          if (this.HasChildren()) {
            const s = this.GetChildren();
            for (let t = 0, e = s.length; t < e; t++) {
              const i = s[t];
              i._SetColorWithOpacity(i.GetOpacity());
            }
          }
        }
        _SetColorWithOpacity(t) {
          tempColor.copyRgb(this._color), tempColor.a = t, this._SetColor(tempColor), this._SetOpacityOfChildren();
        }
        OffsetOpacity(t) {
          this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t) : this.SetOpacity(this.GetOpacity() + t);
        }
        GetOpacity() {
          return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;
        }
        SetUnpremultipliedColor(t) {
          this._color.equalsIgnoringAlpha(t) || (tempColor.copyRgb(t), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));
        }
        SetUnpremultipliedColorRGB(t, e, s) {
          tempColor.setRgb(t, e, s), this.SetUnpremultipliedColor(tempColor);
        }
        OffsetUnpremultipliedColorRGB(t, e, s) {
          0 === t && 0 === e && 0 === s || (tempColor.copyRgb(this._color), tempColor.r += t, tempColor.g += e, tempColor.b += s, this.SetUnpremultipliedColor(tempColor));
        }
        GetUnpremultipliedColor() {
          return this._color;
        }
        GetPremultipliedColor() {
          return this._colorPremultiplied;
        }
        GetDestroyWithParent() {
          return 0 != (this._flags & FLAG_DESTROY_WITH_PARENT);
        }
        SetDestroyWithParent(t) {
          this._SetFlag(FLAG_DESTROY_WITH_PARENT, t);
        }
        GetTransformWithParentX() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_X);
        }
        SetTransformWithParentX(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, t);
        }
        GetTransformWithParentY() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y);
        }
        GetTransformWithParentXOrY() {
          return 0 != (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y));
        }
        SetTransformWithParentY(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y, t);
        }
        GetTransformWithParentWidth() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_W);
        }
        SetTransformWithParentWidth(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, t);
        }
        GetTransformWithParentHeight() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_H);
        }
        SetTransformWithParentHeight(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, t);
        }
        GetTransformWithParentAngle() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_A);
        }
        SetTransformWithParentAngle(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, t);
        }
        GetTransformWithParentZElevation() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION);
        }
        SetTransformWithParentZElevation(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, t);
        }
        GetTransformWithParentOpacity() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_OPACITY);
        }
        SetTransformWithParentOpacity(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_OPACITY, t);
        }
        GetTransformWithParentVisibility() {
          return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY);
        }
        SetTransformWithParentVisibility(t) {
          this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, t);
        }
        _ClearAllSceneGraphFlags() {
          this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS;
        }
        AddChild(t, e) {
          if (t === this) return false;
          if (t.HasParent()) return false;
          if (this._HasChildRecursive(t)) return false;
          if (this._HasAnyParent(t)) return false;
          const s = t.GetX(), i = t.GetY(), n = t.GetWidth(), r = t.GetHeight(), h = t.GetAngle(), a = t.GetZElevation(), o = t.GetOpacity(), l = (t._SetParent(this), t.SetTransformWithParentX(e.transformX), t.SetTransformWithParentY(e.transformY), t.SetTransformWithParentWidth(e.transformWidth), t.SetTransformWithParentHeight(e.transformHeight), t.SetTransformWithParentAngle(e.transformAngle), t.SetTransformWithParentZElevation(e.transformZElevation), t.SetTransformWithParentOpacity(e.transformOpacity), t.SetTransformWithParentVisibility(e.transformVisibility), t.SetDestroyWithParent(e.destroyWithParent), s - this.GetX()), _ = i - this.GetY(), G = -this.GetAngle(), c = Math.cos(G), d = Math.sin(G);
          if (e.transformX && (e.transformAngle ? t._x = l * c - _ * d : t._x = l, e.transformWidth)) {
            const S = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();
            0 != S && (t._x /= S);
          }
          if (e.transformY && (e.transformAngle ? t._y = l * d + _ * c : t._y = _, e.transformHeight)) {
            const f = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();
            0 != f && (t._y /= f);
          }
          if (e.transformWidth) {
            const p = this.GetWidth();
            0 === p || p === Number.EPSILON ? (t._w = 1, t._sceneGraphInfo.SetStartScaleX(1)) : (t._w = n / this.GetWidth(), t._sceneGraphInfo.SetStartScaleX(t._w));
          }
          if (e.transformHeight) {
            const C = this.GetHeight();
            0 === C || C === Number.EPSILON ? (t._h = 1, t._sceneGraphInfo.SetStartScaleY(1)) : (t._h = r / this.GetHeight(), t._sceneGraphInfo.SetStartScaleY(t._h));
          }
          return e.transformAngle && (t._a = h - this.GetAngle()), e.transformZElevation && (t._zElevation = a - this.GetZElevation()), e.transformOpacity && t._sceneGraphInfo.SetOwnOpacity(o), e.transformVisibility && t.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;
        }
        RemoveChild(t) {
          if (t.GetParent() === this) {
            const e = t.GetX(), s = t.GetY(), i = t.GetWidth(), n = t.GetHeight(), r = t.GetAngle(), h = t.GetZElevation(), a = t.GetOpacity();
            t._SetParent(null), t._ClearAllSceneGraphFlags(), t.SetXY(e, s), t.SetSize(i, n), t.SetAngle(r), t.SetZElevation(h), t.SetOpacity(a), this._RemoveChildFromSceneGraphInfo(t), this.SetBboxChanged();
          }
        }
        GetTmpHierarchyPosition() {
          return this._tmpHierarchyPosition;
        }
        _ResetAllSceneGraphState() {
          this._BuildTmpSceneGraphData();
          const t = [...this.children()];
          for (const s of t) this.RemoveChild(s);
          const e = this.GetParent();
          e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();
        }
        _BuildTmpSceneGraphData() {
          if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {
            const e = [...this.children()];
            e.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
            let t2 = 0;
            for (const s of e) {
              const i = s.GetInstance();
              this._tmpSceneGraphChildren.push(i), this._tmpSceneGraphChildrenIndexes.set(i, t2), t2++;
            }
          }
          const t = this.GetParent();
          t && t._BuildTmpSceneGraphData();
        }
        _SetTmpHierarchyPosition() {
          if (-1 === this._tmpHierarchyPosition) {
            const t = [...this.parents()];
            this._tmpHierarchyPosition = t.length;
            for (const s of t) s._SetTmpHierarchyPosition();
            const e = [...this.children()];
            for (const i of e) i._SetTmpHierarchyPosition();
          }
        }
        _ReleaseTmpSceneGraphInfo() {
          this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;
          const t = this.GetParent();
          t && t._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;
        }
        HasParent() {
          return null !== this.GetParent();
        }
        GetParent() {
          const t = this._sceneGraphInfo;
          return null !== t ? t.GetParent() : null;
        }
        GetTopParent() {
          let t = this;
          for (; t.HasParent(); ) t = t.GetParent();
          return t;
        }
        *parents() {
          let t = this.GetParent();
          for (; t; ) yield t, t = t.GetParent();
        }
        HasChild(t) {
          return this.GetChildren().includes(t);
        }
        HasChildren() {
          const t = this._sceneGraphInfo;
          return null !== t && t.HasChildren();
        }
        GetChildren() {
          const t = this._sceneGraphInfo;
          return null !== t ? t.GetChildren() : EMPTY_ARRAY;
        }
        children() {
          return this.GetChildren();
        }
        *allChildren() {
          for (const t of this.children()) yield t, yield* t.allChildren();
        }
        GetChildCount() {
          return this.GetChildren().length;
        }
        GetAllChildCount() {
          return [...this.allChildren()].length;
        }
        GetChildAt(t) {
          const e = this.GetChildren();
          return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];
        }
        GetChildIndex(e) {
          if (e) {
            const s = this.GetChildren();
            if (s) {
              for (let t = 0; t < s.length; t++) if (e === s[t]) return t;
            }
          }
          return NaN;
        }
        _CreateSceneGraphInfo(t) {
          this._sceneGraphInfo || (this._sceneGraphInfo = C33.New(C33.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t);
        }
        _GetSceneGraphInfo() {
          return this._sceneGraphInfo;
        }
        _ReleaseSceneGraphInfo() {
          this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);
        }
        _SetParent(t) {
          t ? (t._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());
        }
        _HasAnyParent(t) {
          if (!this.HasParent()) return false;
          const e = this.GetParent();
          return e === t || e._HasAnyParent(t);
        }
        _HasChildRecursive(t) {
          if (this.HasChild(t)) return true;
          for (const e of this.GetChildren()) if (e._HasChildRecursive(t)) return true;
          return false;
        }
        _AddChildToSceneGraphInfo(t) {
          this._sceneGraphInfo.GetChildren().push(t);
        }
        _RemoveChildFromSceneGraphInfo(t) {
          const e = this._sceneGraphInfo.GetChildren(), s = e.indexOf(t);
          -1 !== s && e.splice(s, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t.HasChildren() || t._ReleaseSceneGraphInfo();
        }
        GetSceneGraphChildrenExportData() {
          const t = sceneGraphExportDataMap.get(this);
          return t ? t.childrenData : null;
        }
        GetSceneGraphZIndexExportData() {
          const t = sceneGraphExportDataMap.get(this);
          return t ? t.zIndexData : NaN;
        }
        GetSceneGraphZIndex() {
          const t = sceneGraphZIndexMap.get(this);
          return C33.IsFiniteNumber(t) ? t : NaN;
        }
        SetSceneGraphZIndex(t) {
          sceneGraphZIndexMap.set(this, t);
        }
        SetUsePointsShaderProgram() {
          this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, true), this._UpdateRendererStateGroup();
        }
        _UpdateRendererStateGroup() {
          if (enableUpdateRendererStateGroup) {
            const e = this._runtime.GetRenderer();
            this._stateGroup && e.ReleaseStateGroup(this._stateGroup);
            let t;
            t = 0 != (this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) ? e.GetPointsRenderingProgram() || "<point>" : e.GetTextureFillShaderProgram() || "<default>", this._stateGroup = e.AcquireStateGroup(t, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation());
          }
        }
        GetRendererStateGroup() {
          return this._stateGroup;
        }
        HasDefaultColor() {
          return this._color === DEFAULT_COLOR;
        }
        SetBlendMode(t) {
          if ((t |= 0) < 0 || 31 < t) throw new RangeError("invalid blend mode");
          this.GetBlendMode() !== t && (this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | t << FLAG_BLEND_MODE_BIT_OFFSET, this._UpdateRendererStateGroup());
        }
        GetBlendMode() {
          return (this._flags & FLAG_BLEND_MODE_MASK) >> FLAG_BLEND_MODE_BIT_OFFSET;
        }
        _SetLayer(t, e) {
          const s = e && this._layer !== t;
          s && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t), this._layer = t, s && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();
        }
        GetLayer() {
          return this._layer;
        }
        GetLayout() {
          return this.GetLayer().GetLayout();
        }
        _SetZIndex(t) {
          this._zIndex = 0 | t;
        }
        GetZIndex() {
          return this._layer._UpdateZIndices(), this._zIndex;
        }
        _SetHTMLZIndex(t) {
          this._htmlZIndex = 0 | t;
        }
        GetHTMLZIndex() {
          return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;
        }
        _GetLastCachedZIndex() {
          return this._zIndex;
        }
        _SetFlag(t, e) {
          e ? this._flags |= t : this._flags &= ~t;
        }
        IsVisible() {
          return 0 != (this._flags & FLAG_IS_VISIBLE);
        }
        SetVisible(t) {
          if (this._SetFlag(FLAG_IS_VISIBLE, t), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t);
        }
        IsCollisionEnabled() {
          return 0 != (this._flags & FLAG_COLLISION_ENABLED);
        }
        SetCollisionEnabled(t) {
          t = !!t, this.IsCollisionEnabled() !== t && (this._SetFlag(FLAG_COLLISION_ENABLED, t), t ? this.SetBboxChanged() : this._RemoveFromCollisionCells());
        }
        SetSolidCollisionFilter(t, e) {
          if (this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, t), this._solidFilterTags && this._solidFilterTags.clear(), e.trim()) {
            this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set());
            for (const s of e.split(" ")) s && this._solidFilterTags.add(s.toLowerCase());
          } else this._solidFilterTags = null;
        }
        IsSolidCollisionAllowed(t) {
          const e = 0 != (this._flags & FLAG_SOLID_FILTER_INCLUSIVE), s = this._solidFilterTags;
          if (t && s) {
            for (const i of s) if (t.has(i)) return e;
          }
          return !e;
        }
        SetBboxChanged() {
          if (this._flags |= FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= ~FLAG_BBOX_CHANGED, this._UpdateRenderCell()), 0 != (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {
            const s = this._sceneGraphInfo.GetChildren();
            for (let t = 0, e = s.length; t < e; ++t) s[t].SetBboxChanged();
          }
        }
        CalculateBbox(t, e, s) {
          const i = this.GetX(), n = this.GetY(), r = this.GetWidth(), h = this.GetHeight(), a = this.GetAngle();
          t.setWH(i - this._ox * r, n - this._oy * h, r, h), s && this.HasMesh() && this._ExpandBboxForMesh(t), 0 === a ? e.setFromRect(t) : (t.offset(-i, -n), e.setFromRotatedRectPrecalc(t, this.GetSinAngle(), this.GetCosAngle()), e.offset(i, n), e.getBoundingBox(t)), t.normalize();
        }
        _UpdateBbox() {
          const t = this._flags;
          0 != (t & FLAG_BBOX_CHANGED) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = t & ~FLAG_BBOX_CHANGED);
        }
        GetBoundingBox() {
          return this._UpdateBbox(), this._boundingBox;
        }
        GetBoundingQuad() {
          return this._UpdateBbox(), this._boundingQuad;
        }
        PixelRoundQuad(t) {
          const e = this.GetX(), s = this.GetY(), i = Math.round(e) - e, n = Math.round(s) - s;
          return 0 == i && 0 == n ? t : (tempQuad.copy(t), tempQuad.offset(i, n), tempQuad);
        }
        OverwriteBoundingBox(t) {
          this._boundingBox.copy(t), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= ~FLAG_BBOX_CHANGED, this._UpdateCollisionCell(), this._UpdateRenderCell();
        }
        SetBboxChangeEventEnabled(t) {
          this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, t);
        }
        IsBboxChangeEventEnabled() {
          return 0 != (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT);
        }
        IsInViewport(t, e, s) {
          return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s ? t.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();
        }
        _IsInViewport_ZElevated() {
          const t = this.GetLayer(), e = this.GetTotalZElevation();
          return !(e >= t.Get2DCameraZ()) && (t.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));
        }
        IsInViewport3D(t) {
          const e = this.GetBoundingBox(), s = e.getLeft(), i = e.getRight(), n = e.getTop(), r = e.getBottom(), h = this.GetTotalZElevation(), a = h + this.GetDepth();
          return t.ContainsAABB(s, n, h, i, r, a);
        }
        IsInViewport2() {
          const t = this.GetLayer();
          if (t.Has3DCamera()) return this.IsInViewport3D(t._GetViewFrustum());
          {
            const e = t.GetLayout();
            return this.IsInViewport(t.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());
          }
        }
        _SetDrawBackFaceOnly(t) {
          this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, t);
        }
        _SetDrawNonBackFacesOnly(t) {
          this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, t);
        }
        IsDrawBackFaceOnly() {
          return 0 != (this._flags & FLAG_DRAW_BACK_FACE_ONLY);
        }
        IsDrawNonBackFacesOnly() {
          return 0 != (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY);
        }
        SetSourceCollisionPoly(t) {
          this._sourceCollisionPoly = t, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);
        }
        GetSourceCollisionPoly() {
          return this._sourceCollisionPoly;
        }
        HasOwnCollisionPoly() {
          return null !== this._sourceCollisionPoly || this.HasMesh();
        }
        GetTransformedCollisionPoly() {
          return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());
        }
        GetCustomTransformedCollisionPoly(t, e, s) {
          let i = 0, n = 1;
          return 0 !== s && (i = Math.sin(s), n = Math.cos(s)), this._GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n);
        }
        _GetCustomTransformedCollisionPolyPrecalc(e, s, t, i, n) {
          let r = this._transformedPolyInfo;
          null === r && (r = { poly: C33.New(C33.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r);
          const h = r.poly;
          if (r.width !== e || r.height !== s || r.angle !== t) {
            const a = this._sourceCollisionPoly;
            if (this.HasMesh()) {
              const o = this.GetOriginX(), l = this.GetOriginY(), _ = this.GetSourceMesh();
              let t2 = this._meshInfo.meshPoly;
              t2 || (a ? (tempCollisionPoly.copy(a), tempCollisionPoly.offset(o, l)) : tempCollisionPoly.setDefaultPoints(), t2 = _.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = t2), _.TransformCollisionPoly(t2, h), h.offset(-o, -l), h.transformPrecalc(e, s, i, n);
            } else a ? (h.copy(a), h.transformPrecalc(e, s, i, n)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
            r.width = e, r.height = s, r.angle = t;
          }
          return h;
        }
        _DiscardTransformedCollisionPoly() {
          this.SetPhysicsBodyChanged(true);
          const t = this._transformedPolyInfo;
          null !== t && (t.width = NaN);
        }
        CreateMesh(t, e) {
          if (t = Math.floor(t), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error("object does not support mesh");
          this.ReleaseMesh(), this._meshInfo = { sourceMesh: C33.New(C33.Gfx.Mesh, t, e), transformedMesh: C33.New(C33.Gfx.Mesh, t, e), meshPoly: null };
        }
        HasMesh() {
          return null !== this._meshInfo;
        }
        GetSourceMesh() {
          if (this.HasMesh()) return this._meshInfo.sourceMesh;
          throw new Error("no mesh");
        }
        GetTransformedMesh() {
          if (this.HasMesh()) return this._meshInfo.transformedMesh;
          throw new Error("no mesh");
        }
        SetMeshChanged(t) {
          this._SetFlag(FLAG_MESH_CHANGED, t);
        }
        IsMeshChanged() {
          return 0 != (this._flags & FLAG_MESH_CHANGED);
        }
        SetPhysicsBodyChanged(t) {
          this._SetFlag(FLAG_PHYSICS_BODY_CHANGED, t);
        }
        IsPhysicsBodyChanged() {
          return 0 != (this._flags & FLAG_PHYSICS_BODY_CHANGED);
        }
        _ExpandBboxForMesh(t) {
          const e = this._meshInfo.sourceMesh, s = Math.min(e.GetMinX(), 0), i = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r = Math.max(e.GetMaxY(), 1), h = t.width(), a = t.height();
          t.offsetLeft(s * h), t.offsetTop(i * a), t.offsetRight((n - 1) * h), t.offsetBottom((r - 1) * a), this._depth = e.GetMaxZ();
        }
        ReleaseMesh() {
          this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());
        }
        SetMeshPoint(t, e, s) {
          t = Math.floor(t), e = Math.floor(e);
          const i = s.mode || "absolute";
          if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error("invalid mode");
          const n = "relative" === i;
          let r = s.x, h = s.y;
          const a = s.zElevation;
          let o = "number" == typeof s.u ? s.u : n ? 0 : -1, l = "number" == typeof s.v ? s.v : n ? 0 : -1;
          if (!this.HasMesh()) return false;
          const _ = this.GetSourceMesh(), G = _.GetMeshPointAt(t, e);
          if (null === G) return false;
          let c = false;
          return "number" == typeof a && G.GetZElevation() !== a && (G.SetZElevation(a), c = true), n && (r += t / (_.GetHSize() - 1), h += e / (_.GetVSize() - 1)), o = -1 !== o || n ? (n && (o += t / (_.GetHSize() - 1)), C33.clamp(o, 0, 1)) : G.GetU(), l = -1 !== l || n ? (n && (l += e / (_.GetVSize() - 1)), C33.clamp(l, 0, 1)) : G.GetV(), G.GetX() === r && G.GetY() === h && G.GetU() === o && G.GetV() === l ? c : (G.SetX(r), G.SetY(h), G.SetU(o), G.SetV(l), this._DiscardTransformedCollisionPoly(), true);
        }
        HasTilemap() {
          return this._inst.HasTilemap();
        }
        ContainsPoint(t, e) {
          return !!this.GetBoundingBox().containsPoint(t, e) && !!this.GetBoundingQuad().containsPoint(t, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t - this.GetX(), e - this.GetY()));
        }
        _IsCollisionCellChanged() {
          return 0 != (this._flags & FLAG_COLLISION_CELL_CHANGED);
        }
        _UpdateCollisionCell() {
          if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 == (this._flags & FLAG_DESTROYED)) {
            const t = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s = this._collisionCells;
            if (tempRect.set(e.XToCell(t.getLeft()), e.YToCell(t.getTop()), e.XToCell(t.getRight()), e.YToCell(t.getBottom())), !s.equals(tempRect)) {
              const i = this._inst;
              s === DEFAULT_COLLISION_CELLS ? (e.Update(i, null, tempRect), this._collisionCells = C33.New(C33.Rect, tempRect)) : (e.Update(i, s, tempRect), s.copy(tempRect)), this._flags &= ~FLAG_COLLISION_CELL_CHANGED;
            }
          }
        }
        _SetCollisionCellChanged() {
          this._flags |= FLAG_COLLISION_CELL_CHANGED;
        }
        _RemoveFromCollisionCells() {
          const t = this._collisionCells;
          t !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null), this._collisionCells = DEFAULT_COLLISION_CELLS);
        }
        _UpdateRenderCell() {
          const t = this.GetLayer();
          if (t.UsesRenderCells() && 0 == (this._flags & FLAG_DESTROYED)) {
            const e = t.GetRenderGrid(), s = this.GetBoundingBox(), i = this._renderCells;
            if (tempRect.set(e.XToCell(s.getLeft()), e.YToCell(s.getTop()), e.XToCell(s.getRight()), e.YToCell(s.getBottom())), !i.equals(tempRect)) {
              const n = this._inst;
              i === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C33.New(C33.Rect, tempRect)) : (e.Update(n, i, tempRect), i.copy(tempRect)), t.SetRenderListStale();
            }
          }
        }
        _RemoveFromRenderCells() {
          const t = this._renderCells;
          t !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t, null), this._renderCells = DEFAULT_RENDER_CELLS);
        }
        GetRenderCellRange() {
          return this._renderCells;
        }
        ZOrderMoveToTop() {
          const t = this._inst, e = this._layer, s = e._GetInstances();
          s.length && s.at(-1) === t || (e._RemoveInstance(t, false), e._AddInstance(t, false), this._runtime.UpdateRender());
        }
        ZOrderMoveToBottom() {
          const t = this._inst, e = this._layer, s = e._GetInstances();
          s.length && s[0] === t || (e._RemoveInstance(t, false), e._PrependInstance(t, false), this._runtime.UpdateRender());
        }
        ZOrderMoveToLayer(t) {
          const e = this._inst, s = this._layer;
          if (s.GetLayout() !== t.GetLayout()) throw new Error("layer from different layout");
          t !== s && (s._RemoveInstance(e, true), this._SetLayer(t), t._AddInstance(e, true), this._runtime.UpdateRender());
        }
        ZOrderMoveAdjacentToInstance(t, e) {
          const s = this._inst;
          let i = false;
          const n = this._layer;
          if (t.GetUID() !== s.GetUID()) {
            const r = t.GetWorldInfo();
            if (!r) throw new Error("expected world instance");
            const h = r.GetLayer(), a = (n.GetIndex() !== h.GetIndex() && (n._RemoveInstance(s, true), this._SetLayer(h), h._AddInstance(s, true), i = true), h.MoveInstanceAdjacent(s, t, !!e));
            (i || a) && this._runtime.UpdateRender();
          }
        }
        GetInstanceEffectList() {
          return this._instanceEffectList;
        }
        _SetHasAnyActiveEffect(t) {
          this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, t);
        }
        HasAnyActiveEffect() {
          return 0 != (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT);
        }
        _SaveToJson(t, e = null) {
          const s = { "x": this.GetX(), "y": this.GetY(), "w": this.GetWidth(), "h": this.GetHeight(), "l": this.GetLayer().GetSID(), "zi": this.GetZIndex() }, i = (0 !== this.GetZElevation() && (s["ze"] = this.GetZElevation()), 0 !== this.GetAngle() && (s["a"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s["c"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s["oX"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s["oY"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s["bm"] = this.GetBlendMode()), this.IsVisible() || (s["v"] = this.IsVisible()), this.IsCollisionEnabled() || (s["ce"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s["be"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s["fx"] = this._instanceEffectList._SaveToJson()), 0 != (this._flags & FLAG_SOLID_FILTER_INCLUSIVE));
          return i && (s["sfi"] = i), this._solidFilterTags && (s["sft"] = [...this._solidFilterTags].join(" ")), this._sceneGraphInfo && "visual-state" !== t && (s["sgi"] = this._sceneGraphInfo._SaveToJson(t, e), sceneGraphExportDataMap.has(this)) && (s["sgcd"] = sceneGraphExportDataMap.get(this).childrenData, s["sgzid"] = sceneGraphExportDataMap.get(this).zIndexData), this.HasMesh() && (s["mesh"] = this.GetSourceMesh().SaveToJson()), s;
        }
        _SaveSceneGraphPropertiesToJson() {
          return { "x": this._x, "y": this._y, "z": this._zElevation, "w": this._w, "h": this._h, "a": this._a, "sgi": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };
        }
        _LoadSceneGraphPropertiesFromJson(t) {
          t && (this._x = t["x"], this._y = t["y"], this._zElevation = t["z"], this._w = t["w"], this._h = t["h"], this._a = t["a"], t["sgi"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t["sgi"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());
        }
        _SetupSceneGraphConnectionsOnChangeOfLayout() {
          this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);
        }
        _OnBeforeLoad(t) {
          "visual-state" !== t && this._ResetAllSceneGraphState();
        }
        _OnAfterLoad(t, e = "full", s = null) {
          t.hasOwnProperty("sgi") && "visual-state" !== e && 0 == (this._flags & FLAG_DESTROYED) && this._sceneGraphInfo._OnAfterLoad(t["sgi"], s);
        }
        _OnAfterLoad2(t, e = "full", s) {
          t.hasOwnProperty("sgi") && "visual-state" !== e && 0 == (this._flags & FLAG_DESTROYED) && (this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null), this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged());
        }
        _LoadFromJson(t, e) {
          if (enableUpdateRendererStateGroup = false, this.SetX(t["x"]), this.SetY(t["y"]), this.SetWidth(t["w"]), this.SetHeight(t["h"]), this._SetZIndex(t["zi"]), this.SetZElevation(t.hasOwnProperty("ze") ? t["ze"] : 0), this.SetAngle(t.hasOwnProperty("a") ? t["a"] : 0), t.hasOwnProperty("c") ? tempColor.setFromJSON(t["c"]) : t.hasOwnProperty("o") ? (tempColor.copyRgb(this._color), tempColor.a = t["o"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t.hasOwnProperty("oX") ? t["oX"] : 0.5), this.SetOriginY(t.hasOwnProperty("oY") ? t["oY"] : 0.5), this.SetBlendMode(t.hasOwnProperty("bm") ? t["bm"] : 0), this.SetVisible(!t.hasOwnProperty("v") || t["v"]), this.SetCollisionEnabled(!t.hasOwnProperty("ce") || t["ce"]), this.SetBboxChangeEventEnabled(!!t.hasOwnProperty("be") && t["be"]), this.SetSolidCollisionFilter(!!t.hasOwnProperty("sfi") && t["sfi"], t.hasOwnProperty("sft") ? t["sft"] : ""), this._instanceEffectList && t.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(t["fx"]), !t.hasOwnProperty("sgi") && "visual-state" !== e && this._tmpSceneGraphChildren) for (const s of this._tmpSceneGraphChildren) s.IsDestroyed() || this._runtime.DestroyInstance(s);
          if (t.hasOwnProperty("sgi") && "visual-state" !== e) {
            this._CreateSceneGraphInfo(null);
            const i = this._sceneGraphInfo, n = t["sgi"];
            i._LoadFromJson(n), i._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), t["sgcd"] && C33.IsFiniteNumber(t["sgzid"]) && sceneGraphExportDataMap.set(this, { childrenData: t["sgcd"], zIndexData: t["sgzid"] });
          }
          if (t.hasOwnProperty("mesh")) {
            const r = t["mesh"];
            this.CreateMesh(r["cols"], r["rows"]), this.GetSourceMesh().LoadFromJson(r);
          } else this.ReleaseMesh();
          this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), "visual-state" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t);
        }
      };
    }
    {
      const C33 = self.C3;
      C33.BehaviorType = class extends C33.DefendedBase {
        constructor(e, t) {
          super();
          const s = e.GetRuntime(), i = s.GetObjectReference(t[1]), r = (s.GetAddonManager()._DelayCreateBehavior(i), this._runtime = s, this._objectClass = e, this._behavior = C33.AddonManager.GetBehaviorByConstructorFunction(i), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i.Instance, this._sid = t[2], this._name = t[0], this._jsPropName = this._runtime.GetJsPropName(t[3]), this._behavior.GetSdkVersion());
          if (r < 2 && (this._sdkType = C33.New(i.Type, this), !(this._sdkType instanceof C33.SDKBehaviorTypeBase))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
          if (C33.AddonManager._PushInitObject(this, r), 2 <= r) {
            const a = i.Type ?? globalThis.ISDKBehaviorTypeBase;
            if (this._iBehaviorType = new a(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
          } else this._iBehaviorType = new globalThis.IBehaviorType();
          C33.AddonManager._PopInitObject(r), this.OnCreate();
        }
        static Create(e, t) {
          return C33.New(C33.BehaviorType, e, t);
        }
        Release() {
          this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;
        }
        GetSdkType() {
          return this._sdkType;
        }
        OnCreate() {
          this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();
        }
        GetRuntime() {
          return this._runtime;
        }
        GetObjectClass() {
          return this._objectClass;
        }
        GetBehavior() {
          return this._behavior;
        }
        GetInstanceSdkCtor() {
          return this._instSdkCtor;
        }
        GetName() {
          return this._name;
        }
        GetSID() {
          return this._sid;
        }
        GetIBehaviorType() {
          return this._iBehaviorType;
        }
        GetJsPropName() {
          return this._jsPropName;
        }
      };
    }
    {
      const C33 = self.C3, IBehaviorInstance = self.IBehaviorInstance;
      C33.BehaviorInstance = class extends C33.DefendedBase {
        constructor(t) {
          super(), this._runtime = t.runtime, this._behaviorType = t.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t.instance, this._index = t.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);
        }
        Release() {
          this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;
        }
        _CreateSdkInstance(t) {
          if (this._sdkInst) throw new Error("already got sdk instance");
          const e = this.GetBehavior().GetSdkVersion();
          if (e < 2) {
            if (this._sdkInst = C33.New(this._behaviorType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKBehaviorInstanceBase)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
          } else {
            const s = this.GetBehavior().GetScriptInterfaceClass();
            this._InitScriptInterface(s.Instance, t);
          }
        }
        GetSdkInstance() {
          return this._sdkInst ?? this._iScriptInterface;
        }
        GetObjectInstance() {
          return this._inst;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetBehaviorType() {
          return this._behaviorType;
        }
        GetBehavior() {
          return this._behavior;
        }
        _GetIndex() {
          return this._index;
        }
        PostCreate() {
          this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();
        }
        OnSpriteFrameChanged(t, e) {
          this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t, e);
        }
        _GetDebuggerProperties() {
          return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
        }
        SaveToJson(t = "full") {
          return this._sdkInst ? this._sdkInst.SaveToJson(t) : this._iScriptInterface._saveToJson(t);
        }
        LoadFromJson(t, e = "full") {
          if (this._sdkInst) return this._sdkInst.LoadFromJson(t, e);
          this._iScriptInterface._loadFromJson(t, e);
        }
        static SortByTickSequence(t, e, s) {
          const n = globalThis.ISDKBehaviorInstanceBase;
          let i, r;
          i = e instanceof n ? t._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r = s instanceof n ? t._UnwrapScriptInterface(s) : s.GetBehaviorInstance();
          const a = i.GetObjectInstance(), h = r.GetObjectInstance(), c = a.GetObjectClass().GetIndex(), o = h.GetObjectClass().GetIndex();
          if (c !== o) return c - o;
          const I = a.GetPUID(), _ = h.GetPUID();
          return I !== _ ? I - _ : i._GetIndex() - r._GetIndex();
        }
        _InitScriptInterface(t, e) {
          const s = IBehaviorInstance, n = t ?? this._sdkInst.GetScriptInterfaceClass(), i = n || s, r = this.GetBehavior().GetSdkVersion();
          if (C33.AddonManager._PushInitObject(this, r), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new i(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(r), !n || this._iScriptInterface instanceof s) return this._iScriptInterface;
          throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
        }
        GetScriptInterface() {
          return this._iScriptInterface || this._InitScriptInterface();
        }
        HasScriptInterface() {
          return !!this._iScriptInterface;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EffectList = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;
          for (const s of t) {
            const f = C33.New(C33.EffectType, this, s, this._allEffectTypes.length);
            this._allEffectTypes.push(f), this._effectTypesByName.set(f.GetName().toLowerCase(), f), 3 <= s.length && this._effectParams.push(this._LoadSingleEffectParameters(f, s[2]));
          }
          this.GetRuntime()._AddEffectList(this);
        }
        Release() {
          this.GetRuntime()._RemoveEffectList(this);
          for (const e of this._effectParamBuffers) e.Release();
          C33.clearArray(this._effectParamBuffers), C33.clearArray(this._allEffectTypes), C33.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C33.clearArray(this._effectParams), this._owner = null;
        }
        _AddInstanceEffectList(e) {
          this._allInstanceEffectLists.add(e);
        }
        _RemoveInstanceEffectList(e) {
          this._allInstanceEffectLists.delete(e);
        }
        _InitRenderer(e) {
          e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {
            const t = e2.GetShaderProgram();
            return 0 < t.GetCustomParametersByteSize() ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
          }), this._UpdateAllEffectParamBuffers());
          for (const t of this._allInstanceEffectLists) t._InitRenderer(e);
        }
        PrependEffectTypes(e) {
          if (e.length) {
            this._allEffectTypes = e.concat(this._allEffectTypes);
            for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);
            for (let e2 = 0, t = this._allEffectTypes.length; e2 < t; ++e2) this._allEffectTypes[e2]._SetIndex(e2);
          }
        }
        _LoadSingleEffectParameters(e, t) {
          e.SetActive(t[0]);
          const s = t.slice(1);
          for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {
            const f = s[e2];
            if (Array.isArray(f)) {
              const r = C33.New(C33.Color);
              r.setFromJSON(f), s[e2] = r;
            }
          }
          return s;
        }
        GetOwner() {
          return this._owner;
        }
        GetRuntime() {
          return this._owner.GetRuntime();
        }
        UpdateActiveEffects() {
          C33.clearArray(this._activeEffectTypes);
          let e = true;
          for (const t of this._allEffectTypes) t.IsActive() && (this._activeEffectTypes.push(t), t.GetShaderProgram().PreservesOpaqueness() || (e = false));
          this._preservesOpaqueness = e;
        }
        GetAllEffectTypes() {
          return this._allEffectTypes;
        }
        HasAnyEffectType() {
          return 0 < this._allEffectTypes.length;
        }
        GetEffectTypeByName(e) {
          return this._effectTypesByName.get(e.toLowerCase()) || null;
        }
        GetEffectTypeByIndex(e) {
          if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
          return this._allEffectTypes[e];
        }
        IsEffectIndexActive(e) {
          return this.GetEffectTypeByIndex(e).IsActive();
        }
        SetEffectIndexActive(e, t) {
          this.GetEffectTypeByIndex(e).SetActive(t);
        }
        GetActiveEffectTypes() {
          return this._activeEffectTypes;
        }
        HasAnyActiveEffect() {
          return 0 < this._activeEffectTypes.length;
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        GetEffectParametersForIndex(e) {
          return this._effectParams[e];
        }
        _GetEffectChainShaderParametersForIndex(e) {
          return (e < this._effectParamBuffers.length ? this._effectParamBuffers : this._effectParams)[e];
        }
        GetEffectParameter(e, t) {
          if (e < 0 || e >= this._effectParams.length) return null;
          const s = this._effectParams[e];
          return t < 0 || t >= s.length ? null : s[t];
        }
        SetEffectParameter(e, t, s) {
          if (e < 0 || e >= this._effectParams.length) return false;
          const f = this._effectParams[e];
          if (t < 0 || t >= f.length) return false;
          const r = f[t];
          if (r instanceof C33.Color) {
            if (r.equalsIgnoringAlpha(s)) return false;
            r.copyRgb(s);
          } else {
            if (r === s) return false;
            f[t] = s;
          }
          return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;
        }
        _UpdateAllEffectParamBuffers() {
          const s = this._effectParams, f = this._effectParamBuffers;
          for (let e = 0, t = Math.min(s.length, f.length); e < t; ++e) {
            const r = f[e], a = s[e];
            for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) r.SetParameterValue(e2, a[e2]);
          }
        }
        static SaveFxParamToJson(e) {
          return e && e instanceof C33.Color ? { "t": "color", "v": e.toJSON() } : e;
        }
        static LoadFxParamFromJson(e) {
          if (null === e) return NaN;
          if ("object" != typeof e) return e;
          {
            const t = e["t"];
            if ("color" !== t) throw new Error("invalid effect parameter type");
            {
              const s = C33.New(C33.Color);
              return s.setFromJSON(e["v"]), s;
            }
          }
        }
        static SaveFxParamsToJson(e) {
          return e.map(C33.EffectList.SaveFxParamToJson);
        }
        static LoadFxParamsFromJson(e) {
          return e.map(C33.EffectList.LoadFxParamFromJson);
        }
        SaveToJson() {
          return this._allEffectTypes.map((e) => ({ "name": e.GetName(), "active": e.IsActive(), "params": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
        }
        LoadFromJson(e) {
          for (const t of e) {
            const s = this.GetEffectTypeByName(t["name"]);
            s && (s.SetActive(t["active"]), this._effectParams[s.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t["params"]));
          }
          this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
        }
      };
    }
    {
      const C33 = self.C3;
      C33.EffectType = class extends C33.DefendedBase {
        constructor(e, t, r) {
          super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = r, this._shaderProgram = null, this._isActive = true;
        }
        Release() {
          this._effectList = null, this._shaderProgram = null;
        }
        Clone(e) {
          const t = C33.New(C33.EffectType, e, [this._id, this._name], -1);
          return t._shaderProgram = this._shaderProgram, t._isActive = this._isActive, t;
        }
        _InitRenderer(e) {
          const t = e.GetShaderProgramByName(this._id);
          if (!t) throw new Error("failed to find shader program '" + this._id + "'");
          this._shaderProgram = t;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetName() {
          return this._name;
        }
        _SetIndex(e) {
          this._index = e;
        }
        GetIndex() {
          return this._index;
        }
        GetOwner() {
          return this._effectList.GetOwner();
        }
        GetRuntime() {
          return this._effectList.GetRuntime();
        }
        SetActive(e) {
          this._isActive = !!e;
        }
        IsActive() {
          return this._isActive;
        }
        GetShaderProgram() {
          return this._shaderProgram;
        }
        GetDefaultParameterValues() {
          const r = [];
          for (let e = 0, t = this._shaderProgram.GetParameterCount(); e < t; ++e) {
            const s = this._shaderProgram.GetParameterType(e);
            if ("float" === s || "percent" === s) r.push(0);
            else {
              if ("color" !== s) throw new TypeError("unknown effect parameter type");
              r.push(C33.New(C33.Color, 1, 1, 1, 1));
            }
          }
          return r;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.InstanceEffectList = class extends C33.DefendedBase {
        constructor(e, t) {
          super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C33.New(C33.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t2) => {
            const s = t2.GetContentObject(), f = s.GetWorldInfo();
            e2.SetColor(f.GetPremultipliedColor()), e2.SetCurrentZ(f.GetTotalZElevation()), s.Draw(e2), e2.SetCurrentZ(0);
          }, getSourceTextureInfo: (e2) => {
            const t2 = e2.GetCurrentTexRect(), [s, f] = e2.GetCurrentSurfaceSize();
            return { srcTexRect: t2, srcWidth: s, srcHeight: f };
          }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());
          for (let e2 = 0, t2 = this._effectList.GetAllEffectTypes().length; e2 < t2; ++e2) this._activeEffectFlags.push(true);
          this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);
        }
        Release() {
          this._effectList._RemoveInstanceEffectList(this);
          for (const e of this._effectParamBuffers) e && e.Release();
          C33.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C33.clearArray(this._activeEffectFlags), C33.clearArray(this._activeEffectTypes), C33.clearArray(this._effectParams), this._inst = null, this._effectList = null;
        }
        _InitRenderer(e) {
          e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {
            const t = e2.GetShaderProgram();
            return 0 < t.GetCustomParametersByteSize() ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;
          }));
        }
        _LoadEffectParameters(e) {
          let t = 0;
          for (const s of e) this._effectParams.push(this._LoadSingleEffectParameters(t, s)), ++t;
          this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();
        }
        _LoadSingleEffectParameters(e, t) {
          this._activeEffectFlags[e] = t[0];
          const s = t.slice(1);
          for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {
            const f = s[e2];
            if (Array.isArray(f)) {
              const a = C33.New(C33.Color);
              a.setFromJSON(f), s[e2] = a;
            }
          }
          return s;
        }
        LoadDefaultEffectParameters() {
          for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());
          this._UpdateAllEffectParamBuffers();
        }
        GetOwner() {
          return this._owner;
        }
        GetEffectList() {
          return this._effectList;
        }
        GetEffectChain() {
          return this._MaybeRebuildEffectChainSteps(), this._effectChain;
        }
        GetRuntime() {
          return this._inst.GetRuntime();
        }
        UpdateActiveEffects() {
          C33.clearArray(this._activeEffectTypes);
          const e = this._wi, s = this._effectList.GetAllEffectTypes(), f = this._activeEffectTypes, a = this._activeEffectFlags;
          let r = true;
          for (let e2 = 0, t = s.length; e2 < t; ++e2) if (a[e2]) {
            const i = s[e2];
            f.push(i), i.GetShaderProgram().PreservesOpaqueness() || (r = false);
          }
          this._preservesOpaqueness = r, e._SetHasAnyActiveEffect(!!f.length), this._needsRebuildSteps = true;
        }
        _MaybeRebuildEffectChainSteps() {
          const e = this._inst, t = this._wi, s = t.HasDefaultColor(), f = e.GetPlugin().Is3D(), a = 0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || t.GetWidth() < 0 || t.GetHeight() < 0, r = e.IsCurrentTexRotated(), i = e.MustPreDraw();
          (this._needsRebuildSteps || s !== this._wasDefaultColor || f !== this._was3D || a !== this._wasRotatedOrNegativeSize || r !== this._wasTexRotated || i !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s || i, is3D: f, isSourceTextureRotated: r, isRotatedOrNegativeSizeInstance: a }), this._needsRebuildSteps = false, this._wasDefaultColor = s, this._was3D = f, this._wasRotatedOrNegativeSize = a, this._wasTexRotated = r, this._wasMustPreDraw = i);
        }
        GetActiveEffectTypes() {
          return this._activeEffectTypes;
        }
        GetEffectParametersForIndex(e) {
          return this._effectParams[e];
        }
        _GetEffectChainShaderParametersForIndex(e) {
          return (e < this._effectParamBuffers.length ? this._effectParamBuffers : this._effectParams)[e];
        }
        GetEffectParameter(e, t) {
          if (e < 0 || e >= this._effectParams.length) return null;
          const s = this._effectParams[e];
          return t < 0 || t >= s.length ? null : s[t];
        }
        SetEffectParameter(e, t, s) {
          if (e < 0 || e >= this._effectParams.length) return false;
          const f = this._effectParams[e];
          if (t < 0 || t >= f.length) return false;
          const a = f[t];
          if (a instanceof C33.Color) {
            if (a.equalsIgnoringAlpha(s)) return false;
            a.copyRgb(s);
          } else {
            if (a === s) return false;
            f[t] = s;
          }
          return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;
        }
        _UpdateAllEffectParamBuffers() {
          const s = this._effectParams, f = this._effectParamBuffers;
          for (let e = 0, t = f.length; e < t; ++e) {
            const a = f[e], r = s[e];
            for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) a.SetParameterValue(e2, r[e2]);
          }
        }
        PreservesOpaqueness() {
          return this._preservesOpaqueness;
        }
        HasAnyActiveBackgroundBlendingEffect() {
          return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());
        }
        IsEffectIndexActive(e) {
          return this._activeEffectFlags[e];
        }
        SetEffectIndexActive(e, t) {
          this._activeEffectFlags[e] = !!t;
        }
        GetAllEffectTypes() {
          return this._effectList.GetAllEffectTypes();
        }
        _SaveToJson() {
          return this._effectList.GetAllEffectTypes().map((e) => ({ "name": e.GetName(), "active": this._activeEffectFlags[e.GetIndex()], "params": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
        }
        _LoadFromJson(e) {
          for (const t of e) {
            const s = this._effectList.GetEffectTypeByName(t["name"]);
            s && (this._activeEffectFlags[s.GetIndex()] = t["active"], this._effectParams[s.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t["params"]));
          }
          this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
        }
      };
    }
    {
      const C33 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C33.New(C33.CollisionPoly), tempPolyB = C33.New(C33.CollisionPoly), tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect);
      let tempPolyC = null, tempRect3 = null, tempQuadB = null;
      C33.CollisionEngine = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);
        }
        Release() {
          this._runtime = null;
        }
        GetRuntime() {
          return this._runtime;
        }
        GetICollisionEngine() {
          return this._iCollisionEngine;
        }
        _Update1sStats() {
          this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;
        }
        Get1secCollisionChecks() {
          return this._collisionCheckSec;
        }
        Get1secPolyChecks() {
          return this._polyCheckSec;
        }
        RegisterCollision(e, t) {
          const s = e.GetWorldInfo(), l = t.GetWorldInfo();
          s && l && s.IsCollisionEnabled() && l.IsCollisionEnabled() && this._registeredCollisions.push([e, t]);
        }
        AddRegisteredCollisionCandidates(t, s, l) {
          for (const [n, o] of this._registeredCollisions) {
            let e = null;
            if (t === n) e = o;
            else {
              if (t !== o) continue;
              e = n;
            }
            !e.BelongsToObjectClass(s) || l.includes(e) || l.push(e);
          }
        }
        CheckRegisteredCollision(e, t) {
          if (this._registeredCollisions.length) {
            for (const [s, l] of this._registeredCollisions) if (e === s && t === l || e === l && t === s) return true;
          }
          return false;
        }
        ClearRegisteredCollisions() {
          C33.clearArray(this._registeredCollisions);
        }
        TestOverlap(e, t) {
          if (!e || !t || e === t) return false;
          const s = e.GetWorldInfo(), l = t.GetWorldInfo();
          if (!s.IsCollisionEnabled() || !l.IsCollisionEnabled()) return false;
          this._collisionCheckCount++;
          const n = s.GetLayer(), o = l.GetLayer(), i = n.IsTransformCompatibleWith(o);
          return i ? this._TestOverlap_SameLayers(s, l) : this._TestOverlap_DifferentLayers(s, l);
        }
        _TestOverlap_SameLayers(e, t) {
          if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return false;
          if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return false;
          if (e.HasTilemap() && t.HasTilemap()) return false;
          if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);
          if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);
          if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return true;
          const s = e.GetTransformedCollisionPoly(), l = t.GetTransformedCollisionPoly();
          return s.intersectsPoly(l, t.GetX() - e.GetX(), t.GetY() - e.GetY());
        }
        _TestOverlap_DifferentLayers(s, l) {
          const e = s.HasTilemap(), t = l.HasTilemap();
          if (e && !t) return this.TestTilemapOverlapDifferentLayers(s, l);
          if (t && !e) return this.TestTilemapOverlapDifferentLayers(l, s);
          if (t || e) return false;
          {
            const n = s.GetLayer(), o = l.GetLayer(), i = (tempPolyA.copy(s.GetTransformedCollisionPoly()), tempPolyB.copy(l.GetTransformedCollisionPoly()), tempPolyA.pointsArr());
            for (let e2 = 0, t2 = i.length; e2 < t2; e2 += 2) {
              const a = e2 + 1, c = i[e2], C = i[a], [d, u] = n.LayerToCanvasCss(c + s.GetX(), C + s.GetY());
              i[e2] = d, i[a] = u;
            }
            const r = tempPolyB.pointsArr();
            for (let e2 = 0, t2 = r.length; e2 < t2; e2 += 2) {
              const h = e2 + 1, p = r[e2], f = r[h], [G, m] = o.LayerToCanvasCss(p + l.GetX(), f + l.GetY());
              r[e2] = G, r[h] = m;
            }
            return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);
          }
        }
        TestTilemapOverlapDifferentLayers(e, t) {
          const s = e.GetLayer(), l = t.GetLayer(), n = (tempPolyC = tempPolyC || C33.New(C33.CollisionPoly), tempRect3 = tempRect3 || C33.New(C33.Rect), tempQuadB = tempQuadB || C33.New(C33.Quad), t.GetX()), o = t.GetY(), [i, r] = l.LayerToCanvasCss(n, o), [a, c] = s.CanvasCssToLayer(i, r), C = a - n, d = c - o;
          if (tempRect3.copy(t.GetBoundingBox()), tempRect3.offset(C, d), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;
          if (tempQuadB.copy(t.GetBoundingQuad()), tempQuadB.offset(C, d), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;
          tempPolyC.copy(t.GetTransformedCollisionPoly());
          const u = tempPolyC.pointsArr();
          for (let e2 = 0, t2 = u.length; e2 < t2; e2 += 2) {
            const h = e2 + 1;
            u[e2] += C, u[h] += d;
          }
          return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t, a, c, tempPolyC, tempRect3, tempQuadB);
        }
        TestTilemapOverlap(e, s, t, l, n, o, i) {
          const r = void 0 !== o ? o : s.GetBoundingBox(), a = e.GetX(), c = e.GetY(), C = e.GetInstance().GetSdkInstance(), d = void 0 !== t ? t : s.GetX(), u = void 0 !== l ? l : s.GetY(), h = s.HasOwnCollisionPoly(), p = void 0 !== i ? i : s.GetBoundingQuad(), f = tileCollRectCandidates;
          C.GetCollisionRectCandidates(r, f);
          for (let e2 = 0, t2 = f.length; e2 < t2; ++e2) {
            const G = f[e2], m = G.GetRect();
            if (this._collisionCheckCount++, r.intersectsRectOffset(m, a, c) && (tempQuad.setFromRect(m), tempQuad.offset(a, c), tempQuad.intersectsQuad(p))) if (h) {
              const y = void 0 !== n ? n : s.GetTransformedCollisionPoly();
              let e3 = d, t3 = u;
              void 0 !== n && (e3 = s.GetX(), t3 = s.GetY());
              const g = G.GetPoly();
              if (g) {
                if (this._polyCheckCount++, g.intersectsPoly(y, e3 - (a + m.getLeft()), t3 - (c + m.getTop()))) return C33.clearArray(f), true;
              } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(y, e3, t3)) return C33.clearArray(f), true;
            } else {
              const T = G.GetPoly();
              if (!T) return C33.clearArray(f), true;
              if (tempPolyA.setFromQuad(p, 0, 0), T.intersectsPoly(tempPolyA, -(a + m.getLeft()), -(c + m.getTop()))) return C33.clearArray(f), true;
            }
          }
          return C33.clearArray(f), false;
        }
        TestAndSelectCanvasPointOverlap(e, o, i) {
          const r = e.GetCurrentSol(), t = this._runtime.GetCurrentEvent();
          if (!t) throw new Error("cannot call outside event");
          const a = t.IsOrBlock(), s = /* @__PURE__ */ new Map(), c = (e2) => {
            let t2 = s.get(e2);
            return void 0 === t2 && (t2 = e2.IsSelfAndParentsInteractive(), s.set(e2, t2)), t2;
          };
          if (r.IsSelectAll()) {
            i || (r._SetSelectAll(false), C33.clearArray(r._GetOwnInstances())), a && C33.clearArray(r._GetOwnElseInstances());
            for (const l of e.GetInstances()) {
              const n = l.GetWorldInfo(), C = n.GetLayer();
              let e2 = false;
              if (e2 = c(C) && n.IsInViewport2() ? o.some(([e3, t2]) => {
                const [s2, l2] = C.CanvasCssToLayer(e3, t2, n.GetTotalZElevation());
                return n.ContainsPoint(s2, l2);
              }) : e2) {
                if (i) return false;
                r._PushInstance(l);
              } else a && r._PushElseInstance(l);
            }
          } else {
            let s2, l = false, n = (!a || t.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) || this._runtime.IsCurrentConditionFirst() && !r._GetOwnElseInstances().length && r._GetOwnInstances().length ? s2 = r._GetOwnInstances() : (s2 = r._GetOwnElseInstances(), l = true), 0);
            for (let t2 = 0, e2 = s2.length; t2 < e2; ++t2) {
              const d = s2[t2], u = d.GetWorldInfo(), h = u.GetLayer();
              let e3 = false;
              if (e3 = c(h) && u.IsInViewport2() ? o.some(([e4, t3]) => {
                const [s3, l2] = h.CanvasCssToLayer(e4, t3, u.GetTotalZElevation());
                return u.ContainsPoint(s3, l2);
              }) : e3) {
                if (i) return false;
                l ? r._PushInstance(d) : s2[n++] = d;
              } else l ? s2[n++] = d : a && r._PushElseInstance(d);
            }
            i || (s2.length = n);
          }
          return e.ApplySolToContainer(), s.clear(), !!i || r.HasAnyInstances();
        }
        _ObjectClassCanUseCollisionCells(e, t) {
          if (e) {
            for (const s of t.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s)) return false;
          }
          return true;
        }
        GetCollisionCandidates(e, t, s, l) {
          if (t.IsFamily()) for (const n of t.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, n) ? (n._UpdateAllCollisionCells(), n._GetCollisionCellGrid().QueryRange(s, l)) : C33.appendArray(l, n.GetInstances());
          else this._ObjectClassCanUseCollisionCells(e, t) ? (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s, l)) : C33.appendArray(l, t.GetInstances());
        }
        GetObjectClassesCollisionCandidates(e, t, s, l) {
          for (const n of t) this.GetCollisionCandidates(e, n, s, l);
        }
        GetSolidCollisionCandidates(e, t, s) {
          const l = this._runtime.GetSolidBehavior();
          l && this.GetObjectClassesCollisionCandidates(e, l.GetObjectClasses(), t, s);
        }
        GetJumpthruCollisionCandidates(e, t, s) {
          const l = this._runtime.GetJumpthruBehavior();
          l && this.GetObjectClassesCollisionCandidates(e, l.GetObjectClasses(), t, s);
        }
        IsSolidCollisionAllowed(e, t) {
          return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get("solidTags")));
        }
        TestOverlapSolid(e) {
          const t = e.GetWorldInfo();
          this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), tempCandidates);
          for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, e) && this.TestOverlap(e, s)) return C33.clearArray(tempCandidates), s;
          return C33.clearArray(tempCandidates), null;
        }
        TestRectOverlapSolid(e, t) {
          this.GetSolidCollisionCandidates(null, e, tempCandidates);
          for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, t) && this.TestRectOverlap(e, s)) return C33.clearArray(tempCandidates), s;
          return C33.clearArray(tempCandidates), null;
        }
        TestOverlapJumpthru(e, t) {
          let s = null;
          t && (s = tempJumpthruRet, C33.clearArray(s));
          const l = e.GetWorldInfo();
          this.GetJumpthruCollisionCandidates(l.GetLayer(), l.GetBoundingBox(), tempCandidates);
          for (const n of tempCandidates) if (n._IsJumpthruEnabled() && this.TestOverlap(e, n)) {
            if (!t) return C33.clearArray(tempCandidates), n;
            s.push(n);
          }
          return C33.clearArray(tempCandidates), s;
        }
        PushOut(t, s, l, n, o) {
          n = n || 50;
          const i = t.GetWorldInfo(), r = i.GetX(), a = i.GetY();
          for (let e = 0; e < n; ++e) if (i.SetXY(r + s * e, a + l * e), i.SetBboxChanged(), !this.TestOverlap(t, o)) return true;
          return i.SetXY(r, a), i.SetBboxChanged(), false;
        }
        PushOutSolid(t, s, l, n, o, i) {
          n = n || 50;
          const r = t.GetWorldInfo(), a = r.GetX(), c = r.GetY();
          let C = null, d = null;
          for (let e = 0; e < n; ++e) if (r.SetXY(a + s * e, c + l * e), r.SetBboxChanged(), !this.TestOverlap(t, C)) {
            if (C = this.TestOverlapSolid(t)) d = C;
            else if (o && (C = i ? this.TestOverlap(t, i) ? i : null : this.TestOverlapJumpthru(t)) && (d = C), !C) return d && this.PushInFractional(t, s, l, d, 16, true), true;
          }
          return r.SetXY(a, c), r.SetBboxChanged(), false;
        }
        PushOutSolidAxis(s, l, n, e) {
          e = e || 50;
          const o = s.GetWorldInfo(), i = o.GetX(), r = o.GetY();
          let a = null, c = null;
          for (let t = 0; t < e; ++t) for (let e2 = 0; e2 < 2; ++e2) {
            const C = 2 * e2 - 1;
            if (o.SetXY(i + l * t * C, r + n * t * C), o.SetBboxChanged(), !this.TestOverlap(s, a)) {
              if (!(a = this.TestOverlapSolid(s))) return c && this.PushInFractional(s, l * C, n * C, c, 16, true), true;
              c = a;
            }
          }
          return o.SetXY(i, r), o.SetBboxChanged(), false;
        }
        PushInFractional(e, t, s, l, n, o) {
          let i = 2, r = false, a = false;
          const c = e.GetWorldInfo();
          let C = c.GetX(), d = c.GetY();
          for (; i <= n; ) {
            const u = 1 / i;
            i *= 2, c.OffsetXY(t * u * (r ? 1 : -1), s * u * (r ? 1 : -1)), c.SetBboxChanged(), this.TestOverlap(e, l) || o && this.TestOverlapSolid(e) ? (r = true, a = true) : (r = false, a = false, C = c.GetX(), d = c.GetY());
          }
          a && (c.SetXY(C, d), c.SetBboxChanged());
        }
        PushOutSolidNearest(s, e = 100) {
          let l = 0;
          const n = s.GetWorldInfo(), o = n.GetX(), i = n.GetY();
          let r = 0, a = this.TestOverlapSolid(s);
          if (!a) return true;
          for (; l <= e; ) {
            let e2 = 0, t = 0;
            switch (r) {
              case 0:
                e2 = 0, t = -1, l++;
                break;
              case 1:
                e2 = 1, t = -1;
                break;
              case 2:
                e2 = 1, t = 0;
                break;
              case 3:
                e2 = 1, t = 1;
                break;
              case 4:
                e2 = 0, t = 1;
                break;
              case 5:
                e2 = -1, t = 1;
                break;
              case 6:
                e2 = -1, t = 0;
                break;
              case 7:
                e2 = -1, t = -1;
            }
            if (r = (r + 1) % 8, n.SetXY(Math.floor(o + e2 * l), Math.floor(i + t * l)), n.SetBboxChanged(), !this.TestOverlap(s, a) && !(a = this.TestOverlapSolid(s))) return true;
          }
          return n.SetXY(o, i), n.SetBboxChanged(), false;
        }
        CalculateBounceAngle(e, t, s, l) {
          const n = e.GetWorldInfo(), o = n.GetX(), i = n.GetY(), r = Math.max(10, C33.distanceTo(t, s, o, i)), a = C33.angleTo(t, s, o, i), c = l || this.TestOverlapSolid(e);
          if (!c) return C33.clampAngle(a + Math.PI);
          let C = c, d = 0, u = 0;
          const h = C33.toRadians(5);
          let p;
          for (p = 1; p < 36; ++p) {
            const P = a - p * h;
            if (n.SetXY(t + Math.cos(P) * r, s + Math.sin(P) * r), n.SetBboxChanged(), !this.TestOverlap(e, C) && !(C = l ? null : this.TestOverlapSolid(e))) {
              d = P;
              break;
            }
          }
          for (36 === p && (d = C33.clampAngle(a + Math.PI)), C = c, p = 1; p < 36; ++p) {
            const O = a + p * h;
            if (n.SetXY(t + Math.cos(O) * r, s + Math.sin(O) * r), n.SetBboxChanged(), !this.TestOverlap(e, C) && !(C = l ? null : this.TestOverlapSolid(e))) {
              u = O;
              break;
            }
          }
          if (36 === p && (u = C33.clampAngle(a + Math.PI)), n.SetXY(o, i), n.SetBboxChanged(), u === d) return u;
          const f = C33.angleDiff(u, d) / 2;
          let G;
          G = C33.angleClockwise(u, d) ? C33.clampAngle(d + f + Math.PI) : C33.clampAngle(u + f);
          const m = Math.cos(a), y = Math.sin(a), g = Math.cos(G), T = Math.sin(G), _ = m * g + y * T, I = m - 2 * _ * g, S = y - 2 * _ * T;
          return C33.angleTo(0, 0, I, S);
        }
        TestSegmentOverlap(e, t, s, l, n) {
          if (!n) return false;
          const o = n.GetWorldInfo();
          if (!o.IsCollisionEnabled()) return false;
          if (this._collisionCheckCount++, tempRect.set(Math.min(e, s), Math.min(t, l), Math.max(e, s), Math.max(t, l)), !o.GetBoundingBox().intersectsRect(tempRect)) return false;
          if (n.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, s, l, n, o);
          if (this._polyCheckCount++, !o.GetBoundingQuad().intersectsSegment(e, t, s, l)) return false;
          if (!o.HasOwnCollisionPoly()) return true;
          const i = o.GetTransformedCollisionPoly();
          return i.intersectsSegment(o.GetX(), o.GetY(), e, t, s, l);
        }
        _TestSegmentOverlapTilemap(s, l, n, o, e, t) {
          const i = t.GetX(), r = t.GetY(), a = e.GetSdkInstance(), c = tileCollRectCandidates;
          tempRect2.set(s, l, n, o), tempRect2.normalize(), a.GetCollisionRectCandidates(tempRect2, c);
          for (let e2 = 0, t2 = c.length; e2 < t2; ++e2) {
            const C = c[e2], d = C.GetRect();
            if (this._collisionCheckCount++, tempRect.intersectsRectOffset(d, i, r) && (tempQuad.setFromRect(d), tempQuad.offset(i, r), tempQuad.intersectsSegment(s, l, n, o))) {
              const u = C.GetPoly();
              if (!u) return C33.clearArray(c), true;
              if (this._polyCheckCount++, u.intersectsSegment(i + d.getLeft(), r + d.getTop(), s, l, n, o)) return C33.clearArray(c), true;
            }
          }
          return C33.clearArray(c), false;
        }
        TestRectOverlap(e, t) {
          if (!t) return false;
          const s = t.GetWorldInfo();
          if (!s.IsCollisionEnabled()) return false;
          if (this._collisionCheckCount++, !s.GetBoundingBox().intersectsRect(e)) return false;
          if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, s);
          if (this._polyCheckCount++, tempQuad.setFromRect(e), !s.GetBoundingQuad().intersectsQuad(tempQuad)) return false;
          if (!s.HasOwnCollisionPoly()) return true;
          const l = tempPolyA, n = (l.setFromRect(e, s.GetX(), s.GetY()), s.GetTransformedCollisionPoly());
          return l.intersectsPoly(n, 0, 0);
        }
        _TestRectOverlapTilemap(s, e, t) {
          const l = t.GetX(), n = t.GetY(), o = e.GetSdkInstance(), i = tileCollRectCandidates;
          o.GetCollisionRectCandidates(s, i);
          for (let e2 = 0, t2 = i.length; e2 < t2; ++e2) {
            const r = i[e2], a = r.GetRect();
            if (this._collisionCheckCount++, s.intersectsRectOffset(a, l, n)) {
              const c = r.GetPoly();
              if (!c) return C33.clearArray(i), true;
              if (this._polyCheckCount++, tempPolyA.setFromRect(s, 0, 0), c.intersectsPoly(tempPolyA, -(l + a.getLeft()), -(n + a.getTop()))) return C33.clearArray(i), true;
            }
          }
          return C33.clearArray(i), false;
        }
        TestRayIntersectsInstance(e, t) {
          if (e) {
            const s = e.GetWorldInfo();
            s.IsCollisionEnabled() && (this._collisionCheckCount++, s.GetBoundingBox().intersectsRect(t.rect)) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s, t) : (this._polyCheckCount++, s.HasOwnCollisionPoly() ? t.TestInstancePoly(e, s.GetX(), s.GetY(), s.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, s.GetBoundingQuad())));
          }
        }
        _TestRayIntersectsTilemap(s, l, n) {
          const o = l.GetX(), i = l.GetY(), r = tileCollRectCandidates;
          s.GetSdkInstance().GetCollisionRectCandidates(n.rect, r);
          for (let e = 0, t = r.length; e < t; e++) {
            const a = r[e], c = a.GetRect();
            if (this._collisionCheckCount++, n.rect.intersectsRectOffset(c, o, i)) {
              const C = a.GetPoly();
              this._polyCheckCount++, C ? n.TestInstancePoly(s, o + c.getLeft(), i + c.getTop(), C) : n.TestInstanceRect(s, l.GetX(), l.GetY(), c);
            }
          }
          C33.clearArray(r);
        }
        SetCollisionCellSize(e, t) {
          if (e !== this._collisionCellWidth || t !== this._collisionCellHeight) {
            this._collisionCellWidth = e, this._collisionCellHeight = t;
            const s = this._runtime.GetAllObjectClasses();
            for (const l of s) if (l.IsWorldType()) {
              for (const n of l.instancesIncludingPendingCreate()) n.GetWorldInfo()._RemoveFromCollisionCells();
              l._GetCollisionCellGrid().SetCellSize(e, t), l._SetAnyCollisionCellChanged();
              for (const o of l.instancesIncludingPendingCreate()) {
                const i = o.GetWorldInfo();
                i._SetCollisionCellChanged(), i._UpdateCollisionCell();
              }
            }
          }
        }
        GetCollisionCellSize() {
          return [this._collisionCellWidth, this._collisionCellHeight];
        }
        _InitCollisionCellSize(e, t) {
          this._collisionCellWidth = e, this._collisionCellHeight = t;
        }
      };
    }
    {
      const C33 = self.C3;
      C33.SparseGrid = class extends C33.DefendedBase {
        constructor(t, e) {
          super(), this._cellWidth = t, this._cellHeight = e, this._cells = C33.New(C33.PairMap);
        }
        Release() {
          this._cells.Release(), this._cells = null;
        }
        SetCellSize(t, e) {
          if (!this._cells.IsEmpty()) throw new Error("grid not empty");
          this._cellWidth = t, this._cellHeight = e;
        }
        GetCell(t, e, l) {
          let i = this._cells.Get(t, e);
          return i || (l ? (i = C33.New(C33.GridCell, this, t, e), this._cells.Set(t, e, i), i) : null);
        }
        XToCell(t) {
          const e = Math.floor(t / this._cellWidth);
          return isFinite(e) ? e : 0;
        }
        YToCell(t) {
          const e = Math.floor(t / this._cellHeight);
          return isFinite(e) ? e : 0;
        }
        Update(i, s, o) {
          if (s) {
            for (let l = s.getLeft(), t = s.getRight(); l <= t; ++l) for (let t2 = s.getTop(), e = s.getBottom(); t2 <= e; ++t2) if (!o || !o.containsPoint(l, t2)) {
              const h = this.GetCell(l, t2, false);
              h && (h.Remove(i), h.IsEmpty()) && this._cells.Delete(l, t2);
            }
          }
          if (o) for (let l = o.getLeft(), t = o.getRight(); l <= t; ++l) for (let t2 = o.getTop(), e = o.getBottom(); t2 <= e; ++t2) s && s.containsPoint(l, t2) || this.GetCell(l, t2, true).Insert(i);
        }
        QueryRange(t, e) {
          let l = this.XToCell(t.getLeft());
          const i = this.YToCell(t.getTop()), s = this.XToCell(t.getRight()), o = this.YToCell(t.getBottom());
          if (isFinite(s) && isFinite(o)) for (; l <= s; ++l) for (let t2 = i; t2 <= o; ++t2) {
            const h = this.GetCell(l, t2, false);
            h && h.Dump(e);
          }
        }
      };
    }
    {
      const C33 = self.C3;
      C33.GridCell = class extends C33.DefendedBase {
        constructor(s, e, t) {
          super(), this._grid = s, this._x = e, this._y = t, this._instances = C33.New(C33.ArraySet);
        }
        Release() {
          this._instances.Release(), this._instances = null, this._grid = null;
        }
        IsEmpty() {
          return this._instances.IsEmpty();
        }
        Insert(s) {
          this._instances.Add(s);
        }
        Remove(s) {
          this._instances.Delete(s);
        }
        Dump(s) {
          C33.appendArray(s, this._instances.GetArray());
        }
      };
    }
    {
      const C33 = self.C3, PADDING = 1e-6, NO_HIT = 2;
      C33.Ray = class {
        constructor() {
          this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C33.Rect(), this.hitFraction = NO_HIT, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;
        }
        DidCollide() {
          return this.hitFraction < 1 + PADDING;
        }
        Reset() {
          this.hitFraction = NO_HIT;
        }
        Set(t, i, s, h) {
          return this.x1 = t, this.y1 = i, this.x2 = s, this.y2 = h, this.dx = s - t, this.dy = h - i, this.rect.set(t, i, s, h), this.rect.normalize(), this.hitFraction = NO_HIT, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;
        }
        Complete() {
          if (false !== this.DidCollide()) {
            const t = this.dx * this.hitFraction, i = this.dy * this.hitFraction, s = Math.hypot(t, i), h = t / s, e = i / s, n = (this.distance = s - PADDING, this.hitX = this.x1 + h * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal), h * this.normalX + e * this.normalY);
            if (this.reflectionX = h - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, 0 < n) {
              const a = Math.PI;
              this.hitNormal = C33.clampAngle(this.hitNormal + a), this.normalX = -this.normalX, this.normalY = -this.normalY;
            }
          }
        }
        TestInstanceSegment(t, i, s, h, e) {
          const n = C33.rayIntersect(this.x1, this.y1, this.x2, this.y2, i, s, h, e);
          0 <= n && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t.GetUID(), this.hitNormalDx = i - h, this.hitNormalDy = s - e);
        }
        TestInstanceRect(t, i, s, h) {
          const e = i + h.getLeft(), n = i + h.getRight(), a = s + h.getTop(), o = s + h.getBottom();
          this.TestInstanceSegment(t, e, a, n, a), this.TestInstanceSegment(t, n, a, n, o), this.TestInstanceSegment(t, n, o, e, o), this.TestInstanceSegment(t, e, o, e, a);
        }
        TestInstanceQuad(t, i) {
          const s = i.getTlx(), h = i.getTly(), e = i.getTrx(), n = i.getTry(), a = i.getBrx(), o = i.getBry(), r = i.getBlx(), l = i.getBly();
          this.TestInstanceSegment(t, s, h, e, n), this.TestInstanceSegment(t, e, n, a, o), this.TestInstanceSegment(t, a, o, r, l), this.TestInstanceSegment(t, r, l, s, h);
        }
        TestInstancePoly(s, h, e, t) {
          const n = t.pointsArr();
          for (let t2 = 0, i = n.length; t2 < i; t2 += 2) {
            const a = (t2 + 2) % i, o = n[t2] + h, r = n[t2 + 1] + e, l = n[a] + h, c = n[1 + a] + e;
            this.TestInstanceSegment(s, o, r, l, c);
          }
        }
      };
    }
    {
      const C33 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set(["high", "low"]), glMatrix = self.glMatrix, mat42 = glMatrix.mat4, vec32 = glMatrix.vec3, tempProjection = mat42.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;
      C33.CanvasManager = class extends C33.DefendedBase {
        constructor(e) {
          super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = "high-performance", this._isLimitedToWebGL1 = false, this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = "", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = "normalized", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = "letterbox-scale", this._documentFullscreenMode = "letterbox-scale", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat42.create(), this._wantFullscreenScalingQuality = "high", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self["C3_Shaders"], this._effectChainManager = C33.New(C33.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = "", this._snapshotQuality = 1, this._snapshotArea = C33.New(C33.Rect), this._snapshotUrl = "", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = "fade-in", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);
        }
        _SetGPUPowerPreference(e) {
          this._gpuPreference = e;
        }
        _SetWebGPUEnabled(e) {
          this._isWebGPUEnabled = !!e;
        }
        _SetZAxisScale(e) {
          this._zAxisScale = e;
        }
        GetZAxisScale() {
          return this._zAxisScale;
        }
        _SetInitFieldOfView(e) {
          this._initFieldOfView = e;
        }
        _SetZDistances(e, t) {
          this._zNear = e, this._zFar = t;
        }
        _SetLimitedToWebGL1(e) {
          this._isLimitedToWebGL1 = !!e;
        }
        async CreateCanvas(e) {
          let t = e["canvas"];
          this._canvasLayers.push({ canvas: t, ctx: null }), this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", (e2) => this._OnFullscreenError(e2)), t.addEventListener("webglcontextlost", (e2) => this._OnWebGLContextLost(e2)), t.addEventListener("webglcontextrestored", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"];
          const s = navigator["gpu"] && this._isWebGPUEnabled;
          let i = false;
          if (s) try {
            await this._InitWebGPUContext(true);
          } catch (e2) {
            this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
          }
          if (!this.GetRenderer()) try {
            await this._InitWebGLContext(true);
          } catch (e2) {
            this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
          }
          if (this.GetRenderer() || (i = true), !this.GetRenderer() && s) try {
            await this._InitWebGPUContext(false);
          } catch (e2) {
            this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
          }
          if (!this.GetRenderer()) try {
            await this._InitWebGLContext(false);
          } catch (e2) {
            this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
          }
          const a = this.GetRenderer();
          if (!a) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
          a.SetHasMajorPerformanceCaveat(i), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), "normalized" === this._zAxisScale ? a.SetZAxisScaleNormalized() : (a.SetZAxisScaleRegular(), a.SetFovY(this._initFieldOfView)), this.SetSize(e["windowInnerWidth"], e["windowInnerHeight"], true), await this._InitRenderer();
        }
        _MaybeLogRendererError(e, t) {
          t && "string" == typeof t.message && t.message.startsWith("renderer-unavailable") || console.error(`Error creating ${e} renderer: `, t);
        }
        async _InitWebGPUContext(e) {
          const t = { nearZ: this._zNear, farZ: this._zFar }, s = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), canSampleDepth: this._runtime.UsesAnyDepthSampling() };
          this._webgpuRenderer = C33.New(C33.Gfx.WebGPURenderer, t), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, s);
        }
        async _InitWebGLContext(e) {
          const t = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };
          this._isLimitedToWebGL1 && (t.maxWebGLVersion = 1), this._webglRenderer = C33.New(C33.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t), await this._webglRenderer.InitState();
        }
        async _InitWebGPU() {
          if (this._shaderData) {
            const e = [];
            for (const [t, s] of Object.entries(this._shaderData)) {
              s.src = s.wgsl;
              const i = C33.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
              e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));
            }
            await Promise.all(e);
          }
        }
        async _InitWebGL() {
          if (this._shaderData) {
            const t = [];
            for (const [s, i] of Object.entries(this._shaderData)) {
              let e;
              if (i.glslWebGL2 && 2 <= this._webglRenderer.GetWebGLVersionNumber()) i.src = i.glslWebGL2, e = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
              else {
                if (!i.glsl) throw new Error(`shader '${s}' does not support WebGL 1`);
                i.src = i.glsl, e = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
              }
              t.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: e, name: s }, i)));
            }
            await Promise.all(t), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();
          }
          this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer));
        }
        async _InitRenderer() {
          this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
          const e = this.GetRenderer();
          e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
          for (const t of this._runtime._GetAllEffectLists()) {
            for (const s of t.GetAllEffectTypes()) s._InitRenderer(e);
            t._InitRenderer(e), t.UpdateActiveEffects();
          }
          this._iRenderer = new self.IRenderer(this._runtime, e);
        }
        Release() {
          this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;
        }
        IsInWorker() {
          return this._runtime.IsInWorker();
        }
        _OnWindowResize(e) {
          const t = this._runtime;
          if (!t.IsExportToVideo()) {
            const s = e["devicePixelRatio"], i = (this.IsInWorker() && (self.devicePixelRatio = s), t._SetDevicePixelRatio(s), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"], this.SetSize(e["innerWidth"], e["innerHeight"]), t.UpdateRender(), new C33.Event("window-resize")), a = (i.data = e, t.Dispatcher().dispatchEventAndWaitAsyncSequential(i), new C33.Event("resize"));
            a.cssWidth = this.GetCssWidth(), a.cssHeight = this.GetCssHeight(), a.deviceWidth = this.GetDeviceWidth(), a.deviceHeight = this.GetDeviceHeight(), t.DispatchUserScriptEvent(a), t.IsDebug() && (t.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t.Render();
          }
        }
        _OnFullscreenChange(e) {
          this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
        }
        _OnFullscreenError(e) {
          this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
        }
        SetSize(e, t, s = false) {
          if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error("invalid size");
          if (this._windowInnerWidth !== e || this._windowInnerHeight !== t || s) {
            this._windowInnerWidth = e, this._windowInnerHeight = t;
            const i = this.GetCurrentFullscreenMode();
            "letterbox-scale" === i ? this._CalculateLetterboxScale(e, t) : "letterbox-integer-scale" === i ? this._CalculateLetterboxIntegerScale(e, t) : "off" === i ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(i);
            for (const { canvas: n } of this._canvasLayers) n.width = this._canvasDeviceWidth, n.height = this._canvasDeviceHeight;
            this._runtime.PostComponentMessageToDOM("canvas", "update-size", { "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight, "displayScale": this.GetDisplayScale() });
            const a = this.GetRenderer();
            a.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);
            for (const h of this._availableAdditionalRenderTargets) a.DeleteRenderTarget(h);
            C33.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();
            const r = this._runtime.GetLayoutManager();
            r.SetAllLayerProjectionChanged(), r.SetAllLayerMVChanged();
          }
        }
        UpdateDefaultProjectionMatrix() {
          this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());
        }
        GetDefaultProjectionMatrix() {
          return this._defaultProjectionMatrix;
        }
        _CalculateLetterboxScale(e, t) {
          const s = this._runtime.GetDevicePixelRatio(), i = this._runtime.GetOriginalViewportWidth(), a = this._runtime.GetOriginalViewportHeight(), r = i / a, n = e / t;
          if (r < n) {
            const h = t * r;
            this._canvasCssWidth = Math.round(h), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;
          } else {
            const o = e / r;
            this._canvasCssWidth = e, this._canvasCssHeight = Math.round(o), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2);
          }
          this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(i, a);
        }
        _CalculateLetterboxIntegerScale(e, t) {
          const s = this._runtime.GetDevicePixelRatio(), i = (1 !== s && (e += 1, t += 1), this._runtime.GetOriginalViewportWidth()), a = this._runtime.GetOriginalViewportHeight(), r = i / a, n = e / t;
          let h;
          if (r < n) {
            const o = t * r;
            h = o * s / i;
          } else {
            const l = e / r;
            h = l * s / a;
          }
          1 < h ? h = Math.floor(h) : h < 1 && (h = 1 / Math.ceil(1 / h)), this._canvasDeviceWidth = Math.round(i * h), this._canvasDeviceHeight = Math.round(a * h), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i, a);
        }
        _CalculateFullsizeCanvas(e, t) {
          const s = this._runtime.GetDevicePixelRatio(), i = (this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this.GetDisplayScale());
          this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i);
        }
        _CalculateFixedSizeCanvas(e, t) {
          const s = this._runtime.GetDevicePixelRatio();
          this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());
        }
        _UpdateFullscreenScalingQuality(s) {
          if ("high" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
          else {
            let e, t;
            if (t = "off" === this.GetCurrentFullscreenMode() ? (e = this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight()) : (e = this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < e || this._canvasDeviceHeight < t) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else if (this._drawWidth = e, this._drawHeight = t, this._fullscreenScalingQuality = "low", "scale-inner" === s) {
              const i = e / t, a = this._windowInnerWidth / this._windowInnerHeight;
              a < i ? this._drawWidth = this._drawHeight * a : i < a && (this._drawHeight = this._drawWidth / a);
            } else if ("scale-outer" === s) {
              const r = e / t, n = this._windowInnerWidth / this._windowInnerHeight;
              r < n ? this._drawWidth = this._drawHeight * n : n < r && (this._drawHeight = this._drawWidth / n);
            }
          }
        }
        GetRuntime() {
          return this._runtime;
        }
        GetMainCanvas() {
          return this._canvasLayers[0].canvas;
        }
        GetEffectChainManager() {
          return this._effectChainManager;
        }
        IsDocumentFullscreen() {
          return this._isDocumentFullscreen;
        }
        GetCssDisplayMode() {
          return this._cssDisplayMode;
        }
        SetFullscreenMode(e) {
          if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
          this._fullscreenMode = e;
          const t = this._runtime.GetLayoutManager();
          t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
        }
        GetFullscreenMode() {
          return this._fullscreenMode;
        }
        SetDocumentFullscreenMode(e) {
          if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
          this._documentFullscreenMode = e;
          const t = this._runtime.GetLayoutManager();
          t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
        }
        GetDocumentFullscreenMode() {
          return this._documentFullscreenMode;
        }
        GetCurrentFullscreenMode() {
          return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();
        }
        SetFullscreenScalingQuality(e) {
          if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error("invalid fullscreen scaling quality");
          this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();
        }
        GetSetFullscreenScalingQuality() {
          return this._wantFullscreenScalingQuality;
        }
        GetCurrentFullscreenScalingQuality() {
          return this._fullscreenScalingQuality;
        }
        static _FullscreenModeNumberToString(e) {
          switch (e) {
            case 0:
              return "off";
            case 1:
              return "crop";
            case 2:
              return "scale-inner";
            case 3:
              return "scale-outer";
            case 4:
              return "letterbox-scale";
            case 5:
              return "letterbox-integer-scale";
            default:
              throw new Error("invalid fullscreen mode");
          }
        }
        GetLastWidth() {
          return this._windowInnerWidth;
        }
        GetLastHeight() {
          return this._windowInnerHeight;
        }
        GetDrawWidth() {
          return this._drawWidth;
        }
        GetDrawHeight() {
          return this._drawHeight;
        }
        SetMipmapsEnabled(e) {
          this._enableMipmaps = !!e;
        }
        _SetTextureAnisotropy(e) {
          this._textureAnisotropy = e;
        }
        GetTextureAnisotropy() {
          return this._textureAnisotropy;
        }
        IsRendererContextLost() {
          return this.GetRenderer().IsContextLost();
        }
        _OnWebGLContextLost(e) {
          console.log("[Construct] WebGL context lost"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();
        }
        _OnWebGPUDeviceLost() {
          console.log("[Construct] WebGPU device lost"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();
        }
        async _OnWebGLContextRestored(e) {
          await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGL context restored");
        }
        async _OnWebGPUDeviceRestored() {
          await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGPU device restored");
        }
        GetWebGLRenderer() {
          return this._webglRenderer;
        }
        GetWebGPURenderer() {
          return this._webgpuRenderer;
        }
        GetRenderer() {
          return this._webgpuRenderer || this._webglRenderer;
        }
        GetIRenderer() {
          return this._iRenderer;
        }
        GetRendererString() {
          let e = "";
          return e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software"), e;
        }
        GetRendererDetailString() {
          return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
        }
        GetRenderScale() {
          return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();
        }
        GetDisplayScale() {
          const e = this.GetCurrentFullscreenMode();
          if ("off" === e || "crop" === e) return 1;
          const t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight(), i = t / s, a = this._canvasDeviceWidth / this._canvasDeviceHeight;
          return "scale-inner" !== e && i < a || "scale-inner" === e && a < i ? this._canvasCssHeight / s : this._canvasCssWidth / t;
        }
        GetEffectLayerScaleParam() {
          return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();
        }
        GetEffectDevicePixelRatioParam() {
          return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();
        }
        SetDeviceTransformOffset(e, t) {
          this._deviceTransformOffX = e, this._deviceTransformOffY = t;
        }
        SetDeviceTransform(t, s, i, e = true) {
          s = s || this._drawWidth, i = i || this._drawHeight;
          const a = s / 2 + this._deviceTransformOffX, r = i / 2 + this._deviceTransformOffY;
          if (e) {
            let e2 = this.GetDefaultProjectionMatrix();
            s === this._drawWidth && i === this._drawHeight || (t.CalculatePerspectiveMatrix(tempProjection, s / i), e2 = tempProjection), t.SetProjectionMatrix(e2);
          }
          const n = t.CalculateLookAtModelView2(a, r, t.GetDefaultCameraZ(i), a, r, 0, i);
          t.SetModelViewMatrix(n);
        }
        SetCssTransform(e, t = true) {
          const s = this.GetCssWidth(), i = this.GetCssHeight(), a = s / 2, r = i / 2, n = (t && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix()), e.CalculateLookAtModelView2(a, r, e.GetDefaultCameraZ(i), a, r, 0, i));
          e.SetModelViewMatrix(n);
        }
        GetDeviceWidth() {
          return this._canvasDeviceWidth;
        }
        GetDeviceHeight() {
          return this._canvasDeviceHeight;
        }
        GetCssWidth() {
          return this._canvasCssWidth;
        }
        GetCssHeight() {
          return this._canvasCssHeight;
        }
        GetCanvasClientX() {
          return this._canvasCssOffsetX;
        }
        GetCanvasClientY() {
          return this._canvasCssOffsetY;
        }
        GetHTMLLayerCount() {
          return this._canvasLayers.length;
        }
        _CanUseImageBitmapRenderingContext() {
          return "undefined" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && ("Chromium" !== C33.Platform.BrowserEngine || 124 <= C33.Platform.BrowserVersionNumber);
        }
        async SetHTMLLayerCount(t, s = false) {
          if (t < 1) throw new Error("invalid HTML layer count");
          if (this._canvasLayers.length !== t) {
            const i = this._runtime.GetLayoutManager().GetMainRunningLayout(), a = { "count": t, "layersDomState": i._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), "immediate": s, "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight };
            let e;
            if (e = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas", "set-html-layer-count", a) : self["c3_runtimeInterface"]["_OnSetHTMLLayerCount"](a), t < this._canvasLayers.length) this._canvasLayers.length = t;
            else for (const r of e["addedCanvases"]) {
              r.width = this._canvasDeviceWidth, r.height = this._canvasDeviceHeight;
              const n = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d", h = r.getContext(n);
              if (!h) throw new Error(`failed to acquire '${n}' canvas context`);
              this._canvasLayers.push({ canvas: r, ctx: h });
            }
            this._runtime.UpdateRender();
          }
        }
        BlitMainCanvasToHTMLLayerCanvas(e) {
          if (!(e >= this._canvasLayers.length)) {
            const t = this.GetMainCanvas(), s = this._canvasLayers[e].ctx;
            this._CanUseImageBitmapRenderingContext() ? s["transferFromImageBitmap"](t["transferToImageBitmap"]()) : (s.globalCompositeOperation = "copy", s.drawImage(t, 0, 0));
          }
        }
        GetAdditionalRenderTarget(t) {
          t.depth = this._runtime.Uses3DFeatures();
          const e = this._availableAdditionalRenderTargets, s = e.findIndex((e2) => e2.IsCompatibleWithOptions(t));
          let i;
          return -1 !== s ? (i = e[s], e.splice(s, 1)) : i = this.GetRenderer().CreateRenderTarget(t), this._usedAdditionalRenderTargets.add(i), i;
        }
        ReleaseAdditionalRenderTarget(e) {
          if (!this._usedAdditionalRenderTargets.has(e)) throw new Error("render target not in use");
          this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);
        }
        GetEffectCompositorRenderTarget() {
          const e = { sampling: this._runtime.GetSampling() };
          return "low" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);
        }
        ReleaseEffectCompositorRenderTarget(e) {
          this.ReleaseAdditionalRenderTarget(e);
        }
        *activeLayersGpuProfiles() {
          for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t of e.GetLayers()) {
            const s = this._layersGpuProfile.get(t);
            s && (yield s);
          }
        }
        GetLayerTimingsBuffer(e) {
          if (!this.GetRenderer().SupportsGPUProfiling()) return null;
          let t = this._layersGpuProfile.get(e);
          return t || (t = { layer: e, name: e.GetName(), timingsBuffer: C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t)), t.timingsBuffer;
        }
        _Update1sFrameRange() {
          const e = this.GetRenderer();
          if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
            this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;
            for (const t of this.activeLayersGpuProfiles()) t.curUtilisation = NaN;
          }
        }
        _UpdateTick() {
          this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();
        }
        _UpdateTick_WebGL() {
          if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
            if (this._runtime.IsDebug()) {
              for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
            }
            if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {
              const s = /* @__PURE__ */ new Map();
              for (const a of this.activeLayersGpuProfiles()) a.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), a.lastTotalUtilisation = Math.min(a.curUtilisation, 1), s.set(a.layer, a.lastTotalUtilisation);
              for (const r of this.activeLayersGpuProfiles()) {
                const n = r.layer, h = s.get(n) || 0, o = h - n.GetSubLayers().reduce((e, t2) => e + (s.get(t2) || 0), 0);
                r.lastSelfUtilisation = C33.clamp(o, 0, 1);
              }
              const t = this._runtime.GetMainRunningLayout(), i = this._gpuLastUtilisation - t._GetRootLayers().reduce((e, t2) => e + (s.get(t2) || 0), 0);
              self.C3Debugger.UpdateGPUProfile(C33.clamp(i, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
          }
        }
        GetGPUFrameTimingsBuffer() {
          return this._gpuFrameTimingsBuffer;
        }
        _UpdateTick_WebGPU() {
          if (0 !== this._gpuTimeEndFrame) {
            for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
              const s = this._webgpuFrameTimings.get(e2);
              if (s && !s.HasResult()) return;
            }
            const e = this._runtime.GetMainRunningLayout(), a = C33.MakeFilledArray(e.GetLayerCount() + 1, 0);
            let t = 0;
            for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
              const r = this._webgpuFrameTimings.get(e2);
              if (r) {
                const n = r.GetResult();
                let s = BigInt(0), i = BigInt(0);
                const h = BigInt(0);
                for (let e3 = 0, t2 = Math.min(a.length, n.length / 2); e3 < t2; ++e3) {
                  const c = n[2 * e3], _ = n[2 * e3 + 1], d = (c !== h && (s === h || c < s) && (s = c), _ > i && (i = _), _ - c), u = Number(d) / 1e9;
                  a[e3] += u;
                }
                const o = i - s, l = Number(o) / 1e9;
                t += l;
              }
            }
            if (this._gpuLastUtilisation = C33.clamp(t, 0, 1), this._runtime.IsDebug()) {
              const i = e.GetLayers(), g = /* @__PURE__ */ new Map();
              for (let e2 = 0, t2 = Math.min(i.length, a.length - 1); e2 < t2; ++e2) {
                const S = a[e2 + 1];
                g.set(i[e2], S);
              }
              const m = [], p = /* @__PURE__ */ new Map();
              for (const [C, R] of g) {
                const G = [...C.selfAndAllSubLayers()].reduce((e2, t2) => e2 + (g.get(t2) || 0), 0);
                p.set(C, G), m.push({ name: C.GetName(), lastSelfUtilisation: C33.clamp(R, 0, 1), lastTotalUtilisation: C33.clamp(G, 0, 1) });
              }
              const f = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t2) => e2 + (p.get(t2) || 0), 0);
              self.C3Debugger.UpdateGPUProfile(C33.clamp(f, 0, 1), this._gpuLastUtilisation, m);
            }
            for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);
            this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
          }
        }
        _AddWebGPUFrameTiming(e) {
          this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);
        }
        GetGPUUtilisation() {
          return this._gpuLastUtilisation;
        }
        SnapshotCanvas(e, t, s, i, a, r) {
          return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(s, i, a, r), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {
            this._snapshotResolve = e2;
          })), this._snapshotPromise;
        }
        _MaybeTakeSnapshot() {
          if (this._snapshotFormat) {
            let e = this.GetMainCanvas();
            const i = this._snapshotArea, a = C33.clamp(Math.floor(i.getLeft()), 0, e.width), r = C33.clamp(Math.floor(i.getTop()), 0, e.height);
            let t = i.width(), s = (t = 0 === t ? e.width - a : C33.clamp(Math.floor(t), 0, e.width - a), i.height());
            if (s = 0 === s ? e.height - r : C33.clamp(Math.floor(s), 0, e.height - r), (0 !== a || 0 !== r || t !== e.width || s !== e.height) && 0 < t && 0 < s) {
              const n = C33.CreateCanvas(t, s), h = n.getContext("2d");
              h.drawImage(e, a, r, t, s, 0, 0, t, s), e = n;
            }
            C33.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {
              this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(this._snapshotUrl);
            }), this._snapshotFormat = "", this._snapshotQuality = 1;
          }
        }
        GetCanvasSnapshotUrl() {
          return this._snapshotUrl;
        }
        SetIsPastingToDrawingCanvas(e) {
          e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;
        }
        IsPastingToDrawingCanvas() {
          return 0 < this._isPastingToDrawingCanvas;
        }
        InitLoadingScreen(e) {
          const t = this.GetRenderer();
          if (2 === e) this._percentText = C33.New(C33.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(PERCENTTEXT_WIDTH, PERCENTTEXT_HEIGHT);
          else if (0 === e) {
            const s = this._runtime.GetLoadingLogoAsset();
            s && s.LoadStaticTexture(t).catch((e2) => console.warn("[C3 runtime] Failed to create texture for loading logo: ", e2));
          } else 4 === e && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.logo = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.powered = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then((e2) => {
            "done" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.website = e2;
          }).catch((e2) => console.warn("Failed to load splash image: ", e2)));
        }
        async _LoadSvgSplashImage(e) {
          e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
          const t = await C33.FetchBlob(e), s = await this._runtime.RasterSvgImage(t, 2048, 2048);
          return this.GetRenderer().CreateStaticTextureAsync(s, { mipMapQuality: "high" });
        }
        async _LoadBitmapSplashImage(e) {
          e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
          const t = await C33.FetchBlob(e);
          return this.GetRenderer().CreateStaticTextureAsync(t, { mipMapQuality: "high" });
        }
        HideCordovaSplashScreen() {
          this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash");
        }
        StartLoadingScreen() {
          this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
          const e = this._runtime.GetLoaderStyle();
          3 !== e && this.HideCordovaSplashScreen();
        }
        async EndLoadingScreen() {
          const e = this.GetRenderer(), t = (this._loadingProgress = 1, this._runtime.GetLoaderStyle());
          4 === t && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = "done", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t && this.HideCordovaSplashScreen();
        }
        _DrawLoadingScreen() {
          if (-1 !== this._rafId) {
            const e = this.GetRenderer(), t = (e.Start(), this._rafId = -1, this._runtime.GetAssetManager().HasHadErrorLoading()), s = this._runtime.GetLoaderStyle();
            if (3 !== s && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s) this._DrawProgressBarAndLogoLoadingScreen(t);
            else if (1 === s) this._DrawProgressBarLoadingScreen(t, PROGRESSBAR_WIDTH, 0);
            else if (2 === s) this._DrawPercentTextLoadingScreen(t);
            else if (3 === s) C33.noop();
            else {
              if (4 !== s) throw new Error("invalid loader style");
              this._DrawSplashLoadingScreen(t);
            }
            e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
          }
        }
        _DrawPercentTextLoadingScreen(e) {
          e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
          const t = this._canvasCssWidth / 2, s = this._canvasCssHeight / 2, i = PERCENTTEXT_WIDTH / 2, a = PERCENTTEXT_HEIGHT / 2, r = (tempQuad.setRect(t - i, s - a, t + i, s + a), this.GetRenderer());
          r.SetTexture(this._percentText.GetTexture()), r.Quad3(tempQuad, this._percentText.GetTexRect());
        }
        _DrawProgressBarLoadingScreen(e, t, s) {
          const i = this.GetRenderer(), a = PROGRESSBAR_HEIGHT, r = (i.SetColorFillMode(), e ? i.SetColorRgba(1, 0, 0, 1) : i.SetColorRgba(0.118, 0.565, 1, 1), this._canvasCssWidth / 2), n = this._canvasCssHeight / 2, h = t / 2, o = a / 2;
          tempRect.setWH(r - h, n - o + s, Math.floor(t * this._loadingProgress), a), i.Rect(tempRect), tempRect.setWH(r - h, n - o + s, t, a), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i.SetColorRgba(0, 0, 0, 1), i.LineRect2(tempRect), tempRect.inflate(1, 1), i.SetColorRgba(1, 1, 1, 1), i.LineRect2(tempRect);
        }
        _DrawProgressBarAndLogoLoadingScreen(e) {
          const t = this.GetRenderer(), s = this._runtime.GetLoadingLogoAsset();
          if (s) {
            const i = s.GetTexture();
            if (i) {
              const a = i.GetWidth(), r = i.GetHeight(), n = this._canvasCssWidth / 2, h = this._canvasCssHeight / 2, o = a / 2, l = r / 2;
              tempQuad.setRect(n - o, h - l, n + o, h + l), t.SetTexture(i), t.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, a, 16 + l);
            } else this._DrawProgressBarLoadingScreen(e, PROGRESSBAR_WIDTH, 0);
          } else this._DrawProgressBarLoadingScreen(e, PROGRESSBAR_WIDTH, 0);
        }
        _DrawSplashLoadingScreen(e) {
          const t = this.GetRenderer(), s = this._splashTextures.logo, i = this._splashTextures.powered, a = this._splashTextures.website, r = Date.now(), n = (0 === this._splashFrameNumber && (this._loaderStartTime = r), this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()), h = n ? 0 : SPLASH_AFTER_FADEOUT_WAIT_TIME, o = n ? 0 : SPLASH_MIN_DISPLAY_TIME;
          let l = 1;
          "fade-in" === this._splashState ? l = Math.min((r - this._loaderStartTime) / SPLASH_FADE_DURATION, 1) : "fade-out" === this._splashState && (l = Math.max(1 - (r - this._splashFadeOutStartTime) / SPLASH_FADE_DURATION, 0)), t.SetColorFillMode(), t.SetColorRgba(0.231 * l, 0.251 * l, 0.271 * l, l), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t.Rect(tempRect);
          const c = Math.ceil(this._canvasCssWidth), _ = Math.ceil(this._canvasCssHeight);
          let d, u;
          256 < this._canvasCssHeight ? (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), i && (d = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.2 * _ - u / 2, d, u), t.SetTexture(i), t.Rect(tempRect)), s && (d = Math.min(0.395 * _, 0.95 * c), u = d, tempRect.setWH(0.5 * c - d / 2, 0.485 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect)), a && (d = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.868 * _ - u / 2, d, u), t.SetTexture(a), t.Rect(tempRect))) : (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), s && (d = 0.55 * _, u = d, tempRect.setWH(0.5 * c - d / 2, 0.45 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect))), this._splashFrameNumber++, "fade-in" === this._splashState && r - this._loaderStartTime >= SPLASH_FADE_DURATION && 2 <= this._splashFrameNumber && (this._splashState = "wait", this._splashFadeInFinishTime = r), "wait" === this._splashState && r - this._splashFadeInFinishTime >= o && 1 <= this._loadingProgress && (this._splashState = "fade-out", this._splashFadeOutStartTime = r), ("fade-out" === this._splashState && r - this._splashFadeOutStartTime >= SPLASH_FADE_DURATION + h || n && 1 <= this._loadingProgress && r - this._loaderStartTime < 500) && this._splashDoneResolve();
        }
      };
    }
    {
      const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, DEFAULT_RUNTIME_OPTS = { "messagePort": null, "runtimeBaseUrl": "", "headless": false, "hasDom": true, "isInWorker": false, "useAudio": true, "exportType": "" };
      let ife = true;
      C33.Runtime = class extends C33.DefendedBase {
        constructor(e) {
          e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e["messagePort"], this._runtimeBaseUrl = e["runtimeBaseUrl"], this._previewUrl = e["previewUrl"], this._isHeadless = !!e["headless"], this._hasDom = !!e["hasDom"], this._isInWorker = !!e["isInWorker"], ife = e["ife"], this._useAudio = !!e["useAudio"], this._exportType = e["exportType"], this._isNWjs = e["isNWjs"], this._isiOSCordova = !!e["isiOSCordova"], this._isiOSWebView = !!e["isiOSWebView"], this._isWindowsWebView2 = !!e["isWindowsWebView2"], this._isAnyWebView2Wrapper = !!e["isAnyWebView2Wrapper"], this._isFBInstantAvailable = !!e["isFBInstantAvailable"], this._isDebug = !("preview" !== this._exportType || !e["isDebug"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = "", this._projectVersion = "", this._projectUniqueId = "", this._appId = "", this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C33.New(C33.AssetManager, this, e), this._layoutManager = C33.New(C33.LayoutManager, this), this._eventSheetManager = C33.New(C33.EventSheetManager, this), this._addonManager = C33.New(C33.AddonManager, this, e["wrapperComponentIds"]), this._collisionEngine = C33.New(C33.CollisionEngine, this), this._timelineManager = C33.New(C33.TimelineManager, this), this._transitionManager = C33.New(C33.TransitionManager, this), this._templateManager = C33.New(C33.TemplateManager, this), this._flowchartManager = C33.New(C33.FlowchartManager, this), this._textIconManager = C33.New(C33.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = "vsync", this._sampling = "trilinear", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {
            this._rafId = -1, this._ruafId = -1, this.Tick(e2);
          }, tickOnly: (e2) => {
            this._ruafId = -1, this.Tick(e2, false, "skip-render");
          }, renderOnly: () => {
            this._rafId = -1, this.Render();
          } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C33.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C33.New(C33.KahanSum), this._gameTimeRaw = C33.New(C33.KahanSum), this._wallTime = C33.New(C33.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null, this._lastSaveJson = "", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C33.New(C33.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { "pretick": C33.New(C33.Event, "pretick", false), "tick": C33.New(C33.Event, "tick", false), "tick2": C33.New(C33.Event, "tick2", false), "instancecreate": C33.New(C33.Event, "instancecreate", false), "instancedestroy": C33.New(C33.Event, "instancedestroy", false), "beforelayoutchange": C33.New(C33.Event, "beforelayoutchange", false), "layoutchange": C33.New(C33.Event, "layoutchange", false) }, this._eventObjects["instancecreate"].instance = null, this._eventObjects["instancedestroy"].instance = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), this._userScriptEventObjects = null;
          const t = (e2, t2) => C33.BehaviorInstance.SortByTickSequence(this, e2, t2);
          this._behInstsToTick = C33.New(C33.RedBlackSet, t), this._behInstsToPostTick = C33.New(C33.RedBlackSet, t), this._behInstsToTick2 = C33.New(C33.RedBlackSet, t), this._jobScheduler = C33.New(C33.JobSchedulerRuntime, this, e["jobScheduler"]), e["canvas"] && (this._canvasManager = C33.New(C33.CanvasManager, this)), this._messagePort.onmessage = (e2) => this["_OnMessageFromDOM"](e2.data), this.AddDOMComponentMessageHandler("runtime", "visibilitychange", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler("runtime", "opus-decode", (e2) => this._WasmDecodeWebMOpus(e2["arrayBuffer"])), this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self["goToLastErrorScript"]), this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener("window-blur", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];
        }
        static Create(e) {
          return C33.New(C33.Runtime, e);
        }
        Release() {
          C33.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;
        }
        ["_OnMessageFromDOM"](e) {
          const t = e["type"];
          if ("event" === t) this._OnEventFromDOM(e);
          else {
            if ("result" !== t) throw new Error(`unknown message '${t}'`);
            this._OnResultFromDOM(e);
          }
        }
        _OnEventFromDOM(e) {
          if (this._isReadyToHandleEvents) {
            const t = e["component"], s = e["handler"], i = e["data"], n = e["dispatchOpts"], a = !(!n || !n["dispatchRuntimeEvent"]), r = !(!n || !n["dispatchUserScriptEvent"]), o = e["responseId"];
            if ("runtime" === t) {
              if (a) {
                const l = new C33.Event(s);
                l.data = i, this._dispatcher.dispatchEventAndWaitAsyncSequential(l);
              }
              if (r) {
                const c = new C33.Event(s, true);
                for (const [d, _] of Object.entries(i)) c[d] = _;
                this.DispatchUserScriptEvent(c);
              }
            }
            const h = this._domEventHandlers.get(t);
            if (h) {
              const u = h.get(s);
              if (u) {
                let e2 = null;
                try {
                  e2 = u(i);
                } catch (e3) {
                  return console.error(`Exception in '${t}' handler '${s}':`, e3), void (null !== o && this._PostResultToDOM(o, false, "" + e3));
                }
                null !== o && (e2 && e2.then ? e2.then((e3) => this._PostResultToDOM(o, true, e3)).catch((e3) => {
                  console.error(`Rejection from '${t}' handler '${s}':`, e3), this._PostResultToDOM(o, false, "" + e3);
                }) : this._PostResultToDOM(o, true, e2));
              } else a || r || console.warn(`[Runtime] No DOM handler '${s}' for component '${t}'`);
            } else a || r || console.warn(`[Runtime] No DOM event handlers for component '${t}'`);
          } else this._waitingToHandleEvents.push(e);
        }
        _PostResultToDOM(e, t, s) {
          this._messagePort.postMessage({ "type": "result", "responseId": e, "isOk": t, "result": s });
        }
        _OnResultFromDOM(e) {
          const t = e["responseId"], s = e["isOk"], i = e["result"], n = this._pendingResponsePromises.get(t);
          s ? n.resolve(i) : n.reject(i), this._pendingResponsePromises.delete(t);
        }
        AddDOMComponentMessageHandler(e, t, s) {
          let i = this._domEventHandlers.get(e);
          if (i || (i = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i)), i.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);
          i.set(t, s);
        }
        PostComponentMessageToDOM(e, t, s, i) {
          this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s, "responseId": null }, i);
        }
        PostComponentMessageToDOMAsync(e, t, s, i) {
          const n = this._nextDomResponseId++, a = new Promise((e2, t2) => {
            this._pendingResponsePromises.set(n, { resolve: e2, reject: t2 });
          });
          return this._messagePort.postMessage({ "type": "event", "component": e, "handler": t, "data": s, "responseId": n }, i), a;
        }
        SendWrapperExtensionMessage(e, t, s, i = -1) {
          this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", { "componentId": e, "messageId": t, "params": s, "asyncId": i });
        }
        SendWrapperExtensionMessageAsync(e, t, s) {
          const i = this._nextDomResponseId++, n = new Promise((e2, t2) => {
            this._pendingResponsePromises.set(i, { resolve: e2, reject: t2 });
          });
          return this.SendWrapperExtensionMessage(e, t, s, i), n;
        }
        _OnWrapperExtensionMessage(e) {
          if (-1 !== e["asyncId"]) {
            const t = e["asyncId"], s = this._pendingResponsePromises.get(t);
            s.resolve(e["params"]), this._pendingResponsePromises.delete(t);
          } else this._OnEventFromDOM({ "component": "wrapper-extension:" + e["componentId"], "handler": e["messageId"], "data": e["params"], "responseId": null });
        }
        AddWrapperExtensionMessageHandler(e, t, s) {
          this.AddDOMComponentMessageHandler("wrapper-extension:" + e, t, s);
        }
        HasWrapperComponentId(e) {
          return this._addonManager.HasWrapperComponentId(e);
        }
        PostToDebugger(e) {
          if (!this.IsDebug()) throw new Error("not in debug mode");
          this.PostComponentMessageToDOM("runtime", "post-to-debugger", e);
        }
        async Init(e) {
          C33.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
          const [t] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
          if (await this._LoadDataJson(t), await this._InitialiseCanvas(e), this.IsPreview() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), this.GetWebGLRenderer()) {
            const s = this.GetWebGLRenderer();
            console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${s.GetWebGLVersionNumber()} [${s.GetUnmaskedRenderer()}]`);
          } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
          this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), this._isReadyToHandleEvents = true;
          for (const i of this._waitingToHandleEvents) this._OnEventFromDOM(i);
          C33.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();
          for (const n of e["runOnStartupFunctions"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(n));
          if (await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]), C33.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C33.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({ "type": "runtime-ready" }), this;
          this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
        }
        async _RunOnStartupFunction(e) {
          try {
            await e(this._iRuntime);
          } catch (e2) {
            console.error("[C3 runtime] Error in runOnStartup function: ", e2);
          }
        }
        async _LoadDataJson(e) {
          const t = e["project"], s = (this._projectName = t[0], this._projectVersion = t[16], this._projectUniqueId = t[31], this._appId = t[38], t[39] || "loading-logo.png"), i = (this._isPixelRoundingEnabled = !!t[9], this._originalViewportWidth = this._viewportWidth = t[10], this._originalViewportHeight = this._viewportHeight = t[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t[37], this._uses3dFeatures = !!t[40], this._sampling = t[14], this._usesAnyBackgroundBlending = t[15], this._usesAnyCrossSampling = t[42], this._usesAnyDepthSampling = t[17], this._usesLoaderLayout = !!t[18], this._loaderStyle = t[19], this._nextUid = t[21], this._pauseOnBlur = t[22], this._assetManager);
          if (i._SetFileStructure(t[45]), i._SetAudioFiles(t[7], t[25]), i._SetMediaSubfolder(t[8]), i._SetFontsSubfolder(t[32]), i._SetIconsSubfolder(t[28]), i._SetWebFonts(t[29]), 0 === this._loaderStyle) {
            let e2 = "";
            (e2 = "flat" === i.GetFileStructure() ? i.GetIconsSubfolder() + s : s) && (this._loadingLogoAsset = i.LoadImage({ url: e2 }));
          }
          this._canvasManager && (this._canvasManager.SetFullscreenMode(C33.CanvasManager._FullscreenModeNumberToString(t[12])), this._canvasManager.SetFullscreenScalingQuality(t[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== t[24]), this._canvasManager._SetGPUPowerPreference(t[34]), this._canvasManager._SetTextureAnisotropy(t[41]), this._canvasManager._SetWebGPUEnabled(t[13]), this._canvasManager._SetZAxisScale(t[30]), this._canvasManager._SetZDistances(t[46], t[47]), this._canvasManager._SetInitFieldOfView(t[26]), this._canvasManager._SetLimitedToWebGL1(t[48]));
          const n = t[43], a = (n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable(), t[2]);
          for (const l of a[1]) this._addonManager.CreateBehavior(l);
          for (const c of a[0]) this._addonManager.CreatePlugin(c);
          this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();
          for (const d of t[3]) {
            const _ = C33.ObjectClass.Create(this, this._allObjectClasses.length, d);
            this._allObjectClasses.push(_), this._objectClassesByName.set(_.GetName().toLowerCase(), _), this._objectClassesBySid.set(_.GetSID(), _);
          }
          for (const u of t[4]) {
            const g = this._allObjectClasses[u[0]];
            g._LoadFamily(u);
          }
          for (const m of t[27]) {
            const p = m.map((e2) => this._allObjectClasses[e2]);
            this._allContainers.push(C33.New(C33.Container, this, p));
          }
          this._InitObjectsScriptInterface();
          for (const f of this._allObjectClasses) f._OnAfterCreate();
          for (const S of t[5]) this._layoutManager.Create(S);
          const r = t[1];
          if (r) {
            const C = this._layoutManager.GetLayoutByName(r);
            C && this._layoutManager.SetFirstLayout(C);
          }
          for (const I of t[35]) this._transitionManager.Create(I);
          for (const T of t[33]) this._timelineManager.Create(T);
          for (const b of t[44]) this._templateManager.Create(b);
          this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);
          for (const v of t[49]) this._flowchartManager.Create(v);
          this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);
          for (const y of t[6]) this._eventSheetManager.Create(y);
          this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C33.clearArray(this._objectReferenceTable), this.FlushPendingInstances();
          let o = "any";
          const h = t[20];
          1 === h ? o = "portrait" : 2 === h && (o = "landscape"), this.PostComponentMessageToDOM("runtime", "set-target-orientation", { "targetOrientation": o });
        }
        async _LoadExportToVideoData(e) {
          const t = e["format"];
          "image-sequence" === t ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : "image-sequence-gif" === t ? this._exportToVideo = new self.C3ExportToGIF(this, e) : "webm" === t ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : "mp4" === t && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = "unlimited-frame", this._canvasManager.SetFullscreenMode("off"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", { "message": this._exportToVideo.GetExportingMessageForPercent(0), "duration": this._exportToVideo.GetDuration() });
        }
        GetLoaderStyle() {
          return this._loaderStyle;
        }
        IsExportToVideo() {
          return null !== this._exportToVideo;
        }
        GetExportVideoDuration() {
          return this._exportToVideo.GetDuration();
        }
        GetExportVideoFramerate() {
          return this._exportToVideo.GetFramerate();
        }
        _InitExportToVideo() {
          return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });
        }
        _ExportToVideoAddFrame() {
          const e = this._tickCount / this.GetExportVideoFramerate();
          return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);
        }
        _ExportToVideoAddKeyframe() {
          this._exportToVideo && this._exportToVideo.AddKeyframe();
        }
        _OnOfflineAudioRenderCompleted(e) {
          this._exportToVideo.OnOfflineAudioRenderCompleted(e);
        }
        _ExportToVideoFinish() {
          return this._exportToVideo.Finish();
        }
        IsFBInstantAvailable() {
          return this._isFBInstantAvailable;
        }
        IsLoading() {
          return this._isLoading;
        }
        AddLoadPromise(e) {
          this._additionalLoadPromises.push(e);
        }
        SetUsingCreatePromises(e) {
          this._isUsingCreatePromises = !!e;
        }
        AddCreatePromise(e) {
          this._isUsingCreatePromises && this._additionalCreatePromises.push(e);
        }
        GetCreatePromises() {
          return this._additionalCreatePromises;
        }
        _GetNextFamilyIndex() {
          return this._familyCount++;
        }
        GetFamilyCount() {
          return this._familyCount;
        }
        _AddEffectList(e) {
          this._allEffectLists.add(e);
        }
        _RemoveEffectList(e) {
          this._allEffectLists.delete(e);
        }
        _GetAllEffectLists() {
          return this._allEffectLists;
        }
        async _InitialiseCanvas(e) {
          this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));
        }
        async _MaybeLoadOpusDecoder() {
          const t = this._assetManager;
          if (!t.IsAudioFormatSupported("audio/webm; codecs=opus")) {
            let e = null;
            const s = t.GetScriptSubfolder(), i = s + "opus.wasm.js", n = s + "opus.wasm.wasm";
            try {
              e = this.IsiOSCordova() && t.IsFileProtocol() ? await t.CordovaFetchLocalFileAsArrayBuffer(n) : await t.FetchArrayBuffer(n);
            } catch (e2) {
              return void console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", e2);
            }
            this.AddJobWorkerBuffer(e, "opus-decoder-wasm"), await this.AddJobWorkerScripts([i]);
          }
        }
        async _WasmDecodeWebMOpus(e) {
          const t = await this.AddJob("OpusDecode", { "arrayBuffer": e }, [e]);
          return t;
        }
        async Start() {
          this._hasStarted = true, this._startTime = Date.now();
          let t = null;
          const e = new Promise((e2) => t = e2);
          if (this._usesLoaderLayout) {
            for (const n of this._allObjectClasses) n.IsFamily() || n.IsOnLoaderLayout() || !n.IsWorldType() || n.OnCreate();
            (async () => {
              await this._assetManager.WaitForAllToLoad(), await e, this._isLoading = false, this._OnLoadFinished();
            })();
          } else this._isLoading = false;
          this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);
          for (const a of this._layoutManager.GetAllLayouts()) a._CreateGlobalNonWorlds();
          this.IsExportToVideo() && await this._InitExportToVideo();
          const s = this._layoutManager.GetFirstLayout(), i = (await s._Load(null, this.GetRenderer()), await s._StartRunning(true), this._fpsLastTime = performance.now(), t(), this._usesLoaderLayout || this._OnLoadFinished(), await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking"));
          i["isSuspended"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();
        }
        _OnLoadFinished() {
          this.Trigger(C33.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM("runtime", "register-sw");
        }
        GetObjectReference(e) {
          e = Math.floor(e);
          const t = this._objectReferenceTable;
          if (e < 0 || e >= t.length) throw new Error("invalid object reference");
          return t[e];
        }
        _LoadJsPropNameTable() {
          for (const e of self.C3_JsPropNameTable) {
            const t = C33.first(Object.keys(e));
            this._jsPropNameTable.push(t);
          }
        }
        GetJsPropName(e) {
          e = Math.floor(e);
          const t = this._jsPropNameTable;
          if (e < 0 || e >= t.length) throw new Error("invalid prop reference");
          return t[e];
        }
        HasDOM() {
          return this._hasDom;
        }
        IsHeadless() {
          return this._isHeadless;
        }
        IsInWorker() {
          return this._isInWorker;
        }
        GetRuntimeBaseURL() {
          return this._runtimeBaseUrl;
        }
        GetPreviewURL() {
          return this._previewUrl;
        }
        GetEventSheetManager() {
          return this._eventSheetManager;
        }
        GetEventStack() {
          return this._eventSheetManager.GetEventStack();
        }
        GetCurrentEventStackFrame() {
          return this._eventSheetManager.GetCurrentEventStackFrame();
        }
        GetCurrentEvent() {
          return this._eventSheetManager.GetCurrentEvent();
        }
        GetCurrentCondition() {
          return this._eventSheetManager.GetCurrentCondition();
        }
        IsCurrentConditionFirst() {
          return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();
        }
        GetCurrentAction() {
          return this._eventSheetManager.GetCurrentAction();
        }
        GetAddonManager() {
          return this._addonManager;
        }
        GetSystemPlugin() {
          return this._addonManager.GetSystemPlugin();
        }
        GetObjectClassByIndex(e) {
          if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError("invalid index");
          return this._allObjectClasses[e];
        }
        GetObjectClassByName(e) {
          return this._objectClassesByName.get(e.toLowerCase()) || null;
        }
        GetObjectClassBySID(e) {
          return this._objectClassesBySid.get(e) || null;
        }
        GetSingleGlobalObjectClassByCtor(e) {
          const t = C33.AddonManager.GetPluginByConstructorFunction(e);
          return t ? t.GetSingleGlobalObjectClass() : null;
        }
        GetAllObjectClasses() {
          return this._allObjectClasses;
        }
        *allInstances() {
          for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());
        }
        Dispatcher() {
          return this._dispatcher;
        }
        UserScriptDispatcher() {
          return this._userScriptDispatcher;
        }
        DispatchUserScriptEvent(e) {
          e.runtime = this.GetIRuntime();
          const t = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
          t && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t && C3Debugger.AddScriptTime();
        }
        DispatchUserScriptEventAsyncWait(e) {
          return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
        }
        GetOriginalViewportWidth() {
          return this._originalViewportWidth;
        }
        GetOriginalViewportHeight() {
          return this._originalViewportHeight;
        }
        SetOriginalViewportSize(e, t) {
          if (this._originalViewportWidth !== e || this._originalViewportHeight !== t) {
            this._originalViewportWidth = e, this._originalViewportHeight = t;
            const s = this.GetLayoutManager();
            s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
          }
        }
        GetViewportWidth() {
          return this._viewportWidth;
        }
        GetViewportHeight() {
          return this._viewportHeight;
        }
        SetViewportSize(e, t) {
          if (this._viewportWidth !== e || this._viewportHeight !== t) {
            this._viewportWidth = e, this._viewportHeight = t;
            const s = this.GetLayoutManager();
            s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
          }
        }
        _SetDevicePixelRatio(e) {
          this.IsExportToVideo() || (this._devicePixelRatio = e);
        }
        GetDevicePixelRatio() {
          return this._devicePixelRatio;
        }
        GetParallaxXOrigin() {
          return this._parallaxXorigin;
        }
        GetParallaxYOrigin() {
          return this._parallaxYorigin;
        }
        GetCanvasManager() {
          return this._canvasManager;
        }
        GetDrawWidth() {
          return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;
        }
        GetDrawHeight() {
          return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;
        }
        GetRenderScale() {
          return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;
        }
        GetDisplayScale() {
          return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;
        }
        GetEffectLayerScaleParam() {
          return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;
        }
        GetEffectDevicePixelRatioParam() {
          return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;
        }
        GetCanvasClientX() {
          return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;
        }
        GetCanvasClientY() {
          return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;
        }
        GetCanvasCssWidth() {
          return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;
        }
        GetCanvasCssHeight() {
          return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;
        }
        GetFullscreenMode() {
          return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off";
        }
        GetAdditionalRenderTarget(e) {
          return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;
        }
        ReleaseAdditionalRenderTarget(e) {
          this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);
        }
        UsesAnyBackgroundBlending() {
          return this._usesAnyBackgroundBlending;
        }
        UsesAnyCrossSampling() {
          return this._usesAnyCrossSampling;
        }
        UsesAnyDepthSampling() {
          return this._usesAnyDepthSampling;
        }
        GetGPUUtilisation() {
          return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;
        }
        IsLinearSampling() {
          return "nearest" !== this.GetSampling();
        }
        GetFramerateMode() {
          return this._framerateMode;
        }
        _SetFramerateMode(e) {
          this._framerateMode !== e && (this._framerateMode = e, -1 !== this._rafId || -1 !== this._ruafId) && (this._CancelAnimationFrame(), this._RequestAnimationFrame());
        }
        GetSampling() {
          return this._sampling;
        }
        UsesLoaderLayout() {
          return this._usesLoaderLayout;
        }
        GetLoadingLogoAsset() {
          return this._loadingLogoAsset;
        }
        ReleaseLoadingLogoAsset() {
          this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);
        }
        GetLayoutManager() {
          return this._layoutManager;
        }
        GetMainRunningLayout() {
          return this._layoutManager.GetMainRunningLayout();
        }
        GetTimelineManager() {
          return this._timelineManager;
        }
        GetTransitionManager() {
          return this._transitionManager;
        }
        GetTemplateManager() {
          return this._templateManager;
        }
        GetFlowchartManager() {
          return this._flowchartManager;
        }
        GetAssetManager() {
          return this._assetManager;
        }
        LoadImage(e) {
          return this._assetManager.LoadImage(e);
        }
        CreateInstance(e, t, s, i, n, a) {
          if (a && this._templateManager) {
            if (e instanceof C33.ObjectClass && e.IsFamily()) {
              const o = e.GetFamilyMembers(), h = Math.floor(this.Random() * o.length);
              return this.CreateInstance(o[h], t, s, i, n, a);
            }
            const r = this._templateManager.GetTemplateData(e, a);
            if (r) {
              const l = this.CreateInstanceFromData(r, t, false, s, i, false, n, void 0, n);
              return this._templateManager.MapInstanceToTemplateName(l, a), l;
            }
          }
          return this.CreateInstanceFromData(e, t, false, s, i, false, n, void 0, n);
        }
        CreateInstanceFromData(e, t, s, i, n, a, r, o, h) {
          let l = null, c = null;
          if (e instanceof C33.ObjectClass) {
            if ((c = e).IsFamily()) {
              const I = c.GetFamilyMembers(), T = Math.floor(this.Random() * I.length);
              c = I[T];
            }
            l = c.GetDefaultInstanceData();
          } else l = e, c = this.GetObjectClassByIndex(l[1]);
          const d = c.GetPlugin().IsWorldType();
          if (this._isLoading && d && !c.IsOnLoaderLayout()) return null;
          const _ = t;
          d || (t = null);
          let u;
          u = s && !a && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;
          const g = l ? l[0] : null, m = C33.New(C33.Instance, { runtime: this, objectType: c, layer: t, worldData: g, instVarData: l ? l[3] : null, uid: u, tags: l ? l[6] : null });
          this._instancesByUid.set(u, m);
          let p = null, f = (d && (p = m.GetWorldInfo(), void 0 !== i && void 0 !== n && (p.SetX(i), p.SetY(n)), c._SetAnyCollisionCellChanged(true)), t && (h || t._AddInstance(m, true), t.GetLayout().MaybeLoadTexturesFor(c)), this._objectCount++, true);
          if (o) {
            const b = o.GetObjectClass();
            if (b.IsInContainer() && c.IsInContainer()) {
              const v = c.GetContainer(), y = b.GetContainer();
              v === y && (f = false);
            }
          }
          if (c.IsInContainer() && !s && !a && f) {
            const M = /* @__PURE__ */ new Set();
            for (const G of c.GetContainer().objectTypes()) if (G !== c) {
              const w = this._MaybeGetChildInstanceForObjectTypeData(G, p, M);
              if (w) {
                const D = this.CreateInstanceFromData(w, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);
                m._AddSibling(D);
              } else {
                const B = this.CreateInstanceFromData(G, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);
                m._AddSibling(B);
              }
            }
            for (const P of m.siblings()) {
              P._AddSibling(m);
              for (const L of m.siblings()) P !== L && P._AddSibling(L);
            }
          }
          if (d && !s && r && this._CreateChildInstancesFromData(m, g, p, t, i, n, h), c.IsInContainer() && !s && !a && r) for (const R of m.siblings()) {
            const A = R.GetWorldInfo();
            if (A) {
              const j = R.GetPlugin(), E = R.GetObjectClass().GetDefaultInstanceData()[0];
              j.IsWorldType() ? this._CreateChildInstancesFromData(R, E, A, t, A.GetX(), A.GetY(), h) : this._CreateChildInstancesFromData(R, E, A, t, void 0, void 0, h);
            }
          }
          if (!a && r) {
            void 0 === i && (i = g[0]), void 0 === n && (n = g[1]);
            const O = p.GetTopParent(), W = i - p.GetX() + O.GetX(), N = n - p.GetY() + O.GetY();
            O.SetXY(W, N);
          }
          c._SetIIDsStale();
          const F = l ? C33.cloneArray(l[5]) : null, x = l ? l[4].map((e2) => C33.cloneArray(e2)) : null, S = d && g && g[13];
          if (S && m._SetHasTilemap(), m._CreateSdkInstance(F, x), S) {
            const k = g[13];
            m.GetSdkInstance().LoadTilemapData(k[2], k[0], k[1]);
          }
          this._instancesPendingCreate.push(m), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m);
          const C = this._eventObjects["instancecreate"];
          return C.instance = m, this._dispatcher.dispatchEvent(C), m;
        }
        _GetInstanceData(e) {
          const t = e[0], s = e[1], i = e[2], n = e[6];
          if (n) return n;
          const a = this._layoutManager.GetLayoutBySID(t), r = a.GetLayer(s);
          return r.GetInitialInstanceData(i);
        }
        _MaybeGetChildInstanceForObjectTypeData(e, t, s) {
          const i = t?.GetSceneGraphChildrenExportData() ?? [];
          for (const n of i) {
            const a = this._GetInstanceData(n), r = !!n[4], o = this.GetObjectClassByIndex(a[1]);
            if (!s.has(a) && (e === o && r)) return s.add(a), a;
          }
        }
        _CreateChildInstancesFromData(t, e, s, i, n, a, r) {
          const o = s.GetSceneGraphZIndexExportData(), h = s.GetSceneGraphChildrenExportData();
          if (t.GetWorldInfo().SetSceneGraphZIndex(o), h) {
            void 0 === n && (n = e[0]), void 0 === a && (a = e[1]);
            const l = /* @__PURE__ */ new Set(), c = e[0], d = e[1];
            for (const _ of h) {
              const u = _[0], g = _[1], m = _[2], p = _[3], f = !!_[4], S = _[5], C = _[6];
              let e2;
              if (C) e2 = C;
              else {
                const v = this._layoutManager.GetLayoutBySID(u), y = v.GetLayer(g);
                e2 = y.GetInitialInstanceData(m);
              }
              const I = this.GetObjectClassByIndex(e2[1]), T = t.HasSibling(I), b = l.has(I);
              if (T && !b && f) {
                const M = t.GetSibling(I), G = (M.GetWorldInfo().Init(e2[0]), n + e2[0][0] - c), w = a + e2[0][1] - d;
                M.GetWorldInfo().SetXY(G, w), M.GetWorldInfo().SetSceneGraphZIndex(S), t.AddChild(M, { transformX: !!(p >> 0 & 1), transformY: !!(p >> 1 & 1), transformWidth: !!(p >> 2 & 1), transformHeight: !!(p >> 3 & 1), transformAngle: !!(p >> 4 & 1), destroyWithParent: !!(p >> 5 & 1), transformZElevation: !!(p >> 6 & 1), transformOpacity: !!(p >> 7 & 1), transformVisibility: !!(p >> 8 & 1) }), l.add(I);
              } else {
                const D = n + e2[0][0] - c, P = a + e2[0][1] - d, L = this.CreateInstanceFromData(e2, i, false, D, P, false, true, t, r);
                L.GetWorldInfo().SetSceneGraphZIndex(S), t.AddChild(L, { transformX: !!(p >> 0 & 1), transformY: !!(p >> 1 & 1), transformWidth: !!(p >> 2 & 1), transformHeight: !!(p >> 3 & 1), transformAngle: !!(p >> 4 & 1), destroyWithParent: !!(p >> 5 & 1), transformZElevation: !!(p >> 6 & 1), transformOpacity: !!(p >> 7 & 1), transformVisibility: !!(p >> 8 & 1) });
              }
            }
          }
        }
        DestroyInstance(t) {
          if (!this._instancesPendingRelease.has(t)) {
            const s = t.GetObjectClass();
            let e = this._instancesPendingDestroy.get(s);
            if (e) {
              if (e.has(t)) return;
              e.add(t);
            } else (e = /* @__PURE__ */ new Set()).add(t), this._instancesPendingDestroy.set(s, e);
            if (this.IsDebug() && C3Debugger.InstanceDestroyed(t), t._MarkDestroyed(), this._hasPendingInstances = true, t.IsInContainer()) for (const e2 of t.siblings()) this.DestroyInstance(e2);
            for (const i of t.children()) i.GetDestroyWithParent() && this.DestroyInstance(i);
            if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {
              const n = this.GetEventSheetManager();
              n.BlockFlushingInstances(true), t._TriggerOnDestroyed(), n.BlockFlushingInstances(false);
            }
            t._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());
          }
        }
        FlushPendingInstances() {
          this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());
        }
        _FlushInstancesPendingCreate() {
          for (const e of this._instancesPendingCreate) {
            const t = e.GetObjectClass();
            t._AddInstance(e);
            for (const s of t.GetFamilies()) s._AddInstance(e), s._SetIIDsStale();
          }
          C33.clearArray(this._instancesPendingCreate);
        }
        _FlushInstancesPendingDestroy() {
          this._dispatcher.SetDelayRemoveEventsEnabled(true);
          for (const [e, t] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t), t.clear();
          this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);
        }
        _FlushInstancesPendingDestroyForObjectClass(e, t) {
          for (const s of t) {
            const i = this._eventObjects["instancedestroy"], n = (i.instance = s, this._dispatcher.dispatchEvent(i), this._instancesByUid.delete(s.GetUID()), this._instanceTimes.delete(s), s.GetWorldInfo());
            n && (n._RemoveFromCollisionCells(), n._RemoveFromRenderCells(), n._MarkDestroyed()), this._instancesPendingRelease.add(s), this._objectCount--;
          }
          C33.arrayRemoveAllInSet(e.GetInstances(), t), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);
          for (const a of e.GetFamilies()) C33.arrayRemoveAllInSet(a.GetInstances(), t), a._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(a);
          if (e.GetPlugin().IsWorldType()) {
            const r = new Set([...t].map((e2) => e2.GetWorldInfo().GetLayer()));
            for (const o of r) o._RemoveAllInstancesInSet(t);
          }
        }
        _GetInstancesPendingCreate() {
          return this._instancesPendingCreate;
        }
        *instancesPendingCreateForObjectClass(e) {
          for (const t of this._GetInstancesPendingCreate()) e.IsFamily() ? t.GetObjectClass().BelongsToFamily(e) && (yield t) : t.GetObjectClass() === e && (yield t);
        }
        _GetNewUID() {
          return this._nextUid++;
        }
        _MapInstanceByUID(e, t) {
          this._instancesByUid.set(e, t);
        }
        _SetAutoSuspendEnabled(e) {
          this._isAutoSuspendEnabled !== (e = !!e) && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled) && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false);
        }
        _IsAutoSuspendEnabled() {
          return this._isAutoSuspendEnabled;
        }
        _OnRendererContextLost() {
          this._dispatcher.dispatchEvent(C33.New(C33.Event, "renderercontextlost")), this.SetSuspended(true);
          for (const t of this._allObjectClasses) !t.IsFamily() && t.HasLoadedTextures() && t.ReleaseTextures();
          const e = this.GetMainRunningLayout();
          e && e._OnRendererContextLost(), C33.ImageInfo.OnRendererContextLost(), C33.ImageAsset.OnRendererContextLost();
        }
        async _OnRendererContextRestored() {
          await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C33.New(C33.Event, "renderercontextrestored")), this.SetSuspended(false), this.UpdateRender();
        }
        _OnVisibilityChange(e) {
          if (this._isAutoSuspendEnabled) {
            const t = e["hidden"];
            this.SetSuspended(t), (this._isPageVisibilitySuspended = t) || this.UpdateRender();
          }
        }
        _OnWindowBlur(e) {
          !this.IsPreview() || !this._pauseOnBlur || C33.Platform.IsMobile || e.data["parentHasFocus"] || (this.SetSuspended(true), this._isPausedOnBlur = true);
        }
        _OnWindowFocus() {
          this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);
        }
        _RequestAnimationFrame() {
          const e = this._tickCallbacks;
          "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.normal));
        }
        _CancelAnimationFrame() {
          -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C33.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);
        }
        IsSuspended() {
          return 0 < this._suspendCount;
        }
        SetSuspended(e) {
          if (!this.IsExportToVideo()) {
            const t = this.IsSuspended(), s = (this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0), this.IsSuspended());
            if (!t && s) console.log("[Construct] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "suspend")), this.Trigger(C33.Plugins.System.Cnds.OnSuspend, null, null);
            else if (t && !s) {
              console.log("[Construct] Resuming");
              const i = performance.now();
              this._lastTickTime = i, this._fpsLastTime = i, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C33.New(C33.Event, "resume")), this.Trigger(C33.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(i);
            }
          }
        }
        _AddBehInstToTick(e) {
          this._behInstsToTick.Add(e);
        }
        _AddBehInstToPostTick(e) {
          this._behInstsToPostTick.Add(e);
        }
        _AddBehInstToTick2(e) {
          this._behInstsToTick2.Add(e);
        }
        _RemoveBehInstToTick(e) {
          this._behInstsToTick.Remove(e);
        }
        _RemoveBehInstToPostTick(e) {
          this._behInstsToPostTick.Remove(e);
        }
        _RemoveBehInstToTick2(e) {
          this._behInstsToTick2.Remove(e);
        }
        _BehaviorTick() {
          const e = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick) t instanceof e ? t._tick() : t.Tick();
          this._behInstsToTick.SetQueueingEnabled(false);
        }
        _BehaviorPostTick() {
          const e = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToPostTick.SetQueueingEnabled(true);
          for (const t of this._behInstsToPostTick) t instanceof e ? t._postTick() : t.PostTick();
          this._behInstsToPostTick.SetQueueingEnabled(false);
        }
        _BehaviorTick2() {
          const e = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToTick2.SetQueueingEnabled(true);
          for (const t of this._behInstsToTick2) t instanceof e ? t._tick2() : t.Tick2();
          this._behInstsToTick2.SetQueueingEnabled(false);
        }
        *_DebugBehaviorTick() {
          const t = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToTick.SetQueueingEnabled(true);
          for (const s of this._behInstsToTick) {
            let e;
            e = s instanceof t ? s._tick() : s.Tick(), C33.IsIterator(e) && (yield* e);
          }
          this._behInstsToTick.SetQueueingEnabled(false);
        }
        *_DebugBehaviorPostTick() {
          const t = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToPostTick.SetQueueingEnabled(true);
          for (const s of this._behInstsToPostTick) {
            let e;
            e = s instanceof t ? s._postTick() : s.PostTick(), C33.IsIterator(e) && (yield* e);
          }
          this._behInstsToPostTick.SetQueueingEnabled(false);
        }
        *_DebugBehaviorTick2() {
          const t = globalThis.ISDKBehaviorInstanceBase;
          this._behInstsToTick2.SetQueueingEnabled(true);
          for (const s of this._behInstsToTick2) {
            let e;
            e = s instanceof t ? s._tick2() : s.Tick2(), C33.IsIterator(e) && (yield* e);
          }
          this._behInstsToTick2.SetQueueingEnabled(false);
        }
        async Tick(t, e, s) {
          this._hasStartedTicking = true;
          const i = "background-wake" === s, n = "background-wake" !== s && "skip-render" !== s, a = this.GetLayoutManager(), r = this.GetCanvasManager();
          if (this._hasStarted && (!this.IsSuspended() || e || i)) {
            const o = performance.now(), h = (this._isInTick = true, this._MeasureDt(t || 0), this._tpsTickCount++, this._ReleasePendingInstances(), this.Step_BeforePreTick()), l = (this.IsDebugging() && await h, this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects["pretick"])), c = (l instanceof Promise && await l, this.Step_AfterPreTick()), d = (this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a.IsPendingChangeMainLayout() && await this._MaybeChangeLayout(), this.Step_RunEventsEtc()), _ = (this.IsDebugging() && await d, a.GetMainRunningLayout()), u = _._GetPendingSetHTMLLayerCount();
            let e2 = false;
            if (-1 !== u && (_._ResetPendingHTMLLayerCount(), r.GetHTMLLayerCount() !== u)) {
              const g = this.GetCanvasManager().SetHTMLLayerCount(u);
              this.IsInWorker() && (e2 = true, await g);
            }
            this.PostComponentMessageToDOM("canvas", "update-html-layer-dom-state", { "layersDomState": _._GetRootLayers().filter((e3) => e3.IsHTMLElementsLayer()).map((e3) => e3._GetHTMLLayerDOMState()) }), n && this.Render(), e2 && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o);
          }
        }
        async Step_BeforePreTick() {
          const e = this._eventSheetManager, t = this.IsDebug();
          this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);
        }
        async Step_AfterPreTick() {
          const e = this.IsDebug(), t = this.IsDebugging(), s = this._dispatcher, i = this._eventObjects, n = this._userScriptEventObjects;
          e && C3Debugger.StartMeasuringTime(), t ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), t ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), e && C3Debugger.AddBehaviorTickTime(), e && C3Debugger.StartMeasuringTime(), t ? await this.DebugFireGeneratorEventAndBreak(i["tick"]) : s.dispatchEvent(i["tick"]), e && C3Debugger.AddPluginTickTime(), this._eventSheetManager.BlockFlushingInstances(false), this.DispatchUserScriptEvent(n["tick"]);
        }
        async Step_RunEventsEtc() {
          const e = this._eventSheetManager, t = this._dispatcher, s = this._eventObjects, i = this.IsDebug(), n = this.IsDebugging();
          i && C3Debugger.StartMeasuringTime(), n ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), i && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), i && C3Debugger.StartMeasuringTime(), n ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), i && C3Debugger.AddBehaviorTickTime(), i && C3Debugger.StartMeasuringTime(), n ? await this.DebugFireGeneratorEventAndBreak(s["tick2"]) : t.dispatchEvent(s["tick2"]), i && C3Debugger.AddPluginTickTime(), e.BlockFlushingInstances(false), n && await e.RunQueuedDebugTriggersAsync();
        }
        _ReleasePendingInstances() {
          if (0 !== this._instancesPendingRelease.size) {
            const e = this._dispatcher;
            e.SetDelayRemoveEventsEnabled(true);
            for (const t of this._instancesPendingReleaseAffectedObjectClasses) t.GetSolStack().RemoveInstances(this._instancesPendingRelease);
            this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);
            for (const s of this._instancesPendingRelease) s.Release();
            this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);
          }
        }
        async _MaybeChangeLayout() {
          const e = this.GetLayoutManager();
          let t = 0;
          for (; e.IsPendingChangeMainLayout() && t++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());
        }
        _MeasureDt(e) {
          let t = 0;
          if (this.IsExportToVideo()) t = 1 / this.GetExportVideoFramerate(), this._dtRaw = t, this._dt1 = t;
          else if (0 !== this._lastTickTime) {
            const s = Math.max(e - this._lastTickTime, 0);
            0.5 < (t = s / 1e3) && (t = 0), this._dtRaw = t, this._dt1 = C33.clamp(t, this._minDt, this._maxDt);
          }
          this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t * this._timeScale), this._wallTime.Add(this._dt1);
          for (const [i, n] of this._instanceTimes) n.Add(this._dt1 * i.GetTimeScale());
          this._canvasManager && this._canvasManager._UpdateTick(), 1e3 <= e - this._fpsLastTime && (this._fpsLastTime += 1e3, 1e3 <= e - this._fpsLastTime && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug()) && C3Debugger.Update1sPerfStats();
        }
        _SetTrackingInstanceTime(e, t) {
          if (t) {
            if (!this._instanceTimes.has(e)) {
              const s = C33.New(C33.KahanSum);
              s.Copy(this._gameTime), this._instanceTimes.set(e, s);
            }
          } else this._instanceTimes.delete(e);
        }
        _GetInstanceGameTime(e) {
          const t = this._instanceTimes.get(e);
          return t ? t.Get() : this.GetGameTime();
        }
        async _DoChangeLayout(e) {
          const t = this._dispatcher, s = this.GetLayoutManager(), i = s.GetMainRunningLayout();
          await i._StopRunning(), i._Unload(e, this.GetRenderer()), i === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t.dispatchEvent(this._eventObjects["beforelayoutchange"]), C33.Asyncify.SetHighThroughputMode(true), await e._Load(i, this.GetRenderer()), C33.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t.dispatchEvent(this._eventObjects["layoutchange"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();
        }
        UpdateRender() {
          this._needRender = true;
        }
        GetWebGLRenderer() {
          return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;
        }
        GetWebGPURenderer() {
          return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;
        }
        GetRenderer() {
          return this._canvasManager ? this._canvasManager.GetRenderer() : null;
        }
        Render() {
          const s = this._canvasManager;
          if (s && !s.IsRendererContextLost()) {
            const i = this.GetRenderer(), e = i.SupportsGPUProfiling(), n = e && i.IsWebGL(), a = e && i.IsWebGPU();
            if (n && i.CheckForQueryResults(), this._needRender || this.IsExportToVideo()) {
              const r = this._layoutManager.GetMainRunningLayout(), o = (this._fpsFrameCount++, i.Start(), this.IsDebug());
              o && C3Debugger.StartMeasuringTime(), this._needRender = false;
              let e2 = null, t = (n && (e2 = s.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), i.StartQuery(e2)), null);
              a && (t = i.StartFrameTiming(2 * (1 + r.GetLayerCount())), i.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && "low" === s.GetCurrentFullscreenScalingQuality() ? i.SetFixedSizeDepthBuffer(s.GetDrawWidth(), s.GetDrawHeight()) : i.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), r), e2 && i.EndQuery(e2), a && (i.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(t)), i.Finish(), o && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), s && s._MaybeTakeSnapshot();
            } else i.IncrementFrameNumber();
          }
        }
        _NeedsHTMLLayerCompositing(e) {
          return "low" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());
        }
        _Render(t, s) {
          t.SetTextureFillMode(), t.SetAlphaBlend(), t.SetColorRgba(1, 1, 1, 1), t.SetRenderTarget(null), t.SetTexture(null), t.SetDepthEnabled(this.Uses3DFeatures()), this._NeedsHTMLLayerCompositing(t) && s._MaybeStartDrawToOwnTexture(t);
          const i = s.GetHTMLLayerCount();
          for (let e = 1; e < i; ++e) s.DrawForHTMLLayerIndex(t, e), t.IsWebGPU() && t.Restart();
          this._NeedsHTMLLayerCompositing(t) || s._MaybeStartDrawToOwnTexture(t), s.DrawMain(t);
        }
        Trigger(e, t, s) {
          if (!this._hasStarted) return false;
          const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();
          let n = 0;
          i && (n = performance.now());
          const a = this.IsDebug(), r = (a && this.SetDebuggingEnabled(false), this._eventSheetManager._Trigger(this._layoutManager, e, t, s));
          if (i) {
            const o = performance.now() - n;
            this._mainThreadTimeCounter += o, a && C3Debugger.AddTriggersTime(o);
          }
          return a && this.SetDebuggingEnabled(true), r;
        }
        DebugTrigger(e, t, s) {
          if (!this.IsDebugging()) return this.Trigger(e, t, s);
          if (this.HitBreakpoint()) throw new Error("called DebugTrigger() while stopped on breakpoint");
          if (this._isInTick || this._eventSheetManager.IsInTrigger()) return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);
          throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
        }
        async TriggerAsync(e, t, s) {
          if (!this.IsDebugging()) return this.Trigger(e, t, s);
          if (!this._hasStarted) return false;
          if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, s);
          if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, s);
          const i = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);
          let a = n.next();
          for (; !a.done; ) await this.DebugBreak(a.value), a = n.next();
          return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, a.value;
        }
        FastTrigger(e, t, s) {
          const i = this.IsDebug(), n = (i && this.SetDebuggingEnabled(false), this._eventSheetManager._FastTrigger(this._layoutManager, e, t, s));
          return i && this.SetDebuggingEnabled(true), n;
        }
        DebugFastTrigger(e, t, s) {
          return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, s);
        }
        ScheduleTriggers(e) {
          return this._scheduleTriggersThrottle.Add(e);
        }
        PushCurrentLayout(e) {
          this._currentLayoutStack.push(e);
        }
        PopCurrentLayout() {
          if (!this._currentLayoutStack.length) throw new Error("layout stack empty");
          this._currentLayoutStack.pop();
        }
        GetCurrentLayout() {
          return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();
        }
        GetDt(e) {
          return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;
        }
        _GetDtFast() {
          return this._dt;
        }
        GetDt1() {
          return this._dt1;
        }
        GetDtRaw() {
          return this._dtRaw;
        }
        GetTimeScale() {
          return this._timeScale;
        }
        SetTimeScale(e) {
          (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;
        }
        SetMinDt(e) {
          this._minDt = Math.max(e, 0);
        }
        GetMinDt() {
          return this._minDt;
        }
        SetMaxDt(e) {
          this._maxDt = Math.max(e, 0);
        }
        GetMaxDt() {
          return this._maxDt;
        }
        GetFramesPerSecond() {
          return this._fps;
        }
        GetTicksPerSecond() {
          return this._tps;
        }
        GetMainThreadTime() {
          return this._mainThreadTime;
        }
        GetStartTime() {
          return this._startTime;
        }
        GetGameTime() {
          return this._gameTime.Get();
        }
        GetGameTimeRaw() {
          return this._gameTimeRaw.Get();
        }
        GetWallTime() {
          return this._wallTime.Get();
        }
        GetTickCount() {
          return this._tickCount;
        }
        GetTickCountNoSave() {
          return this._tickCountNoSave;
        }
        GetObjectCount() {
          return this._objectCount;
        }
        GetProjectName() {
          return this._projectName;
        }
        GetProjectVersion() {
          return this._projectVersion;
        }
        GetProjectUniqueId() {
          return this._projectUniqueId;
        }
        GetAppId() {
          return this._appId;
        }
        GetInstanceByUID(e) {
          if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
          return this._instancesByUid.get(e) || null;
        }
        _RefreshUidMap() {
          this._instancesByUid.clear();
          for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t);
        }
        IsPreview() {
          return "preview" === this._exportType;
        }
        IsDebug() {
          return this._isDebug;
        }
        GetExportType() {
          return this._exportType;
        }
        IsNWjs() {
          return "nwjs" === this.GetExportType() || this._isNWjs;
        }
        IsCordova() {
          return "cordova" === this._exportType;
        }
        IsAndroidWebView() {
          return "Android" === C33.Platform.OS && ("cordova" === this._exportType || "playable-ad-single-file" === this._exportType || "playable-ad-zip" === this._exportType || "instant-games" === this._exportType);
        }
        IsiOSCordova() {
          return this._isiOSCordova;
        }
        IsiOSWebView() {
          return this._isiOSWebView;
        }
        IsWindowsWebView2() {
          return this._isWindowsWebView2;
        }
        IsAnyWebView2Wrapper() {
          return this._isAnyWebView2Wrapper;
        }
        GetCollisionEngine() {
          return this._collisionEngine;
        }
        GetSolidBehavior() {
          return this._addonManager.GetSolidBehavior();
        }
        GetJumpthruBehavior() {
          return this._addonManager.GetJumpthruBehavior();
        }
        Uses3DFeatures() {
          return this._uses3dFeatures;
        }
        GetZScaleFactor() {
          return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());
        }
        GetDefaultCameraZ(e) {
          return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());
        }
        IsLayoutFirstTick() {
          return this._isLayoutFirstTick;
        }
        SetPixelRoundingEnabled(e) {
          this._isPixelRoundingEnabled !== (e = !!e) && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());
        }
        IsPixelRoundingEnabled() {
          return this._isPixelRoundingEnabled;
        }
        GetTextIconSet(e) {
          if (!this._iconChangeHandlers.has(e)) {
            const s = () => this.DeleteTextIconSet(e);
            this._iconChangeHandlers.set(e, s), e.Dispatcher().addEventListener("animationframeimagechange", s);
          }
          const t = this._textIconManager.GetIconSet(e);
          return t.HasLoaded() || t.LoadContent().then(() => this.UpdateRender()), t;
        }
        DeleteTextIconSet(e) {
          this._textIconManager.DeleteIconSet(e);
        }
        _GetTextIconSetMeta(e) {
          const t = [];
          for (const s of e.GetAnimations()) for (const i of s.GetFrames()) {
            const n = i.GetImageInfo();
            t.push({ source: i, width: n.GetWidth(), height: n.GetHeight(), tag: i.GetTag() });
          }
          return { icons: t };
        }
        async _GetTextIconSetContent(e) {
          const t = C33.New(C33.PromiseThrottle), s = [], n = /* @__PURE__ */ new Map();
          for (const r of e.GetAnimations()) for (const o of r.GetFrames()) {
            const h = o.GetImageInfo().GetImageAsset();
            n.has(h) || (n.set(h, null), s.push(t.Add(async () => {
              const e2 = await h.LoadToDrawable();
              n.set(h, e2);
            })));
          }
          await Promise.all(s);
          const i = [];
          for (const l of e.GetAnimations()) for (const c of l.GetFrames()) i.push(t.Add(async () => {
            const e2 = c.GetImageInfo(), t2 = n.get(e2.GetImageAsset()), s2 = await e2.ExtractImageToCanvas(t2), i2 = await createImageBitmap(s2);
            return { drawable: i2 };
          }));
          const a = await Promise.all(i);
          for (const d of n.values()) d instanceof ImageBitmap && d["close"] && d["close"]();
          return { icons: a };
        }
        SaveToSlot(e) {
          this._saveToSlotName = e, this._saveToJsonString = false;
        }
        SaveToJsonString() {
          this._saveToSlotName = "", this._saveToJsonString = true;
        }
        LoadFromSlot(e) {
          this._loadFromSlotName = e;
        }
        LoadFromJsonString(e) {
          this._loadFromJson = e;
        }
        GetLastSaveJsonString() {
          return this._lastSaveJson;
        }
        _NeedsHandleSaveOrLoad() {
          return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);
        }
        async _HandleSaveOrLoad() {
          if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug()) && C3Debugger.StepIfPausedInDebugger(), this._saveToJsonString) {
            const e = await this._SaveToJsonString();
            this._lastSaveJson = e, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "", this._ClearSaveOrLoad();
          }
          if (null !== this._loadFromJson) {
            this.FlushPendingInstances();
            try {
              await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
            } catch (e) {
              console.error("[Construct] Failed to load state from JSON string: ", e), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);
            }
            this._ClearSaveOrLoad();
          }
        }
        _ClearSaveOrLoad() {
          this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null;
        }
        _GetProjectStorage() {
          return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: "c3-localstorage-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;
        }
        _GetSavegamesStorage() {
          return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: "c3-savegames-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;
        }
        async _DoSaveToSlot(e) {
          const t = await this._SaveToJsonString();
          try {
            await this._GetSavegamesStorage().setItem(e, t), console.log("[Construct] Saved state to storage (" + t.length + " chars)"), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "";
          } catch (e2) {
            console.error("[Construct] Failed to save state to storage: ", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveFailed, null);
          }
        }
        async _DoLoadFromSlot(e) {
          try {
            const t = await this._GetSavegamesStorage().getItem(e);
            if (!t) throw new Error("empty slot");
            console.log("[Construct] Loaded state from storage (" + t.length + " chars)"), await this._DoLoadFromJsonString(t), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
          } catch (e2) {
            console.error("[Construct] Failed to load state from storage: ", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);
          }
        }
        async _SaveToJsonString() {
          const e = { "c3save": true, "version": 1, "rt": { "time": this.GetGameTime(), "timeRaw": this.GetGameTimeRaw(), "walltime": this.GetWallTime(), "timescale": this.GetTimeScale(), "tickcount": this.GetTickCount(), "next_uid": this._nextUid, "running_layout": this.GetMainRunningLayout().GetSID(), "start_time_offset": Date.now() - this._startTime }, "types": {}, "layouts": {}, "events": this._eventSheetManager._SaveToJson(), "timelines": this._timelineManager._SaveToJson(), "user_script_data": null };
          for (const s of this._allObjectClasses) s.IsFamily() || s.HasNoSaveBehavior() || (e["types"][s.GetSID().toString()] = s._SaveToJson());
          for (const i of this._layoutManager.GetAllLayouts()) e["layouts"][i.GetSID().toString()] = i._SaveToJson();
          const t = this._CreateUserScriptEvent("save");
          return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e["user_script_data"] = t.saveData, JSON.stringify(e);
        }
        IsLoadingState() {
          return this._isLoadingState;
        }
        async _DoLoadFromJsonString(e) {
          const t = this.GetLayoutManager(), s = JSON.parse(e);
          if (s["c2save"]) throw new Error("C2 saves are incompatible with C3 runtime");
          if (!s["c3save"]) throw new Error("not valid C3 save data");
          if (1 < s["version"]) throw new Error("C3 save data from future version");
          this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "beforeload"));
          for (const h of this.allInstances()) {
            const l = h.GetObjectClass();
            l.HasNoSaveBehavior() || h._OnBeforeLoad();
          }
          const i = s["rt"], n = (this._gameTime.Set(i["time"]), i.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(i["timeRaw"]), this._wallTime.Set(i["walltime"]), this._timeScale = i["timescale"], this._tickCount = i["tickcount"], this._startTime = Date.now() - i["start_time_offset"], i["running_layout"]);
          let a = !(this._isLoadingState = true);
          if (n !== this.GetMainRunningLayout().GetSID()) {
            const c = t.GetLayoutBySID(n);
            if (!c) return;
            await this._DoChangeLayout(c), a = true;
          }
          for (const [d, _] of Object.entries(s["layouts"])) {
            const u = parseInt(d, 10), g = t.GetLayoutBySID(u);
            g && g._LoadFromJson(_);
          }
          const r = /* @__PURE__ */ new Set();
          for (const [m, p] of Object.entries(s["types"])) {
            const f = parseInt(m, 10), S = this.GetObjectClassBySID(f);
            !S || S.IsFamily() || S.HasNoSaveBehavior() || S._LoadFromJson(p, r);
          }
          for (const C of this._layoutManager.GetAllLayouts()) for (const I of C.allLayers()) I._LoadFromJsonAfterInstances();
          if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a) {
            for (const T of this.allInstances()) T.SetupInitialSceneGraphConnections();
            for (const [b, v] of Object.entries(s["types"])) {
              const y = parseInt(b, 10), M = this.GetObjectClassBySID(y);
              !M || M.IsFamily() || M.HasNoSaveBehavior() || M._SetupSceneGraphConnectionsOnChangeOfLayout(v);
            }
          }
          this._nextUid = i["next_uid"], this._eventSheetManager._LoadFromJson(s["events"]);
          for (const G of this._allObjectClasses) if (!G.IsFamily() && G.IsInContainer()) for (const w of G.GetInstances()) {
            const D = w.GetIID();
            for (const P of G.GetContainer().objectTypes()) if (P !== G) {
              const L = P.GetInstances();
              if (D < 0 || D >= L.length) throw new Error("missing sibling instance");
              w._AddSibling(L[D]);
            }
          }
          this._timelineManager._LoadFromJson(s["timelines"]), t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();
          for (const R of r) R._OnCreatedForLoadingSavegame();
          this.DoAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, "afterload")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
          for (const [A, E] of Object.entries(s["types"])) {
            const O = parseInt(A, 10), k = this.GetObjectClassBySID(O);
            k && k._ClearLoadInstancesJson();
          }
          const o = this._CreateUserScriptEvent("load");
          o.saveData = s["user_script_data"], await this.DispatchUserScriptEventAsyncWait(o), this.UpdateRender();
        }
        SortOnTmpHierarchyPosition(e, t) {
          return e.GetWorldInfo().GetTmpHierarchyPosition() - t.GetWorldInfo().GetTmpHierarchyPosition();
        }
        AddInstanceNeedingAfterLoad(e, t) {
          !e.GetWorldInfo() || this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t), this._instancesNeedingAfterLoadArray.push(e));
        }
        ClearIntancesNeedingAfterLoad() {
          this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C33.clearArray(this._instancesNeedingAfterLoadArray);
        }
        DoAfterLoad(e = "full", t = null) {
          this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition);
          for (const s of this._instancesNeedingAfterLoadArray) s._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s), e, t);
          for (const i of this._instancesNeedingAfterLoadArray) i._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(i), e, t);
          this.ClearIntancesNeedingAfterLoad();
        }
        async AddJobWorkerScripts(e) {
          const t = await Promise.all(e.map(async (e2) => {
            const t2 = this.IsCordova() && this._assetManager.IsFileProtocol();
            if (t2 || "playable-ad-single-file" === this.GetExportType()) {
              const s = await this._assetManager.FetchBlob(e2);
              return URL.createObjectURL(s);
            }
            return new URL(e2, location.href).toString();
          }));
          this._jobScheduler.ImportScriptsToJobWorkers(t);
        }
        AddJobWorkerBlob(e, t) {
          this._jobScheduler.SendBlobToJobWorkers(e, t);
        }
        AddJobWorkerBuffer(e, t) {
          this._jobScheduler.SendBufferToJobWorkers(e, t);
        }
        AddJob(e, t, s, i) {
          return this._jobScheduler.AddJob(e, t, s, null, null, i);
        }
        BroadcastJob(e, t, s, i) {
          return this._jobScheduler.BroadcastJob(e, t, s, i);
        }
        GetMaxNumJobWorkers() {
          return this._jobScheduler.GetMaxNumWorkers();
        }
        InvokeDownload(e, t) {
          this.PostComponentMessageToDOM("runtime", "invoke-download", { "url": e, "filename": t });
        }
        async RasterSvgImage(e, t, s, i, n, a) {
          if (i = i || t, n = n || s, this.IsInWorker()) {
            const r = await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", { "blob": e, "imageWidth": t, "imageHeight": s, "surfaceWidth": i, "surfaceHeight": n, "imageBitmapOpts": a });
            return r["imageBitmap"];
          }
          {
            const o = await self["C3_RasterSvgImageBlob"](e, t, s, i, n);
            return a ? self.createImageBitmap(o, a) : o;
          }
        }
        async GetSvgImageSize(e) {
          return this.IsInWorker() ? this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", { "blob": e }) : self["C3_GetSvgImageSize"](e);
        }
        RequestDeviceOrientationEvent() {
          this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"));
        }
        RequestDeviceMotionEvent() {
          this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-motion"));
        }
        Random() {
          return this._randomNumberCallback();
        }
        SetRandomNumberGeneratorCallback(e) {
          this._randomNumberCallback = e;
        }
        _GetRemotePreviewStatusInfo() {
          const e = this.GetRenderer();
          return { "fps": this.GetFramesPerSecond(), "tps": this.GetTicksPerSecond(), "cpu": this.GetMainThreadTime(), "gpu": this.GetGPUUtilisation(), "layout": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "", "renderer": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };
        }
        HitBreakpoint() {
          return !!this.IsDebug() && C3Debugger.HitBreakpoint();
        }
        DebugBreak(e) {
          return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();
        }
        DebugBreakNext() {
          return !!this.IsDebugging() && C3Debugger.BreakNext();
        }
        SetDebugBreakpointsEnabled(e) {
          this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();
        }
        AreDebugBreakpointsEnabled() {
          return this._breakpointsEnabled;
        }
        IsDebugging() {
          return this._isDebugging;
        }
        SetDebuggingEnabled(e) {
          e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();
        }
        _UpdateDebuggingFlag() {
          this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;
        }
        IsCPUProfiling() {
          return this.IsDebug() && C3Debugger.IsCPUProfiling();
        }
        IsGPUProfiling() {
          return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();
        }
        async DebugIterateAndBreak(e) {
          if (e) for (const t of e) await this.DebugBreak(t);
        }
        DebugFireGeneratorEventAndBreak(e) {
          return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));
        }
        _InvokeFunctionFromJS(e) {
          return this._eventSheetManager._InvokeFunctionFromJS(e["name"], e["params"]);
        }
        _GetHTMLLayerWrapElement(e) {
          if (this.IsInWorker()) throw new Error("not supported in worker mode");
          return self["c3_runtimeInterface"]["_GetHTMLWrapElement"](e);
        }
        GetIRuntime() {
          return this._iRuntime;
        }
        _CreateUserScriptEvent(e) {
          const t = C33.New(C33.Event, e, false);
          return t.runtime = this._iRuntime, t;
        }
        _InitScriptInterfaces() {
          this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { "tick": this._CreateUserScriptEvent("tick") };
        }
        _InitObjectsScriptInterface() {
          const e = {};
          for (const t of this._allObjectClasses) e[t.GetJsPropName()] = { value: t.GetIObjectClass(), enumerable: true, writable: false };
          this._iRuntime._InitObjects(e);
        }
        _InitGlobalVariableScriptInterface() {
          const e = {};
          for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();
          this._iRuntime._InitGlobalVars(e);
        }
        _GetCommonScriptInterfaces() {
          return this._commonScriptInterfaces;
        }
        _MapScriptInterface(e, t) {
          this._interfaceMap.set(e, t);
        }
        _UnwrapScriptInterface(e) {
          return this._interfaceMap.get(e);
        }
        _UnwrapIObjectClass(e) {
          if (!(e instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
          const t = this._UnwrapScriptInterface(e);
          if (t && t instanceof C33.ObjectClass) return t;
          throw new Error("invalid IObjectClass");
        }
        _UnwrapIInstance(e) {
          if (!(e instanceof self.IInstance)) throw new TypeError("expected IInstance");
          const t = this._UnwrapScriptInterface(e);
          if (t && t instanceof C33.Instance) return t;
          throw new Error("invalid IInstance");
        }
        _UnwrapIWorldInstance(e) {
          if (!(e instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
          const t = this._UnwrapScriptInterface(e);
          if (t && t instanceof C33.Instance) return t;
          throw new Error("invalid IInstance");
        }
      }, self["C3_CreateRuntime"] = C33.Runtime.Create, self["C3_InitRuntime"] = (e, t) => e.Init(t);
    }
    {
      const C33 = self.C3;
      C33.JobSchedulerRuntime = class extends C33.DefendedBase {
        constructor(r, e) {
          super(), this._runtime = r, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e["inputPort"], e["outputPort"].onmessage = (r2) => this._OnJobWorkerMessage(r2), this._maxNumWorkers = e["maxNumWorkers"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;
        }
        async Init() {
        }
        GetMaxNumWorkers() {
          return this._maxNumWorkers;
        }
        ImportScriptsToJobWorkers(r) {
          this._inputPort.postMessage({ "type": "_import_scripts", "scripts": r });
        }
        SendBlobToJobWorkers(r, e) {
          this._inputPort.postMessage({ "type": "_send_blob", "blob": r, "id": e });
        }
        SendBufferToJobWorkers(r, e) {
          this._inputPort.postMessage({ "type": "_send_buffer", "buffer": r, "id": e }, [r]);
        }
        AddJob(r, e, o, s, t, i) {
          if (o = o || [], "number" == typeof i && (i = Math.floor(i)) <= 0) throw new Error("invalid maxWorkerNum");
          const n = this._nextJobId++, a = { "type": r, "isBroadcast": false, "maxWorkerNum": i, "jobId": n, "params": e, "transferables": o }, _ = new Promise((r2, e2) => {
            this._jobPromises.set(n, { resolve: r2, progress: s, reject: e2, cancelled: false, maxWorkerNum: i });
          });
          return t && t.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a, o), this._MaybeCreateExtraWorker(), _;
        }
        BroadcastJob(r, e, o, s) {
          if (o = o || [], "number" == typeof s && (s = Math.floor(s)) <= 0) throw new Error("invalid maxWorkerNum");
          const t = this._nextJobId++, i = { "type": r, "isBroadcast": true, "maxWorkerNum": s, "jobId": t, "params": e, "transferables": o };
          this._inputPort.postMessage(i, o);
        }
        _CancelJob(r) {
          const e = this._jobPromises.get(r);
          e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ "type": "_cancel", "jobId": r }));
        }
        _OnJobWorkerMessage(r) {
          const e = r.data, o = e["type"], s = e["jobId"];
          switch (o) {
            case "result":
              this._OnJobResult(s, e["result"]);
              break;
            case "progress":
              this._OnJobProgress(s, e["progress"]);
              break;
            case "error":
              this._OnJobError(s, e["error"]);
              break;
            case "ready":
              this._OnJobWorkerReady();
              break;
            default:
              throw new Error(`unknown message from worker '${o}'`);
          }
        }
        _OnJobResult(r, e) {
          const o = this._jobPromises.get(r);
          if (!o) throw new Error("invalid job ID");
          o.cancelled || o.resolve(e), this._jobPromises.delete(r);
        }
        _OnJobProgress(r, e) {
          const o = this._jobPromises.get(r);
          if (!o) throw new Error("invalid job ID");
          !o.cancelled && o.progress && o.progress(e);
        }
        _OnJobError(r, e) {
          const o = this._jobPromises.get(r);
          if (!o) throw new Error("invalid job ID");
          o.cancelled || o.reject(e), this._jobPromises.delete(r);
        }
        _OnJobWorkerReady() {
          this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ "type": "_no_more_workers" }));
        }
        _GetWorkerCountNeededForPendingJobs() {
          let r = 0;
          const e = [...this._jobPromises.values()].sort((r2, e2) => {
            const o = r2.maxWorkerNum || 1 / 0, s = e2.maxWorkerNum || 1 / 0;
            return o - s;
          });
          for (const o of e) {
            const s = o.maxWorkerNum || 1 / 0;
            r < s && r++;
          }
          return r;
        }
        async _MaybeCreateExtraWorker() {
          if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {
            this._isCreatingWorker = true;
            const r = await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker");
            r["outputPort"].onmessage = (r2) => this._OnJobWorkerMessage(r2);
          } catch (r) {
            this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r);
          }
        }
      };
    }
    {
      self["C3_Shaders"] = {};
    }
    {
      {
        let ForEachOrdered_SortInstances2 = function(e, t) {
          const r2 = e[1], n2 = t[1];
          if ("number" == typeof r2 && "number" == typeof n2) return r2 - n2;
          {
            const a2 = "" + r2, i2 = "" + n2;
            return a2 < i2 ? -1 : i2 < a2 ? 1 : 0;
          }
        };
        ForEachOrdered_SortInstances = ForEachOrdered_SortInstances2;
        const a = self.C3;
        let r = null, n = "", s = "", o = [], u = "", l = "", c = "";
        const i = a.New(a.ArrayStack);
        a.Plugins.System = class extends a.SDKPluginBase {
          constructor(e) {
            super(e), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();
          }
          Release() {
            super.Release();
          }
          UpdateRender() {
            this._runtime.UpdateRender();
          }
          Trigger(e) {
            this._runtime.Trigger(e, null, null);
          }
          GetRegex(e, t) {
            return r && e === n && t === s || (r = new RegExp(e, t), n = e, s = t), r.lastIndex = 0, r;
          }
          GetRegexMatches(e, t, r2) {
            if (e !== u || t !== l || r2 !== c) {
              const n2 = this.GetRegex(t, r2);
              o = e.match(n2), u = e, l = t, c = r2;
            }
            return o;
          }
          async _LoadTexturesForObjectClasses(e, t) {
            if (t.length) {
              this._imagesLoadingTotal += t.length;
              const r2 = [];
              for (const n2 of t) r2.push(e.MaybeLoadTexturesFor(n2));
              await a.PromiseAllWithProgress(r2, () => {
                this._imagesLoadingComplete++;
              }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(a.Plugins.System.Cnds.OnImageLoadingComplete, null, null));
            }
          }
          _UnloadTexturesForObjectClasses(e, t) {
            for (const r2 of t) 0 === r2.GetInstanceCount() && e.MaybeUnloadTexturesFor(r2);
          }
          _GetForEachStack() {
            return i;
          }
          _Repeat(t) {
            const r2 = this._runtime.GetEventSheetManager(), e = r2.GetEventStack(), n2 = e.GetCurrentStackFrame(), a2 = n2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = n2.IsSolModifierAfterCnds(), o2 = e.Push(a2), u2 = r2.GetLoopStack(), l2 = u2.Push();
            if (l2.SetEnd(t), s2) for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) r2.PushCopySol(i2), l2.SetIndex(e2), a2.Retrigger(n2, o2), r2.PopSol(i2);
            else for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) l2.SetIndex(e2), a2.Retrigger(n2, o2);
            return e.Pop(), u2.Pop(), false;
          }
          *_DebugRepeat(t) {
            const r2 = this._runtime.GetEventSheetManager(), e = r2.GetEventStack(), n2 = e.GetCurrentStackFrame(), a2 = n2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = n2.IsSolModifierAfterCnds(), o2 = e.Push(a2), u2 = r2.GetLoopStack(), l2 = u2.Push();
            if (l2.SetEnd(t), s2) for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) r2.PushCopySol(i2), l2.SetIndex(e2), yield* a2.DebugRetrigger(n2, o2), r2.PopSol(i2);
            else for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) l2.SetIndex(e2), yield* a2.DebugRetrigger(n2, o2);
            return e.Pop(), u2.Pop(), false;
          }
          _While() {
            const t = this._runtime.GetEventSheetManager(), e = t.GetEventStack(), r2 = e.GetCurrentStackFrame(), n2 = r2.GetCurrentEvent(), a2 = n2.GetSolModifiers(), i2 = r2.IsSolModifierAfterCnds(), s2 = e.Push(n2), o2 = t.GetLoopStack(), u2 = o2.Push();
            if (i2) for (let e2 = 0; !u2.IsStopped(); ++e2) t.PushCopySol(a2), u2.SetIndex(e2), n2.Retrigger(r2, s2) || u2.Stop(), t.PopSol(a2);
            else for (let e2 = 0; !u2.IsStopped(); ++e2) u2.SetIndex(e2), n2.Retrigger(r2, s2) || u2.Stop();
            return e.Pop(), o2.Pop(), false;
          }
          *_DebugWhile() {
            const t = this._runtime.GetEventSheetManager(), e = t.GetEventStack(), r2 = e.GetCurrentStackFrame(), n2 = r2.GetCurrentEvent(), a2 = n2.GetSolModifiers(), i2 = r2.IsSolModifierAfterCnds(), s2 = e.Push(n2), o2 = t.GetLoopStack(), u2 = o2.Push();
            if (i2) for (let e2 = 0; !u2.IsStopped(); ++e2) {
              t.PushCopySol(a2), u2.SetIndex(e2);
              const l2 = yield* n2.DebugRetrigger(r2, s2);
              l2 || u2.Stop(), t.PopSol(a2);
            }
            else for (let e2 = 0; !u2.IsStopped(); ++e2) {
              u2.SetIndex(e2);
              const c2 = yield* n2.DebugRetrigger(r2, s2);
              c2 || u2.Stop();
            }
            return e.Pop(), o2.Pop(), false;
          }
          _For(e, t, r2) {
            const n2 = this._runtime.GetEventSheetManager(), a2 = n2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l2 = a2.Push(s2), c2 = n2.GetLoopStack(), h = c2.Push();
            if (h.SetName(e), h.SetEnd(r2), r2 < t) if (u2) for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) n2.PushCopySol(o2), h.SetIndex(e2), s2.Retrigger(i2, l2), n2.PopSol(o2);
            else for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) h.SetIndex(e2), s2.Retrigger(i2, l2);
            else if (u2) for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) n2.PushCopySol(o2), h.SetIndex(e2), s2.Retrigger(i2, l2), n2.PopSol(o2);
            else for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) h.SetIndex(e2), s2.Retrigger(i2, l2);
            return a2.Pop(), c2.Pop(), false;
          }
          *_DebugFor(e, t, r2) {
            const n2 = this._runtime.GetEventSheetManager(), a2 = n2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l2 = a2.Push(s2), c2 = n2.GetLoopStack(), h = c2.Push();
            if (h.SetName(e), h.SetEnd(r2), r2 < t) if (u2) for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) n2.PushCopySol(o2), h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2), n2.PopSol(o2);
            else for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2);
            else if (u2) for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) n2.PushCopySol(o2), h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2), n2.PopSol(o2);
            else for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2);
            return a2.Pop(), c2.Pop(), false;
          }
          _ForEach(r2) {
            const e = r2.GetCurrentSol(), t = e.GetInstances();
            if (0 !== t.length) {
              const n2 = this._runtime.GetEventSheetManager(), s2 = n2.GetEventStack(), o2 = s2.GetCurrentStackFrame(), u2 = o2.GetCurrentEvent(), l2 = u2.GetSolModifiers(), c2 = o2.IsSolModifierAfterCnds(), h = s2.Push(u2), g = n2.GetLoopStack(), S = g.Push(), d = r2.IsInContainer(), p = i.Push();
              if (a.shallowAssignArray(p, t), S.SetEnd(p.length), c2) for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {
                n2.PushCopySol(l2);
                const m = p[e2];
                r2.GetCurrentSol().SetSinglePicked(m), d && m.SetSiblingsSinglePicked(), S.SetIndex(e2), u2.Retrigger(o2, h), n2.PopSol(l2);
              }
              else {
                e._SetSelectAll(false);
                const G = e._GetOwnInstances();
                a.clearArray(G), G.push(null);
                for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {
                  const y = p[e2];
                  G[0] = y, d && y.SetSiblingsSinglePicked(), S.SetIndex(e2), u2.Retrigger(o2, h);
                }
              }
              s2.Pop(), g.Pop(), a.clearArray(p), i.Pop();
            }
            return false;
          }
          *_DebugForEach(r2) {
            const e = r2.GetCurrentSol(), t = e.GetInstances();
            if (0 !== t.length) {
              const n2 = this._runtime.GetEventSheetManager(), s2 = n2.GetEventStack(), o2 = s2.GetCurrentStackFrame(), u2 = o2.GetCurrentEvent(), l2 = u2.GetSolModifiers(), c2 = o2.IsSolModifierAfterCnds(), h = s2.Push(u2), g = n2.GetLoopStack(), S = g.Push(), d = r2.IsInContainer(), p = i.Push();
              if (a.shallowAssignArray(p, t), S.SetEnd(p.length), c2) for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {
                n2.PushCopySol(l2);
                const m = p[e2];
                r2.GetCurrentSol().SetSinglePicked(m), d && m.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* u2.DebugRetrigger(o2, h), n2.PopSol(l2);
              }
              else {
                e._SetSelectAll(false);
                const G = e._GetOwnInstances();
                a.clearArray(G), G.push(null);
                for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {
                  const y = p[e2];
                  G[0] = y, d && y.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* u2.DebugRetrigger(o2, h);
                }
              }
              s2.Pop(), g.Pop(), a.clearArray(p), i.Pop();
            }
            return false;
          }
          _ForEachOrdered(r2, e) {
            const t = r2.GetCurrentSol(), n2 = t.GetInstances();
            if (0 !== n2.length) {
              const s2 = this._runtime.GetEventSheetManager(), o2 = s2.GetEventStack(), u2 = s2.GetCurrentCondition(), l2 = o2.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = o2.Push(c2), d = s2.GetLoopStack(), p = d.Push(), m = r2.IsInContainer(), G = i.Push();
              a.clearArray(G), p.SetEnd(n2.length);
              for (let e2 = 0, t2 = n2.length; e2 < t2; ++e2) G.push([n2[e2], u2.ReevaluateParameter(1, e2)]);
              if (G.sort(ForEachOrdered_SortInstances2), 1 === e && G.reverse(), g) for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {
                s2.PushCopySol(h);
                const y = G[e2][0];
                r2.GetCurrentSol().SetSinglePicked(y), m && y.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S), s2.PopSol(h);
              }
              else {
                t._SetSelectAll(false);
                const f = t._GetOwnInstances();
                a.clearArray(f), f.push(null);
                for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {
                  const C = G[e2][0];
                  f[0] = C, m && C.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S);
                }
              }
              o2.Pop(), d.Pop(), a.clearArray(G), i.Pop();
            }
            return false;
          }
          *_DebugForEachOrdered(r2, e) {
            const t = r2.GetCurrentSol(), n2 = t.GetInstances();
            if (0 !== n2.length) {
              const s2 = this._runtime.GetEventSheetManager(), o2 = s2.GetEventStack(), u2 = s2.GetCurrentCondition(), l2 = o2.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = o2.Push(c2), d = s2.GetLoopStack(), p = d.Push(), m = r2.IsInContainer(), G = i.Push();
              a.clearArray(G), p.SetEnd(n2.length);
              for (let e2 = 0, t2 = n2.length; e2 < t2; ++e2) G.push([n2[e2], u2.ReevaluateParameter(1, e2)]);
              if (G.sort(ForEachOrdered_SortInstances2), 1 === e && G.reverse(), g) for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {
                s2.PushCopySol(h);
                const y = G[e2][0];
                r2.GetCurrentSol().SetSinglePicked(y), m && y.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S), s2.PopSol(h);
              }
              else {
                t._SetSelectAll(false);
                const f = t._GetOwnInstances();
                a.clearArray(f), f.push(null);
                for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {
                  const C = G[e2][0];
                  f[0] = C, m && C.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S);
                }
              }
              o2.Pop(), d.Pop(), a.clearArray(G), i.Pop();
            }
            return false;
          }
          _GetFunctionMap(e, t) {
            let r2 = this._functionMaps.get(e);
            if (!r2) {
              if (!t) return null;
              r2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e, r2);
            }
            return r2;
          }
          _DoCallMappedFunction(e, t, r2, n2, a2) {
            t.GetEventBlock().RunAsMappedFunctionCall(r2, t.IsCopyPicked()), n2 && e.PopSol(a2);
          }
          *_DebugDoCallMappedFunction(e, t, r2, n2, a2) {
            yield* t.GetEventBlock().DebugRunAsMappedFunctionCall(r2, t.IsCopyPicked()), n2 && e.PopSol(a2);
          }
        };
      }
      {
        const a1 = self.C3;
        a1.Plugins.System.Type = class extends a1.DefendedBase {
          constructor(e) {
            super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
          }
          OnCreate() {
          }
          Release() {
            this._objectClass = null, this._runtime = null, this._plugin = null;
          }
        };
      }
      {
        const d1 = self.C3;
        d1.Plugins.System.Instance = class extends d1.DefendedBase {
          constructor(e, t) {
            super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();
          }
          Release() {
            this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;
          }
        };
      }
      {
        const h1 = self.C3, i1 = [];
        h1.Plugins.System.Cnds = { EveryTick() {
          return true;
        }, OnLayoutStart() {
          return true;
        }, OnLayoutEnd() {
          return true;
        }, OnSuspend() {
          return true;
        }, OnResume() {
          return true;
        }, IsSuspended() {
          return this._runtime.IsSuspended();
        }, Else() {
          const e = this._runtime.GetCurrentEventStackFrame();
          return !e.GetElseBranchRan() && !e.GetLastEventTrue();
        }, TriggerOnce() {
          const e = this._runtime.GetCurrentCondition(), t = e.GetSavedDataMap();
          let r = t.get("TriggerOnce_lastTick");
          void 0 === r && (r = -1, t.set("TriggerOnce_lastTick", -1));
          const n = this._runtime.GetTickCount();
          return t.set("TriggerOnce_lastTick", n), this._runtime.IsLayoutFirstTick() || r !== n - 1;
        }, Every(e) {
          const t = this._runtime.GetCurrentCondition(), r = t.GetSavedDataMap(), n = r.get("Every_lastTime") || 0, a = this._runtime.GetGameTime(), i = (r.has("Every_seconds") || r.set("Every_seconds", e), r.get("Every_seconds"));
          return n + i <= a ? (r.set("Every_lastTime", n + i), a >= r.get("Every_lastTime") + 0.04 && r.set("Every_lastTime", a), r.set("Every_seconds", e), true) : (a < n - 0.1 && r.set("Every_lastTime", a), false);
        }, IsGroupActive(e) {
          const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
          return t && t.IsGroupActive();
        }, IsPreview() {
          return this._runtime.IsPreview();
        }, IsMobile() {
          return h1.Platform.IsMobile;
        }, OnLoadFinished() {
          return true;
        }, OnCanvasSnapshot() {
          return true;
        }, EffectsSupported() {
          return true;
        }, OnSaveComplete() {
          return true;
        }, OnSaveFailed() {
          return true;
        }, OnLoadComplete() {
          return true;
        }, OnLoadFailed() {
          return true;
        }, ObjectUIDExists(e) {
          return !!this._runtime.GetInstanceByUID(e);
        }, IsOnPlatform(e) {
          switch (e) {
            case 0:
              return "browser" === h1.Platform.Context;
            case 1:
              return "iOS" === h1.Platform.OS;
            case 2:
              return "Android" === h1.Platform.OS;
            case 8:
              return "cordova" === h1.Platform.Context;
            case 9:
              return "scirra-arcade" === this._runtime.GetExportType();
            case 10:
              return "nwjs" === h1.Platform.Context;
            case 13:
              return "windows-uwp" === this._runtime.GetExportType();
            default:
              return false;
          }
        }, RegexTest(e, t, r) {
          const n = this.GetRegex(t, r);
          return n.test(e);
        }, Compare(e, t, r) {
          return h1.compare(e, t, r);
        }, CompareBetween(e, t, r) {
          return t <= e && e <= r;
        }, CompareVar(e, t, r) {
          return h1.compare(e.GetValue(), t, r);
        }, CompareBoolVar(e) {
          return !!e.GetValue();
        }, CompareTime(e, t) {
          const r = this._runtime.GetGameTime();
          if (0 !== e) return h1.compare(r, e, t);
          {
            const n = this._runtime.GetCurrentCondition(), a = n.GetSavedDataMap();
            return !a.get("CompareTime_executed") && t <= r ? (a.set("CompareTime_executed", true), true) : false;
          }
        }, IsNaN(e) {
          return isNaN(e);
        }, AngleWithin(e, t, r) {
          return h1.angleDiff(h1.toRadians(e), h1.toRadians(r)) <= h1.toRadians(t);
        }, IsClockwiseFrom(e, t) {
          return h1.angleClockwise(h1.toRadians(e), h1.toRadians(t));
        }, IsBetweenAngles(e, t, r) {
          let n = h1.toRadians(e), a = h1.toRadians(t), i = h1.toRadians(r), s = !h1.angleClockwise(i, a);
          return s ? !(!h1.angleClockwise(n, a) && h1.angleClockwise(n, i)) : h1.angleClockwise(n, a) && !h1.angleClockwise(n, i);
        }, IsValueType(e, t) {
          return "number" == typeof e ? 0 === t : 1 === t;
        }, EvaluateExpression(e) {
          return !!e;
        }, OnSignal(e) {
          return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();
        }, PickByComparison(e, r, n, a) {
          if (!e) return false;
          const t = this._GetForEachStack(), i = t.Push(), s = e.GetCurrentSol(), o = (h1.shallowAssignArray(i, s.GetInstances()), s.IsSelectAll() && h1.clearArray(s._GetOwnElseInstances()), this._runtime.GetCurrentCondition());
          let u = 0;
          for (let e2 = 0, t2 = i.length; e2 < t2; ++e2) {
            const c = i[e2];
            i[u] = c, r = o.ReevaluateParameter(1, e2), a = o.ReevaluateParameter(3, e2), h1.compare(r, n, a) ? ++u : s._PushElseInstance(c);
          }
          h1.truncateArray(i, u), s.SetArrayPicked(i);
          const l = !!i.length;
          return h1.clearArray(i), t.Pop(), e.ApplySolToContainer(), l;
        }, PickByEvaluate(e, t) {
          if (!e) return false;
          const r = this._GetForEachStack(), n = r.Push(), a = e.GetCurrentSol(), i = (h1.shallowAssignArray(n, a.GetInstances()), a.IsSelectAll() && h1.clearArray(a._GetOwnElseInstances()), this._runtime.GetCurrentCondition());
          let s = 0;
          for (let e2 = 0, t2 = n.length; e2 < t2; ++e2) {
            const u = n[e2];
            n[s] = u, i.ReevaluateParameter(1, e2) ? ++s : a._PushElseInstance(u);
          }
          h1.truncateArray(n, s), a.SetArrayPicked(n);
          const o = !!n.length;
          return h1.clearArray(n), r.Pop(), e.ApplySolToContainer(), o;
        }, PickByHighestLowestValue(e, r, n) {
          if (!e) return false;
          const t = e.GetCurrentSol(), a = t.GetInstances();
          if (0 === a.length) return false;
          const i = this._runtime.GetCurrentCondition();
          let s = null, o = 0;
          for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) {
            const u = a[e2];
            n = i.ReevaluateParameter(2, e2), (null === s || 0 === r && n < o || 1 === r && n > o) && (o = n, s = u);
          }
          return t.PickOne(s), e.ApplySolToContainer(), true;
        }, PickNth(e, t) {
          if (!e) return false;
          const r = e.GetCurrentSol(), n = r.GetInstances();
          if ((t = Math.floor(t)) >= n.length) return false;
          const a = n[t];
          return r.PickOne(a), e.ApplySolToContainer(), true;
        }, PickRandom(e) {
          if (!e) return false;
          const t = e.GetCurrentSol(), r = t.GetInstances(), n = Math.floor(this._runtime.Random() * r.length);
          if (n >= r.length) return false;
          const a = r[n];
          return t.PickOne(a), e.ApplySolToContainer(), true;
        }, PickAll(e) {
          if (!e) return false;
          if (!e.GetInstanceCount()) return false;
          const t = e.GetCurrentSol();
          return t._SetSelectAll(true), e.ApplySolToContainer(), true;
        }, PickOverlappingPoint(e, r, n) {
          if (!e) return false;
          const a = e.GetCurrentSol(), t = a.GetInstances(), i = this._runtime.GetCurrentEvent(), s = i.IsOrBlock(), o = this._runtime.GetCurrentCondition().IsInverted();
          a.IsSelectAll() ? (h1.shallowAssignArray(i1, t), a.ClearArrays(), a._SetSelectAll(false)) : s ? (h1.shallowAssignArray(i1, a._GetOwnElseInstances()), h1.clearArray(a._GetOwnElseInstances())) : (h1.shallowAssignArray(i1, a._GetOwnInstances()), h1.clearArray(a._GetOwnInstances()));
          for (let e2 = 0, t2 = i1.length; e2 < t2; ++e2) {
            const u = i1[e2];
            h1.xor(u.GetWorldInfo().ContainsPoint(r, n), o) ? a._PushInstance(u) : a._PushElseInstance(u);
          }
          return e.ApplySolToContainer(), h1.xor(!!a._GetOwnInstances().length, o);
        }, PickLastCreated(t) {
          if (!t) return false;
          const r = t.IsFamily();
          let n = null;
          const a = this._runtime._GetInstancesPendingCreate();
          for (let e2 = a.length - 1; 0 <= e2; --e2) {
            const i = a[e2];
            if (r) {
              if (i.GetObjectClass().BelongsToFamily(t)) {
                n = i;
                break;
              }
            } else if (i.GetObjectClass() === t) {
              n = i;
              break;
            }
          }
          if (!n) {
            const s = t.GetInstances();
            s.length && (n = s.at(-1));
          }
          if (!n) return false;
          const e = t.GetCurrentSol();
          return e.PickOne(n), t.ApplySolToContainer(), true;
        }, Repeat(e) {
          return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);
        }, While() {
          return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();
        }, For(e, t, r) {
          return this._runtime.IsDebugging() ? this._DebugFor(e, t, r) : this._For(e, t, r);
        }, ForEach(e) {
          return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);
        }, ForEachOrdered(e, t, r) {
          return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, r) : this._ForEachOrdered(e, r);
        }, LayerVisible(e) {
          return !!e && e.IsVisible();
        }, LayerInteractive(e) {
          return !!e && e.IsSelfAndParentsInteractive();
        }, LayerIsHTML(e) {
          return !!e && e.IsHTMLElementsLayer();
        }, LayerEmpty(e) {
          return !!e && !e.GetInstanceCount();
        }, LayerCmpOpacity(e, t, r) {
          return !!e && h1.compare(100 * e.GetOpacity(), t, r);
        }, LayerNameExists(e) {
          const t = this._runtime.GetMainRunningLayout();
          return !!t && t.HasLayerByName(e);
        }, OnImageLoadingComplete() {
          return true;
        }, IsLoadingImages() {
          return 0 < this._imagesLoadingTotal;
        }, TemplateExists(e, t) {
          const r = this._runtime.GetTemplateManager();
          return !!r && !!t && !!r.GetTemplateData(e, t);
        } };
      }
      {
        let SortZOrderList2 = function(e, t) {
          const r = e[0], n = t[0], a = r - n;
          if (0 != a) return a;
          const i = e[1], s = t[1];
          return i - s;
        }, SortInstancesByValue2 = function(e, t) {
          return e[1] - t[1];
        };
        SortZOrderList = SortZOrderList2, SortInstancesByValue = SortInstancesByValue2;
        const M2 = self.C3;
        const N2 = [], O2 = [], P2 = M2.New(M2.Rect), Q2 = M2.New(M2.Color), R2 = [];
        M2.Plugins.System.Acts = { SetVar(e, t) {
          e.SetValue(t);
        }, AddVar(e, t) {
          e.IsNumber() && "number" != typeof t && (t = parseFloat(t)), e.SetValue(e.GetValue() + t);
        }, SubVar(e, t) {
          e.IsNumber() && e.SetValue(e.GetValue() - t);
        }, SetBoolVar(e, t) {
          e.SetValue(!!t);
        }, ToggleBoolVar(e) {
          e.SetValue(!e.GetValue());
        }, ResetEventVar(e) {
          e.SetValue(e.GetInitialValue());
        }, ResetGlobals(e) {
          this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);
        }, CreateObject(e, t, r, n, a, i) {
          if (e && t) {
            const s = this._runtime.CreateInstance(e, t, r, n, a, i);
            if (s) {
              a && t.SortAndAddInstancesByZIndex(s);
              const o = this._runtime.GetEventSheetManager(), u = (o.BlockFlushingInstances(true), s._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false), /* @__PURE__ */ new Map());
              s.CollectInstancesToPick(u, e, a);
              for (const [l, c] of u) l.GetCurrentSol().SetSetPicked(c);
            }
          }
        }, CreateObjectByName(e, t, r, n, a, i) {
          if (e && t) {
            const s = this._runtime.GetObjectClassByName(e);
            s && M2.Plugins.System.Acts.CreateObject.call(this, s, t, r, n, a, i);
          }
        }, RecreateInitialObjects(n, a, i, s, o, e, u, l, c, h, g) {
          if (n) {
            const S = this._runtime.GetCurrentLayout();
            let t = S;
            if (e) {
              const d = this._runtime.GetLayoutManager().GetLayoutByName(e);
              if (!d) return;
              t = d;
            }
            let r = null;
            if (!("number" != typeof u || 0 <= u) || (r = t.GetLayer(u))) {
              let e2 = null;
              if (!("number" != typeof l || 0 <= l) || (e2 = S.GetLayer(l))) {
                P2.set(a, i, s, o);
                const p = t.RecreateInitialObjects(n, P2, r, e2, c, h, g);
                n.GetCurrentSol().SetArrayPicked(p), n.ApplySolToContainer();
              }
            }
          }
        }, StopLoop() {
          const e = this._loopStack;
          e.IsInLoop() && e.GetCurrent().Stop();
        }, SetGroupActive(e, t) {
          const r = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
          r && (0 === t ? r.SetGroupActive(false) : 1 === t ? r.SetGroupActive(true) : r.SetGroupActive(!r.IsGroupActive()));
        }, SetTimescale(e) {
          this._runtime.SetTimeScale(e);
        }, SetObjectTimescale(e, t) {
          if (t < 0 && (t = 0), e) {
            const r = e.GetCurrentSol(), n = r.GetInstances();
            for (const a of n) a.SetTimeScale(t);
          }
        }, RestoreObjectTimescale(e) {
          if (e) {
            const t = e.GetCurrentSol(), r = t.GetInstances();
            for (const n of r) n.RestoreTimeScale();
          }
        }, Wait(e) {
          if (!(e < 0)) return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(e), true;
        }, WaitForSignal(e) {
          return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;
        }, WaitForPreviousActions() {
          const e = this._runtime.GetEventSheetManager();
          return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;
        }, Signal(e) {
          this._runtime.GetEventSheetManager().Signal(e);
        }, async SnapshotCanvas(e, t, r, n, a, i) {
          const s = this._runtime.GetCanvasManager();
          s && (this.UpdateRender(), await s.SnapshotCanvas(0 === e ? "image/png" : "image/jpeg", t / 100, r, n, a, i), await this._runtime.TriggerAsync(M2.Plugins.System.Cnds.OnCanvasSnapshot, null));
        }, SetCanvasSize(e, t) {
          if (!(e <= 0 || t <= 0)) {
            this._runtime.SetViewportSize(e, t), this._runtime.GetCurrentLayout().BoundScrolling();
            const r = this._runtime.GetCanvasManager();
            r && ("off" !== r.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(e, t), r.SetSize(r.GetLastWidth(), r.GetLastHeight(), true), this._runtime.UpdateRender());
          }
        }, SetFullscreenQuality(e) {
          const t = this._runtime.GetCanvasManager();
          t && "off" !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 !== e ? "high" : "low"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), true));
        }, SaveState(e) {
          this._runtime.SaveToSlot(e);
        }, SaveStateJSON() {
          this._runtime.SaveToJsonString();
        }, LoadState(e) {
          this._runtime.LoadFromSlot(e);
        }, LoadStateJSON(e) {
          this._runtime.LoadFromJsonString(e);
        }, SetHalfFramerateMode(e) {
        }, ResetPersisted() {
          for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();
        }, SetPixelRounding(e) {
          this._runtime.SetPixelRoundingEnabled(0 !== e);
        }, SetFramerateMinMax(e, t) {
          this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t);
        }, SetDeltaTimeMinMax(e, t) {
          this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t);
        }, SetFramerateMode(e) {
          this._runtime._SetFramerateMode(["vsync", "unlimited-tick", "unlimited-frame"][e]);
        }, SortZOrderByInstVar(e, r) {
          if (e) {
            const t = e.GetCurrentSol(), n = t.GetInstances(), a = N2, i = O2, s = this._runtime.GetCurrentLayout(), o = e.IsFamily(), u = e.GetFamilyIndex();
            for (let e2 = 0, t2 = n.length; e2 < t2; ++e2) {
              const l = n[e2], c = l.GetWorldInfo();
              if (c) {
                let e3;
                e3 = o ? l.GetInstanceVariableValue(r + l.GetObjectClass().GetFamilyInstanceVariableOffset(u)) : l.GetInstanceVariableValue(r), a.push([c.GetLayer().GetIndex(), c.GetZIndex()]), i.push([l, e3]);
              }
            }
            if (a.length) {
              a.sort(SortZOrderList2), i.sort(SortInstancesByValue2);
              let r2 = false;
              for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) {
                const h = i[e2][0], g = s.GetLayerByIndex(a[e2][0]), S = a[e2][1], d = g._GetInstances();
                d[S] !== h && ((d[S] = h).GetWorldInfo()._SetLayer(g, true), g.SetZIndicesChanged(h), r2 = true);
              }
              r2 && this._runtime.UpdateRender(), M2.clearArray(N2), M2.clearArray(O2);
            }
          }
        }, SetCollisionCellSize(e, t) {
          e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0 || !Number.isFinite(e) || !Number.isFinite(t) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t);
        }, GoToLayout(e) {
          if (!this._runtime.IsLoading()) {
            const t = this._runtime.GetLayoutManager();
            t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e);
          }
        }, GoToLayoutByName(e) {
          if (!this._runtime.IsLoading()) {
            const t = this._runtime.GetLayoutManager();
            if (!t.IsPendingChangeMainLayout()) {
              const r = t.GetLayoutByName(e);
              r && t.ChangeMainLayout(r);
            }
          }
        }, NextPrevLayout(e) {
          if (!this._runtime.IsLoading()) {
            const t = this._runtime.GetLayoutManager();
            if (!t.IsPendingChangeMainLayout()) {
              const r = t.GetAllLayouts(), n = r.indexOf(t.GetMainRunningLayout());
              if ((!e || 0 !== n) && (e || n !== r.length - 1)) {
                const a = r[n + (e ? -1 : 1)];
                t.ChangeMainLayout(a);
              }
            }
          }
        }, RestartLayout() {
          if (!this._runtime.IsLoading()) {
            const e = this._runtime.GetLayoutManager();
            e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());
          }
        }, SetLayerVisible(e, t) {
          e && e.SetVisible(t);
        }, SetLayerInteractive(e, t) {
          e && e.SetInteractive(t);
        }, SetLayerHTML(e, t) {
          e && e.SetIsHTMLElementsLayer(t);
        }, SetLayerOpacity(e, t) {
          e && e.SetOpacity(t / 100);
        }, SetLayerScale(e, t) {
          e && e.SetOwnScale(t);
        }, SetLayerScaleRate(e, t) {
          e && e.SetScaleRate(t);
        }, SetLayerAngle(e, t) {
          e && e.SetAngle(M2.toRadians(+t));
        }, SetLayerScroll(e, t, r) {
          e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t), e.SetScrollY(r));
        }, RestoreLayerScroll(e) {
          e && e.SetOwnScrollPositionEnabled(false);
        }, SetLayerParallax(e, t, r) {
          e && e.SetParallax(t / 100, r / 100);
        }, SetLayerZElevation(e, t) {
          e && e.SetZElevation(+t);
        }, SetLayerBackground(e, t) {
          if (e) {
            Q2.setFromRgbValue(t), Q2.clamp();
            const r = e.GetBackgroundColor();
            r.equalsIgnoringAlpha(Q2) || (r.copyRgb(Q2), this.UpdateRender());
          }
        }, SetLayerTransparent(e, t) {
          e && e.SetTransparent(t);
        }, SetLayerBlendMode(e, t) {
          e && e.SetBlendMode(t);
        }, SetLayerEffectEnabled(e, t, r) {
          if (e) {
            const n = e.GetEffectList(), a = n.GetEffectTypeByName(r);
            if (a) {
              const i = 1 === t;
              a.IsActive() !== i && (a.SetActive(i), e.UpdateActiveEffects(), this._runtime.UpdateRender());
            }
          }
        }, SetLayerEffectParam(e, t, r, n) {
          if (e) {
            const a = e.GetEffectList(), i = a.GetEffectTypeByName(t);
            if (i) {
              r = Math.floor(r);
              const s = i.GetShaderProgram().GetParameterType(r);
              if (s) {
                "color" === s ? (Q2.setFromRgbValue(n), n = Q2) : "percent" === s && (n /= 100);
                const o = a.SetEffectParameter(i.GetIndex(), r, n);
                o && i.IsActive() && this._runtime.UpdateRender();
              }
            }
          }
        }, SetLayerForceOwnTexture(e, t) {
          e && e.SetForceOwnTexture(t);
        }, SetLayoutScale(e) {
          this._runtime.GetCurrentLayout().SetScale(+e);
        }, SetLayoutAngle(e) {
          this._runtime.GetCurrentLayout().SetAngle(M2.toRadians(+e));
        }, SetLayoutEffectEnabled(e, t) {
          const r = this._runtime.GetCurrentLayout(), n = r.GetEffectList(), a = n.GetEffectTypeByName(t);
          if (a) {
            const i = 1 === e;
            a.IsActive() !== i && (a.SetActive(i), r.UpdateActiveEffects(), this._runtime.UpdateRender());
          }
        }, SetLayoutEffectParam(e, t, r) {
          const n = this._runtime.GetCurrentLayout(), a = n.GetEffectList(), i = a.GetEffectTypeByName(e);
          if (i) {
            t = Math.floor(t);
            const s = i.GetShaderProgram().GetParameterType(t);
            if (s) {
              "color" === s ? (Q2.setFromRgbValue(r), r = Q2) : "percent" === s && (r /= 100);
              const o = a.SetEffectParameter(i.GetIndex(), t, r);
              o && i.IsActive() && this._runtime.UpdateRender();
            }
          }
        }, SetLayoutVanishingPoint(e, t) {
          const r = this._runtime.GetCurrentLayout();
          r.SetVanishingPointXY(e / 100, t / 100);
        }, SetLayoutProjection(e) {
          const t = this._runtime.GetCurrentLayout();
          0 === e ? t.SetPerspectiveProjection() : t.SetOrthographicProjection();
        }, ScrollX(e) {
          const t = this._runtime.GetCurrentLayout();
          t.SetScrollX(e);
        }, ScrollY(e) {
          const t = this._runtime.GetCurrentLayout();
          t.SetScrollY(e);
        }, Scroll(e, t) {
          const r = this._runtime.GetCurrentLayout();
          r.SetScrollX(e), r.SetScrollY(t);
        }, ScrollToObject(e) {
          if (e) {
            const t = e.GetFirstPicked();
            if (t) {
              const r = t.GetWorldInfo();
              if (r) {
                const n = this._runtime.GetCurrentLayout();
                n.SetScrollX(r.GetX()), n.SetScrollY(r.GetY());
              }
            }
          }
        }, AddLayer(e, t, r) {
          const n = this._runtime.GetCurrentLayout();
          try {
            n.AddLayer(e, t, r);
          } catch (e2) {
            console.warn("[Construct] Cannot add layer: ", e2);
          }
        }, MoveLayer(e, t, r) {
          if (e) {
            const n = this._runtime.GetCurrentLayout();
            try {
              n.MoveLayer(e, t, r);
            } catch (e2) {
              console.warn("[Construct] Cannot move layer: ", e2);
            }
          }
        }, RemoveLayer(e) {
          if (e) {
            const t = this._runtime.GetCurrentLayout();
            t.RemoveLayer(e);
          }
        }, RemoveAllDynamicLayers() {
          this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();
        }, async LoadObjectTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          if (t && e && !this._runtime.IsLoading()) {
            const r = e.IsFamily() ? e.GetFamilyMembers() : [e];
            await this._LoadTexturesForObjectClasses(t, r);
          }
        }, async LoadObjectTexturesByName(e) {
          await M2.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
        }, UnloadObjectTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          if (t && e) {
            const r = e.IsFamily() ? e.GetFamilyMembers() : [e];
            this._UnloadTexturesForObjectClasses(t, r);
          }
        }, UnloadObjectTexturesByName(e) {
          M2.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
        }, UnloadUnusedTextures() {
          const e = this._runtime.GetMainRunningLayout();
          if (e) {
            const t = e._GetTextureLoadedObjectTypes();
            this._UnloadTexturesForObjectClasses(e, t);
          }
        }, async LoadLayoutTextures(e) {
          const t = this._runtime.GetMainRunningLayout();
          e && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses());
        }, async LoadLayoutTexturesByName(e) {
          const t = this._runtime.GetMainRunningLayout(), r = this._runtime.GetLayoutManager().GetLayoutByName(e);
          r && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, r._GetInitialObjectClasses());
        }, SetFunctionReturnValue(e) {
          const t = this._eventStack.GetCurrentExpFuncStackFrame();
          if (t) switch (t.GetFunctionReturnType()) {
            case 1:
              "number" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 2:
              "string" == typeof e && t.SetFunctionReturnValue(e);
              break;
            case 3:
              t.SetFunctionReturnValue(e);
          }
        }, MapFunction(e, t, r) {
          const n = this._GetFunctionMap(e.toLowerCase(), true), a = n.strMap, i = t.toLowerCase(), s = (a.has(i) && console.warn(`[Construct] Function map '${e}' string '${t}' already in map; overwriting entry`), M2.first(a.values()) || n.defaultFunc);
          if (s) {
            const o = 0 !== s.GetReturnType(), u = 0 !== r.GetReturnType();
            if (o != u) return void console.error(`[Construct] Function map '${e}' string '${t}' function return type not compatible with other functions in the map; entry ignored`);
          }
          a.set(i, r);
        }, MapFunctionDefault(e, t) {
          const r = this._GetFunctionMap(e.toLowerCase(), true), n = (r.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`), M2.first(r.strMap.values()) || r.defaultFunc);
          if (n) {
            const a = 0 !== n.GetReturnType(), i = 0 !== t.GetReturnType();
            if (a != i) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);
          }
          r.defaultFunc = t;
        }, CallMappedFunction(e, t, r) {
          const n = this._runtime, a = n.IsDebugging() ? R2 : null, i = (r = Math.floor(r), this._GetFunctionMap(e.toLowerCase(), false));
          if (!i) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a;
          let s = i.strMap.get(t.toLowerCase());
          if (!s) {
            if (!i.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`), a;
            s = i.defaultFunc, r = 0;
          }
          if (!s.IsEnabled()) return a;
          if (0 !== s.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`), a;
          const o = n.GetEventSheetManager(), u = o.GetCurrentEvent(), l = u.GetSolModifiersIncludingParents(), c = 0 < l.length, h = (c && (s.IsCopyPicked() ? o.PushCopySol(l) : o.PushCleanSol(l)), []), g = o.FindFirstFunctionBlockParent(u);
          if (g) {
            const d = g.GetFunctionParameters();
            for (let e2 = r, t2 = d.length; e2 < t2; ++e2) h.push(d[e2].GetValue());
          }
          const S = s.GetFunctionParameters();
          for (let e2 = h.length, t2 = S.length; e2 < t2; ++e2) h.push(S[e2].GetInitialValue());
          return n.IsDebugging() ? this._DebugDoCallMappedFunction(o, s, h, c, l) : this._DoCallMappedFunction(o, s, h, c, l);
        } };
      }
      {
        const Vf = self.C3;
        Vf.Plugins.System.Exps = { int: function(e) {
          return "string" == typeof e && (e = parseInt(e, 10), isNaN(e)) && (e = 0), Math.floor(e);
        }, float: function(e) {
          return e = "string" == typeof e && (e = parseFloat(e), isNaN(e)) ? 0 : e;
        }, str(e) {
          return e.toString();
        }, len(e) {
          return "string" == typeof e ? e.length : 0;
        }, random(e, t) {
          return void 0 === t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e;
        }, choose(...e) {
          const t = Math.floor(this._runtime.Random() * e.length);
          return e[t];
        }, chooseindex(e, ...t) {
          return "number" != typeof e && (e = 0), t[e = Vf.clamp(Math.floor(e), 0, t.length - 1)];
        }, pi() {
          return Math.PI;
        }, infinity() {
          return 1 / 0;
        }, sqrt(e) {
          return Math.sqrt(e);
        }, abs(e) {
          return Math.abs(e);
        }, round(e) {
          return Math.round(e);
        }, roundtodp(e, t) {
          t = Math.max(Math.floor(t), 0);
          const r = Math.pow(10, t);
          return Math.round((e + Number.EPSILON) * r) / r;
        }, floor(e) {
          return Math.floor(e);
        }, ceil(e) {
          return Math.ceil(e);
        }, sign(e) {
          return Math.sign(e);
        }, sin(e) {
          return Math.sin(Vf.toRadians(e));
        }, cos(e) {
          return Math.cos(Vf.toRadians(e));
        }, tan(e) {
          return Math.tan(Vf.toRadians(e));
        }, asin(e) {
          return Vf.toDegrees(Math.asin(e));
        }, acos(e) {
          return Vf.toDegrees(Math.acos(e));
        }, atan(e) {
          return Vf.toDegrees(Math.atan(e));
        }, exp(e) {
          return Math.exp(e);
        }, ln(e) {
          return Math.log(e);
        }, log10(e) {
          return Math.log10(e);
        }, max(...r) {
          let n = r[0];
          "number" != typeof n && (n = 0);
          for (let t = 1, e = r.length; t < e; ++t) {
            let e2 = r[t];
            "number" == typeof e2 && n < e2 && (n = e2);
          }
          return n;
        }, min(...r) {
          let n = r[0];
          "number" != typeof n && (n = 0);
          for (let t = 1, e = r.length; t < e; ++t) {
            let e2 = r[t];
            "number" == typeof e2 && n > e2 && (n = e2);
          }
          return n;
        }, clamp(e, t, r) {
          return Vf.clamp(e, t, r);
        }, distance(e, t, r, n) {
          return Vf.distanceTo(e, t, r, n);
        }, angle(e, t, r, n) {
          return Vf.toDegrees(Vf.angleTo(e, t, r, n));
        }, lerp(e, t, r) {
          return Vf.lerp(e, t, r);
        }, unlerp(e, t, r) {
          return Vf.unlerp(e, t, r);
        }, qarp(e, t, r, n) {
          return Vf.qarp(e, t, r, n);
        }, cubic(e, t, r, n, a) {
          return Vf.cubic(e, t, r, n, a);
        }, cosp(e, t, r) {
          return Vf.cosp(e, t, r);
        }, anglediff(e, t) {
          return Vf.toDegrees(Vf.angleDiff(Vf.toRadians(e), Vf.toRadians(t)));
        }, anglelerp(e, t, r) {
          return Vf.toDegrees(Vf.angleLerp(Vf.toRadians(e), Vf.toRadians(t), r));
        }, anglerotate(e, t, r) {
          return Vf.toDegrees(Vf.angleRotate(Vf.toRadians(e), Vf.toRadians(t), Vf.toRadians(r)));
        }, setbit(e, t, r) {
          return (e |= 0) & ~(1 << (t |= 0)) | (r = 0 !== r ? 1 : 0) << t;
        }, togglebit(e, t) {
          return (e |= 0) ^ 1 << (t |= 0);
        }, getbit(e, t) {
          return (e |= 0) & 1 << (t |= 0) ? 1 : 0;
        }, newline() {
          return "\n";
        }, uppercase(e) {
          return "string" == typeof e ? e.toUpperCase() : "";
        }, lowercase(e) {
          return "string" == typeof e ? e.toLowerCase() : "";
        }, left(e, t) {
          return "string" == typeof e ? e.substr(0, t) : "";
        }, mid(e, t, r) {
          return "string" != typeof e ? "" : r < 0 ? e.substr(t) : e.substr(t, r);
        }, right(e, t) {
          return "string" == typeof e ? e.substr(Math.max(e.length - t, 0)) : "";
        }, trim(e) {
          return "string" == typeof e ? e.trim() : "";
        }, tokenat(e, t, r) {
          if ("string" != typeof e || "string" != typeof r) return "";
          let n = e.split(r);
          return (t = Math.floor(t)) < 0 || t >= n.length ? "" : n[t];
        }, tokencount(e, t) {
          return "string" == typeof e && "string" == typeof t && e.length ? e.split(t).length : 0;
        }, find(e, t) {
          return "string" == typeof e && "string" == typeof t ? e.search(new RegExp(Vf.EscapeRegex(t), "i")) : -1;
        }, findcase(e, t) {
          return "string" == typeof e && "string" == typeof t ? e.search(new RegExp(Vf.EscapeRegex(t), "")) : -1;
        }, replace(e, t, r) {
          return "string" == typeof e && "string" == typeof t && "string" == typeof r ? e.replace(new RegExp(Vf.EscapeRegex(t), "gi"), r) : "string" == typeof e ? e : "";
        }, stringsub(e, ...r) {
          let n = e;
          for (let e2 = 0, t = r.length; e2 < t; ++e2) n = n.replaceAll(`{${e2}}`, r[e2].toString());
          return n;
        }, regexsearch(e, t, r) {
          const n = this.GetRegex(t, r);
          return e ? e.search(n) : -1;
        }, regexreplace(e, t, r, n) {
          const a = this.GetRegex(t, r);
          return e ? e.replace(a, n) : "";
        }, regexmatchcount(e, t, r) {
          const n = this.GetRegexMatches(e.toString(), t, r);
          return n ? n.length : 0;
        }, regexmatchat(e, t, r, n) {
          n = Math.floor(n);
          const a = this.GetRegexMatches(e.toString(), t, r);
          return !a || n < 0 || n >= a.length ? "" : a[n];
        }, zeropad(e, t) {
          let r = e < 0 ? "-" : "";
          const n = t - (e = e < 0 ? -e : e).toString().length;
          return (r += "0".repeat(Math.max(n, 0))) + e.toString();
        }, urlencode(e) {
          return encodeURIComponent(e);
        }, urldecode(e) {
          return decodeURIComponent(e);
        }, dt() {
          return this._runtime._GetDtFast();
        }, timescale() {
          return this._runtime.GetTimeScale();
        }, wallclocktime() {
          return (Date.now() - this._runtime.GetStartTime()) / 1e3;
        }, unixtime() {
          return Date.now();
        }, time() {
          return this._runtime.GetGameTime();
        }, tickcount() {
          return this._runtime.GetTickCount();
        }, objectcount() {
          return this._runtime.GetObjectCount();
        }, fps() {
          return this._runtime.GetFramesPerSecond();
        }, cpuutilisation() {
          return this._runtime.GetMainThreadTime();
        }, gpuutilisation() {
          return this._runtime.GetGPUUtilisation();
        }, windowwidth() {
          return this._runtime.GetCanvasManager().GetDeviceWidth();
        }, windowheight() {
          return this._runtime.GetCanvasManager().GetDeviceHeight();
        }, originalwindowwidth() {
          return this._runtime.GetOriginalViewportWidth();
        }, originalwindowheight() {
          return this._runtime.GetOriginalViewportHeight();
        }, originalviewportwidth() {
          return this._runtime.GetOriginalViewportWidth();
        }, originalviewportheight() {
          return this._runtime.GetOriginalViewportHeight();
        }, scrollx() {
          return this._runtime.GetCurrentLayout().GetScrollX();
        }, scrolly() {
          return this._runtime.GetCurrentLayout().GetScrollY();
        }, layoutname() {
          return this._runtime.GetCurrentLayout().GetName();
        }, layoutscale() {
          return this._runtime.GetCurrentLayout().GetScale();
        }, layoutangle() {
          return Vf.toDegrees(this._runtime.GetCurrentLayout().GetAngle());
        }, layoutwidth() {
          return this._runtime.GetCurrentLayout().GetWidth();
        }, layoutheight() {
          return this._runtime.GetCurrentLayout().GetHeight();
        }, vanishingpointx() {
          return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();
        }, vanishingpointy() {
          return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();
        }, viewportleft(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getLeft() : 0;
        }, viewporttop(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getTop() : 0;
        }, viewportright(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getRight() : 0;
        }, viewportbottom(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().getBottom() : 0;
        }, viewportwidth(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().width() : 0;
        }, viewportheight(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetViewport3D().height() : 0;
        }, viewportmidx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          if (t) {
            const r = t.GetViewport3D();
            return (r.getLeft() + r.getRight()) / 2;
          }
          return 0;
        }, viewportmidy(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          if (t) {
            const r = t.GetViewport3D();
            return (r.getTop() + r.getBottom()) / 2;
          }
          return 0;
        }, canvastolayerx(e, t, r) {
          const n = this._runtime.GetCurrentLayout().GetLayer(e);
          return n ? n.CanvasCssToLayer(t, r)[0] : 0;
        }, canvastolayery(e, t, r) {
          const n = this._runtime.GetCurrentLayout().GetLayer(e);
          return n ? n.CanvasCssToLayer(t, r)[1] : 0;
        }, layertocanvasx(e, t, r) {
          const n = this._runtime.GetCurrentLayout().GetLayer(e);
          return n ? n.LayerToCanvasCss(t, r)[0] : 0;
        }, layertocanvasy(e, t, r) {
          const n = this._runtime.GetCurrentLayout().GetLayer(e);
          return n ? n.LayerToCanvasCss(t, r)[1] : 0;
        }, layertolayerx(e, t, r, n) {
          const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);
          if (!i || !s || i === s) return r;
          const [o, u] = i.LayerToCanvasCss(r, n);
          return s.CanvasCssToLayer(o, u)[0];
        }, layertolayery(e, t, r, n) {
          const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);
          if (!i || !s || i === s) return n;
          const [o, u] = i.LayerToCanvasCss(r, n);
          return s.CanvasCssToLayer(o, u)[1];
        }, layerscale(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetOwnScale() : 0;
        }, layerangle(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? Vf.toDegrees(t.GetOwnAngle()) : 0;
        }, layeropacity(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetOpacity() : 0;
        }, layerscalerate(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScaleRate() : 0;
        }, layerscrollx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScrollX() : 0;
        }, layerscrolly(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetScrollY() : 0;
        }, layerparallaxx(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetParallaxX() : 0;
        }, layerparallaxy(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? 100 * t.GetParallaxY() : 0;
        }, layerzelevation(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetZElevation() : 0;
        }, layerindex(e) {
          const t = this._runtime.GetCurrentLayout().GetLayer(e);
          return t ? t.GetIndex() : -1;
        }, canvassnapshot() {
          const e = this._runtime.GetCanvasManager();
          return e ? e.GetCanvasSnapshotUrl() : "";
        }, loopindex(e) {
          const t = this._loopStack;
          if (!t.IsInLoop()) return 0;
          if (e) {
            const r = t.FindByName(e);
            return r ? r.GetIndex() : 0;
          }
          return t.GetCurrent().GetIndex();
        }, savestatejson() {
          return this._runtime.GetLastSaveJsonString();
        }, callmapped(e, t, ...r) {
          const n = this._GetFunctionMap(e.toLowerCase(), false);
          if (!n) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;
          let a = n.strMap.get(t.toLowerCase());
          if (!a) {
            if (!n.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; returning 0 (consider setting a default)`), 0;
            a = n.defaultFunc;
          }
          const i = a.GetReturnType(), s = a.GetDefaultReturnValue();
          if (0 === i) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has no return type so cannot be called from an expression; returning 0`), 0;
          if (!a.IsEnabled()) return s;
          const o = this._runtime, u = o.GetEventSheetManager(), l = u.GetCurrentEvent(), c = l.GetSolModifiersIncludingParents(), h = 0 < c.length, g = (h && (a.IsCopyPicked() ? u.PushCopySol(c) : u.PushCleanSol(c)), a.GetFunctionParameters());
          for (let e2 = r.length, t2 = g.length; e2 < t2; ++e2) r.push(g[e2].GetInitialValue());
          const S = a.GetEventBlock(), d = S.RunAsExpressionFunctionCall(S.GetSolModifiersIncludingParents(), a.IsCopyPicked(), i, s, ...r);
          return h && u.PopSol(c), d;
        }, loadingprogress() {
          return this._runtime.GetAssetManager().GetLoadProgress();
        }, imageloadingprogress() {
          return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;
        }, renderer() {
          return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl";
        }, rendererdetail() {
          return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
        }, imagememoryusage() {
          let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
          return Math.round(100 * e / 1048576) / 100;
        }, rgb(e, t, r) {
          return Vf.PackRGB(e, t, r);
        }, rgbex(e, t, r) {
          return Vf.PackRGBEx(e / 100, t / 100, r / 100);
        }, rgba(e, t, r, n) {
          return Vf.PackRGBAEx(e / 100, t / 100, r / 100, n / 100);
        }, rgbex255(e, t, r) {
          return Vf.PackRGBEx(e / 255, t / 255, r / 255);
        }, rgba255(e, t, r, n) {
          return Vf.PackRGBAEx(e / 255, t / 255, r / 255, n / 255);
        }, projectname() {
          return this._runtime.GetProjectName();
        }, projectversion() {
          return this._runtime.GetProjectVersion();
        }, currenteventsheetname() {
          return this._runtime.GetCurrentEvent().GetEventSheet().GetName();
        }, currenteventnumber() {
          return this._runtime.GetCurrentEvent().GetDisplayNumber();
        } };
      }
    }
    var ForEachOrdered_SortInstances;
    var SortZOrderList;
    var SortInstancesByValue;
    {
      {
        const a = self.C3, b = "html-element";
        a.Plugins.HTMLElement = class extends a.SDKDOMPluginBase {
          constructor(t) {
            super(t, b), this.AddElementMessageHandler("initial-content", (t2, e) => t2._OnInitialContent(e)), this.AddElementMessageHandler("click", (t2, e) => t2._OnClick(e)), this.AddElementMessageHandler("animationend", (t2, e) => t2._OnAnimationEnd(e));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const k = self.C3;
        k.Plugins.HTMLElement.Type = class extends k.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const n = self.C3, o = self.C3X, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 9, y = 10, z = 11, A = 12, B = 13, C = 14, D = 15, E = "html-element", F = (n.Plugins.HTMLElement.Instance = class extends n.SDKDOMInstanceBase {
          constructor(e, i) {
            super(e, E), this._tag = "div", this._htmlContent = "", this._textContent = "", this._id = "", this._className = "", this._targetId = "", this._targetClass = "";
            let a = this._cssAnimationName = "", o2 = !(this._initialType = "html"), l = 0, h = false, c = n.New(n.Color), g = false, m = n.New(n.Color), _ = (this._autoFontSize = true, this._autoFontSizeOffset = 0, false), d = "";
            if (i) {
              this._tag = i[p] || "div", a = i[q];
              const S = i[r];
              1 === S ? a = n.New(n.BBString, a, { convertLineBreaks: true }).toHTML() : 2 === S && (this._initialType = "text"), this.GetWorldInfo().SetVisible(i[s]), this._id = i[t], this._className = i[u], o2 = i[v], l = i[w], h = i[x], c.setFromJSON(i[y]), g = i[z], m.setFromJSON(i[A]), this._autoFontSize = i[B], _ = i[C], d = i[D];
            }
            "html" === this._initialType ? this._htmlContent = a : this._textContent = a, this.CreateElement({ "tag": this._tag, "str": a, "type": this._initialType, "id": this._id, "className": this._className, "allow-context-menu": o2, "stop-input-events-mode": l, "css-color": h ? c.getCssRgb() : "", "css-background-color": g ? m.getCssRgb() : "", "allow-text-selection": _, "style-attribute": d });
          }
          Release() {
            super.Release();
          }
          _GetStringContent(t2, e) {
            let s2 = "html";
            return "bbcode" === e ? t2 = n.New(n.BBString, t2, { convertLineBreaks: true }).toHTML() : "text" === e && (s2 = "text"), { contentType: s2, str: t2 };
          }
          async _SetContent(t2, e = "html", n2 = "", s2 = false) {
            const { contentType: i, str: r2 } = this._GetStringContent(t2, e);
            if (!n2) {
              if ("html" === i) {
                if ("html" === this._initialType && this._htmlContent === r2) return;
                this._htmlContent = r2;
              } else if ("text" === i) {
                if ("text" === this._initialType && this._textContent === r2) return;
                this._textContent = r2;
              }
            }
            await this._SendHTMLUpdateMessage("set-content", { "str": r2, "type": i, "selector": n2, "is-all": s2 });
          }
          async _InsertContent(t2, e = "html", n2 = true, s2 = "", i = false) {
            if (t2) {
              const { contentType: r2, str: a } = this._GetStringContent(t2, e);
              await this._SendHTMLUpdateMessage("insert-content", { "str": a, "type": r2, "at-end": n2, "selector": s2, "is-all": i });
            }
          }
          async _RemoveContent(t2, e = false, n2 = false) {
            await this._SendHTMLUpdateMessage("remove-content", { "selector": t2, "is-clear": e, "is-all": n2 });
          }
          async _SetContentClass(t2, e, n2, s2 = false) {
            await this._SendHTMLUpdateMessage("set-content-class", { "mode": t2, "class-array": e, "selector": n2, "is-all": s2 });
          }
          async _SetContentAttribute(t2, e, n2, s2, i = false) {
            await this._SendHTMLUpdateMessage("set-content-attribute", { "mode": t2, "attribute": e, "value": n2, "selector": s2, "is-all": i });
          }
          async _SetContentCSSStyle(t2, e, s2, i = false) {
            await this._SendHTMLUpdateMessage("set-content-css-style", { "prop": n.CSSToCamelCase(t2), "value": e, "selector": s2, "is-all": i });
          }
          async _SendHTMLUpdateMessage(t2, e) {
            const n2 = await this.PostToDOMElementAsync(t2, e);
            n2["isOk"] && (this._htmlContent = n2["html"], this._textContent = n2["text"]);
          }
          async _PositionObjectAtElement(t2, e) {
            const n2 = await this.PostToDOMElementAsync("get-element-box", { "selector": e });
            if (n2["isOk"]) {
              const s2 = this._runtime.GetCanvasManager(), i = n2["left"] - s2.GetCanvasClientX(), r2 = n2["top"] - s2.GetCanvasClientY(), a = n2["right"] - s2.GetCanvasClientX(), o2 = n2["bottom"] - s2.GetCanvasClientY();
              for (const l of t2) {
                const h = l.GetWorldInfo();
                if (h) {
                  const c = h.GetLayer(), [C2, g] = c.CanvasCssToLayer(i, r2, h.GetZElevation()), [m, _] = c.CanvasCssToLayer(a, o2, h.GetZElevation());
                  if (isFinite(C2) && isFinite(g) && isFinite(m) && isFinite(_)) {
                    const d = m - C2, S = _ - g, u2 = h.GetOriginX(), p2 = h.GetOriginY(), I2 = C2 + u2 * d, y2 = g + p2 * S;
                    h.GetX() === I2 && h.GetY() === y2 && h.GetWidth() === d && h.GetHeight() === S || (h.SetXY(I2, y2), h.SetSize(d, S), h.SetBboxChanged());
                  }
                }
              }
            }
          }
          async _CreateSpriteImgElement(t2, e, n2, s2, i) {
            const r2 = t2.GetWorldInfo(), a = t2.GetCurrentImageInfo();
            if (r2 && a) {
              const o2 = await a.ExtractImageToBlobURL(), l = await this.PostToDOMElementAsync("insert-img-element", { "blobUrl": o2, "width": a.GetWidth(), "height": a.GetHeight(), "selector": e, "insertAt": n2, "id": s2, "class": i });
              l["isOk"] && (this._htmlContent = l["html"], this._textContent = l["text"]);
            }
          }
          async _SetElementScrollPosition(t2, e, n2) {
            await this.PostToDOMElementAsync("set-scroll-position", { "selector": t2, "direction": e, "position": n2 });
          }
          GetElementState() {
            return { "html": this._htmlContent };
          }
          _OnInitialContent(t2) {
            this._htmlContent = t2["html"], this._textContent = t2["text"];
          }
          _GetHTMLContent() {
            return this._htmlContent;
          }
          _GetTextContent() {
            return this._textContent;
          }
          async _OnClick(t2) {
            const e = t2["chain"];
            for (const s2 of e) this._targetId = s2["targetId"], this._targetClass = s2["targetClass"], this.DispatchScriptEvent("click", true, { "targetId": this._targetId, "targetClass": this._targetClass }), this._targetId && await this.TriggerAsync(n.Plugins.HTMLElement.Cnds.OnClickedID), this._targetClass && await this.TriggerAsync(n.Plugins.HTMLElement.Cnds.OnClickedClass);
            if (0 < e.length) {
              const i = e[0];
              this._targetId = i["targetId"], this._targetClass = i["targetClass"];
            } else this._targetId = "", this._targetClass = "";
            await this.TriggerAsync(n.Plugins.HTMLElement.Cnds.OnClicked), this._targetId = "", this._targetClass = "";
          }
          async _OnAnimationEnd(t2) {
            this._targetId = t2["targetId"], this._targetClass = t2["targetClass"], this._cssAnimationName = t2["animationName"], this.DispatchScriptEvent("animationend", true, { "targetId": this._targetId, "targetClass": this._targetClass, "animationName": this._cssAnimationName }), await this.TriggerAsync(n.Plugins.HTMLElement.Cnds.OnCSSAnimationEnded), this._targetId = "", this._targetClass = "", this._cssAnimationName = "";
          }
          Draw(t2) {
          }
          SaveToJson() {
            return { "t": this._tag, "h": this._htmlContent, "id": this._id, "c": this._className };
          }
          LoadFromJson(t2) {
            this._tag = t2["t"], this._htmlContent = t2["h"], this._id = t2["id"], this._className = t2["c"], this.UpdateElementState();
          }
          GetPropertyValueByIndex(t2) {
          }
          SetPropertyValueByIndex(t2, e) {
          }
          GetDebuggerProperties() {
            return [];
          }
          GetScriptInterfaceClass() {
            return self.IHTMLElementInstance;
          }
        }, /* @__PURE__ */ new WeakMap()), G = /* @__PURE__ */ new Set(["html", "bbcode", "text"]), H = /* @__PURE__ */ new Set(["add", "toggle", "remove"]), I = /* @__PURE__ */ new Set(["set", "remove"]), J = ["start", "end", "replace"], K = /* @__PURE__ */ new Set(["left", "top"]);
        self.IHTMLElementInstance = class extends self.IDOMInstance {
          constructor() {
            super(), F.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          setContent(t2, e = "html", n2 = "", s2 = false) {
            if (o.RequireString(t2), G.has(e)) return o.RequireString(n2), F.get(this)._SetContent(t2, e, n2, !!s2);
            throw new Error("invalid type");
          }
          insertContent(t2, e = "html", n2 = true, s2 = "", i = false) {
            if (o.RequireString(t2), G.has(e)) return o.RequireString(s2), F.get(this)._InsertContent(t2, e, !!n2, s2, !!i);
            throw new Error("invalid type");
          }
          setContentClass(t2, e, n2, s2 = false) {
            if (H.has(t2)) return "string" == typeof e && (e = e.split(" ")), o.RequireArray(e), o.RequireString(n2), F.get(this)._SetContentClass(t2, e, n2, !!s2);
            throw new Error("invalid mode");
          }
          setContentAttribute(t2, e, n2, s2, i = false) {
            if (I.has(t2)) return o.RequireString(e), n2 = n2.toString(), o.RequireString(s2), F.get(this)._SetContentAttribute(t2, e, n2, s2, !!i);
            throw new Error("invalid type");
          }
          setContentCssStyle(t2, e, n2, s2) {
            return o.RequireString(t2), e = e.toString(), o.RequireString(n2), F.get(this)._SetContentCSSStyle(t2, e, n2, !!s2);
          }
          positionInstanceAtElement(t2, e) {
            o.RequireInstanceOf(t2, self.IWorldInstance), o.RequireString(e);
            const n2 = F.get(this), s2 = n2.GetRuntime(), i = s2._UnwrapIWorldInstance(t2);
            return F.get(this)._PositionObjectAtElement([i], e);
          }
          createSpriteImgElement(t2, e, n2, s2, i) {
            o.RequireInstanceOf(t2, self.ISpriteInstance), o.RequireString(e), o.RequireOptionalString(s2), o.RequireOptionalString(i);
            const r2 = J.indexOf(n2);
            if (r2 < 0) throw new Error("invalid insert position");
            const a = F.get(this), l = a.GetRuntime(), h = l._UnwrapIWorldInstance(t2);
            return F.get(this)._CreateSpriteImgElement(h, e, r2, s2, i);
          }
          setScrollPosition(t2, e, n2) {
            if (o.RequireString("selector"), K.has(e)) return o.RequireNumber(n2), F.get(this)._SetElementScrollPosition(t2, e, n2);
            throw new Error("invalid direction");
          }
          get htmlContent() {
            return F.get(this)._GetHTMLContent();
          }
          set htmlContent(t2) {
            F.get(this)._SetContent(t2, "html", "", false);
          }
          get textContent() {
            return F.get(this)._GetTextContent();
          }
          set textContent(t2) {
            F.get(this)._SetContent(t2, "text", "", false);
          }
        };
      }
      {
        const jb = self.C3;
        jb.Plugins.HTMLElement.Cnds = { OnClicked() {
          return true;
        }, OnClickedID(t) {
          return jb.equalsNoCase(this._targetId, t);
        }, OnClickedClass(t) {
          const e = this._targetClass.toLowerCase().split(" "), n = t.toLowerCase().split(" ");
          return n.every((t2) => e.includes(t2));
        }, OnCSSAnimationEnded(t) {
          return jb.equalsNoCase(this._cssAnimationName, t);
        } };
      }
      {
        const qb = self.C3, rb = ["html", "bbcode", "text"], sb = ["add", "toggle", "remove"], tb = ["set", "remove"];
        qb.Plugins.HTMLElement.Acts = { SetContent(t, e, n, s) {
          return this._SetContent(e, rb[t], n, 0 !== s);
        }, InsertContent(t, e, n, s, i) {
          return this._InsertContent(e, rb[t], 0 !== n, s, 0 !== i);
        }, RemoveContent(t, e, n) {
          return this._RemoveContent(e, 0 !== t, 0 !== n);
        }, SetContentClass(t, e, n, s) {
          return this._SetContentClass(sb[t], e.split(" "), n, 0 !== s);
        }, SetContentAttribute(t, e, n, s, i) {
          return this._SetContentAttribute(tb[t], e, n.toString(), s, 0 !== i);
        }, SetContentCSSStyle(t, e, n, s) {
          return this._SetContentCSSStyle(t, e, n, 0 !== s);
        }, PositionObjectAtElement(t, e) {
          if (t) return this._PositionObjectAtElement(t.GetCurrentSol().GetInstances(), e);
        }, CreateSpriteImgElement(t, e, n, s, i) {
          if (t) {
            const r = t.GetFirstPicked();
            if (r) return this._CreateSpriteImgElement(r, e, n, s, i);
          }
        }, SetScrollPosition(t, e, n) {
          return this._SetElementScrollPosition(t, ["left", "top"][e], n);
        } };
      }
      {
        const c1 = self.C3;
        c1.Plugins.HTMLElement.Exps = { HTMLContent() {
          return this._htmlContent;
        }, TextContent() {
          return this._textContent;
        }, TargetID() {
          return this._targetId;
        }, TargetClass() {
          return this._targetClass;
        }, EscapeHTML(t) {
          return c1.EscapeHTML(t.toString());
        } };
      }
    }
    {
      {
        const C33 = self.C3;
        C33.Plugins.Browser = class BrowserPlugin extends C33.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const C33 = self.C3;
        C33.Plugins.Browser.Type = class BrowserType extends C33.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const C33 = self.C3, DOM_COMPONENT_ID = "browser";
        C33.Plugins.Browser.Instance = class BrowserInstance extends C33.SDKInstanceBase {
          constructor(e, t) {
            super(e, DOM_COMPONENT_ID), this._initLocationStr = "", this._isOnline = false, this._referrer = "", this._docTitle = "", this._isCookieEnabled = false, this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._isConstructArcade = false, this._cssStyleMap = /* @__PURE__ */ new Map(), this._isInstallAvailable = false, this._installResult = "", this._isWarnOnCloseEnabled = false, this.AddDOMMessageHandlers([["online-state", (e2) => this._OnOnlineStateChanged(e2)], ["backbutton", () => this._OnBackButton()], ["sw-message", (e2) => this._OnSWMessage(e2)], ["hashchange", (e2) => this._OnHashChange(e2)], ["install-available", () => this._OnInstallAvailable()], ["app-installed", (e2) => this._OnAppInstalled(e2)]]);
            const n = this.GetRuntime().Dispatcher();
            this._disposables = new C33.CompositeDisposable(C33.Disposable.From(n, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()), C33.Disposable.From(n, "window-resize", () => this._OnWindowResize()), C33.Disposable.From(n, "suspend", () => this._OnSuspend()), C33.Disposable.From(n, "resume", () => this._OnResume())), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", { "exportType": this._runtime.GetExportType() }).then((e2) => {
              this._initLocationStr = e2["location"], this._isOnline = e2["isOnline"], this._referrer = e2["referrer"], this._docTitle = e2["title"], this._isCookieEnabled = e2["isCookieEnabled"], this._screenWidth = e2["screenWidth"], this._screenHeight = e2["screenHeight"], this._windowOuterWidth = e2["windowOuterWidth"], this._windowOuterHeight = e2["windowOuterHeight"], this._isConstructArcade = e2["isConstructArcade"];
            }));
          }
          Release() {
            super.Release();
          }
          _OnAfterFirstLayoutStart() {
            this.PostToDOM("ready-for-sw-messages");
          }
          async _OnOnlineStateChanged(e) {
            const t = !!e["isOnline"];
            this._isOnline !== t && (this._isOnline = t, this._isOnline ? await this.TriggerAsync(C33.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(C33.Plugins.Browser.Cnds.OnOffline));
          }
          async _OnWindowResize() {
            await this.TriggerAsync(C33.Plugins.Browser.Cnds.OnResize);
          }
          _OnSuspend() {
            this.Trigger(C33.Plugins.Browser.Cnds.OnPageHidden);
          }
          _OnResume() {
            this.Trigger(C33.Plugins.Browser.Cnds.OnPageVisible);
          }
          async _OnBackButton() {
            await this.TriggerAsync(C33.Plugins.Browser.Cnds.OnBackButton);
          }
          _OnSWMessage(e) {
            const t = e["type"];
            "downloading-update" === t ? this.Trigger(C33.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === t || "update-pending" === t ? this.Trigger(C33.Plugins.Browser.Cnds.OnUpdateReady) : "offline-ready" === t && this.Trigger(C33.Plugins.Browser.Cnds.OnOfflineReady);
          }
          _OnHashChange(e) {
            this._initLocationStr = e["location"], this.Trigger(C33.Plugins.Browser.Cnds.OnHashChange);
          }
          _OnInstallAvailable() {
            this._isInstallAvailable = true, this.Trigger(C33.Plugins.Browser.Cnds.OnInstallAvailable);
          }
          _OnAppInstalled(e) {
            this._isInstallAvailable = false, this.Trigger(C33.Plugins.Browser.Cnds.OnAppInstalled);
          }
          _IsWarnOnCloseEnabled() {
            return this._isWarnOnCloseEnabled;
          }
          _SetWarnOnCloseEnabled(e) {
            this._isWarnOnCloseEnabled !== (e = !!e) && (this._isWarnOnCloseEnabled = e, this.PostToDOM("set-warn-on-close", { "enabled": e }));
          }
          GetDebuggerProperties() {
            const e = "plugins.browser.debugger";
            return [{ title: "plugins.browser.name", properties: [{ name: e + ".user-agent", value: navigator.userAgent }, { name: e + ".is-online", value: this._isOnline }, { name: e + ".is-fullscreen", value: this._runtime.GetCanvasManager().IsDocumentFullscreen() }] }];
          }
        };
      }
      {
        const C33 = self.C3;
        C33.Plugins.Browser.Cnds = { IsOnline() {
          return this._isOnline;
        }, OnOnline() {
          return true;
        }, OnOffline() {
          return true;
        }, OnResize() {
          return true;
        }, CookiesEnabled() {
          return this._isCookieEnabled;
        }, IsFullscreen() {
          return this._runtime.GetCanvasManager().IsDocumentFullscreen();
        }, OnBackButton() {
          return true;
        }, IsPortraitLandscape(e) {
          const t = this._runtime.GetCanvasManager().GetLastWidth(), n = this._runtime.GetCanvasManager().GetLastHeight(), s = t <= n ? 0 : 1;
          return s === e;
        }, OnUpdateFound() {
          return true;
        }, OnUpdateReady() {
          return true;
        }, OnOfflineReady() {
          return true;
        }, OnHashChange() {
          return true;
        }, OnInstallAvailable() {
          return true;
        }, IsInstallAvailable() {
          return this._isInstallAvailable;
        }, OnInstallResult(e) {
          switch (e) {
            case 0:
              return "accepted" === this._installResult;
            case 1:
              return "dismissed" === this._installResult;
            case 2:
              return "error" === this._installResult;
            case 3:
              return true;
            default:
              return false;
          }
        }, OnAppInstalled() {
          return true;
        }, CompareDisplayMode(e) {
          const t = this._runtime.GetCanvasManager().GetCssDisplayMode();
          switch (e) {
            case 0:
              return "browser" === t;
            case 1:
              return "minimal-ui" === t;
            case 2:
              return "standalone" === t;
            case 3:
              return "fullscreen" === t;
            default:
              return false;
          }
        }, IsWarnOnCloseEnabled() {
          return this._IsWarnOnCloseEnabled();
        }, PageVisible() {
          return !this._runtime.IsSuspended();
        }, OnPageHidden() {
          return true;
        }, OnPageVisible() {
          return true;
        }, HasJava() {
          return false;
        }, IsDownloadingUpdate() {
          return false;
        }, OnMenuButton() {
          return false;
        }, OnSearchButton() {
          return false;
        }, IsMetered() {
          return false;
        }, IsCharging() {
          return true;
        }, SupportsFullscreen() {
          return true;
        } };
      }
      {
        const C3 = self.C3, ORIENTATIONS = ["portrait", "landscape", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
        C3.Plugins.Browser.Acts = { Alert(e) {
          this.PostToDOM("alert", { "message": e.toString() });
        }, Close() {
          this._isConstructArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"));
        }, Focus() {
          this.PostToDOM("set-focus", { "isFocus": true });
        }, Blur() {
          this.PostToDOM("set-focus", { "isFocus": false });
        }, GoBack() {
          this._isConstructArcade || this.PostToDOM("navigate", { "type": "back" });
        }, GoForward() {
          this._isConstructArcade || this.PostToDOM("navigate", { "type": "forward" });
        }, GoHome() {
        }, Reload() {
          this._isConstructArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({ "type": "reload" }) : this.PostToDOM("navigate", { "type": "reload" }));
        }, GoToURL(e, t) {
          this._PostToDOMMaybeSync("navigate", { "type": "url", "url": e, "target": t, "exportType": this._runtime.GetExportType() });
        }, GoToURLWindow(e, t) {
          this._PostToDOMMaybeSync("navigate", { "type": "new-window", "url": e, "tag": t, "exportType": this._runtime.GetExportType() });
        }, RequestFullScreen(e, t) {
          2 <= e && (e += 1), 1 === (e = 6 === e ? 2 : e) && (e = 0);
          const n = C3.CanvasManager._FullscreenModeNumberToString(e);
          this._runtime.GetCanvasManager().SetDocumentFullscreenMode(n), this._PostToDOMMaybeSync("request-fullscreen", { "navUI": t });
        }, CancelFullScreen() {
          this._PostToDOMMaybeSync("exit-fullscreen");
        }, Vibrate(e) {
          const n = e.split(",");
          for (let e2 = 0, t = n.length; e2 < t; ++e2) n[e2] = parseInt(n[e2], 10);
          this._PostToDOMMaybeSync("vibrate", { "pattern": n });
        }, async InvokeDownload(e, t) {
          if (e && t) {
            const n = await this._runtime.GetAssetManager().GetProjectFileUrl(e);
            this._runtime.InvokeDownload(n, t);
          }
        }, InvokeDownloadString(e, t, n) {
          if (n) {
            const s = `data:${t},` + encodeURIComponent(e);
            this._runtime.InvokeDownload(s, n);
          }
        }, ConsoleLog(e, t) {
          t = t.toString(), 0 === e ? console.log(t) : 1 === e ? console.warn(t) : 2 === e && console.error(t);
        }, ConsoleGroup(e) {
          console.group(e);
        }, ConsoleGroupEnd() {
          console.groupEnd();
        }, ExecJs(jsStr) {
          try {
            eval(jsStr);
          } catch (err) {
            console.error("Error executing JavaScript: ", err);
          }
        }, LockOrientation(e) {
          if (!((e = Math.floor(e)) < 0 || e >= ORIENTATIONS.length)) {
            const t = ORIENTATIONS[e];
            this._PostToDOMMaybeSync("lock-orientation", { "orientation": t });
          }
        }, UnlockOrientation() {
          this._PostToDOMMaybeSync("unlock-orientation");
        }, LoadStyleSheet(e) {
          this._runtime.GetAssetManager().LoadStyleSheet(e);
        }, async SetDocumentCSSStyle(e, t, n, s) {
          await this.PostToDOMAsync("set-document-css-style", { "prop": C3.CSSToCamelCase(e), "value": t, "selector": n, "is-all": 0 !== s });
        }, async GetDocumentCSSStyle(e, t, n) {
          const s = await this.PostToDOMAsync("get-document-css-style", { "prop": e, "selector": t });
          s["isOk"] && this._cssStyleMap.set(n.toLowerCase(), s["result"].trim());
        }, SetHash(e) {
          this.PostToDOM("set-hash", { "hash": e });
        }, SetWindowSize(e, t) {
          this.PostToDOM("set-window-size", { "windowWidth": e, "windowHeight": t });
        }, SetWindowPosition(e, t) {
          this.PostToDOM("set-window-position", { "windowX": e, "windowY": t });
        }, async RequestInstall() {
          const e = await this.PostToDOMAsync("request-install");
          this._installResult = e["result"], this.Trigger(C3.Plugins.Browser.Cnds.OnInstallResult);
        }, SetWarnOnClose(e) {
          this._SetWarnOnCloseEnabled(e);
        } };
      }
      {
        const C3 = self.C3;
        C3.Plugins.Browser.Exps = { URL() {
          return this._runtime.IsInWorker() ? this._initLocationStr : location.toString();
        }, Protocol() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).protocol;
        }, Domain() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).hostname;
        }, Port() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).port;
        }, PathName() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).pathname;
        }, Hash() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).hash;
        }, QueryString() {
          return (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).search;
        }, QueryParam(e) {
          const t = (this._runtime.IsInWorker() ? new URL(this._initLocationStr) : location).search, n = RegExp("[?&]" + e + "=([^&]*)").exec(t);
          return n ? decodeURIComponent(n[1].replace(/\+/g, " ")) : "";
        }, Referrer() {
          return this._referrer;
        }, Title() {
          return this._docTitle;
        }, Language() {
          return navigator.language;
        }, Platform() {
          return navigator.platform;
        }, UserAgent() {
          return navigator.userAgent;
        }, ExecJS(jsStr) {
          let result = 0;
          try {
            result = eval(jsStr);
          } catch (err) {
            console.error("Error executing JavaScript: ", err);
          }
          return "number" == typeof result || "string" == typeof result ? result : "boolean" == typeof result && result ? 1 : 0;
        }, CSSStyleValue(e) {
          return this._cssStyleMap.get(e) || "";
        }, Name() {
          return navigator.appName;
        }, Version() {
          return navigator.appVersion;
        }, Product() {
          return navigator.product;
        }, Vendor() {
          return navigator.vendor;
        }, BatteryLevel() {
          return 1;
        }, BatteryTimeLeft() {
          return 1 / 0;
        }, Bandwidth() {
          const e = navigator["connection"];
          return e && (e["downlink"] || e["downlinkMax"] || e["bandwidth"]) || 1 / 0;
        }, ConnectionType() {
          const e = navigator["connection"];
          return e && e["type"] || "unknown";
        }, DevicePixelRatio() {
          return self.devicePixelRatio;
        }, ScreenWidth() {
          return this._screenWidth;
        }, ScreenHeight() {
          return this._screenHeight;
        }, WindowInnerWidth() {
          return this._runtime.GetCanvasManager().GetLastWidth();
        }, WindowInnerHeight() {
          return this._runtime.GetCanvasManager().GetLastHeight();
        }, WindowOuterWidth() {
          return this._windowOuterWidth;
        }, WindowOuterHeight() {
          return this._windowOuterWidth;
        }, DisplayMode() {
          return this._runtime.GetCanvasManager().GetCssDisplayMode();
        }, InstallResult() {
          return this._installResult;
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Sprite = class extends a.SDKPluginBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3, e = self.C3X, f = [], g = (d.Plugins.Sprite.Type = class extends d.SDKTypeBase {
          constructor(t) {
            super(t), this._animations = t.GetAnimations();
          }
          Release() {
            d.clearArray(this._animations), super.Release();
          }
          OnCreate() {
            for (const t of this._animations) t.LoadAllAssets(this._runtime);
          }
          LoadTextures(e2) {
            const n = { sampling: this._runtime.GetSampling() };
            return Promise.all(this._animations.map((t) => t.LoadAllTextures(e2, n)));
          }
          ReleaseTextures() {
            for (const t of this._animations) t.ReleaseAllTextures();
          }
          OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture();
          }
          _UpdateAllCurrentTexture() {
            for (const t of this._objectClass.instancesIncludingPendingCreate()) t.GetSdkInstance()._UpdateCurrentTexture();
          }
          FinishCondition(t) {
            d.Plugins.Sprite.FinishCollisionCondition(this, t);
          }
          BeforeRunAction(t) {
            f.push({ objectClass: null, createHierarchy: false, instances: [] });
          }
          _SpawnPickInstance(t, e2, n) {
            const i = f.at(-1);
            i.objectClass = t, i.createHierarchy = n, i.instances.push(e2);
          }
          AfterRunAction(t) {
            const e2 = f.pop(), n = e2.objectClass, i = e2.createHierarchy;
            if (n) {
              const r = /* @__PURE__ */ new Map();
              for (const a of e2.instances) a.CollectInstancesToPick(r, n, i);
              for (const [s, o] of r) s.GetCurrentSol().SetSetPicked(o);
            }
          }
          _AddAnimation(t) {
            const e2 = this.GetObjectClass().AddAnimation(t), n = this.GetRuntime(), i = e2.GetFrameAt(0);
            return i.GetImageInfo().LoadStaticTexture(n.GetRenderer(), { sampling: n.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;
          }
          _RemoveAnimation(t) {
            for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t);
            this.GetObjectClass().RemoveAnimation(t);
          }
          _AddAnimationFrame(t, e2) {
            const n = this._objectClass.GetAnimationByName(t);
            if (!n) throw new Error(`cannot find animation name '${t}'`);
            let i = n.FrameTagOrIndexToIndex(e2);
            i < 0 && (i += n.GetFrameCount() + 1);
            const r = d.AnimationFrameInfo.CreateDynamic(this.GetRuntime()), a = (n.InsertFrameAt(r, i), this.GetRuntime());
            r.GetImageInfo().LoadStaticTexture(a.GetRenderer(), { sampling: a.GetSampling() }).then(() => this._UpdateAllCurrentTexture());
            for (const s of this._objectClass.instancesIncludingPendingCreate()) s.GetSdkInstance()._OnAnimationFramesChanged();
            return r;
          }
          _RemoveAnimationFrame(t, e2) {
            const n = this._objectClass.GetAnimationByName(t);
            if (!n) throw new Error(`cannot find animation name '${t}'`);
            if (1 === n.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t}'`);
            let i = n.FrameTagOrIndexToIndex(e2);
            i < 0 && (i += n.GetFrameCount()), n.RemoveFrameAt(i);
            for (const r of this._objectClass.instancesIncludingPendingCreate()) r.GetSdkInstance()._OnAnimationFramesChanged();
          }
          GetScriptInterfaceClass() {
            return self.ISpriteObjectType;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.ISpriteObjectType = class extends self.IObjectClass {
          constructor(t) {
            super(t), g.set(this, t.GetSdkType());
          }
          getAnimation(t) {
            e.RequireString(t);
            const n = g.get(this).GetObjectClass().GetAnimationByName(t);
            return n ? n.GetIAnimation() : null;
          }
          getAllAnimations() {
            return g.get(this).GetObjectClass().GetAllAnimations().map((t) => t.GetIAnimation());
          }
          addAnimation(t) {
            return e.RequireString(t), g.get(this)._AddAnimation(t).GetIAnimation();
          }
          removeAnimation(t) {
            e.RequireString(t), g.get(this)._RemoveAnimation(t);
          }
          addAnimationFrame(t, n) {
            if (e.RequireString(t), "number" != typeof n && "string" != typeof n) throw new TypeError("invalid insert location");
            return g.get(this)._AddAnimationFrame(t, n).GetIAnimationFrame();
          }
          removeAnimationFrame(t, n) {
            if (e.RequireString(t), "number" != typeof n && "string" != typeof n) throw new TypeError("invalid insert location");
            g.get(this)._RemoveAnimationFrame(t, n);
          }
        };
      }
      {
        const ea = self.C3, fa = self.C3X, ga = 0, ha = 1, ia = 2, ja = 3, ka = ea.New(ea.Rect), la = ea.New(ea.Quad), ma = ea.New(ea.Vector2), na = 1, oa = 2, pa = 4, qa = (ea.Plugins.Sprite.Instance = class extends ea.SDKWorldInstanceBase {
          constructor(t, e) {
            super(t);
            let n = true, i = "", r = 0, a = true;
            e && (n = !!e[ga], i = e[ha], r = e[ia], a = e[ja]), this._currentAnimation = this._objectClass.GetAnimationByName(i) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = ea.clamp(r, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const s = this._currentAnimationFrame.GetImageInfo(), o = (this._currentTexture = s.GetTexture(), this._currentRcTex = s.GetTexRect(), this._currentQuadTex = s.GetTexQuad(), this.HandleRendererContextLoss(), t.SetFlag(oa, true), t.SetFlag(na, 0 <= this._currentAnimation.GetSpeed()), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = ea.New(ea.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = "", this._changeAnimFrameIndex = -1, this._changeAnimationName = "", this._changeAnimationFrom = 0, this.GetWorldInfo());
            this._bquadRef = o.GetBoundingQuad(), o.SetVisible(n), o.SetCollisionEnabled(a), o.SetOriginX(this._currentAnimationFrame.GetOriginX()), o.SetOriginY(this._currentAnimationFrame.GetOriginY()), o.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), o.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();
          }
          Release() {
            this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();
          }
          GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo();
          }
          IsOriginalSizeKnown() {
            return true;
          }
          OnRendererContextLost() {
            this._currentTexture = null;
          }
          OnRendererContextRestored() {
            this._UpdateCurrentTexture();
          }
          Draw(t) {
            const e = this._currentTexture;
            if (null !== e) {
              t.SetTexture(e);
              const n = this.GetWorldInfo();
              n.HasMesh() ? this._DrawMesh(n, t) : this._DrawStandard(n, t);
            }
          }
          _DrawStandard(t, e) {
            let n = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() && (n = t.PixelRoundQuad(n)), e.Quad4(n, this._currentQuadTex);
          }
          _DrawMesh(e, t) {
            const n = e.GetTransformedMesh();
            if (e.IsMeshChanged()) {
              e.CalculateBbox(ka, la, false);
              let t2 = la;
              this._runtime.IsPixelRoundingEnabled() && (t2 = e.PixelRoundQuad(t2)), n.CalculateTransformedMesh(e.GetSourceMesh(), t2, this._currentQuadTex), e.SetMeshChanged(false);
            }
            n.Draw(t);
          }
          GetAnimationTime() {
            return this._animationTimer.Get();
          }
          IsAnimationPlaying() {
            return this._inst.GetFlag(oa);
          }
          SetAnimationPlaying(t) {
            this._inst.SetFlag(oa, t);
          }
          IsPlayingForwards() {
            return this._inst.GetFlag(na);
          }
          SetPlayingForwards(t) {
            this._inst.SetFlag(na, t);
          }
          IsInAnimationTrigger() {
            return this._inst.GetFlag(pa);
          }
          SetInAnimationTrigger(t) {
            this._inst.SetFlag(pa, t);
          }
          Tick() {
            this._changeAnimationName && this._DoChangeAnimation(), 0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
            const t = this._currentAnimationSpeed;
            if (this.IsAnimationPlaying() && 0 !== t) {
              const e = this._runtime.GetDt(this._inst), n = (this._animationTimer.Add(e), this.GetAnimationTime()), i = this._currentAnimationFrame, r = i.GetDuration() / t;
              if (!(n < this._frameStartTime + r)) {
                const a = this._currentAnimation, s = this._currentAnimationRepeatTo, o = a.GetFrameCount(), m = a.GetRepeatCount(), h = a.IsLooping(), u = a.IsPingPong(), c = (this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += r, this._currentFrameIndex >= o && (u ? (this.SetPlayingForwards(false), this._currentFrameIndex = o - 2) : !h && (this._animationRepeats++, this._animationRepeats >= m) ? this._FinishAnimation(false) : this._currentFrameIndex = s), this._currentFrameIndex < 0 && (u ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), h || (this._animationRepeats++, this._animationRepeats >= m && this._FinishAnimation(true))) : !h && (this._animationRepeats++, this._animationRepeats >= m) ? this._FinishAnimation(true) : this._currentFrameIndex = s), this._currentFrameIndex = ea.clamp(this._currentFrameIndex, 0, o - 1), a.GetFrameAt(this._currentFrameIndex));
                n > this._frameStartTime + c.GetDuration() / t && (this._frameStartTime = n), this._OnFrameChanged(i, c);
              }
            } else this._StopTicking();
          }
          _FinishAnimation(t) {
            this._currentFrameIndex = t ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent("animationend", false, { animationName: this._animTriggerName }), this.Trigger(ea.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(ea.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;
          }
          _OnFrameChanged(n, i, t) {
            if (n !== i) {
              const e = this.GetWorldInfo(), r = n.GetImageInfo(), a = i.GetImageInfo(), s = r.GetWidth(), o = r.GetHeight(), m = a.GetWidth(), h = a.GetHeight(), u = (t && t.onFrameChange ? t.onFrameChange(e, s, o, m, h) : (s !== m && e.SetWidth(e.GetWidth() * (m / s)), o !== h && e.SetHeight(e.GetHeight() * (h / o))), e.SetOriginX(i.GetOriginX()), e.SetOriginY(i.GetOriginY()), e.SetSourceCollisionPoly(i.GetCollisionPoly()), e.SetBboxChanged(), this._currentAnimationFrame = i, this._currentTexture = a.GetTexture(), this._currentRcTex = a.GetTexRect(), this._currentQuadTex = a.GetTexQuad(), this.GetInstance().GetBehaviorInstances());
              for (let t2 = 0, e2 = u.length; t2 < e2; ++t2) u[t2].OnSpriteFrameChanged(n, i);
              this.DispatchScriptEvent("framechange", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(ea.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();
            }
          }
          _StartAnim(t) {
            this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();
          }
          _SetAnim(t, e, n) {
            this._changeAnimationName = t, this._changeAnimationFrom = e, this._StartTicking(), !n && this.IsInAnimationTrigger() || this._DoChangeAnimation();
          }
          _GetCurrentAnimation() {
            return this._currentAnimation;
          }
          _GetCurrentAnimationName() {
            return this._changeAnimationName || this._currentAnimation.GetName();
          }
          _OnAnimationRemoved(t) {
            ea.equalsNoCase(t, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);
          }
          _SetAnimFrame(t) {
            if ("string" == typeof t) if (String(Number(t)) === t) t = Number(t);
            else {
              const e = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
              if (!e) return;
              if (-1 === (t = e.GetFrameIndexByTag(t))) return;
            }
            isFinite(t) && (this._changeAnimFrameIndex = t, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
          }
          _OnAnimationFramesChanged() {
            if (!this._changeAnimationName && -1 === this._changeAnimFrameIndex) {
              const t = this._currentAnimationFrame, e = this._currentAnimation.GetFrameAt(ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
              t !== e && this._OnFrameChanged(t, e), 1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimationSpeed && this._StartTicking();
            }
          }
          _GetAnimFrame() {
            return this._currentFrameIndex;
          }
          _GetAnimFrameTag() {
            return this._currentAnimationFrame.GetTag();
          }
          _SetAnimSpeed(t) {
            this._currentAnimationSpeed = Math.abs(t), this.SetPlayingForwards(0 <= t), 0 < this._currentAnimationSpeed && this._StartTicking();
          }
          _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;
          }
          _SetAnimRepeatToFrame(t) {
            "string" == typeof t && -1 === (t = this._currentAnimation.GetFrameIndexByTag(t)) || (t = ea.clamp(Math.floor(t), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = t);
          }
          _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo;
          }
          _DoChangeAnimation(t) {
            const e = this._currentAnimationFrame, n = this._objectClass.GetAnimationByName(this._changeAnimationName);
            if (this._changeAnimationName = "", n && (n !== this._currentAnimation || !this.IsAnimationPlaying())) {
              this._currentAnimation = n, this.SetPlayingForwards(0 <= n.GetSpeed()), this._currentAnimationSpeed = Math.abs(n.GetSpeed()), this._currentAnimationRepeatTo = n.GetRepeatTo(), this._currentFrameIndex = ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();
              const i = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
              this._OnFrameChanged(e, i, t);
            }
          }
          _DoChangeAnimFrame(t) {
            const e = this._currentAnimationFrame, n = this._currentFrameIndex;
            if (this._currentFrameIndex = ea.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, t || n !== this._currentFrameIndex) {
              const i = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
              this._OnFrameChanged(e, i), this._frameStartTime = this.GetAnimationTime();
            }
          }
          _UpdateCurrentTexture() {
            const t = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = t.GetTexture(), this._currentRcTex = t.GetTexRect(), this._currentQuadTex = t.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);
          }
          GetTexture() {
            return this._currentTexture;
          }
          GetTexRect() {
            return this._currentRcTex;
          }
          GetTexQuad() {
            return this._currentQuadTex;
          }
          GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount();
          }
          GetImagePoint(t) {
            const e = this._currentAnimationFrame, n = this.GetWorldInfo();
            let i = null;
            if ("string" == typeof t) i = e.GetImagePointByName(t);
            else {
              if ("number" != typeof t) throw new TypeError("expected string or number");
              i = e.GetImagePointByIndex(t - 1);
            }
            let r = n.GetTotalZElevation();
            if (!i) return [n.GetX(), n.GetY(), r];
            if (ma.copy(i.GetVec2()), n.HasMesh()) {
              const [a, s, o] = n.GetSourceMesh().TransformPoint(ma.getX(), ma.getY());
              ma.set(a, s), r += o;
            }
            return ma.offset(-e.GetOriginX(), -e.GetOriginY()), ma.scale(n.GetWidth(), n.GetHeight()), ma.rotate(n.GetAngle()), ma.offset(n.GetX(), n.GetY()), [ma.getX(), ma.getY(), r];
          }
          GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();
          }
          GetCollisionPolyPoint(t) {
            t = Math.floor(t);
            const e = this.GetWorldInfo(), n = e.GetTransformedCollisionPoly(), i = n.pointCount();
            if ((t = t === i ? 0 : t) < 0 || i <= t) return [0, 0];
            const r = n.pointsArr();
            return [r[2 * t + 0] + e.GetX(), r[2 * t + 1] + e.GetY()];
          }
          GetDebuggerProperties() {
            const e = ea.Plugins.Sprite.Acts, t = "plugins.sprite.debugger.animation-properties";
            return [{ title: t + ".title", properties: [{ name: t + ".current-animation", value: this._currentAnimation.GetName(), onedit: (t2) => this.CallAction(e.SetAnim, t2, 0) }, { name: t + ".current-frame", value: this._currentFrameIndex, onedit: (t2) => this.CallAction(e.SetAnimFrame, t2) }, { name: t + ".is-playing", value: this.IsAnimationPlaying(), onedit: (t2) => t2 ? this.CallAction(e.StartAnim, 0) : this.CallAction(e.StopAnim) }, { name: t + ".speed", value: this._currentAnimationSpeed, onedit: (t2) => this.CallAction(e.SetAnimSpeed, t2) }, { name: t + ".repeats", value: this._animationRepeats, onedit: (t2) => this._animationRepeats = t2 }] }];
          }
          SaveToJson() {
            const t = { "a": this._currentAnimation.GetSID() }, e = (0 !== this._frameStartTime && (t["fs"] = this._frameStartTime), this.GetAnimationTime()), n = (0 !== e && (t["at"] = e), 0 !== this._currentFrameIndex && (t["f"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t["cas"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t["ar"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t["rt"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t["ap"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t["af"] = this.IsPlayingForwards()), this.GetWorldInfo());
            return n.IsCollisionEnabled() && (t["ce"] = n.IsCollisionEnabled()), t;
          }
          LoadFromJson(t) {
            const e = this.GetObjectClass().GetAnimationBySID(t["a"]), n = (e && (this._currentAnimation = e), this._frameStartTime = t.hasOwnProperty("fs") ? t["fs"] : 0, this._animationTimer.Set(t.hasOwnProperty("at") ? t["at"] : 0), t.hasOwnProperty("f") ? t["f"] : 0), i = (this._currentFrameIndex = ea.clamp(n, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = t.hasOwnProperty("cas") ? t["cas"] : 0, this._animationRepeats = t.hasOwnProperty("ar") ? t["ar"] : 1, t.hasOwnProperty("rt") ? t["rt"] : 0), r = (this._currentAnimationRepeatTo = ea.clamp(i, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!t.hasOwnProperty("ap") || !!t["ap"]), this.SetPlayingForwards(!t.hasOwnProperty("af") || !!t["af"]), this._currentAnimation.GetFrameAt(this._currentFrameIndex)), a = (this._currentAnimationFrame = r, this._UpdateCurrentTexture(), this.GetWorldInfo());
            a.SetOriginX(r.GetOriginX()), a.SetOriginY(r.GetOriginY()), a.SetSourceCollisionPoly(r.GetCollisionPoly()), a.SetCollisionEnabled(!!t["ce"]), this.IsAnimationPlaying() && this._StartTicking();
          }
          GetPropertyValueByIndex(t) {
            const e = this.GetWorldInfo();
            switch (t) {
              case ja:
                return e.IsCollisionEnabled();
              case ia:
                return ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
              case ha:
                return this._currentAnimation.GetName();
            }
          }
          SetPropertyValueByIndex(t, e, n) {
            const i = this.GetWorldInfo();
            switch (t) {
              case ja:
                i.SetCollisionEnabled(!!e);
                break;
              case ia: {
                this.SetAnimationPlaying(false);
                const r = this._currentAnimation.GetFrameCount() - 1, a = e = ea.clamp(e, 0, r), s = this._currentAnimation.GetFrameAt(this._currentFrameIndex), o = this._currentAnimation.GetFrameAt(a);
                this._OnFrameChanged(s, o, n), this._currentFrameIndex = ea.clamp(a, 0, r);
                break;
              }
              case ha: {
                this._changeAnimationName = e, this._DoChangeAnimation(n);
                const m = this._currentAnimation.GetFrameCount();
                1 < m && 0 < this._currentAnimation.GetSpeed() ? this._StartTicking() : this._StopTicking();
                break;
              }
            }
          }
          GetScriptInterfaceClass() {
            return self.ISpriteInstance;
          }
        }, /* @__PURE__ */ new WeakMap()), ra = /* @__PURE__ */ new Map([["current-frame", 0], ["beginning", 1]]);
        self.ISpriteInstance = class extends self.IWorldInstance {
          constructor() {
            super(), qa.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          getImagePointCount() {
            return qa.get(this).GetImagePointCount();
          }
          getImagePointX(t) {
            return this.getImagePoint(t)[0];
          }
          getImagePointY(t) {
            return this.getImagePoint(t)[1];
          }
          getImagePointZ(t) {
            return this.getImagePoint(t)[2];
          }
          getImagePoint(t) {
            if ("string" != typeof t && "number" != typeof t) throw new TypeError("expected string or number");
            return qa.get(this).GetImagePoint(t);
          }
          getPolyPointCount() {
            return qa.get(this).GetCollisionPolyPointCount();
          }
          getPolyPointX(t) {
            return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t)[0];
          }
          getPolyPointY(t) {
            return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t)[1];
          }
          getPolyPoint(t) {
            return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t);
          }
          stopAnimation() {
            qa.get(this).SetAnimationPlaying(false);
          }
          startAnimation(t = "current-frame") {
            fa.RequireString(t);
            const e = ra.get(t);
            if (void 0 === e) throw new Error("invalid mode");
            qa.get(this)._StartAnim(e);
          }
          setAnimation(t, e = "beginning") {
            fa.RequireString(t), fa.RequireString(e);
            const n = ra.get(e);
            if (void 0 === n) throw new Error("invalid mode");
            const i = qa.get(this);
            if (!i.GetObjectClass().GetAnimationByName(t)) throw new Error(`animation name "${t}" does not exist`);
            i._SetAnim(t, n);
          }
          getAnimation(t) {
            fa.RequireString(t);
            const e = qa.get(this).GetObjectClass().GetAnimationByName(t);
            return e ? e.GetIAnimation() : null;
          }
          get animation() {
            return qa.get(this)._GetCurrentAnimation().GetIAnimation();
          }
          get animationName() {
            return qa.get(this)._GetCurrentAnimationName();
          }
          set animationFrame(t) {
            fa.RequireFiniteNumber(t), qa.get(this)._SetAnimFrame(t);
          }
          get animationFrame() {
            return qa.get(this)._GetAnimFrame();
          }
          set animationFrameTag(t) {
            fa.RequireString(t), qa.get(this)._SetAnimFrame(t);
          }
          get animationFrameTag() {
            return qa.get(this)._GetAnimFrameTag();
          }
          set animationSpeed(t) {
            fa.RequireFiniteNumber(t), qa.get(this)._SetAnimSpeed(t);
          }
          get animationSpeed() {
            return qa.get(this)._GetAnimSpeed();
          }
          set animationRepeatToFrame(t) {
            fa.RequireFiniteNumber(t), qa.get(this)._SetAnimRepeatToFrame(t);
          }
          get animationRepeatToFrame() {
            return qa.get(this)._GetAnimRepeatToFrame();
          }
          get imageWidth() {
            return qa.get(this).GetCurrentImageInfo().GetWidth();
          }
          get imageHeight() {
            return qa.get(this).GetCurrentImageInfo().GetHeight();
          }
          getImageSize() {
            const t = qa.get(this).GetCurrentImageInfo();
            return [t.GetWidth(), t.GetHeight()];
          }
          async replaceCurrentAnimationFrame(t) {
            fa.RequireInstanceOf(t, Blob);
            const e = qa.get(this), n = e.GetRuntime(), i = e.GetCurrentImageInfo(), r = ea.New(ea.ImageInfo);
            if (r.LoadDynamicBlobAsset(n, t), await r.LoadStaticTexture(n.GetRenderer(), { sampling: n.GetSampling() }), e.WasReleased()) r.Release();
            else {
              i.ReplaceWith(r);
              const a = e.GetSdkType();
              a._UpdateAllCurrentTexture(), a.GetObjectClass().Dispatcher().dispatchEvent(new ea.Event("animationframeimagechange")), n.UpdateRender();
            }
          }
          setSolidCollisionFilter(t, e) {
            fa.RequireString(e), qa.get(this).GetWorldInfo().SetSolidCollisionFilter(!!t, e);
          }
        };
      }
      {
        const Vb = self.C3;
        Vb.Plugins.Sprite.Cnds = { IsAnimPlaying(t) {
          return Vb.equalsNoCase(this._GetCurrentAnimationName(), t);
        }, CompareFrame(t, e) {
          return Vb.compare(this._currentFrameIndex, t, e);
        }, CompareFrameTag(t, e) {
          if ("string" != typeof e) return false;
          const n = this._currentAnimationFrame.GetTag();
          return Vb.compare(n.toLowerCase(), t, e.toLowerCase());
        }, CompareAnimSpeed(t, e) {
          return Vb.compare(this._GetAnimSpeed(), t, e);
        }, OnAnimFinished(t) {
          return Vb.equalsNoCase(this._animTriggerName, t);
        }, OnAnyAnimFinished() {
          return true;
        }, OnFrameChanged() {
          return true;
        }, IsMirrored() {
          return this.GetWorldInfo().GetWidth() < 0;
        }, IsFlipped() {
          return this.GetWorldInfo().GetHeight() < 0;
        }, OnURLLoaded() {
          return true;
        }, OnURLFailed() {
          return true;
        }, IsCollisionEnabled() {
          return this.GetWorldInfo().IsCollisionEnabled();
        } };
      }
      {
        const d1 = self.C3;
        d1.Plugins.Sprite.Acts = { Spawn(t, e, n, i, r) {
          if (t && e) {
            const [a, s] = this.GetImagePoint(n), o = this._runtime.CreateInstance(t, e, a, s, i, r);
            if (o) {
              if (i && e.SortAndAddInstancesByZIndex(o), t.GetPlugin().IsRotatable()) {
                const h = o.GetWorldInfo();
                h.SetAngle(this.GetWorldInfo().GetAngle()), h.SetBboxChanged();
              }
              const m = this._runtime.GetEventSheetManager();
              m.BlockFlushingInstances(true), o._TriggerOnCreatedOnSelfAndRelated(), m.BlockFlushingInstances(false), t !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t, o, i);
            }
          }
        }, StopAnim() {
          this.SetAnimationPlaying(false);
        }, StartAnim(t) {
          this._StartAnim(t);
        }, SetAnim(t, e) {
          this._SetAnim(t, e);
        }, SetAnimFrame(t) {
          this._SetAnimFrame(t);
        }, SetAnimSpeed(t) {
          this._SetAnimSpeed(t);
        }, SetAnimRepeatToFrame(t) {
          this._SetAnimRepeatToFrame(t);
        }, AddRemoveAnimation(e, t) {
          try {
            0 === e ? this.GetSdkType()._AddAnimation(t) : this.GetSdkType()._RemoveAnimation(t);
          } catch (t2) {
            console.error(`[Construct] Error ${0 === e ? "adding" : "removing"} animation: `, t2);
          }
        }, AddRemoveAnimationFrame(e, t, n) {
          try {
            0 === e ? this.GetSdkType()._AddAnimationFrame(t, n) : this.GetSdkType()._RemoveAnimationFrame(t, n);
          } catch (t2) {
            console.error(`[Construct] Error ${0 === e ? "adding" : "removing"} animation frame: `, t2);
          }
        }, SetMirrored(t) {
          const e = this.GetWorldInfo(), n = e.GetWidth(), i = Math.abs(n) * (0 === t ? -1 : 1);
          n !== i && (e.SetWidth(i), e.SetBboxChanged());
        }, SetFlipped(t) {
          const e = this.GetWorldInfo(), n = e.GetHeight(), i = Math.abs(n) * (0 === t ? -1 : 1);
          n !== i && (e.SetHeight(i), e.SetBboxChanged());
        }, SetScale(t) {
          const e = this._currentAnimationFrame, n = e.GetImageInfo(), i = this.GetWorldInfo(), r = i.GetWidth() < 0 ? -1 : 1, a = i.GetHeight() < 0 ? -1 : 1, s = n.GetWidth() * t * r, o = n.GetHeight() * t * a;
          i.GetWidth() === s && i.GetHeight() === o || (i.SetSize(s, o), i.SetBboxChanged());
        }, async LoadURL(t, e, n) {
          const i = this._currentAnimationFrame, r = i.GetImageInfo(), a = this.GetWorldInfo(), s = this._runtime, o = this._sdkType;
          if (r.GetURL() === t) 0 === e && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), this.Trigger(d1.Plugins.Sprite.Cnds.OnURLLoaded);
          else {
            const m = d1.New(d1.ImageInfo);
            try {
              if (await m.LoadDynamicAsset(s, t), !m.IsLoaded()) throw new Error("image failed to load");
              if (this.WasReleased()) return void m.Release();
              await m.LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() });
            } catch (t2) {
              return console.error("Load image from URL failed: ", t2), void (this.WasReleased() || this.Trigger(d1.Plugins.Sprite.Cnds.OnURLFailed));
            }
            this.WasReleased() ? m.Release() : (r.ReplaceWith(m), o._UpdateAllCurrentTexture(), o.GetObjectClass().Dispatcher().dispatchEvent(new d1.Event("animationframeimagechange")), s.UpdateRender(), 0 === e && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), await this.TriggerAsync(d1.Plugins.Sprite.Cnds.OnURLLoaded));
          }
        }, SetCollisions(t) {
          this.GetWorldInfo().SetCollisionEnabled(t);
        }, SetSolidCollisionFilter(t, e) {
          this.GetWorldInfo().SetSolidCollisionFilter(0 === t, e);
        }, SetEffect(t) {
          this.GetWorldInfo().SetBlendMode(t), this._runtime.UpdateRender();
        } };
      }
      {
        const dc = self.C3;
        dc.Plugins.Sprite.Exps = { AnimationFrame() {
          return this._GetAnimFrame();
        }, AnimationFrameTag() {
          return this._GetAnimFrameTag();
        }, AnimationFrameCount() {
          return this._currentAnimation.GetFrameCount();
        }, AnimationName() {
          return this._currentAnimation.GetName();
        }, AnimationSpeed() {
          return this._GetAnimSpeed();
        }, OriginalAnimationSpeed() {
          return this._currentAnimation.GetSpeed();
        }, ImagePointX(t) {
          return this.GetImagePoint(t)[0];
        }, ImagePointY(t) {
          return this.GetImagePoint(t)[1];
        }, ImagePointZ(t) {
          return this.GetImagePoint(t)[2];
        }, ImagePointCount() {
          return this.GetImagePointCount();
        }, ImageWidth() {
          return this.GetCurrentImageInfo().GetWidth();
        }, ImageHeight() {
          return this.GetCurrentImageInfo().GetHeight();
        }, PolyPointXAt(t) {
          return this.GetCollisionPolyPoint(t)[0];
        }, PolyPointYAt(t) {
          return this.GetCollisionPolyPoint(t)[1];
        }, PolyPointCount() {
          return this.GetCollisionPolyPointCount();
        } };
      }
    }
    {
      {
        const a = self.C3, b = "user-media";
        a.Plugins.UserMedia = class extends a.SDKDOMPluginBase {
          constructor(e) {
            super(e, b), this._lastStateSequenceNumber = -1, this._videoState = /* @__PURE__ */ new Map(), this.AddElementMessageHandler("video-ready", (e2, t) => e2._OnVideoReady(t)), this._runtime.AddDOMComponentMessageHandler(b, "state", (e2) => this._OnUpdateState(e2));
          }
          Release() {
            super.Release();
          }
          _OnUpdateState(e) {
            const t = e["sequenceNumber"];
            if (!(t <= this._lastStateSequenceNumber)) {
              this._lastStateSequenceNumber = t, this._videoState.clear();
              for (const [i, s] of Object.entries(e["videoData"])) this._videoState.set(parseInt(i, 10), s);
            }
          }
          _DeleteVideoState(e) {
            this._videoState.delete(e);
          }
          GetVideoState(e) {
            return this._videoState.get(e) || null;
          }
        };
      }
      {
        const n = self.C3;
        n.Plugins.UserMedia.Type = class extends n.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const q = self.C3, r = "user-media", s = q.New(q.Rect), t = q.New(q.Quad);
        q.Plugins.UserMedia.Instance = class extends q.SDKDOMInstanceBase {
          constructor(e, t2) {
            super(e, r), this._videoSources = [], this._audioSources = [], this._isRequesting = false, this._isVideoReady = false, this._isVideoActive = false, this._videoWidth = 0, this._videoHeight = 0, this._snapshotUrl = "";
            const i = this._runtime.Dispatcher();
            this._disposables = new q.CompositeDisposable(q.Disposable.From(i, "renderercontextlost", () => this._OnRendererContextLost())), this.CreateElement(), this._StartTicking();
          }
          Release() {
            this.GetPlugin()._DeleteVideoState(this.GetElementId()), this._ReleaseTexture(), super.Release();
          }
          _MaybeCreateTexture(e, t2, i) {
            if (this._webGLTexture) {
              if (this._webGLTexture.GetWidth() === t2 || this._webGLTexture.GetHeight() === i) return;
              this._ReleaseTexture();
            }
            this._webGLTexture = e.CreateDynamicTexture(t2, i, { sampling: this._runtime.GetSampling(), mipMap: false });
          }
          _ReleaseTexture() {
            this._webGLTexture && (this._runtime.GetRenderer().DeleteTexture(this._webGLTexture), this._webGLTexture = null);
          }
          GetElementState() {
            return {};
          }
          _OnRendererContextLost() {
            this._webGLTexture = null;
          }
          _OnVideoReady(e) {
            this._isVideoActive && (this._isVideoReady = true, this._videoWidth = e["width"], this._videoHeight = e["height"]);
          }
          Draw(d) {
            const h = this.GetWorldInfo();
            if (d.SetColorFillMode(), d.SetColorRgba(0, 0, 0, 1), d.Quad(h.GetBoundingQuad()), d.SetTextureFillMode(), d.ResetColor(), this._isVideoActive && this._isVideoReady) {
              let e = 0, i = 0, r2 = null;
              if (this._runtime.IsInWorker()) {
                const S = this.GetMyState();
                if (!S) return;
                const p = S["imageBitmap"];
                if (!p) return;
                e = p.width, i = p.height, r2 = p;
              } else {
                const v = self["C3UserMedia_GetVideoElement"](this.GetElementId());
                if (!v) return;
                if (e = v.videoWidth, i = v.videoHeight, e <= 0 || i <= 0) return;
                r2 = v;
              }
              this._MaybeCreateTexture(d, e, i), d.UpdateTexture(r2, this._webGLTexture);
              const c = e / i, l = h.GetWidth(), g = h.GetHeight(), _ = l / g;
              let n = 0, o = 0, a = 0, u = 0;
              c < _ ? (a = g * c, u = g, n = Math.max(Math.floor((l - a) / 2), 0)) : (a = l, u = l / c, o = Math.max(Math.floor((g - u) / 2), 0)), d.SetTexture(this._webGLTexture), s.setWH(h.GetX() + n, h.GetY() + o, a, u), t.setFromRect(s), d.Quad(t);
            }
          }
          Tick() {
            if (this._isVideoActive && this._isVideoReady) {
              this._runtime.UpdateRender();
              const e = this.GetMyState();
              e && (this._videoWidth = e["width"], this._videoHeight = e["height"]);
            }
          }
          GetMyState() {
            return this.GetPlugin().GetVideoState(this.GetElementId());
          }
        };
      }
      {
        const T = self.C3;
        T.Plugins.UserMedia.Cnds = { OnApproved() {
          return true;
        }, OnDeclined() {
          return true;
        }, OnMediaSources() {
          return true;
        }, OnSnapshot() {
          return true;
        }, SupportsUserMedia() {
          return true;
        }, SupportsSpeechRecognition() {
          return false;
        }, OnSpeechRecognitionStart() {
          return true;
        }, OnSpeechRecognitionEnd() {
          return true;
        }, OnSpeechRecognitionError() {
          return true;
        }, OnSpeechRecognitionResult() {
          return true;
        }, IsRecognisingSpeech() {
          return false;
        }, OnDeviceLight() {
          return true;
        }, SupportsSpeechSynthesis() {
          return false;
        }, IsSpeaking() {
          return false;
        }, OnCanvasRecordingReady() {
          return true;
        }, SupportsCanvasRecording() {
          return false;
        }, IsCanvasRecordFormatSupported() {
          return false;
        } };
      }
      {
        const U = self.C3;
        U.Plugins.UserMedia.Acts = { async RequestCamera(e, t, i, s, r, n) {
          if (!this._isRequesting) {
            this._isRequesting = true, e = Math.floor(e), i = Math.floor(i), s = Math.floor(s);
            const o = { "video": {} };
            if (0 <= e && e < this._videoSources.length) {
              const u = this._videoSources[e]["deviceId"];
              u && (o["video"]["deviceId"] = { "exact": u });
            }
            if (0 < t && (o["video"]["facingMode"] = { "ideal": 1 === t ? "user" : "environment" }), 0 < i && 0 < s && (o["video"]["width"] = i, o["video"]["height"] = s), r && (o["audio"] = {}, 0 <= n) && n < this._audioSources.length) {
              const d = this._audioSources[n]["deviceId"];
              d && (o["audio"]["deviceId"] = { "exact": d });
            }
            const a = await this.PostToDOMElementAsync("request-camera", { "constraints": o });
            this._isRequesting = false, a["ok"] ? (this._isVideoActive = true, this._isVideoReady = false, await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnApproved)) : await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnDeclined);
          }
        }, async RequestMic(e, t) {
          if (!this._isRequesting) {
            this._isRequesting = true;
            const i = { "audio": {} };
            if (0 <= (t = Math.floor(t)) && t < this._audioSources.length) {
              const r = this._audioSources[t]["deviceId"];
              r && (i["audio"]["deviceId"] = { "exact": r });
            }
            const s = await this.PostToDOMElementAsync("request-microphone", { "constraints": i, "tag": e });
            this._isRequesting = false, s["ok"] ? await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnApproved) : await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnDeclined);
          }
        }, Stop() {
          this._isVideoActive = false, this._isVideoReady = false, this._videoWidth = 0, this._videoHeight = 0, this.PostToDOMElement("stop"), this._runtime.UpdateRender();
        }, async Snapshot(e, t) {
          const i = await this.PostToDOMElementAsync("snapshot", { "format": 0 === e ? "image/png" : "image.jpeg", "quality": t / 100 });
          this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = i["snapshotUrl"], await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnSnapshot);
        }, async GetMediaSources() {
          const e = await this.PostToDOMAsync("get-media-sources");
          this._videoSources = e["videoSources"], this._audioSources = e["audioSources"], await this.TriggerAsync(U.Plugins.UserMedia.Cnds.OnMediaSources);
        }, RequestSpeechRecognition(e, t, i) {
        }, StepSpeechRecognition() {
        }, SpeakText(e, t, i, s, r, n) {
        }, StopSpeaking() {
        }, PauseSpeaking() {
        }, ResumeSpeaking() {
        }, StartRecordingCanvas() {
        }, StopRecordingCanvas() {
        } };
      }
      {
        const va = self.C3;
        va.Plugins.UserMedia.Exps = { VideoWidth() {
          return this._videoWidth;
        }, VideoHeight() {
          return this._videoHeight;
        }, SnapshotURL() {
          return this._snapshotUrl;
        }, AudioSourceCount() {
          return this._audioSources.length;
        }, AudioSourceLabelAt(e) {
          return (e = Math.floor(e)) < 0 || e >= this._audioSources.length ? "" : this._audioSources[e]["label"];
        }, CameraSourceCount() {
          return this._videoSources.length;
        }, CameraSourceLabelAt(e) {
          return (e = Math.floor(e)) < 0 || e >= this._videoSources.length ? "" : this._videoSources[e]["label"];
        }, CameraSourceFacingAt(e) {
          return (e = Math.floor(e)) < 0 || e >= this._videoSources.length ? "" : this._videoSources[e]["facing"];
        }, FinalTranscript() {
          return "";
        }, InterimTranscript() {
          return "";
        }, SpeechError() {
          return "";
        }, AmbientLux() {
          return 0;
        }, VoiceCount() {
          return 0;
        }, VoiceNameAt() {
          return "";
        }, VoiceLangAt() {
          return "";
        }, VoiceURIAt() {
          return "";
        }, CanvasRecordingURL() {
          return "";
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Text = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Text.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          LoadTextures(e) {
          }
          ReleaseTextures() {
          }
        };
      }
      {
        const h = self.C3, i = self.C3X, j = [0, 0, 0], k = 0, l = 1, m = 2, n = 3, o = 4, p = 5, q = 6, r = 7, s = 8, t = 9, u = 10, v = 11, w = 12, x = 13, y = 14, z = 15, A = ["left", "center", "right"], B = ["top", "center", "bottom"], C = ["ltr", "rtl"], D = ["word", "cjk", "character"], E = new h.Rect(), F = new h.Quad(), G = new h.Color(), H = h.New(h.Vector2), I = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["iconoffsety", null]]), J = (h.Plugins.Text.Instance = class extends h.SDKWorldInstanceBase {
          constructor(e, i2) {
            if (super(e), this._text = "", this._enableBBcode = true, this._faceName = "Arial", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = false, this._isItalic = false, this._color = h.New(h.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = "word", this._textDirection = 0, this._resolutionMode = "auto", this._fixedScaleFactor = 1, this._iconObjectClass = null, this._htmlString = "", this._isHtmlStringUpToDate = false, this._readAloud = false, this._screenReaderText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = h.New(h.Gfx.RendererText, this._runtime.GetRenderer(), { timeout: 5 }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged(), this._pendingUpdateIconSet = false, i2) {
              this._text = i2[k], this._enableBBcode = !!i2[l], this._faceName = i2[m], this._ptSize = i2[n], this._lineHeightOffset = i2[o], this._isBold = !!i2[p], this._isItalic = !!i2[q], this._horizontalAlign = i2[s], this._verticalAlign = i2[t], this._wrapMode = D[i2[u]], this._textDirection = i2[v], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(i2[w]));
              const a = i2[r];
              this._color.setRgb(a[0], a[1], a[2]), this.GetWorldInfo().SetVisible(i2[x]), this._readAloud = !!i2[z];
            }
            this._UpdateTextSettings(), this._UpdateScreenReaderText();
          }
          Release() {
            this._SetIconObjectClass(null), this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._rendererText.Release(), this._rendererText = null, super.Release();
          }
          _UpdateTextSettings() {
            const e = this._rendererText;
            e.SetText(this._text), e.SetBBCodeEnabled(this._enableBBcode), this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null), e.SetIconSmoothing("nearest" !== this._runtime.GetSampling()), e.SetFontName(this._faceName), e.SetLineHeight(this._lineHeightOffset), e.SetBold(this._isBold), e.SetItalic(this._isItalic), e.SetColor(this._color), e.SetHorizontalAlignment(A[this._horizontalAlign]), e.SetVerticalAlignment(B[this._verticalAlign]), e.SetWordWrapMode(this._wrapMode), e.SetTextDirection(C[this._textDirection]);
          }
          _UpdateTextSize() {
            const e = this.GetWorldInfo(), t2 = (this._rendererText.SetFontSize(this._ptSize), this._rendererText.SetFontSizeScale(e.GetSceneGraphScale()), e.GetLayer());
            let i2;
            "auto" === this._resolutionMode ? i2 = t2.GetResolutionScaleFactorToZ(e.GetTotalZElevation()) : "fixed" === this._resolutionMode && (i2 = this._fixedScaleFactor), e.HasMesh() && i2 !== this._rendererText.GetZoom() && e.SetMeshChanged(true), this._rendererText.SetSize(e.GetWidth(), e.GetHeight(), i2);
          }
          _SetIconObjectClass(e) {
            e && (e.IsFamily() || e.GetPlugin().constructor !== h.Plugins.Sprite) || e !== this._iconObjectClass && (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._iconObjectClass = e, this._iconObjectClass && this._iconObjectClass.Dispatcher().addEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
          }
          _OnIconObjectClassImageChanged() {
            this._runtime.DeleteTextIconSet(this._iconObjectClass), this._runtime.UpdateRender(), this._pendingUpdateIconSet = true;
          }
          _UpdateScreenReaderText() {
            if (this._readAloud) {
              let e = this._text;
              this._enableBBcode && (e = h.BBString.StripAnyTags(e)), this._screenReaderText ? this._screenReaderText.SetText(e) : this._screenReaderText = h.New(h.ScreenReaderText, this._runtime, e);
            } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);
          }
          Draw(e) {
            const t2 = this.GetWorldInfo(), i2 = (this._UpdateTextSize(), this._pendingUpdateIconSet && (this._pendingUpdateIconSet = false, this._rendererText.IsBBCodeEnabled()) && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)), this._rendererText.GetTexture());
            if (i2) {
              const s2 = t2.GetLayer();
              if (0 === t2.GetAngle() && 0 === s2.GetAngle() && 0 === t2.GetTotalZElevation() && !t2.HasMesh() && s2.RendersIn2DMode()) {
                const r2 = t2.GetBoundingQuad(), [n2, a] = s2.LayerToDrawSurface(r2.getTlx(), r2.getTly()), [o2, h2] = s2.LayerToDrawSurface(r2.getBrx(), r2.getBry()), _ = n2 - Math.round(n2), l2 = a - Math.round(a), [c, d] = (E.set(n2, a, o2, h2), E.offset(-_, -l2), F.setFromRect(E), e.GetRenderTargetSize(e.GetRenderTarget()));
                this._runtime.GetCanvasManager().SetDeviceTransform(e, c, d), e.SetTexture(i2), e.Quad3(F, this._rendererText.GetTexRect()), s2._SetTransform(e);
              } else e.SetTexture(i2), t2.HasMesh() ? this._DrawMesh(t2, e) : this._DrawStandard(t2, e);
            }
          }
          _DrawStandard(e, t2) {
            let i2 = e.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (i2 = this._PixelRoundQuad(i2)), t2.Quad3(i2, this._rendererText.GetTexRect());
          }
          _DrawMesh(t2, e) {
            const i2 = t2.GetTransformedMesh();
            if (t2.IsMeshChanged()) {
              t2.CalculateBbox(E, F, false);
              let e2 = F;
              this._runtime.IsPixelRoundingEnabled() && (e2 = this._PixelRoundQuad(e2)), i2.CalculateTransformedMesh(t2.GetSourceMesh(), e2, this._rendererText.GetTexRect()), t2.SetMeshChanged(false);
            }
            i2.Draw(e);
          }
          _PixelRoundQuad(e) {
            const t2 = e.getTlx() - Math.round(e.getTlx()), i2 = e.getTly() - Math.round(e.getTly());
            return 0 == t2 && 0 == i2 ? e : (F.copy(e), F.offset(-t2, -i2), F);
          }
          GetCurrentSurfaceSize() {
            const e = this._rendererText.GetTexture();
            return e ? [e.GetWidth(), e.GetHeight()] : [100, 100];
          }
          GetCurrentTexRect() {
            return this._rendererText.GetTexRect();
          }
          IsCurrentTexRotated() {
            return false;
          }
          SaveToJson() {
            const e = { "t": this._text, "c": this._color.toJSON(), "fn": this._faceName, "ps": this._ptSize };
            return this._enableBBcode && (e["bbc"] = this._enableBBcode), 0 !== this._horizontalAlign && (e["ha"] = this._horizontalAlign), 0 !== this._verticalAlign && (e["va"] = this._verticalAlign), "word" !== this._wrapMode && (e["wr"] = this._wrapMode), 0 !== this._lineHeightOffset && (e["lho"] = this._lineHeightOffset), this._isBold && (e["b"] = this._isBold), this._isItalic && (e["i"] = this._isItalic), -1 !== this._typewriterEndTime && (e["tw"] = { "st": this._typewriterStartTime, "en": this._typewriterEndTime, "l": this._typewriterLength }), this._iconObjectClass && (e["ioc"] = this._iconObjectClass.GetSID()), "fixed" === this._resolutionMode && (e["fs"] = this._fixedScaleFactor), e;
          }
          LoadFromJson(e) {
            if (this._CancelTypewriter(), this._text = e["t"], this._color.setFromJSON(e["c"]), this._faceName = e["fn"], this._ptSize = e["ps"], this._enableBBcode = !!e.hasOwnProperty("bbc") && e["bbc"], this._horizontalAlign = e.hasOwnProperty("ha") ? e["ha"] : 0, this._verticalAlign = e.hasOwnProperty("va") ? e["va"] : 0, e.hasOwnProperty("wr")) {
              const t2 = e["wr"];
              this._wrapMode = "boolean" == typeof t2 ? t2 ? "word" : "character" : t2;
            } else this._wrapMode = "word";
            if (this._lineHeightOffset = e.hasOwnProperty("lho") ? e["lho"] : 0, this._isBold = !!e.hasOwnProperty("b") && e["b"], this._isItalic = !!e.hasOwnProperty("i") && e["i"], e.hasOwnProperty("tw")) {
              const i2 = e["tw"];
              this._typewriterStartTime = i2["st"], this._typewriterEndTime = i2["en"], this._typewriterLength = i2["l"];
            }
            if (e.hasOwnProperty("ioc")) {
              const s2 = this.GetRuntime().GetObjectClassBySID(e["ioc"]);
              s2 && this._SetIconObjectClass(s2);
            } else this._SetIconObjectClass(null);
            e.hasOwnProperty("fs") ? (this._resolutionMode = "fixed", this._fixedScaleFactor = e["fs"]) : this._resolutionMode = "auto", this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, -1 !== this._typewriterEndTime && this._StartTicking();
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case k:
                return this.GetText();
              case l:
                return this._enableBBcode;
              case m:
                return this._GetFontFace();
              case n:
                return this._GetFontSize();
              case o:
                return this._GetLineHeight();
              case p:
                return this._IsBold();
              case q:
                return this._IsItalic();
              case r:
                return j[0] = this._color.getR(), j[1] = this._color.getG(), j[2] = this._color.getB(), j;
              case s:
                return this._GetHAlign();
              case t:
                return this._GetVAlign();
              case u:
                return this._GetWrapMode();
              case z:
                return this._IsReadAloud();
            }
          }
          SetPropertyValueByIndex(e, i2) {
            switch (e) {
              case k:
                this._SetText(i2);
                break;
              case l:
                this._enableBBcode !== !!i2 && (this._enableBBcode = !!i2, this._UpdateTextSettings());
                break;
              case m:
                this._SetFontFace(i2);
                break;
              case n:
                this._SetFontSize(i2);
                break;
              case o:
                this._SetLineHeight(i2);
                break;
              case p:
                this._SetBold(i2);
                break;
              case q:
                this._SetItalic(i2);
                break;
              case r:
                const a = this._color, h2 = i2;
                a.getR() === h2[0] && a.getG() === h2[1] && a.getB() === h2[2] || (this._color.setRgb(h2[0], h2[1], h2[2]), this._UpdateTextSettings());
                break;
              case s:
                this._SetHAlign(i2);
                break;
              case t:
                this._SetVAlign(i2);
                break;
              case u:
                this._SetWrapMode(i2);
            }
          }
          SetPropertyColorOffsetValueByIndex(e, t2, i2, s2) {
            0 === t2 && 0 === i2 && 0 === s2 || e === r && (this._color.addRgb(t2, i2, s2), this._UpdateTextSettings());
          }
          _SetText(e) {
            this._text !== e && (this._text = e, this._rendererText.SetText(e), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
          }
          GetText() {
            return this._text;
          }
          _StartTypewriter(e, t2) {
            this._UpdateTextSize(), this._SetText(e), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + t2 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = this._rendererText.GetLengthInGraphemes(), this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking();
          }
          _CancelTypewriter() {
            this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking();
          }
          _FinishTypewriter() {
            -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(h.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());
          }
          _SetFontFace(e) {
            this._faceName !== e && (this._faceName = e, this._rendererText.SetFontName(e), this._runtime.UpdateRender());
          }
          _GetFontFace() {
            return this._faceName;
          }
          _SetBold(e) {
            this._isBold !== (e = !!e) && (this._isBold = e, this._rendererText.SetBold(e), this._runtime.UpdateRender());
          }
          _IsBold() {
            return this._isBold;
          }
          _SetItalic(e) {
            this._isItalic !== (e = !!e) && (this._isItalic = e, this._rendererText.SetItalic(e), this._runtime.UpdateRender());
          }
          _IsItalic() {
            return this._isItalic;
          }
          _SetFontSize(e) {
            this._ptSize !== e && (this._ptSize = e, this._runtime.UpdateRender());
          }
          _GetFontSize() {
            return this._ptSize;
          }
          _SetFontColor(e) {
            this._color.equalsIgnoringAlpha(e) || (this._color.copyRgb(e), this._rendererText.SetColor(this._color), this._runtime.UpdateRender());
          }
          _GetFontColor() {
            return this._color;
          }
          _SetLineHeight(e) {
            this._lineHeightOffset !== e && (this._lineHeightOffset = e, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetLineHeight() {
            return this._lineHeightOffset;
          }
          _SetHAlign(e) {
            this._horizontalAlign !== e && (this._horizontalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetHAlign() {
            return this._horizontalAlign;
          }
          _SetVAlign(e) {
            this._verticalAlign !== e && (this._verticalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetVAlign() {
            return this._verticalAlign;
          }
          _SetWrapModeByIndex(e) {
            this._SetWrapMode(D[e]);
          }
          _SetWrapMode(e) {
            this._wrapMode !== e && (this._wrapMode = e, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetWrapMode() {
            return this._wrapMode;
          }
          _SetTextDirection(e) {
            this._textDirection !== e && (this._textDirection = e, this._UpdateTextSettings(), this._runtime.UpdateRender());
          }
          _GetTextDirection() {
            return this._textDirection;
          }
          _SetReadAloud(e) {
            this._readAloud = !!e, this._UpdateScreenReaderText();
          }
          _IsReadAloud() {
            return this._readAloud;
          }
          _SetResolutionMode(e) {
            this._resolutionMode !== e && (this._resolutionMode = e, this._runtime.UpdateRender());
          }
          _GetResolutionMode() {
            return this._resolutionMode;
          }
          _SetFixedScaleFactor(e) {
            this._fixedScaleFactor !== e && (this._fixedScaleFactor = e, "fixed" === this._resolutionMode) && this._runtime.UpdateRender();
          }
          _GetFixedScaleFactor() {
            return this._fixedScaleFactor;
          }
          _GetTextWidth() {
            return this._UpdateTextSize(), this._rendererText.GetTextWidth();
          }
          _GetTextHeight() {
            return this._UpdateTextSize(), this._rendererText.GetTextHeight();
          }
          _GetTagAtPosition(e, t2) {
            this._UpdateTextSize();
            const i2 = this.GetWorldInfo(), s2 = (H.set(e - i2.GetX(), t2 - i2.GetY()), H.rotate(-i2.GetAngle()), H.offset(i2.GetWidth() * i2.GetOriginX(), i2.GetHeight() * i2.GetOriginY()), H.divide(i2.GetWidth(), i2.GetHeight()), H.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight()), this._rendererText.HitTestFragment(H.getX(), H.getY()));
            if (s2) {
              const r2 = s2.GetStyleTag("tag");
              if (r2) return r2.param;
            }
            return "";
          }
          _HasTagAtPosition(e, t2, i2) {
            const s2 = this._GetTagAtPosition(t2, i2);
            return s2 && h.equalsNoCase(e, s2);
          }
          _GetTagPosition(e, t2) {
            this._UpdateTextSize(), t2 = Math.floor(t2);
            const i2 = this._rendererText.FindFragmentWithTag(e, t2);
            if (!i2) return null;
            const s2 = this.GetWorldInfo(), r2 = this._rendererText.GetDrawScale(), n2 = i2.GetPosX(), a = i2.GetPosY() - (i2.GetHeight() - i2.GetFontBoundingBoxDescent()) * r2, o2 = i2.GetWidth() * r2 / this._rendererText.GetWidth() * s2.GetWidth(), h2 = i2.GetHeight() * r2 / this._rendererText.GetHeight() * s2.GetHeight();
            return H.set(n2, a), H.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight()), H.scale(s2.GetWidth(), s2.GetHeight()), H.offset(-s2.GetWidth() * s2.GetOriginX(), -s2.GetHeight() * s2.GetOriginY()), H.rotate(s2.GetAngle()), H.offset(s2.GetX(), s2.GetY()), { x: H.getX(), y: H.getY(), width: o2, height: h2 };
          }
          _GetTagCount(e) {
            return this._UpdateTextSize(), this._rendererText.CountFragmentsWithTag(e);
          }
          _GetHTMLCloseTag(e) {
            let t2 = I.get(e);
            return null === t2 ? "" : `</${(t2 = t2 || "span") || "span"}>`;
          }
          _GetHTMLOpenTag(e, t2) {
            let i2 = I.get(e);
            if (null === i2) return "";
            switch (i2 = i2 || "span", e) {
              case "color":
                return `<${i2} style="color: ${t2}">`;
              case "font":
                return `<${i2} style="font-family: '${t2}'">`;
              case "opacity":
                return `<${i2} style="opacity: ${t2}%">`;
              case "size":
                return `<${i2} style="font-size: ${t2}pt">`;
              case "background":
                return `<${i2} style="background-color: ${t2}">`;
              case "hide":
                return `<${i2} style="visibility: hidden">`;
              case "class":
                return `<${i2} class="${t2}">`;
              case "tag":
                return `<${i2} data-tag="${t2}">`;
              default:
                return `<${i2}>`;
            }
          }
          async _UpdateHTMLString() {
            if (!this._isHtmlStringUpToDate) {
              const e = new h.BBString(this._text, { noEscape: true }).toFragmentList(), t2 = /* @__PURE__ */ new Map();
              let i2 = '<span class="c3-text"';
              const s2 = [], r2 = (s2.push(`font-family: '${this._GetFontFace()}';`), this._IsBold() && s2.push("font-weight: bold;"), this._IsItalic() && s2.push("font-style: italic;"), "character" === this._GetWrapMode() && s2.push("word-break: break-all;"), i2 += ` style="${s2.join(" ")}">`, this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null);
              if (this._iconObjectClass) {
                const o2 = h.New(h.PromiseThrottle), _ = [], l2 = /* @__PURE__ */ new Map();
                for (const d of e) if (d.IsIcon()) {
                  const g = d.GetTextIcon(r2);
                  if (g) {
                    const u2 = g.GetSource(), T = u2.GetImageInfo().GetImageAsset();
                    l2.has(T) || (l2.set(T, null), _.push(o2.Add(async () => {
                      const e2 = await T.LoadToDrawable();
                      l2.set(T, e2);
                    })));
                  }
                }
                await Promise.all(_);
                const c = [];
                for (const S of e) if (S.IsIcon()) {
                  const p2 = S.GetTextIcon(r2);
                  if (p2) {
                    const x2 = p2.GetSource(), G2 = x2.GetImageInfo().GetImageAsset();
                    c.push(o2.Add(async () => {
                      const e2 = await x2.GetImageInfo().ExtractImageToBlobURL(l2.get(G2));
                      t2.set(p2, e2);
                    }));
                  }
                }
                await Promise.all(c);
                for (const m2 of l2.values()) m2 instanceof ImageBitmap && m2["close"] && m2["close"]();
              }
              const n2 = /* @__PURE__ */ new Map();
              for (const f of e) {
                const w2 = f.GetStyleMap();
                let e2 = [...n2.keys()];
                e2.reverse();
                for (const I2 of e2) w2.has(I2) && w2.get(I2) === n2.get(I2) || (n2.delete(I2), i2 += this._GetHTMLCloseTag(I2));
                for (const [R, y2] of w2) n2.has(R) || (n2.set(R, y2), i2 += this._GetHTMLOpenTag(R, y2));
                if (f.IsText() && (i2 += h.ReplaceAll(h.EscapeHTML(f.GetCharacterArray().join("")), "\n", "<br>")), f.IsIcon() && r2) {
                  const b = f.GetTextIcon(r2);
                  if (b) {
                    const C2 = t2.get(b);
                    if (C2) {
                      const s3 = [];
                      let t3 = "0.2em";
                      const F2 = w2.get("iconoffsety");
                      if (F2) {
                        let e3 = F2.trim();
                        t3 = e3.endsWith("%") ? parseFloat(e3) / 100 + "em" : e3 + "px";
                      }
                      s3.push("top: " + t3), "nearest" === this._runtime.GetSampling() && s3.push("image-rendering: pixelated"), i2 += `<img class="c3-text-icon" data-icon="${f.GetIconParameter()}" width="${b.GetWidth()}" height="${b.GetHeight()}" style="${s3.join(";")}" src="${C2}">`;
                    }
                  }
                }
              }
              const a = [...n2.keys()];
              a.reverse();
              for (const A2 of a) i2 += this._GetHTMLCloseTag(A2);
              i2 += "</span>", this._htmlString = i2, this._isHtmlStringUpToDate = true;
            }
            return this._htmlString;
          }
          Tick() {
            const t2 = this._runtime.GetWallTime();
            if (t2 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(h.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();
            else {
              let e = h.relerp(this._typewriterStartTime, this._typewriterEndTime, t2, 0, this._typewriterLength);
              (e = Math.floor(e)) !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(e), this._runtime.UpdateRender());
            }
          }
          GetDebuggerProperties() {
            const e = "plugins.text";
            return [{ title: e + ".name", properties: [{ name: e + ".properties.text.name", value: this.GetText(), onedit: (e2) => this._SetText(e2) }, { name: e + ".properties.font.name", value: this._GetFontFace(), onedit: (e2) => this._SetFontFace(e2) }, { name: e + ".properties.size.name", value: this._GetFontSize(), onedit: (e2) => this._SetFontSize(e2) }, { name: e + ".properties.line-height.name", value: this._GetLineHeight(), onedit: (e2) => this._SetLineHeight(e2) }, { name: e + ".properties.bold.name", value: this._IsBold(), onedit: (e2) => this._SetBold(e2) }, { name: e + ".properties.italic.name", value: this._IsItalic(), onedit: (e2) => this._SetItalic(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITextInstance;
          }
        }, /* @__PURE__ */ new WeakMap()), K = /* @__PURE__ */ new Map([["left", 0], ["center", 1], ["right", 2]]), L = /* @__PURE__ */ new Map([["top", 0], ["center", 1], ["bottom", 2]]), M = ["ltr", "rtl"], N = /* @__PURE__ */ new Set(["auto", "fixed"]);
        self.ITextInstance = class extends self.IWorldInstance {
          constructor() {
            super(), J.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          get text() {
            return J.get(this).GetText();
          }
          set text(e) {
            i.RequireString(e);
            const t2 = J.get(this);
            t2._CancelTypewriter(), t2._SetText(e);
          }
          typewriterText(e, t2) {
            i.RequireString(e), i.RequireFiniteNumber(t2);
            const s2 = J.get(this);
            s2._CancelTypewriter(), s2._StartTypewriter(e, t2);
          }
          typewriterFinish() {
            J.get(this)._FinishTypewriter();
          }
          set fontFace(e) {
            i.RequireString(e), J.get(this)._SetFontFace(e);
          }
          get fontFace() {
            return J.get(this)._GetFontFace();
          }
          set isBold(e) {
            J.get(this)._SetBold(e);
          }
          get isBold() {
            return J.get(this)._IsBold();
          }
          set isItalic(e) {
            J.get(this)._SetItalic(e);
          }
          get isItalic() {
            return J.get(this)._IsItalic();
          }
          set sizePt(e) {
            i.RequireFiniteNumber(e), J.get(this)._SetFontSize(e);
          }
          get sizePt() {
            return J.get(this)._GetFontSize();
          }
          set fontColor(e) {
            if (i.RequireArray(e), e.length < 3) throw new Error("expected 3 elements");
            G.setRgb(e[0], e[1], e[2]), J.get(this)._SetFontColor(G);
          }
          get fontColor() {
            const e = J.get(this)._GetFontColor();
            return [e.getR(), e.getG(), e.getB()];
          }
          set lineHeight(e) {
            i.RequireFiniteNumber(e), J.get(this)._SetLineHeight(e);
          }
          get lineHeight() {
            return J.get(this)._GetLineHeight();
          }
          set horizontalAlign(e) {
            i.RequireString(e);
            const t2 = K.get(e);
            if (void 0 === t2) throw new Error("invalid mode");
            J.get(this)._SetHAlign(t2);
          }
          get horizontalAlign() {
            return A[J.get(this)._GetHAlign()];
          }
          set verticalAlign(e) {
            i.RequireString(e);
            const t2 = L.get(e);
            if (void 0 === t2) throw new Error("invalid mode");
            J.get(this)._SetVAlign(t2);
          }
          get verticalAlign() {
            return B[J.get(this)._GetVAlign()];
          }
          set wordWrapMode(e) {
            if (!D.includes(e)) throw new Error("invalid mode");
            J.get(this)._SetWrapMode(e);
          }
          get wordWrapMode() {
            return J.get(this)._GetWrapMode();
          }
          set textDirection(e) {
            i.RequireString(e);
            const t2 = M.indexOf(e);
            if (-1 === t2) throw new Error("invalid text direction");
            J.get(this)._SetTextDirection(t2);
          }
          get textDirection() {
            return M[J.get(this)._GetTextDirection()];
          }
          set readAloud(e) {
            J.get(this)._SetReadAloud(!!e);
          }
          get readAloud() {
            return J.get(this)._IsReadAloud();
          }
          setFixedResolutionMode(e) {
            i.RequireFiniteNumber(e);
            const t2 = J.get(this);
            t2._SetResolutionMode("fixed"), t2._SetFixedScaleFactor(e);
          }
          setAutoResolutionMode() {
            J.get(this)._SetResolutionMode("auto");
          }
          get textWidth() {
            return J.get(this)._GetTextWidth();
          }
          get textHeight() {
            return J.get(this)._GetTextHeight();
          }
          getTextSize() {
            const e = J.get(this);
            return [e._GetTextWidth(), e._GetTextHeight()];
          }
          hasTagAtPosition(e, t2, s2) {
            return i.RequireString(e), i.RequireFiniteNumber(t2), i.RequireFiniteNumber(s2), J.get(this)._HasTagAtPosition(e, t2, s2);
          }
          getTagAtPosition(e, t2) {
            return i.RequireFiniteNumber(e), i.RequireFiniteNumber(t2), J.get(this)._GetTagAtPosition(e, t2);
          }
          getTagPositionAndSize(e, t2 = 0) {
            return i.RequireString(e), i.RequireFiniteNumber(t2), J.get(this)._GetTagPosition(e, t2);
          }
          getTagCount(e) {
            return i.RequireString(e), J.get(this)._GetTagCount(e);
          }
          changeIconSet(e) {
            const t2 = J.get(this), i2 = t2.GetRuntime()._UnwrapIObjectClass(e);
            t2._SetIconObjectClass(i2);
          }
          getAsHtmlString() {
            return J.get(this)._UpdateHTMLString();
          }
        };
      }
      {
        const Tb = self.C3;
        Tb.Plugins.Text.Cnds = { CompareText(e, t) {
          return t ? this._text === e : Tb.equalsNoCase(this._text, e);
        }, IsRunningTypewriterText() {
          return -1 !== this._typewriterEndTime;
        }, OnTypewriterTextFinished() {
          return true;
        }, HasTagAtPosition(e, t, i) {
          return this._HasTagAtPosition(e, t, i);
        } };
      }
      {
        const Zb = self.C3, $b = Zb.New(Zb.Color);
        Zb.Plugins.Text.Acts = { SetText(e) {
          this._CancelTypewriter(), "number" == typeof e && e < 1e9 && (e = Math.round(1e10 * e) / 1e10), this._SetText(e.toString());
        }, AppendText(e) {
          this._CancelTypewriter(), (e = (e = "number" == typeof e && e < 1e9 ? Math.round(1e10 * e) / 1e10 : e).toString()) && this._SetText(this._text + e);
        }, TypewriterText(e, t) {
          this._CancelTypewriter(), "number" == typeof e && e < 1e9 && (e = Math.round(1e10 * e) / 1e10), this._StartTypewriter(e.toString(), t);
        }, SetFontFace(e, t) {
          let i = false, s = false;
          switch (t) {
            case 1:
              i = true;
              break;
            case 2:
              s = true;
              break;
            case 3:
              i = true, s = true;
          }
          e === this._faceName && i === this._isBold && s === this._isItalic || (this._SetFontFace(e), this._SetBold(i), this._SetItalic(s));
        }, SetFontSize(e) {
          this._SetFontSize(e);
        }, SetFontColor(e) {
          $b.setFromRgbValue(e), $b.clamp(), this._SetFontColor($b);
        }, SetWebFont(e, t) {
          console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
        }, SetEffect(e) {
          this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();
        }, TypewriterFinish() {
          this._FinishTypewriter();
        }, SetLineHeight(e) {
          this._SetLineHeight(e);
        }, SetHAlign(e) {
          this._SetHAlign(e);
        }, SetVAlign(e) {
          this._SetVAlign(e);
        }, SetWrapping(e) {
          this._SetWrapModeByIndex(e);
        }, SetTextDirection(e) {
          this._SetTextDirection(e);
        }, ChangeIconSet(e) {
          this._SetIconObjectClass(e);
        }, UpdateHTML() {
          return this._UpdateHTMLString();
        }, SetReadAloud(e) {
          this._SetReadAloud(e);
        }, SetResolutionMode(e, t) {
          this._SetResolutionMode(["auto", "fixed"][e]), this._SetFixedScaleFactor(t);
        } };
      }
      {
        const v1 = self.C3;
        v1.Plugins.Text.Exps = { Text() {
          return this._text;
        }, PlainText() {
          return this._enableBBcode ? v1.BBString.StripAnyTags(this._text) : this._text;
        }, FaceName() {
          return this._faceName;
        }, FaceSize() {
          return this._ptSize;
        }, TextWidth() {
          return this._GetTextWidth();
        }, TextHeight() {
          return this._GetTextHeight();
        }, LineHeight() {
          return this._lineHeightOffset;
        }, TagAtPosition(e, t) {
          return this._GetTagAtPosition(e, t);
        }, TagCount(e) {
          return this._GetTagCount(e);
        }, TagX(e, t) {
          const i = this._GetTagPosition(e, t);
          return i ? i.x : 0;
        }, TagY(e, t) {
          const i = this._GetTagPosition(e, t);
          return i ? i.y : 0;
        }, TagWidth(e, t) {
          const i = this._GetTagPosition(e, t);
          return i ? i.width : 0;
        }, TagHeight(e, t) {
          const i = this._GetTagPosition(e, t);
          return i ? i.height : 0;
        }, AsHTML() {
          return this._htmlString;
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Touch = class extends a.SDKPluginBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        let GetTouchSdkInstance2 = function() {
          return s.GetSingleGlobalInstance().GetSdkInstance();
        };
        GetTouchSdkInstance = GetTouchSdkInstance2;
        const d = self.C3, e = self.C3X;
        d.Plugins.Touch.Type = class extends d.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
          GetScriptInterfaceClass() {
            return self.ITouchObjectType;
          }
        };
        let s = null;
        self.ITouchObjectType = class extends self.IObjectClass {
          constructor(t) {
            super(t), (s = t).GetRuntime()._GetCommonScriptInterfaces().touch = this;
          }
          requestPermission(t) {
            e.RequireString(t);
            const s2 = GetTouchSdkInstance2();
            if ("orientation" === t) return s2._RequestPermission(0);
            if ("motion" === t) return s2._RequestPermission(1);
            throw new Error("invalid type");
          }
        };
      }
      {
        const m = self.C3, n = "touch";
        m.Plugins.Touch.Instance = class extends m.SDKInstanceBase {
          constructor(t, e) {
            super(t, n), this._touches = /* @__PURE__ */ new Map(), this._useMouseInput = false, this._isMouseDown = false, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._triggerType = 0, this._permissionPromises = [], e && (this._useMouseInput = e[0]), this.AddDOMMessageHandler("permission-result", (t2) => this._OnPermissionResult(t2));
            const s = this.GetRuntime().Dispatcher();
            this._disposables = new m.CompositeDisposable(m.Disposable.From(s, "pointerdown", (t2) => this._OnPointerDown(t2.data)), m.Disposable.From(s, "pointermove", (t2) => this._OnPointerMove(t2.data)), m.Disposable.From(s, "pointerup", (t2) => this._OnPointerUp(t2.data, false)), m.Disposable.From(s, "pointercancel", (t2) => this._OnPointerUp(t2.data, true)), m.Disposable.From(s, "deviceorientation", (t2) => this._OnDeviceOrientation(t2.data)), m.Disposable.From(s, "deviceorientationabsolute", (t2) => this._OnDeviceOrientationAbsolute(t2.data)), m.Disposable.From(s, "devicemotion", (t2) => this._OnDeviceMotion(t2.data)), m.Disposable.From(s, "tick2", (t2) => this._OnTick2()));
          }
          Release() {
            this._touches.clear(), super.Release();
          }
          _OnPointerDown(t) {
            if ("mouse" === t["pointerType"]) {
              if (!this._useMouseInput) return;
              this._isMouseDown = true;
            }
            const e = t["pointerId"];
            if (!this._touches.has(e)) {
              const s = t["pageX"] - this._runtime.GetCanvasClientX(), i = t["pageY"] - this._runtime.GetCanvasClientY(), n2 = performance.now(), r = this._touches.size, o = (this._triggerIndex = r, this._triggerId = e, m.New(m.Plugins.Touch.TouchInfo));
              o.Init(n2, s, i, e, r), this._touches.set(e, o), this.Trigger(m.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(m.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s, this._curTouchY = i, this._triggerType = 0, this.Trigger(m.Plugins.Touch.Cnds.OnTouchObject);
            }
          }
          _OnPointerMove(t) {
            if ("mouse" !== t["pointerType"] || this._isMouseDown) {
              const e = this._touches.get(t["pointerId"]);
              if (e) {
                const s = performance.now();
                if (!(s - e.GetTime() < 2)) {
                  const i = t["pageX"] - this._runtime.GetCanvasClientX(), n2 = t["pageY"] - this._runtime.GetCanvasClientY();
                  e.Update(s, i, n2, t["width"], t["height"], t["pressure"]);
                }
              }
            }
          }
          _OnPointerUp(t, e) {
            if ("mouse" === t["pointerType"]) {
              if (!this._isMouseDown) return;
              this._isMouseDown = false;
            }
            const s = performance.now(), i = t["pointerId"], n2 = this._touches.get(i);
            if (n2) {
              if (this._triggerIndex = n2.GetStartIndex(), this._triggerId = n2.GetId(), !e) {
                const r = t["pageX"] - this._runtime.GetCanvasClientX(), o = t["pageY"] - this._runtime.GetCanvasClientY();
                this._curTouchX = r, this._curTouchY = o, this._triggerType = 1, this.Trigger(m.Plugins.Touch.Cnds.OnTouchObject);
              }
              if (this.Trigger(m.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(m.Plugins.Touch.Cnds.OnTouchEnd), !e) {
                const u = n2.ShouldTriggerTap(s);
                "single-tap" === u ? (this.Trigger(m.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = n2.GetX(), this._curTouchY = n2.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === u && (this.Trigger(m.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = n2.GetX(), this._curTouchY = n2.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnDoubleTapGestureObject));
              }
              n2.Release(), this._touches.delete(i);
            }
          }
          _RequestPermission(s) {
            return this._PostToDOMMaybeSync("request-permission", { "type": s }), new Promise((t, e) => {
              this._permissionPromises.push({ type: s, resolve: t, reject: e });
            });
          }
          _OnPermissionResult(t) {
            const e = t["result"], s = t["type"], i = (this._triggerPermission = s, this._permissionPromises.filter((t2) => t2.type === s));
            for (const n2 of i) n2.resolve(e ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter((t2) => t2.type !== s), e ? (this.Trigger(m.Plugins.Touch.Cnds.OnPermissionGranted), 0 === s ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(m.Plugins.Touch.Cnds.OnPermissionDenied);
          }
          _OnDeviceOrientation(t) {
            "number" == typeof t["webkitCompassHeading"] ? this._orientCompassHeading = t["webkitCompassHeading"] : t["absolute"] && (this._orientCompassHeading = t["alpha"]), this._orientAlpha = t["alpha"], this._orientBeta = t["beta"], this._orientGamma = t["gamma"];
          }
          _OnDeviceOrientationAbsolute(t) {
            this._orientCompassHeading = t["alpha"];
          }
          _OnDeviceMotion(t) {
            const e = t["acceleration"], s = (e && (this._accX = e["x"], this._accY = e["y"], this._accZ = e["z"]), t["accelerationIncludingGravity"]);
            s && (this._accWithGX = s["x"], this._accWithGY = s["y"], this._accWithGZ = s["z"]);
          }
          _OnTick2() {
            const t = performance.now();
            let e = 0;
            for (const s of this._touches.values()) s.GetTime() <= t - 50 && s._SetLastTime(t), s.ShouldTriggerHold(t) && (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this._getTouchIndex = e, this.Trigger(m.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++e;
          }
          _GetTouchByIndex(t) {
            t = Math.floor(t);
            for (const e of this._touches.values()) {
              if (0 === t) return e;
              --t;
            }
            return null;
          }
          _IsClientPosOnCanvas(t, e) {
            return 0 <= t && 0 <= e && t < this._runtime.GetCanvasCssWidth() && e < this._runtime.GetCanvasCssHeight();
          }
          GetDebuggerProperties() {
            return [{ title: "plugins.touch.debugger.touches", properties: [...this._touches.values()].map((t) => ({ name: "$" + t.GetId(), value: t.GetX() + ", " + t.GetY() })) }];
          }
        };
      }
      {
        const ra = self.C3, sa = [];
        ra.Plugins.Touch.Cnds = { OnTouchStart() {
          return true;
        }, OnTouchEnd() {
          return true;
        }, IsInTouch() {
          return 0 < this._touches.size;
        }, OnTouchObject(t, e) {
          return !!t && e === this._triggerType && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);
        }, IsTouchingObject(t) {
          if (!t) return false;
          const e = this._runtime.GetCurrentCondition(), s = e.IsInverted(), i = [...this._touches.values()].filter((t2) => this._IsClientPosOnCanvas(t2.GetX(), t2.GetY())).map((t2) => [t2.GetX(), t2.GetY()]);
          return ra.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, i, s), s);
        }, CompareTouchSpeed(t, e, s) {
          const i = this._GetTouchByIndex(t);
          return !!i && ra.compare(i.GetSpeed(), e, s);
        }, OrientationSupported() {
          return true;
        }, MotionSupported() {
          return true;
        }, CompareOrientation(t, e, s) {
          this._runtime.RequestDeviceOrientationEvent();
          let i = 0;
          return i = 0 === t ? this._orientAlpha : 1 === t ? this._orientBeta : this._orientGamma, ra.compare(i, e, s);
        }, CompareAcceleration(t, e, s) {
          this._runtime.RequestDeviceMotionEvent();
          let i = 0;
          return i = 0 === t ? this._accWithGX : 1 === t ? this._accWithGY : 2 === t ? this._accWithGZ : 3 === t ? this._accX : 4 === t ? this._accY : this._accZ, ra.compare(i, e, s);
        }, OnNthTouchStart(t) {
          return (t = Math.floor(t)) === this._triggerIndex;
        }, OnNthTouchEnd(t) {
          return (t = Math.floor(t)) === this._triggerIndex;
        }, HasNthTouch(t) {
          return t = Math.floor(t), this._touches.size >= t + 1;
        }, OnHoldGesture() {
          return true;
        }, OnTapGesture() {
          return true;
        }, OnDoubleTapGesture() {
          return true;
        }, OnHoldGestureObject(t) {
          return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);
        }, OnTapGestureObject(t) {
          return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);
        }, OnDoubleTapGestureObject(t) {
          return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);
        }, OnPermissionGranted(t) {
          return this._triggerPermission === t;
        }, OnPermissionDenied(t) {
          return this._triggerPermission === t;
        } };
      }
      {
        const Va = self.C3;
        Va.Plugins.Touch.Acts = { RequestPermission(t) {
          this._RequestPermission(t);
        } };
      }
      {
        const Xa = self.C3;
        Xa.Plugins.Touch.Exps = { TouchCount() {
          return this._touches.size;
        }, X(t) {
          const e = this._GetTouchByIndex(this._getTouchIndex);
          return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, true) : 0;
        }, Y(t) {
          const e = this._GetTouchByIndex(this._getTouchIndex);
          return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, false) : 0;
        }, XAt(t, e) {
          const s = this._GetTouchByIndex(t);
          return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
        }, YAt(t, e) {
          const s = this._GetTouchByIndex(t);
          return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
        }, XForID(t, e) {
          const s = this._touches.get(t);
          return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;
        }, YForID(t, e) {
          const s = this._touches.get(t);
          return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;
        }, AbsoluteX() {
          const t = this._GetTouchByIndex(0);
          return t ? t.GetX() : 0;
        }, AbsoluteY() {
          const t = this._GetTouchByIndex(0);
          return t ? t.GetY() : 0;
        }, AbsoluteXAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetX() : 0;
        }, AbsoluteYAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetY() : 0;
        }, AbsoluteXForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetX() : 0;
        }, AbsoluteYForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetY() : 0;
        }, SpeedAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? e.GetSpeed() : 0;
        }, SpeedForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetSpeed() : 0;
        }, AngleAt(t) {
          const e = this._GetTouchByIndex(t);
          return e ? Xa.toDegrees(e.GetAngle()) : 0;
        }, AngleForID(t) {
          const e = this._touches.get(t);
          return e ? Xa.toDegrees(e.GetAngle()) : 0;
        }, CompassHeading() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading;
        }, Alpha() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha;
        }, Beta() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta;
        }, Gamma() {
          return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma;
        }, AccelerationXWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGX;
        }, AccelerationYWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGY;
        }, AccelerationZWithG() {
          return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ;
        }, AccelerationX() {
          return this._runtime.RequestDeviceMotionEvent(), this._accX;
        }, AccelerationY() {
          return this._runtime.RequestDeviceMotionEvent(), this._accY;
        }, AccelerationZ() {
          return this._runtime.RequestDeviceMotionEvent(), this._accZ;
        }, TouchIndex() {
          return this._triggerIndex;
        }, TouchID() {
          return this._triggerId;
        }, WidthForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetWidth() : 0;
        }, HeightForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetHeight() : 0;
        }, PressureForID(t) {
          const e = this._touches.get(t);
          return e ? e.GetPressure() : 0;
        } };
      }
    }
    var GetTouchSdkInstance;
    {
      const C33 = self.C3, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25;
      let lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;
      C33.Plugins.Touch.TouchInfo = class extends C33.DefendedBase {
        constructor() {
          super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = false, this._isTooFarForHold = false;
        }
        Release() {
        }
        Init(t, s, i, e, _) {
          this._pointerId = e, this._startIndex = _, this._time = t, this._lastTime = t, this._startTime = t, this._startX = s, this._startY = i, this._x = s, this._y = i, this._lastX = s, this._lastY = i;
        }
        Update(t, s, i, e, _, h) {
          this._lastTime = this._time, this._time = t, this._lastX = this._x, this._lastY = this._y, this._x = s, this._y = i, this._width = e, this._height = _, this._pressure = h, !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) >= GESTURE_HOLD_THRESHOLD && (this._isTooFarForHold = true);
        }
        GetId() {
          return this._pointerId;
        }
        GetStartIndex() {
          return this._startIndex;
        }
        GetTime() {
          return this._time;
        }
        _SetLastTime(t) {
          this._lastTime = t;
        }
        GetX() {
          return this._x;
        }
        GetY() {
          return this._y;
        }
        GetSpeed() {
          const t = C33.distanceTo(this._x, this._y, this._lastX, this._lastY), s = (this._time - this._lastTime) / 1e3;
          return 0 < s ? t / s : 0;
        }
        GetAngle() {
          return C33.angleTo(this._lastX, this._lastY, this._x, this._y);
        }
        GetWidth() {
          return this._width;
        }
        GetHeight() {
          return this._height;
        }
        GetPressure() {
          return this._pressure;
        }
        ShouldTriggerHold(t) {
          return !this._hasTriggeredHold && t - this._startTime >= GESTURE_HOLD_TIMEOUT && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD && (this._hasTriggeredHold = true);
        }
        ShouldTriggerTap(t) {
          return !this._hasTriggeredHold && t - this._startTime <= GESTURE_TAP_TIMEOUT && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD ? t - lastTapTime <= 2 * GESTURE_TAP_TIMEOUT && C33.distanceTo(lastTapX, lastTapY, this._x, this._y) < GESTURE_DOUBLETAP_THRESHOLD ? (lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4, "double-tap") : (lastTapX = this._x, lastTapY = this._y, lastTapTime = t, "single-tap") : "";
        }
        GetPositionForLayer(t, s, i) {
          if (void 0 === s) {
            const e = t.GetLayerByIndex(0);
            return e.CanvasCssToLayer_DefaultTransform(this._x, this._y)[i ? 0 : 1];
          }
          {
            const _ = t.GetLayer(s);
            return _ ? _.CanvasCssToLayer(this._x, this._y)[i ? 0 : 1] : 0;
          }
        }
      };
    }
    {
      {
        const a = self.C3, b = "list";
        a.Plugins.List = class extends a.SDKDOMPluginBase {
          constructor(e) {
            super(e, b), this.AddElementMessageHandler("click", (e2, t) => e2._OnClick(t)), this.AddElementMessageHandler("dblclick", (e2, t) => e2._OnDoubleClick(t)), this.AddElementMessageHandler("change", (e2, t) => e2._OnChange(t));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const k = self.C3;
        k.Plugins.List.Type = class extends k.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const n = self.C3, o = self.C3X, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 8, y = 0, z = 1, A = "list", B = (n.Plugins.List.Instance = class extends n.SDKDOMInstanceBase {
          constructor(e, i) {
            if (super(e, A), this._items = [], this._stringItems = "", this._title = "", this._isEnabled = true, this._isDropdown = true, this._isMultiSelect = false, this._autoFontSize = true, this._id = "", this._className = "", this._selectedIndex = -1, this._selectedIndices = [], i) {
              const n2 = i[p];
              this._items = n2 ? n2.split("\n") : [], this._stringItems = i[p], this._title = i[q], this.GetWorldInfo().SetVisible(!!i[r]), this._isEnabled = !!i[s], this._isDropdown = i[t] === z, this._isMultiSelect = !!i[u], this._autoFontSize = !!i[v], this._id = i[w], this._className = i[x], this._isDropdown && (this._selectedIndex = 0);
            }
            this.CreateElement({ "id": this._id, "className": this._className, "isDropdown": this._isDropdown, "isMultiSelect": this._isMultiSelect, "items": this._items });
          }
          Release() {
            n.clearArray(this._items), this._items = null, n.clearArray(this._selectedIndices), this._selectedIndices = null, super.Release();
          }
          GetElementState() {
            return { "title": this._title, "isEnabled": this._isEnabled, "isMultiSelect": this._isMultiSelect };
          }
          _UpdateSelectedIndex() {
            this.PostToDOMElement("set-selected-index", { "selectedIndex": this._selectedIndex });
          }
          _ReadSelectionState(e) {
            this._selectedIndex = e["selectedIndex"], this._selectedIndices = e["selectedIndices"];
          }
          async _OnClick(e) {
            this._ReadSelectionState(e), this.DispatchScriptEvent("click"), await this.TriggerAsync(n.Plugins.List.Cnds.OnClicked);
          }
          async _OnDoubleClick(e) {
            this._ReadSelectionState(e), this.DispatchScriptEvent("dblclick"), await this.TriggerAsync(n.Plugins.List.Cnds.OnDoubleClicked);
          }
          async _OnChange(e) {
            this._ReadSelectionState(e), this.DispatchScriptEvent("selectionchange"), await this.TriggerAsync(n.Plugins.List.Cnds.OnSelectionChanged);
          }
          _GetItemCount() {
            return this._items.length;
          }
          _SetSelectedIndex(e) {
            (e = (e = Math.floor(e)) < 0 ? -1 : e) >= this._items.length || this._selectedIndex !== e && (this._selectedIndex = e, this._selectedIndices = [e], this._UpdateSelectedIndex());
          }
          _GetSelectedIndex() {
            return this._selectedIndex;
          }
          _GetSelectedCount() {
            return this._selectedIndices.length;
          }
          _GetSelectedIndexAt(e) {
            return (e = Math.floor(e)) < 0 || e >= this._selectedIndices.length ? 0 : this._selectedIndices[e];
          }
          _GetSelectedTextAt(e) {
            return (e = Math.floor(e)) < 0 || e >= this._selectedIndices.length || (e = this._selectedIndices[e]) < 0 || e >= this._items.length ? "" : this._items[e];
          }
          _SetTooltip(e) {
            this._title !== e && (this._title = e, this.UpdateElementState());
          }
          _GetTooltip() {
            return this._title;
          }
          _AddItem(e) {
            this._items.push(e), this.PostToDOMElement("add-item", { "text": e, "index": -1 });
          }
          _AddItemAt(s2, e) {
            if ((s2 = Math.max(Math.floor(s2), 0)) >= this._items.length) this._items.push(e), s2 = -1;
            else {
              this._items.splice(s2, 0, e), this._selectedIndex >= s2 && this._selectedIndex++;
              for (let e2 = 0, t2 = this._selectedIndices.length; e2 < t2; ++e2) this._selectedIndices[e2] >= s2 && this._selectedIndices[e2]++;
            }
            this.PostToDOMElement("add-item", { "index": s2, "text": e });
          }
          _RemoveItem(s2) {
            if (!((s2 = Math.floor(s2)) < 0 || s2 >= this._items.length)) {
              this._items.splice(s2, 1), this._selectedIndex >= s2 && this._selectedIndex--;
              let t2 = this._selectedIndices.indexOf(s2);
              -1 !== t2 && this._selectedIndices.splice(t2, 1), t2 = 0;
              for (let e = this._selectedIndices.length; t2 < e; ++t2) this._selectedIndices[t2] >= s2 && this._selectedIndices[t2]--;
              this.PostToDOMElement("remove-item", { "index": s2 });
            }
          }
          _SetItemText(e, t2) {
            (e = Math.floor(e)) < 0 || e >= this._items.length || (this._items[e] = t2, this.PostToDOMElement("set-item", { "index": e, "text": t2 }));
          }
          _GetItemText(e) {
            return (e = Math.floor(e)) < 0 || e >= this._items.length ? "" : this._items[e];
          }
          _Clear() {
            n.clearArray(this._items), this._selectedIndex = -1, n.clearArray(this._selectedIndices), this.PostToDOMElement("clear");
          }
          _SetMultiSelect(e) {
            this._isMultiSelect !== (e = !!e) && (this._isMultiSelect = e, this.UpdateElementState());
          }
          _IsMultiSelect() {
            return this._isMultiSelect;
          }
          _SetEnabled(e) {
            this._isEnabled !== (e = !!e) && (this._isEnabled = e, this.UpdateElementState());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          Draw(e) {
          }
          SaveToJson() {
            return { "title": this._title, "isEnabled": this._isEnabled, "id": this._id, "items": n.cloneArray(this._items), "selectedIndex": this._selectedIndex, "selectedIndices": this._selectedIndices };
          }
          LoadFromJson(e) {
            this._title = e["title"], this._isEnabled = e["isEnabled"], this._id = e["id"], this._items = n.cloneArray(e["items"]), this._stringItems = this._items.join("/n"), this._selectedIndex = e["selectedIndex"], this._selectedIndices = e["selectedIndices"], this.UpdateElementState(), this.PostToDOMElement("load-state", { "items": this._items, "selectedIndex": this._selectedIndex, "selectedIndices": this._selectedIndices });
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case p:
                return this._stringItems;
              case q:
                return this._GetTooltip();
              case s:
                return this._IsEnabled();
              case u:
                return this._IsMultiSelect();
              case v:
                return this._autoFontSize;
            }
          }
          SetPropertyValueByIndex(e, t2) {
            switch (e) {
              case p:
                this._stringItems !== t2 && (this._items = t2.split("\n"), this._stringItems = t2, this._selectedIndex = n.clamp(this._selectedIndex, 0, this._items.length - 1), this.UpdateElementState(), this.PostToDOMElement("load-state", { "items": this._items, "selectedIndex": this._selectedIndex, "selectedIndices": this._selectedIndices }));
                break;
              case q:
                this._SetTooltip(t2);
                break;
              case s:
                this._SetEnabled(t2);
                break;
              case u:
                this._SetMultiSelect(t2);
                break;
              case v:
                this._autoFontSize !== !!t2 && (this._autoFontSize = !!t2, this.UpdateElementState());
            }
          }
          GetDebuggerProperties() {
            const e = "plugins.list";
            return [{ title: e + ".name", properties: [{ name: e + ".debugger.item-count", value: this._GetItemCount() }, { name: e + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }, { name: e + ".debugger.selected-index", value: this._GetSelectedIndex() }] }, { title: e + ".properties.items.name", properties: this._items.map((e2, t2) => ({ name: "$" + t2, value: e2, onedit: (e3) => this._SetItemText(t2, e3) })) }];
          }
          GetScriptInterfaceClass() {
            return self.IListInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IListInstance = class extends self.IDOMInstance {
          constructor() {
            super(), B.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set selectedIndex(e) {
            o.RequireFiniteNumber(e), B.get(this)._SetSelectedIndex(e);
          }
          get selectedIndex() {
            return B.get(this)._GetSelectedIndex();
          }
          get selectedCount() {
            return B.get(this)._GetSelectedCount();
          }
          getSelectedIndexAt(e) {
            return o.RequireFiniteNumber(e), B.get(this)._GetSelectedIndexAt(e);
          }
          getSelectedTextAt(e) {
            return o.RequireFiniteNumber(e), B.get(this)._GetSelectedTextAt(e);
          }
          set tooltip(e) {
            o.RequireString(e), B.get(this)._SetTooltip(e);
          }
          get tooltip() {
            return B.get(this)._GetTooltip();
          }
          addItem(e) {
            o.RequireString(e), B.get(this)._AddItem(e);
          }
          insertItem(e, t2) {
            o.RequireFiniteNumber(e), o.RequireString(t2), B.get(this)._AddItemAt(e, t2);
          }
          setItemText(e, t2) {
            o.RequireFiniteNumber(e), o.RequireString(t2), B.get(this)._SetItemText(e, t2);
          }
          getItemText(e) {
            return o.RequireFiniteNumber(e), B.get(this)._GetItemText(e);
          }
          removeItem(e) {
            o.RequireFiniteNumber(e), B.get(this)._RemoveItem(e);
          }
          clear() {
            B.get(this)._Clear();
          }
          get itemCount() {
            return B.get(this)._GetItemCount();
          }
        };
      }
      {
        const va = self.C3;
        va.Plugins.List.Cnds = { CompareSelection(e, t) {
          return va.compare(this._selectedIndex, e, t);
        }, OnSelectionChanged() {
          return true;
        }, OnClicked() {
          return true;
        }, OnDoubleClicked() {
          return true;
        }, CompareSelectedText(e, t) {
          const s = this._selectedIndex;
          if (s < 0 || s >= this._items.length) return false;
          const i = this._items[s];
          return t ? i === e : va.equalsNoCase(i, e);
        }, CompareTextAt(e, t, s) {
          if ((e = Math.floor(e)) < 0 || e >= this._items.length) return false;
          const i = this._items[e];
          return s ? i === t : va.equalsNoCase(i, t);
        } };
      }
      {
        const Ga = self.C3;
        Ga.Plugins.List.Acts = { Select(e) {
          this._SetSelectedIndex(e);
        }, SetTooltip(e) {
          this._SetTooltip(e);
        }, SetVisible(e) {
          const t = this.GetWorldInfo();
          e = 0 !== e, t.IsVisible() !== e && t.SetVisible(e);
        }, AddItem(e) {
          this._AddItem(e);
        }, AddItemAt(e, t) {
          this._AddItemAt(e, t);
        }, Remove(e) {
          this._RemoveItem(e);
        }, SetItemText(e, t) {
          this._SetItemText(e, t);
        }, Clear() {
          this._Clear();
        } };
      }
      {
        const Ra = self.C3;
        Ra.Plugins.List.Exps = { ItemCount() {
          return this._GetItemCount();
        }, ItemTextAt(e) {
          return this._GetItemText(e);
        }, SelectedIndex() {
          return this._GetSelectedIndex();
        }, SelectedText() {
          return this._GetItemText(this._GetSelectedIndex());
        }, SelectedCount() {
          return this._GetSelectedCount();
        }, SelectedIndexAt(e) {
          return this._GetSelectedIndexAt(e);
        }, SelectedTextAt(e) {
          return this._GetSelectedTextAt(e);
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Dictionary = class extends a.SDKPluginBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Dictionary.Type = class extends d.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IInstance, j = (g.Plugins.Dictionary.Instance = class extends g.SDKInstanceBase {
          constructor(t, e) {
            super(t), this._data = /* @__PURE__ */ new Map(), this._curKey = "";
          }
          Release() {
            this._data.clear(), super.Release();
          }
          GetAsJsonString() {
            return JSON.stringify({ "c2dictionary": true, "data": g.MapToObject(this._data) });
          }
          GetDataMap() {
            return this._data;
          }
          SaveToJson() {
            return g.MapToObject(this._data);
          }
          LoadFromJson(t) {
            g.ObjectToMap(t, this._data);
          }
          GetDebuggerProperties() {
            const t = "plugins.dictionary";
            return [{ title: t + ".name", properties: [{ name: t + ".debugger.key-count", value: this._data.size }, ...[...this._data].map((e) => ({ name: "$" + e[0], value: e[1], onedit: (t2) => this._data.set(e[0], t2) }))] }];
          }
          GetScriptInterfaceClass() {
            return self.IDictionaryInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IDictionaryInstance = class extends i {
          constructor() {
            super(), j.set(this, i._GetInitInst().GetSdkInstance());
          }
          getDataMap() {
            return j.get(this).GetDataMap();
          }
        };
      }
      {
        const s = self.C3;
        s.Plugins.Dictionary.Cnds = { CompareValue(t, e, a) {
          const n = this._data.get(t);
          return void 0 !== n && s.compare(n, e, a);
        }, ForEachKey() {
          const t = this._runtime, e = t.GetEventSheetManager(), s2 = t.GetCurrentEvent(), a = s2.GetSolModifiers(), n = t.GetEventStack(), r = n.GetCurrentStackFrame(), i = n.Push(s2);
          t.SetDebuggingEnabled(false);
          for (const o of this._data.keys()) {
            this._curKey = o, e.PushCopySol(a);
            const c = this.GetObjectClass().GetCurrentSol();
            c.PickOne(this.GetInstance()), s2.Retrigger(r, i), e.PopSol(a);
          }
          return t.SetDebuggingEnabled(true), this._curKey = "", n.Pop(), false;
        }, CompareCurrentValue(t, e) {
          const a = this._data.get(this._curKey);
          return void 0 !== a && s.compare(a, t, e);
        }, HasKey(t) {
          return this._data.has(t);
        }, IsEmpty() {
          return 0 === this._data.size;
        } };
      }
      {
        const K = self.C3;
        K.Plugins.Dictionary.Acts = { AddKey(t, e) {
          this._data.set(t, e);
        }, SetKey(t, e) {
          this._data.has(t) && this._data.set(t, e);
        }, DeleteKey(t) {
          this._data.delete(t);
        }, Clear() {
          this._data.clear();
        }, JSONLoad(t) {
          let e = null;
          try {
            e = JSON.parse(t);
          } catch (t2) {
            return void console.error("[Construct] Error parsing JSON: ", t2);
          }
          e["c2dictionary"] && K.ObjectToMap(e["data"], this._data);
        }, JSONDownload(t) {
          const e = URL.createObjectURL(new Blob([this.GetAsJsonString()], { type: "application/json" }));
          this._runtime.InvokeDownload(e, t);
        } };
      }
      {
        const V = self.C3;
        V.Plugins.Dictionary.Exps = { Get(t) {
          const e = this._data.get(t);
          return void 0 === e ? 0 : e;
        }, GetDefault(t, e) {
          const s = this._data.get(t);
          return void 0 === s ? e : s;
        }, KeyCount() {
          return this._data.size;
        }, CurrentKey() {
          return this._curKey;
        }, CurrentValue() {
          return this._data.get(this._curKey) ?? 0;
        }, AsJSON() {
          return this.GetAsJsonString();
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Arr = class extends a.SDKPluginBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Arr.Type = class extends d.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        let ResizeArray2 = function(e, r, s) {
          if (r < e.length) g.truncateArray(e, r);
          else if (r > e.length) if ("function" == typeof s) for (let t = e.length; t < r; ++t) e.push(s());
          else for (let t = e.length; t < r; ++t) e.push(s);
        };
        ResizeArray = ResizeArray2;
        const g = self.C3, h = self.C3X, i = self.IInstance;
        g.Plugins.Arr.Instance = class extends g.SDKInstanceBase {
          constructor(t, e) {
            super(t), this._cx = 10, this._cy = 1, this._cz = 1, this._arr = null, this._forX = [], this._forY = [], this._forZ = [], this._forDepth = -1, e && (this._cx = e[0], this._cy = e[1], this._cz = e[2]), this._arr = g.MakeFilledArray(this._cx, () => g.MakeFilledArray(this._cy, () => g.MakeFilledArray(this._cz, 0)));
          }
          Release() {
            this._arr = null, super.Release();
          }
          At(t, e, r) {
            return t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), 0 <= t && t < this._cx && 0 <= e && e < this._cy && 0 <= r && r < this._cz ? this._arr[t][e][r] : 0;
          }
          Set(t, e, r, s) {
            t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), 0 <= t && t < this._cx && 0 <= e && e < this._cy && 0 <= r && r < this._cz && (this._arr[t][e][r] = s);
          }
          SetSize(t, r, s) {
            if (t = Math.floor(t), r = Math.floor(r), s = Math.floor(s), r < 0 && (r = 0), s < 0 && (s = 0), this._cx !== (t = t < 0 ? 0 : t) || this._cy !== r || this._cz !== s) {
              this._cx = t, this._cy = r, this._cz = s;
              const i2 = this._arr;
              ResizeArray2(i2, t, () => g.MakeFilledArray(r, () => g.MakeFilledArray(s, 0)));
              for (let e = 0; e < t; ++e) {
                ResizeArray2(i2[e], r, () => g.MakeFilledArray(s, 0));
                for (let t2 = 0; t2 < r; ++t2) ResizeArray2(i2[e][t2], s, 0);
              }
            }
          }
          GetWidth() {
            return this._cx;
          }
          GetHeight() {
            return this._cy;
          }
          GetDepth() {
            return this._cz;
          }
          _ShuffleHelper(t, e, r, s, i2) {
            for (; 0 < e; ) {
              const h2 = Math.floor(this._runtime.Random() * e);
              if (--e, 0 === t) {
                const o = this.At(e, s, i2), n = this.At(h2, s, i2);
                this.Set(e, s, i2, n), this.Set(h2, s, i2, o);
              } else if (1 === t) {
                const l = this.At(r, e, i2), c = this.At(r, h2, i2);
                this.Set(r, e, i2, c), this.Set(r, h2, i2, l);
              } else if (2 === t) {
                const a = this.At(r, s, e), _ = this.At(r, s, h2);
                this.Set(r, s, e, _), this.Set(r, s, h2, a);
              }
            }
          }
          GetDebuggerProperties() {
            const t = "plugins.arr.debugger", e = "plugins.arr.properties", r = [{ title: t + ".array-properties.title", properties: [{ name: e + ".width.name", value: this._cx, onedit: (t2) => this.SetSize(t2, this._cy, this._cz) }, { name: e + ".height.name", value: this._cy, onedit: (t2) => this.SetSize(this._cx, t2, this._cz) }, { name: e + ".depth.name", value: this._cz, onedit: (t2) => this.SetSize(this._cx, this._cy, t2) }, { name: e + ".elements.name", value: this._cx * this._cy * this._cz }] }], s = [];
            if (1 === this._cy && 1 === this._cz) for (let e2 = 0; e2 < this._cx; ++e2) s.push({ name: "$" + e2, value: this._arr[e2][0][0], onedit: (t2) => this._arr[e2][0][0] = t2 });
            else for (let t2 = 0; t2 < this._cx; ++t2) s.push({ name: "$" + t2, value: this._arr[t2].toString() });
            return s.length && r.push({ title: t + ".array-data.title", properties: s }), r;
          }
          GetAsJsonString() {
            return JSON.stringify({ "c2array": true, "size": [this._cx, this._cy, this._cz], "data": this._arr });
          }
          SaveToJson() {
            return { "size": [this._cx, this._cy, this._cz], "data": this._arr };
          }
          LoadFromJson(t) {
            const e = t["size"];
            this._cx = e[0], this._cy = e[1], this._cz = e[2], this._arr = t["data"];
          }
          _GetForX() {
            return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0;
          }
          _GetForY() {
            return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0;
          }
          _GetForZ() {
            return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0;
          }
          GetScriptInterfaceClass() {
            return self.IArrayInstance;
          }
        };
        const j = /* @__PURE__ */ new WeakMap();
        self.IArrayInstance = class extends i {
          constructor() {
            super(), j.set(this, i._GetInitInst().GetSdkInstance());
          }
          get width() {
            return j.get(this).GetWidth();
          }
          get height() {
            return j.get(this).GetHeight();
          }
          get depth() {
            return j.get(this).GetDepth();
          }
          setSize(t, e = 1, r = 1) {
            h.RequireFiniteNumber(t), h.RequireFiniteNumber(e), h.RequireFiniteNumber(r), j.get(this).SetSize(t, e, r);
          }
          getAt(t, e = 0, r = 0) {
            return h.RequireFiniteNumber(t), h.RequireFiniteNumber(e), h.RequireFiniteNumber(r), j.get(this).At(t, e, r);
          }
          setAt(t, e, r = 0, s = 0) {
            if (h.RequireFiniteNumber(e), h.RequireFiniteNumber(r), h.RequireFiniteNumber(s), "number" != typeof t && "string" != typeof t) throw new TypeError("invalid type");
            j.get(this).Set(e, r, s, t);
          }
        };
      }
      {
        let DoForEachTrigger2 = function(t, e, r, s, i, h) {
          t.PushCopySol(r);
          const o = h.GetObjectClass().GetCurrentSol();
          o.PickOne(h.GetInstance()), e.Retrigger(s, i), t.PopSol(r);
        };
        DoForEachTrigger = DoForEachTrigger2;
        const ma = self.C3;
        ma.Plugins.Arr.Cnds = { CompareX(t, e, r) {
          return ma.compare(this.At(t, 0, 0), e, r);
        }, CompareXY(t, e, r, s) {
          return ma.compare(this.At(t, e, 0), r, s);
        }, CompareXYZ(t, e, r, s, i) {
          return ma.compare(this.At(t, e, r), s, i);
        }, ArrForEach(t) {
          const e = this._runtime, s = e.GetEventSheetManager(), i = e.GetCurrentEvent(), h = i.GetSolModifiers(), r = e.GetEventStack(), o = r.GetCurrentStackFrame(), n = r.Push(i), l = ++this._forDepth, c = this._forX, a = this._forY, _ = this._forZ, f = this._cx, u = this._cy, p = this._cz;
          if (l === this._forX.length ? (c.push(0), a.push(0), _.push(0)) : (c[l] = 0, a[l] = 0, _[l] = 0), e.SetDebuggingEnabled(false), 0 === t) for (let r2 = 0; r2 < f; ++r2) for (let e2 = 0; e2 < u; ++e2) for (let t2 = 0; t2 < p; ++t2) c[l] = r2, a[l] = e2, _[l] = t2, DoForEachTrigger2(s, i, h, o, n, this);
          else if (1 === t) for (let e2 = 0; e2 < f; ++e2) for (let t2 = 0; t2 < u; ++t2) c[l] = e2, a[l] = t2, DoForEachTrigger2(s, i, h, o, n, this);
          else for (let t2 = 0; t2 < f; ++t2) c[l] = t2, DoForEachTrigger2(s, i, h, o, n, this);
          return e.SetDebuggingEnabled(true), this._forDepth--, r.Pop(), false;
        }, CompareCurrent(t, e) {
          return ma.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), t, e);
        }, Contains(s) {
          const t = this._cx, i = this._cy, h = this._cz, o = this._arr;
          for (let r = 0; r < t; ++r) for (let e = 0; e < i; ++e) for (let t2 = 0; t2 < h; ++t2) if (o[r][e][t2] === s) return true;
          return false;
        }, IsEmpty() {
          return 0 === this._cx || 0 === this._cy || 0 === this._cz;
        }, CompareSize(t, e, r) {
          let s = 0;
          switch (t) {
            case 0:
              s = this._cx;
              break;
            case 1:
              s = this._cy;
              break;
            case 2:
              s = this._cz;
          }
          return ma.compare(s, e, r);
        } };
      }
      {
        let CompareValues2 = function(t, e) {
          if ("number" == typeof t && "number" == typeof e) return t - e;
          {
            const r = t.toString(), s = e.toString();
            return r < s ? -1 : s < r ? 1 : 0;
          }
        };
        CompareValues = CompareValues2;
        const n0 = self.C3;
        n0.Plugins.Arr.Acts = { Clear(s) {
          const t = this._cx, i = this._cy, h = this._cz, o = this._arr;
          for (let r = 0; r < t; ++r) for (let e = 0; e < i; ++e) for (let t2 = 0; t2 < h; ++t2) o[r][e][t2] = s;
        }, SetSize(t, e, r) {
          this.SetSize(t, e, r);
        }, SetX(t, e) {
          this.Set(t, 0, 0, e);
        }, SetXY(t, e, r) {
          this.Set(t, e, 0, r);
        }, SetXYZ(t, e, r, s) {
          this.Set(t, e, r, s);
        }, Push(r, s, t) {
          const i = this._cx, h = this._cy, e = this._cz, o = this._arr;
          if (0 === t) {
            const n = n0.MakeFilledArray(h, () => n0.MakeFilledArray(e, s));
            0 === r ? o.push(n) : o.unshift(n), this._cx++;
          } else if (1 === t) {
            for (let t2 = 0; t2 < i; ++t2) {
              const l = n0.MakeFilledArray(e, s);
              0 === r ? o[t2].push(l) : o[t2].unshift(l);
            }
            this._cy++;
          } else {
            for (let e2 = 0; e2 < i; ++e2) for (let t2 = 0; t2 < h; ++t2) 0 === r ? o[e2][t2].push(s) : o[e2][t2].unshift(s);
            this._cz++;
          }
        }, Pop(r, t) {
          const s = this._cx, i = this._cy, e = this._cz, h = this._arr;
          if (0 === t) 0 !== s && (0 === r ? h.pop() : h.shift(), this._cx--);
          else if (1 === t) {
            if (0 !== i) {
              for (let t2 = 0; t2 < s; ++t2) 0 === r ? h[t2].pop() : h[t2].shift();
              this._cy--;
            }
          } else if (0 !== e) {
            for (let e2 = 0; e2 < s; ++e2) for (let t2 = 0; t2 < i; ++t2) 0 === r ? h[e2][t2].pop() : h[e2][t2].shift();
            this._cz--;
          }
        }, Reverse(t) {
          const r = this._cx, s = this._cy, e = this._cz, i = this._arr;
          if (0 !== r && 0 !== s && 0 !== e) if (0 === t) i.reverse();
          else if (1 === t) for (let t2 = 0; t2 < r; ++t2) i[t2].reverse();
          else for (let e2 = 0; e2 < r; ++e2) for (let t2 = 0; t2 < s; ++t2) i[e2][t2].reverse();
        }, Sort(t) {
          const r = this._cx, s = this._cy, e = this._cz, i = this._arr;
          if (0 !== r && 0 !== s && 0 !== e) if (0 === t) i.sort((t2, e2) => CompareValues2(t2[0][0], e2[0][0]));
          else if (1 === t) for (let t2 = 0; t2 < r; ++t2) i[t2].sort((t3, e2) => CompareValues2(t3[0], e2[0]));
          else for (let e2 = 0; e2 < r; ++e2) for (let t2 = 0; t2 < s; ++t2) i[e2][t2].sort(CompareValues2);
        }, Shuffle(r) {
          const s = this._cx, i = this._cy, h = this._cz;
          if (0 !== s && 0 !== i && 0 !== h) if (0 === r) for (let e = 0; e < i; ++e) for (let t = 0; t < h; ++t) this._ShuffleHelper(r, s, 0, e, t);
          else if (1 === r) for (let e = 0; e < s; ++e) for (let t = 0; t < h; ++t) this._ShuffleHelper(r, i, e, 0, t);
          else for (let e = 0; e < s; ++e) for (let t = 0; t < i; ++t) this._ShuffleHelper(r, h, e, t, 0);
        }, Delete(r, t) {
          if (!((r = Math.floor(r)) < 0)) {
            const s = this._cx, i = this._cy, e = this._cz, h = this._arr;
            if (0 === t) s <= r || (h.splice(r, 1), this._cx--);
            else if (1 === t) {
              if (!(i <= r)) {
                for (let t2 = 0; t2 < s; ++t2) h[t2].splice(r, 1);
                this._cy--;
              }
            } else if (!(e <= r)) {
              for (let e2 = 0; e2 < s; ++e2) for (let t2 = 0; t2 < i; ++t2) h[e2][t2].splice(r, 1);
              this._cz--;
            }
          }
        }, Insert(r, s, t) {
          if (!((s = Math.floor(s)) < 0)) {
            const i = this._cx, h = this._cy, e = this._cz, o = this._arr;
            if (0 === t) i < s || (o.splice(s, 0, n0.MakeFilledArray(h, () => n0.MakeFilledArray(e, r))), this._cx++);
            else if (1 === t) {
              if (!(h < s)) {
                for (let t2 = 0; t2 < i; ++t2) o[t2].splice(s, 0, n0.MakeFilledArray(e, r));
                this._cy++;
              }
            } else if (!(s > e)) {
              for (let e2 = 0; e2 < i; ++e2) for (let t2 = 0; t2 < h; ++t2) o[e2][t2].splice(s, 0, r);
              this._cz++;
            }
          }
        }, SplitString(t, e, r) {
          const s = t.split(e);
          this.SetSize(s.length, 1, 1);
          for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {
            let t3 = s[e2];
            0 === r ? String(Number(t3)) === t3 && (t3 = Number(t3)) : 2 === r && (t3 = Number(t3)), this.Set(e2, 0, 0, t3);
          }
        }, JSONLoad(t) {
          let e = null;
          try {
            e = JSON.parse(t);
          } catch (t2) {
            return void console.error("[Construct] Failed to parse JSON: ", t2);
          }
          if (e["c2array"]) {
            const r = e["size"];
            this._cx = r[0], this._cy = r[1], this._cz = r[2], this._arr = e["data"];
          }
        }, JSONDownload(t) {
          const e = URL.createObjectURL(new Blob([this.GetAsJsonString()], { type: "application/json" }));
          this._runtime.InvokeDownload(e, t);
        } };
      }
      {
        const n1 = self.C3;
        n1.Plugins.Arr.Exps = { At(t, e, r) {
          return this.At(t, e || 0, r || 0);
        }, Width() {
          return this._cx;
        }, Height() {
          return this._cy;
        }, Depth() {
          return this._cz;
        }, CurX() {
          return this._GetForX();
        }, CurY() {
          return this._GetForY();
        }, CurZ() {
          return this._GetForZ();
        }, CurValue() {
          return this.At(this._GetForX(), this._GetForY(), this._GetForZ());
        }, Front() {
          return this.At(0, 0, 0);
        }, Back() {
          return this.At(this._cx - 1, 0, 0);
        }, IndexOf(r) {
          const s = this._arr;
          for (let t = 0, e = this._cx; t < e; ++t) if (s[t][0][0] === r) return t;
          return -1;
        }, LastIndexOf(e) {
          const r = this._arr;
          for (let t = this._cx - 1; 0 <= t; --t) if (r[t][0][0] === e) return t;
          return -1;
        }, JoinString(t) {
          let e = [];
          for (let t2 = 0; t2 < this._cx; ++t2) e.push(this.At(t2, 0, 0));
          return e.join(t);
        }, AsJSON() {
          return this.GetAsJsonString();
        } };
      }
    }
    var ResizeArray;
    var DoForEachTrigger;
    var CompareValues;
    {
      {
        const a = self.C3;
        a.Plugins.AJAX = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.AJAX.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3;
        g.Plugins.AJAX.Instance = class extends g.SDKInstanceBase {
          constructor(e, t) {
            if (super(e), this._lastData = "", this._lastStatusCode = 0, this._curTag = "", this._progress = 0, this._timeout = -1, this._nextRequestHeaders = /* @__PURE__ */ new Map(), this._nextReponseBinaryData = null, this._nextRequestOverrideMimeType = "", this._nextRequestWithCredentials = false, this._nwjsFs = null, this._nwjsPath = null, this._nwjsAppFolder = null, this._isNWjs = this._runtime.IsNWjs(), this._isNWjs) {
              this._nwjsFs = __require("fs"), this._nwjsPath = __require("path");
              const s = self["process"] || nw["process"];
              this._nwjsAppFolder = this._nwjsPath["dirname"](s["execPath"]) + "\\";
            }
          }
          Release() {
            super.Release();
          }
          async _TriggerError(e, t, s) {
            console.error(`[Construct] AJAX request to '${t}' (tag '${e}') failed: `, s), this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnAnyError), this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnError);
          }
          async _TriggerComplete(e) {
            this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnAnyComplete), this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnComplete);
          }
          async _OnProgress(e, t) {
            t["lengthComputable"] && (this._progress = t["loaded"] / t["total"], this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnProgress));
          }
          async _OnUploadProgress(e, t) {
            t["lengthComputable"] && (this._progress = t["loaded"] / t["total"], this._curTag = e, await this.TriggerAsync(g.Plugins.AJAX.Cnds.OnUploadProgress));
          }
          _OnError(s, r, e) {
            if (this._isNWjs) {
              const t = this._nwjsFs, a = this._nwjsAppFolder + r;
              t["existsSync"](a) ? t["readFile"](a, { "encoding": "utf8" }, (e2, t2) => {
                e2 ? this._TriggerError(s, r, e2) : (this._lastData = t2.replace(/\r\n/g, "\n"), this._TriggerComplete(s));
              }) : this._TriggerError(s, r, e);
            } else this._TriggerError(s, r, e);
          }
          async _DoCordovaRequest(t, s) {
            const e = this._runtime.GetAssetManager(), r = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
              if (r) {
                const a = await e.CordovaFetchLocalFileAsArrayBuffer(s);
                r.SetArrayBufferTransfer(a), this._lastData = "";
              } else {
                const i = await e.CordovaFetchLocalFileAsText(s);
                this._lastData = i.replace(/\r\n/g, "\n");
              }
              this._lastStatusCode = 0, this._TriggerComplete(t);
            } catch (e2) {
              this._TriggerError(t, s, e2);
            }
          }
          _DoRequest(o, u, e, l) {
            return new Promise((t) => {
              const s = (e2) => {
                this._OnError(o, u, e2), t();
              }, r = this._nextReponseBinaryData;
              this._nextReponseBinaryData = null;
              try {
                const a = new XMLHttpRequest();
                a.onreadystatechange = () => {
                  if (4 === a.readyState) {
                    if (r ? this._lastData = "" : this._lastData = (a.responseText || "").replace(/\r\n/g, "\n"), this._lastStatusCode = a.status, 400 <= a.status) this._TriggerError(o, u, a.status + a.statusText);
                    else {
                      const e2 = this._lastData.length || r && a.response instanceof ArrayBuffer;
                      this._isNWjs && !e2 || !this._isNWjs && 0 === a.status && !e2 || (r && r.SetArrayBufferTransfer(a.response), this._TriggerComplete(o));
                    }
                    t();
                  }
                }, a.onerror = s, a.ontimeout = s, a.onabort = s, a["onprogress"] = (e2) => this._OnProgress(o, e2), a["upload"]["onprogress"] = (e2) => this._OnUploadProgress(o, e2), a.open(e, u), 0 <= this._timeout && void 0 !== a["timeout"] && (a["timeout"] = this._timeout), a.responseType = r ? "arraybuffer" : "text", l && !this._nextRequestHeaders.has("Content-Type") && ("string" != typeof l ? a["setRequestHeader"]("Content-Type", "application/octet-stream") : a["setRequestHeader"]("Content-Type", "application/x-www-form-urlencoded"));
                for (const [i, n] of this._nextRequestHeaders) try {
                  a["setRequestHeader"](i, n);
                } catch (e2) {
                  console.error(`[Construct] AJAX: Failed to set header '${i}: ${n}': `, e2);
                }
                if (this._nextRequestHeaders.clear(), this._nextRequestOverrideMimeType) {
                  try {
                    a["overrideMimeType"](this._nextRequestOverrideMimeType);
                  } catch (e2) {
                    console.error("[Construct] AJAX: failed to override MIME type: ", e2);
                  }
                  this._nextRequestOverrideMimeType = "";
                }
                this._nextRequestWithCredentials && (a.withCredentials = true, this._nextRequestWithCredentials = false), l ? a.send(l) : a.send();
              } catch (e2) {
                s(e2);
              }
            });
          }
          GetDebuggerProperties() {
            const e = "plugins.ajax.debugger";
            return [{ title: e + ".title", properties: [{ name: e + ".last-status-code", value: this._lastStatusCode }, { name: e + ".last-data", value: this._lastData }] }];
          }
          SaveToJson() {
            return { "lastData": this._lastData, "lastStatusCode": this._lastStatusCode };
          }
          LoadFromJson(e) {
            this._lastData = e["lastData"], this._lastStatusCode = e.hasOwnProperty("lastStatusCode") ? e["lastStatusCode"] : 0, this._curTag = "", this._progress = 0;
          }
        };
      }
      {
        const $ = self.C3;
        $.Plugins.AJAX.Cnds = { OnComplete(e) {
          return $.equalsNoCase(this._curTag, e);
        }, OnAnyComplete() {
          return true;
        }, OnError(e) {
          return $.equalsNoCase(this._curTag, e);
        }, OnAnyError() {
          return true;
        }, OnProgress(e) {
          return $.equalsNoCase(this._curTag, e);
        }, OnUploadProgress(e) {
          return $.equalsNoCase(this._curTag, e);
        } };
      }
      {
        const da = self.C3;
        da.Plugins.AJAX.Acts = { async Request(e, t) {
          this._runtime.IsCordova() && da.IsRelativeURL(t) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(e, t) : await this._DoRequest(e, t, "GET", null);
        }, async RequestFile(e, t) {
          this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(e, t) : await this._DoRequest(e, t, "GET", null);
        }, async Post(e, t, s, r) {
          await this._DoRequest(e, t, r, s);
        }, async PostBinary(e, t, s, r) {
          if (s) {
            const a = s.GetFirstPicked(this._inst);
            if (a) {
              const i = a.GetSdkInstance(), n = i.GetArrayBufferReadOnly();
              await this._DoRequest(e, t, r, n);
            }
          }
        }, SetTimeout(e) {
          this._timeout = 1e3 * e;
        }, SetHeader(e, t) {
          this._nextRequestHeaders.set(e, t);
        }, SetResponseBinary(e) {
          if (e) {
            const t = e.GetFirstPicked(this._inst);
            t && (this._nextReponseBinaryData = t.GetSdkInstance());
          }
        }, OverrideMIMEType(e) {
          this._nextRequestOverrideMimeType = e;
        }, SetWithCredentials(e) {
          this._nextRequestWithCredentials = !!e;
        } };
      }
      {
        const Aa = self.C3;
        Aa.Plugins.AJAX.Exps = { LastData() {
          return this._lastData;
        }, LastStatusCode() {
          return this._lastStatusCode;
        }, Progress() {
          return this._progress;
        }, Tag() {
          return this._curTag;
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Clipboard = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Clipboard.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = "clipboard";
        g.Plugins.Clipboard.Instance = class extends g.SDKInstanceBase {
          constructor(e, s) {
            super(e, h), this._copyResolve = null, this._requestPasteResolve = null, this._pastedText = "", this._pastedBinaryArrayBuffer = null, this._pastedBinaryType = "", this.AddDOMMessageHandlers([["copy-result", (e2) => this._OnCopyResult(e2)], ["request-paste-text-result", (e2) => this._OnRequestPasteTextResult(e2)], ["request-paste-binary-result", (e2) => this._OnRequestPasteBinaryResult(e2)], ["window-paste-text", (e2) => this._OnWindowPasteText(e2)], ["window-paste-binary", (e2) => this._OnWindowPasteBinary(e2)]]);
          }
          GetPastedText() {
            return this._pastedText;
          }
          async _OnCopyResult(e) {
            this._copyResolve && (this._copyResolve(), this._copyResolve = null), e["isOk"] ? await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnCopySuccess) : await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnCopyError);
          }
          async _OnRequestPasteTextResult(e) {
            this._requestPasteResolve && (this._requestPasteResolve(), this._requestPasteResolve = null), e["isOk"] ? (this._pastedText = e["text"], await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteText)) : await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteError);
          }
          async _OnRequestPasteBinaryResult(e) {
            if (this._requestPasteResolve && (this._requestPasteResolve(), this._requestPasteResolve = null), e["isOk"]) {
              for (const [s, t] of e["binary"]) this._pastedBinaryType = s, this._pastedBinaryArrayBuffer = t, await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteBinary);
              this._pastedBinaryType = "", this._pastedBinaryArrayBuffer = null;
            } else await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteError);
          }
          async _OnWindowPasteText(e) {
            this._pastedText = e["text"], await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteText);
          }
          async _OnWindowPasteBinary(e) {
            this._pastedBinaryType = e["type"], this._pastedBinaryArrayBuffer = e["arrayBuffer"], await this.TriggerAsync(g.Plugins.Clipboard.Cnds.OnPasteBinary), this._pastedBinaryType = "", this._pastedBinaryArrayBuffer = null;
          }
        };
      }
      {
        const x = self.C3;
        x.Plugins.Clipboard.Cnds = { OnCopySuccess() {
          return true;
        }, OnCopyError() {
          return true;
        }, OnPasteText() {
          return true;
        }, OnPasteBinary(e, s) {
          if (!x.equalsNoCase(this._pastedBinaryType, s)) return false;
          if (!e) return false;
          const t = e.GetFirstPicked(this._inst);
          if (!t) return false;
          const r = t.GetSdkInstance();
          return r.SetArrayBufferCopy(this._pastedBinaryArrayBuffer), true;
        }, OnPasteError() {
          return true;
        } };
      }
      {
        const C = self.C3;
        C.Plugins.Clipboard.Acts = { CopyText(e) {
          return this._PostToDOMMaybeSync("copy-text", { "text": e }), new Promise((e2) => this._copyResolve = e2);
        }, CopyBinary(e, s) {
          if (e) {
            const t = e.GetFirstPicked(this._inst);
            if (t) {
              const r = t.GetSdkInstance();
              return this._PostToDOMMaybeSync("copy-binary", { "arrayBuffer": r.GetArrayBufferReadOnly(), "type": s }), new Promise((e2) => this._copyResolve = e2);
            }
          }
        }, RequestPasteText() {
          return this._PostToDOMMaybeSync("request-paste-text"), new Promise((e) => this._requestPasteResolve = e);
        }, RequestPasteBinary() {
          return this._PostToDOMMaybeSync("request-paste-binary"), new Promise((e) => this._requestPasteResolve = e);
        } };
      }
      {
        const M = self.C3;
        M.Plugins.Clipboard.Exps = { PastedText() {
          return this._pastedText;
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.LocalStorage = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.LocalStorage.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = "localstorage";
        g.Plugins.LocalStorage.Instance = class extends g.SDKInstanceBase {
          constructor(e, t) {
            super(e, h), this._currentKey = "", this._lastValue = "", this._keyNamesList = [], this._errorMessage = "", this._isPersistent = false, this._pendingGets = 0, this._pendingSets = 0, this._isInMemoryOnly = false, t && (this._isInMemoryOnly = t[0]);
            const s = this._runtime._GetProjectStorage();
            this._storage = null, this._isInMemoryOnly ? this._storage = s.createInstance({ forceInMemoryFallback: true }) : this._storage = s, this._debugCache = /* @__PURE__ */ new Map(), this._isLoadingDebugCache = false, this._runtime.AddLoadPromise(this._Init());
          }
          async _Init() {
            const e = await Promise.race([this.PostToDOMAsync("init"), g.Wait(3e3)]);
            e && (this._isPersistent = e["isPersistent"]);
          }
          Release() {
            super.Release();
          }
          async _TriggerStorageError(e) {
            this._errorMessage = this._GetErrorString(e), await this.TriggerAsync(g.Plugins.LocalStorage.Cnds.OnError);
          }
          _GetErrorString(e) {
            return e ? "string" == typeof e ? e : "string" == typeof e.message ? e.message : "string" == typeof e.name ? e.name : "string" == typeof e.data ? e.data : "unknown error" : "unknown error";
          }
          GetDebuggerProperties() {
            return this._isLoadingDebugCache || this._DebugCacheStorage(), [{ title: "plugins.localstorage.name", properties: [...this._debugCache.entries()].map((t) => ({ name: "$" + t[0], value: t[1], onedit: (e) => this._storage.setItem(t[0], e) })) }];
          }
          async _DebugCacheStorage() {
            this._isLoadingDebugCache = true;
            try {
              const s = await this._storage.keys(), r = (s.sort((e, t) => {
                const s2 = e.toLowerCase(), r2 = t.toLowerCase();
                return s2 < r2 ? -1 : r2 < s2 ? 1 : 0;
              }), await Promise.all(s.map((e) => this._storage.getItem(e))));
              this._debugCache.clear();
              for (let e = 0, t = s.length; e < t; ++e) this._debugCache.set(s[e], r[e]);
            } catch (e) {
              console.warn("[C3 debugger] Error displaying local storage: ", e);
            } finally {
              this._isLoadingDebugCache = false;
            }
          }
        };
      }
      {
        const B = self.C3;
        B.Plugins.LocalStorage.Cnds = { OnItemSet(e) {
          return this._currentKey === e;
        }, OnAnyItemSet() {
          return true;
        }, OnItemGet(e) {
          return this._currentKey === e;
        }, OnAnyItemGet() {
          return true;
        }, OnItemRemoved(e) {
          return this._currentKey === e;
        }, OnAnyItemRemoved() {
          return true;
        }, OnCleared() {
          return true;
        }, OnAllKeyNamesLoaded() {
          return true;
        }, OnError() {
          return true;
        }, OnItemExists(e) {
          return this._currentKey === e;
        }, OnItemMissing(e) {
          return this._currentKey === e;
        }, CompareKey(e, t) {
          return B.compare(this._currentKey, e, t);
        }, CompareValue(e, t) {
          return B.compare(this._lastValue, e, t);
        }, IsProcessingSets() {
          return 0 < this._pendingSets;
        }, IsProcessingGets() {
          return 0 < this._pendingGets;
        }, OnAllSetsComplete() {
          return true;
        }, OnAllGetsComplete() {
          return true;
        }, IsPersistent() {
          return this._isPersistent;
        } };
      }
      {
        let IsExpressionType2 = function(e) {
          return "string" == typeof e || "number" == typeof e;
        };
        IsExpressionType = IsExpressionType2;
        const L = self.C3;
        L.Plugins.LocalStorage.Acts = { async SetItem(e, t) {
          this._pendingSets++;
          try {
            const s = await this._storage.setItem(e, t);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = s, await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAnyItemSet), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemSet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAllSetsComplete);
          }
        }, async SetBinaryItem(e, t) {
          if (t) {
            const s = t.GetFirstPicked(this._inst);
            if (s) {
              const r = s.GetSdkInstance();
              if (r) {
                const i = r.GetArrayBufferReadOnly();
                this._pendingSets++;
                try {
                  await this._storage.setItem(e, i), await this.ScheduleTriggers(async () => {
                    this._currentKey = e, this._lastValue = "", await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAnyItemSet), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemSet);
                  });
                } catch (e2) {
                  await this._TriggerStorageError(e2);
                } finally {
                  this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAllSetsComplete);
                }
              }
            }
          }
        }, async GetItem(e) {
          this._pendingGets++;
          try {
            const t = await this._storage.getItem(e);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = IsExpressionType2(t) ? t : "", await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAnyItemGet), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemGet);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          } finally {
            this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAllGetsComplete);
          }
        }, async GetBinaryItem(t, e) {
          if (e) {
            const s = e.GetFirstPicked(this._inst);
            if (s) {
              const r = s.GetSdkInstance();
              this._pendingGets++;
              try {
                let e2 = await this._storage.getItem(t);
                e2 = e2 instanceof ArrayBuffer ? e2 : new ArrayBuffer(0), await this.ScheduleTriggers(async () => {
                  this._lastValue = "", this._currentKey = t, r.SetArrayBufferTransfer(e2), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAnyItemGet), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemGet);
                });
              } catch (e2) {
                await this._TriggerStorageError(e2);
              } finally {
                this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAllGetsComplete);
              }
            }
          }
        }, async CheckItemExists(e) {
          try {
            const t = await this._storage.getItem(e);
            await this.ScheduleTriggers(async () => {
              this._currentKey = e, null == t ? (this._lastValue = "", await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = IsExpressionType2(t) ? t : "", await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemExists));
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          }
        }, async RemoveItem(e) {
          try {
            await this._storage.removeItem(e), await this.ScheduleTriggers(async () => {
              this._currentKey = e, this._lastValue = "", await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAnyItemRemoved), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnItemRemoved);
            });
          } catch (e2) {
            await this._TriggerStorageError(e2);
          }
        }, async ClearStorage() {
          try {
            await this._storage.clear(), await this.ScheduleTriggers(async () => {
              this._currentKey = "", this._lastValue = "", L.clearArray(this._keyNamesList), await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnCleared);
            });
          } catch (e) {
            await this._TriggerStorageError(e);
          }
        }, async GetAllKeyNames() {
          try {
            const e = await this._storage.keys();
            await this.ScheduleTriggers(async () => {
              this._keyNamesList = e, await this.TriggerAsync(L.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded);
            });
          } catch (e) {
            await this._TriggerStorageError(e);
          }
        }, async RequestPersistent() {
          const e = await this.PostToDOMAsync("request-persistent");
          e["isOk"] && (this._isPersistent = e["isPersistent"]);
        }, LoadMemoryFromJSON(t) {
          if (this._isInMemoryOnly) {
            let e;
            try {
              e = JSON.parse(t);
            } catch (e2) {
              return void console.error("[Local Storage] Failed to parse memory storage JSON: ", e2);
            }
            e && e["is-c3-storage"] && Array.isArray(e["items"]) || console.error("[Local Storage] Failed to load memory storage JSON: invalid data"), this._storage.SetMemoryStorage(new Map(e["items"]));
          }
        } };
      }
      {
        const qa = self.C3;
        qa.Plugins.LocalStorage.Exps = { ItemValue() {
          return this._lastValue;
        }, Key() {
          return this._currentKey;
        }, KeyCount() {
          return this._keyNamesList.length;
        }, KeyAt(e) {
          return (e = Math.floor(e)) < 0 || e >= this._keyNamesList.length ? "" : this._keyNamesList[e];
        }, ErrorMessage() {
          return this._errorMessage;
        }, MemoryStorageAsJSON() {
          return this._isInMemoryOnly ? JSON.stringify({ "is-c3-storage": true, "items": [...this._storage.GetMemoryStorage()] }) : "";
        } };
      }
    }
    var IsExpressionType;
    {
      {
        const a = self.C3, b = "text-input";
        a.Plugins.TextBox = class extends a.SDKDOMPluginBase {
          constructor(t) {
            super(t, b), this.AddElementMessageHandler("click", (t2, e) => t2._OnClick(e)), this.AddElementMessageHandler("dblclick", (t2, e) => t2._OnDoubleClick(e)), this.AddElementMessageHandler("change", (t2, e) => t2._OnChange(e));
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const k = self.C3;
        k.Plugins.TextBox.Type = class extends k.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const n = self.C3, o = self.C3X, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 8, y = 9, z = 10, A = "text-input", B = ["text", "password", "email", "number", "tel", "url", "textarea", "search"], C = (n.Plugins.TextBox.Instance = class extends n.SDKDOMInstanceBase {
          constructor(e, i) {
            super(e, A), this._text = "", this._placeholder = "", this._title = "", this._isEnabled = true, this._isReadOnly = false, this._spellCheck = false, this._type = "text", this._autoFontSize = true, this._maxLength = -1, this._id = "", this._className = "", i && (this._text = i[p], this._placeholder = i[q], this._title = i[r], this.GetWorldInfo().SetVisible(i[s]), this._isEnabled = i[t], this._isReadOnly = i[u], this._spellCheck = i[v], this._type = B[i[w]], this._autoFontSize = i[x], this._id = i[y], this._className = i[z]), this.CreateElement({ "type": this._type, "id": this._id, "className": this._className });
          }
          Release() {
            super.Release();
          }
          GetElementState() {
            return { "text": this._text, "placeholder": this._placeholder, "title": this._title, "isEnabled": this._isEnabled, "isReadOnly": this._isReadOnly, "spellCheck": this._spellCheck, "maxLength": this._maxLength };
          }
          async _OnClick(t2) {
            this.DispatchScriptEvent("click", true), await this.TriggerAsync(n.Plugins.TextBox.Cnds.OnClicked);
          }
          async _OnDoubleClick(t2) {
            this.DispatchScriptEvent("dblclick", true), await this.TriggerAsync(n.Plugins.TextBox.Cnds.OnDoubleClicked);
          }
          async _OnChange(t2) {
            this._text = t2["text"], this.DispatchScriptEvent("change", true), await this.TriggerAsync(n.Plugins.TextBox.Cnds.OnTextChanged);
          }
          _SetText(t2) {
            this._text !== t2 && (this._text = t2, this.UpdateElementState());
          }
          _GetText() {
            return this._text;
          }
          _SetPlaceholder(t2) {
            this._placeholder !== t2 && (this._placeholder = t2, this.UpdateElementState());
          }
          _GetPlaceholder() {
            return this._placeholder;
          }
          _SetTooltip(t2) {
            this._title !== t2 && (this._title = t2, this.UpdateElementState());
          }
          _GetTooltip() {
            return this._title;
          }
          _SetEnabled(t2) {
            this._isEnabled !== (t2 = !!t2) && (this._isEnabled = t2, this.UpdateElementState());
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          _SetReadOnly(t2) {
            this._isReadOnly !== (t2 = !!t2) && (this._isReadOnly = t2, this.UpdateElementState());
          }
          _IsReadOnly() {
            return this._isReadOnly;
          }
          _SetMaxLength(t2) {
            t2 = Math.max(+t2, -1), this._maxLength !== t2 && (this._maxLength = t2, this.UpdateElementState());
          }
          _GetMaxLength() {
            return this._maxLength;
          }
          _ScrollToBottom() {
            Promise.resolve().then(() => this.PostToDOMElement("scroll-to-bottom"));
          }
          Draw(t2) {
          }
          SaveToJson() {
            return { "t": this._text, "p": this._placeholder, "ti": this._title, "e": this._isEnabled, "r": this._isReadOnly, "sp": this._spellCheck, "ml": this._maxLength, "type": this._type, "id": this._id };
          }
          LoadFromJson(t2) {
            this._text = t2["t"], this._placeholder = t2["p"], this._title = t2["ti"], this._isEnabled = t2["e"], this._isReadOnly = t2["r"], this._spellCheck = t2["sp"], this._maxLength = t2.hasOwnProperty("ml") ? t2["ml"] : -1, this._type = t2["type"], this._id = t2["id"], this.UpdateElementState();
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case p:
                return this._text;
              case q:
                return this._placeholder;
              case r:
                return this._title;
              case t:
                return this._isEnabled;
              case u:
                return this._isReadOnly;
              case v:
                return this._spellCheck;
              case x:
                return this._autoFontSize;
            }
          }
          SetPropertyValueByIndex(e, s2) {
            switch (e) {
              case p:
                this._text !== s2 && (this._text = s2, this.UpdateElementState());
                break;
              case q:
                this._placeholder !== s2 && (this._placeholder = s2, this.UpdateElementState());
                break;
              case r:
                this._title !== s2 && (this._title = s2, this.UpdateElementState());
                break;
              case t:
                this._isEnabled !== !!s2 && (this._isEnabled = !!s2, this.UpdateElementState());
                break;
              case u:
                this._isReadOnly !== !!s2 && (this._isReadOnly = !!s2, this.UpdateElementState());
                break;
              case v:
                this._spellCheck !== !!s2 && (this._spellCheck = !!s2, this.UpdateElementState());
                break;
              case x:
                this._autoFontSize = !!s2;
            }
          }
          GetDebuggerProperties() {
            const e = n.Plugins.TextBox.Acts, t2 = "plugins.textbox";
            return [{ title: t2 + ".name", properties: [{ name: t2 + ".properties.text.name", value: this._text, onedit: (t3) => this.CallAction(e.SetText, t3) }, { name: t2 + ".properties.enabled.name", value: this._isEnabled, onedit: (t3) => this.CallAction(e.SetEnabled, t3) }, { name: t2 + ".properties.read-only.name", value: this._isReadOnly, onedit: (t3) => this.CallAction(e.SetReadOnly, t3) }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITextInputInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.ITextInputInstance = class extends self.IDOMInstance {
          constructor() {
            super(), C.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set text(t2) {
            o.RequireString(t2), C.get(this)._SetText(t2);
          }
          get text() {
            return C.get(this)._GetText();
          }
          set placeholder(t2) {
            o.RequireString(t2), C.get(this)._SetPlaceholder(t2);
          }
          get placeholder() {
            return C.get(this)._GetPlaceholder();
          }
          set tooltip(t2) {
            o.RequireString(t2), C.get(this)._SetTooltip(t2);
          }
          get tooltip() {
            return C.get(this)._GetTooltip();
          }
          set isEnabled(t2) {
            C.get(this)._SetEnabled(t2);
          }
          get isEnabled() {
            return C.get(this)._IsEnabled();
          }
          set isReadOnly(t2) {
            C.get(this)._SetReadOnly(t2);
          }
          get isReadOnly() {
            return C.get(this)._IsReadOnly();
          }
          set maxLength(t2) {
            o.RequireFiniteNumber(t2), C.get(this)._SetMaxLength(t2);
          }
          get maxLength() {
            return C.get(this)._GetMaxLength();
          }
          scrollToBottom() {
            C.get(this)._ScrollToBottom();
          }
        };
      }
      {
        const ea = self.C3;
        ea.Plugins.TextBox.Cnds = { CompareText(t, e) {
          return 0 === e ? ea.equalsNoCase(this._text, t) : this._text === t;
        }, OnTextChanged() {
          return true;
        }, OnClicked() {
          return true;
        }, OnDoubleClicked() {
          return true;
        } };
      }
      {
        const ha = self.C3;
        ha.Plugins.TextBox.Acts = { SetText(t) {
          this._SetText(t.toString());
        }, AppendText(t) {
          "" !== t && this._SetText(this._GetText() + t);
        }, SetPlaceholder(t) {
          this._SetPlaceholder(t);
        }, SetTooltip(t) {
          this._SetTooltip(t);
        }, SetReadOnly(t) {
          this._SetReadOnly(0 === t);
        }, ScrollToBottom() {
          this._ScrollToBottom();
        }, SetMaxLength(t) {
          this._SetMaxLength(t);
        } };
      }
      {
        const oa = self.C3;
        oa.Plugins.TextBox.Exps = { Text() {
          return this._GetText();
        }, MaxLength() {
          return this._GetMaxLength();
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.Date = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Date.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3;
        g.Plugins.Date.Instance = class extends g.SDKInstanceBase {
          constructor(e, t) {
            super(e);
          }
        };
      }
      {
        const k = self.C3, l = [], m = (l[0] = [(e) => k.Plugins.Date.Exps.GetYear(e), (e) => k.Plugins.Date.Exps.GetMonth(e), (e) => k.Plugins.Date.Exps.GetDate(e), (e) => k.Plugins.Date.Exps.GetDay(e), (e) => k.Plugins.Date.Exps.GetHours(e), (e) => k.Plugins.Date.Exps.GetMinutes(e), (e) => k.Plugins.Date.Exps.GetSeconds(e), (e) => k.Plugins.Date.Exps.GetMilliseconds(e)], l[1] = [(e) => k.Plugins.Date.Exps.GetUTCYear(e), (e) => k.Plugins.Date.Exps.GetUTCMonth(e), (e) => k.Plugins.Date.Exps.GetUTCDate(e), (e) => k.Plugins.Date.Exps.GetUTCDay(e), (e) => k.Plugins.Date.Exps.GetUTCHours(e), (e) => k.Plugins.Date.Exps.GetUTCMinutes(e), (e) => k.Plugins.Date.Exps.GetUTCSeconds(e), (e) => k.Plugins.Date.Exps.GetUTCMilliseconds(e)], (e) => k.Plugins.Date.Exps.Parse(e));
        k.Plugins.Date.Cnds = { CompareTimeStamps(e, t, n) {
          return k.compare(e, t, n);
        }, CompareDateStrings(e, t, n) {
          return k.compare(m(e), t, m(n));
        }, CompareTimestampParts(e, t, n, s) {
          return k.compare(l[1][s](e), t, l[1][s](n));
        }, CompareDateStringParts(e, t, n, s, a) {
          return k.compare(l[a][s](m(e)), t, l[a][s](m(n)));
        } };
      }
      {
        const T = self.C3;
        T.Plugins.Date.Acts = {};
      }
      {
        const U = self.C3, V = self.Intl, W = /* @__PURE__ */ new Map(), X = (W.set("local", /* @__PURE__ */ new Map([["year", (e) => new Date(e).getFullYear()], ["month", (e) => new Date(e).getMonth()], ["date", (e) => new Date(e).getDate()], ["day", (e) => new Date(e).getDay()], ["hours", (e) => new Date(e).getHours()], ["minutes", (e) => new Date(e).getMinutes()], ["seconds", (e) => new Date(e).getSeconds()], ["milliseconds", (e) => new Date(e).getMilliseconds()]])), W.set("universal", /* @__PURE__ */ new Map([["year", (e) => new Date(e).getUTCFullYear()], ["month", (e) => new Date(e).getUTCMonth()], ["date", (e) => new Date(e).getUTCDate()], ["day", (e) => new Date(e).getUTCDay()], ["hours", (e) => new Date(e).getUTCHours()], ["minutes", (e) => new Date(e).getUTCMinutes()], ["seconds", (e) => new Date(e).getUTCSeconds()], ["milliseconds", (e) => new Date(e).getUTCMilliseconds()]])), /* @__PURE__ */ new Map()), Y = (X.set("local", /* @__PURE__ */ new Map([["year", (e, t) => new Date(e).setFullYear(t)], ["month", (e, t) => new Date(e).setMonth(t)], ["date", (e, t) => new Date(e).setDate(t)], ["hours", (e, t) => new Date(e).setHours(t)], ["minutes", (e, t) => new Date(e).setMinutes(t)], ["seconds", (e, t) => new Date(e).setSeconds(t)], ["milliseconds", (e, t) => new Date(e).setMilliseconds(t)]])), X.set("universal", /* @__PURE__ */ new Map([["year", (e, t) => new Date(e).setUTCFullYear(t)], ["month", (e, t) => new Date(e).setUTCMonth(t)], ["date", (e, t) => new Date(e).setUTCDate(t)], ["hours", (e, t) => new Date(e).setUTCHours(t)], ["minutes", (e, t) => new Date(e).setUTCMinutes(t)], ["seconds", (e, t) => new Date(e).setUTCSeconds(t)], ["milliseconds", (e, t) => new Date(e).setUTCMilliseconds(t)]])), function(e, t, n, s) {
          n.includes(e) && (s[t] = e);
        }), Z = function(e, t) {
          e && ("12" === e ? t["hour12"] = true : "24" === e && (t["hour12"] = false));
        }, $ = function(e) {
          try {
            return V.getCanonicalLocales(e);
          } catch (e2) {
            return self.navigator.language;
          }
        }, _ = ["full", "long", "medium", "short"], aa = ["full", "long", "medium", "short"], ba = ["long", "short", "narrow"], ca = ["numeric", "2-digit"], da = ["numeric", "2-digit", "long", "short", "narrow"], ea = ["numeric", "2-digit"], fa = ["numeric", "2-digit"], ga = ["numeric", "2-digit"], ha = ["numeric", "2-digit"];
        U.Plugins.Date.Exps = { ToString(e) {
          return new Date(e).toString();
        }, ToDateString(e) {
          return new Date(e).toDateString();
        }, ToTimeString(e) {
          return new Date(e).toTimeString();
        }, ToLocaleString(e) {
          return new Date(e).toLocaleString();
        }, ToLocaleDateString(e) {
          return new Date(e).toLocaleDateString();
        }, ToLocaleTimeString(e) {
          return new Date(e).toLocaleTimeString();
        }, ToUTCString(e) {
          return new Date(e).toUTCString();
        }, Parse(e) {
          return Date.parse(e);
        }, Get(e, t, n, s, a, r, l) {
          return Date.UTC(e, t, n, s, a, r, l);
        }, Now() {
          return Date.now();
        }, TimezoneOffset() {
          return new Date(Date.now()).getTimezoneOffset();
        }, GetYear(e) {
          return W.get("local").get("year")(e);
        }, GetUTCYear(e) {
          return W.get("universal").get("year")(e);
        }, GetMonth(e) {
          return W.get("local").get("month")(e);
        }, GetUTCMonth(e) {
          return W.get("universal").get("month")(e);
        }, GetDate(e) {
          return W.get("local").get("date")(e);
        }, GetUTCDate(e) {
          return W.get("universal").get("date")(e);
        }, GetDay(e) {
          return W.get("local").get("day")(e);
        }, GetUTCDay(e) {
          return W.get("universal").get("day")(e);
        }, GetHours(e) {
          return W.get("local").get("hours")(e);
        }, GetUTCHours(e) {
          return W.get("universal").get("hours")(e);
        }, GetMinutes(e) {
          return W.get("local").get("minutes")(e);
        }, GetUTCMinutes(e) {
          return W.get("universal").get("minutes")(e);
        }, GetSeconds(e) {
          return W.get("local").get("seconds")(e);
        }, GetUTCSeconds(e) {
          return W.get("universal").get("seconds")(e);
        }, GetMilliseconds(e) {
          return W.get("local").get("milliseconds")(e);
        }, GetUTCMilliseconds(e) {
          return W.get("universal").get("milliseconds")(e);
        }, ChangeYear(e, t) {
          return X.get("local").get("year")(e, t);
        }, ChangeUTCYear(e, t) {
          return X.get("universal").get("year")(e, t);
        }, ChangeMonth(e, t) {
          return X.get("local").get("month")(e, t);
        }, ChangeUTCMonth(e, t) {
          return X.get("universal").get("month")(e, t);
        }, ChangeDate(e, t) {
          return X.get("local").get("date")(e, t);
        }, ChangeUTCDate(e, t) {
          return X.get("universal").get("date")(e, t);
        }, ChangeDay(e, t) {
          const n = U.Plugins.Date.Exps.GetYear(e), s = U.Plugins.Date.Exps.GetMonth(e), a = U.Plugins.Date.Exps.GetDate(e), r = U.Plugins.Date.Exps.GetHours(e), l = U.Plugins.Date.Exps.GetMinutes(e), i = U.Plugins.Date.Exps.GetSeconds(e), u = U.Plugins.Date.Exps.GetMilliseconds(e), o = U.Plugins.Date.Exps.GetDay(e), g = t - o;
          return new Date(n, s, a + g, r, l, i, u).getTime();
        }, ChangeUTCDay(e, t) {
          const n = U.Plugins.Date.Exps.GetUTCYear(e), s = U.Plugins.Date.Exps.GetUTCMonth(e), a = U.Plugins.Date.Exps.GetUTCDate(e), r = U.Plugins.Date.Exps.GetUTCHours(e), l = U.Plugins.Date.Exps.GetUTCMinutes(e), i = U.Plugins.Date.Exps.GetUTCSeconds(e), u = U.Plugins.Date.Exps.GetUTCMilliseconds(e), o = U.Plugins.Date.Exps.GetUTCDay(e), g = t - o;
          return U.Plugins.Date.Exps.Get(n, s, a + g, r, l, i, u);
        }, ChangeHours(e, t) {
          return X.get("local").get("hours")(e, t);
        }, ChangeUTCHours(e, t) {
          return X.get("universal").get("hours")(e, t);
        }, ChangeMinutes(e, t) {
          return X.get("local").get("minutes")(e, t);
        }, ChangeUTCMinutes(e, t) {
          return X.get("universal").get("minutes")(e, t);
        }, ChangeSeconds(e, t) {
          return X.get("local").get("seconds")(e, t);
        }, ChangeUTCSeconds(e, t) {
          return X.get("universal").get("seconds")(e, t);
        }, ChangeMilliseconds(e, t) {
          return X.get("local").get("milliseconds")(e, t);
        }, ChangeUTCMilliseconds(e, t) {
          return X.get("universal").get("milliseconds")(e, t);
        }, Difference(e, t) {
          return t - e;
        }, ToTimerHours(e) {
          return Math.trunc(U.Plugins.Date.Exps.ToTotalHours(e));
        }, ToTimerMinutes(e) {
          return Math.trunc(U.Plugins.Date.Exps.ToTotalMinutes(e)) % 60;
        }, ToTimerSeconds(e) {
          return Math.trunc(U.Plugins.Date.Exps.ToTotalSeconds(e)) % 60;
        }, ToTimerMilliseconds(e) {
          return e % 1e3;
        }, ToTotalHours(e) {
          return e / 36e5;
        }, ToTotalMinutes(e) {
          return e / 6e4;
        }, ToTotalSeconds(e) {
          return e / 1e3;
        }, FormatDateWithStyles(e, t, n, s, a) {
          const r = $(e);
          if (r) {
            let e2 = {};
            return Y.call(this, n, "dateStyle", _, e2), Y.call(this, s, "timeStyle", aa, e2), Z.call(this, a, e2), new V.DateTimeFormat(r, e2).format(t);
          }
        }, FormatDateWithComponents(e, t, n, s, a, r, l, i, u, o) {
          const g = $(e);
          if (g) {
            const c = {};
            return Y.call(this, n, "weekday", ba, c), Y.call(this, s, "year", ca, c), Y.call(this, a, "month", da, c), Y.call(this, r, "day", ea, c), Y.call(this, l, "hour", fa, c), Y.call(this, i, "minute", ga, c), Y.call(this, u, "second", ha, c), Z.call(this, o, c), new V.DateTimeFormat(g, c).format(t);
          }
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Plugins.qrcode = class extends a.SDKPluginBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.qrcode.Type = class extends d.SDKTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = g.New(g.Rect);
        let r = false;
        g.Plugins.qrcode.Instance = class extends g.SDKWorldInstanceBase {
          constructor(e, t) {
            super(e), this._text = "", this._correctionLevel = "h", t && (this._text = t[0], this._correctionLevel = ["l", "m", "q", "h"][t[1]], this.GetWorldInfo().SetVisible(t[2]));
            const r2 = this._runtime.Dispatcher();
            this._disposables = new g.CompositeDisposable(g.Disposable.From(r2, "renderercontextlost", () => this._OnRendererContextLost())), this._qrTexture = null;
          }
          Release() {
            this._ReleaseTexture(), super.Release();
          }
          _GetQRCodeCorrectionLevel(e) {
            const t = self.C3_QRCode.CorrectLevel;
            switch (e) {
              case "l":
                return t.L;
              case "m":
                return t.M;
              case "q":
                return t.Q;
              case "h":
                return t.H;
              default:
                throw new Error(`unknown correction level '${e}'`);
            }
          }
          _GenerateQRCodeTexture(e) {
            this._ReleaseTexture();
            try {
              const t = new self.C3_QRCode(null, { width: 512, height: 512, text: this._text, correctLevel: this._GetQRCodeCorrectionLevel(this._correctionLevel) });
              this._qrTexture = e.CreateStaticTexture(t.getCanvas(), { sampling: "nearest" });
            } catch (e2) {
              r || (console.error(`Unable to create QR code with text length ${this._text.length}: `, e2), r = true);
            }
          }
          _ReleaseTexture() {
            this._qrTexture && (this._runtime.GetRenderer().DeleteTexture(this._qrTexture), this._qrTexture = null);
          }
          _OnRendererContextLost() {
            this._qrTexture = null;
          }
          Draw(e) {
            this._qrTexture || this._GenerateQRCodeTexture(e);
            const t = this.GetWorldInfo(), r2 = t.GetBoundingBox(), s = Math.min(r2.width(), r2.height());
            i.setWH(r2.getLeft(), r2.getTop(), s, s), e.SetTexture(this._qrTexture), e.Rect(i);
          }
          _SetText(e) {
            this._text !== e && (this._text = e, this._ReleaseTexture(), this._runtime.UpdateRender());
          }
          _GetText() {
            return this._text;
          }
          _SetCorrectionLevel(e) {
            this._correctionLevel !== e && (this._correctionLevel = e, this._ReleaseTexture(), this._runtime.UpdateRender());
          }
          _GetCorrectionLevel(e) {
            return this._correctionLevel;
          }
          GetDebuggerProperties() {
            const e = "plugins.qrcode", t = e + ".properties";
            return [{ title: e + ".name", properties: [{ name: t + ".text.name", value: this._GetText(), onedit: (e2) => this._SetText(e2) }, { name: t + ".correction-level.name", value: this._GetCorrectionLevel().toUpperCase() }] }];
          }
          GetScriptInterfaceClass() {
            return self.IQRCodeInstance;
          }
        };
        const k = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new Set(["l", "m", "q", "h"]);
        self.IQRCodeInstance = class extends self.IWorldInstance {
          constructor() {
            super(), k.set(this, self.IInstance._GetInitInst().GetSdkInstance());
          }
          set text(e) {
            h.RequireString(e), k.get(this)._SetText(e);
          }
          get text() {
            return k.get(this)._GetText();
          }
          set correctionLevel(e) {
            if (!l.has(e)) throw new Error(`invalid correction level '${e}'`);
            k.get(this)._SetCorrectionLevel(e);
          }
          get correctionLevel() {
            return k.get(this)._GetCorrectionLevel();
          }
        };
      }
      {
        const I = self.C3;
        I.Plugins.qrcode.Cnds = {};
      }
      {
        const J = self.C3;
        J.Plugins.qrcode.Acts = { SetText(e) {
          this._SetText(e);
        }, SetCorrectionLevel(e) {
          this._SetCorrectionLevel(["l", "m", "q", "h"][e]);
        } };
      }
      {
        const M = self.C3;
        M.Plugins.qrcode.Exps = {};
      }
    }
    {
      !function() {
        function e(t2) {
          this.mode = i.MODE_8BIT_BYTE, this.data = t2, this.parsedData = [];
          for (var e2 = 0, r2 = this.data.length; e2 < r2; e2++) {
            var o2 = [], n2 = this.data.charCodeAt(e2);
            65536 < n2 ? (o2[0] = 240 | (1835008 & n2) >>> 18, o2[1] = 128 | (258048 & n2) >>> 12, o2[2] = 128 | (4032 & n2) >>> 6, o2[3] = 128 | 63 & n2) : 2048 < n2 ? (o2[0] = 224 | (61440 & n2) >>> 12, o2[1] = 128 | (4032 & n2) >>> 6, o2[2] = 128 | 63 & n2) : 128 < n2 ? (o2[0] = 192 | (1984 & n2) >>> 6, o2[1] = 128 | 63 & n2) : o2[0] = n2, this.parsedData.push(o2);
          }
          this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
        }
        function h(t2, e2) {
          this.typeNumber = t2, this.errorCorrectLevel = e2, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
        }
        e.prototype = { getLength: function(t2) {
          return this.parsedData.length;
        }, write: function(t2) {
          for (var e2 = 0, r2 = this.parsedData.length; e2 < r2; e2++) t2.put(this.parsedData[e2], 8);
        } }, h.prototype = { addData: function(t2) {
          t2 = new e(t2);
          this.dataList.push(t2), this.dataCache = null;
        }, isDark: function(t2, e2) {
          if (t2 < 0 || this.moduleCount <= t2 || e2 < 0 || this.moduleCount <= e2) throw new Error(t2 + "," + e2);
          return this.modules[t2][e2];
        }, getModuleCount: function() {
          return this.moduleCount;
        }, make: function() {
          this.makeImpl(false, this.getBestMaskPattern());
        }, makeImpl: function(t2, e2) {
          this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
          for (var r2 = 0; r2 < this.moduleCount; r2++) {
            this.modules[r2] = new Array(this.moduleCount);
            for (var o2 = 0; o2 < this.moduleCount; o2++) this.modules[r2][o2] = null;
          }
          this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t2, e2), 7 <= this.typeNumber && this.setupTypeNumber(t2), null == this.dataCache && (this.dataCache = h.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e2);
        }, setupPositionProbePattern: function(t2, e2) {
          for (var r2 = -1; r2 <= 7; r2++) if (!(t2 + r2 <= -1 || this.moduleCount <= t2 + r2)) for (var o2 = -1; o2 <= 7; o2++) e2 + o2 <= -1 || this.moduleCount <= e2 + o2 || (this.modules[t2 + r2][e2 + o2] = 0 <= r2 && r2 <= 6 && (0 == o2 || 6 == o2) || 0 <= o2 && o2 <= 6 && (0 == r2 || 6 == r2) || 2 <= r2 && r2 <= 4 && 2 <= o2 && o2 <= 4);
        }, getBestMaskPattern: function() {
          for (var t2 = 0, e2 = 0, r2 = 0; r2 < 8; r2++) {
            this.makeImpl(true, r2);
            var o2 = m.getLostPoint(this);
            (0 == r2 || o2 < t2) && (t2 = o2, e2 = r2);
          }
          return e2;
        }, createMovieClip: function(t2, e2, r2) {
          var o2 = t2.createEmptyMovieClip(e2, r2);
          this.make();
          for (var n2 = 0; n2 < this.modules.length; n2++) for (var i2 = +n2, a2 = 0; a2 < this.modules[n2].length; a2++) {
            var s2 = +a2;
            this.modules[n2][a2] && (o2.beginFill(0, 100), o2.moveTo(s2, i2), o2.lineTo(1 + s2, i2), o2.lineTo(1 + s2, 1 + i2), o2.lineTo(s2, 1 + i2), o2.endFill());
          }
          return o2;
        }, setupTimingPattern: function() {
          for (var t2 = 8; t2 < this.moduleCount - 8; t2++) null == this.modules[t2][6] && (this.modules[t2][6] = t2 % 2 == 0);
          for (var e2 = 8; e2 < this.moduleCount - 8; e2++) null == this.modules[6][e2] && (this.modules[6][e2] = e2 % 2 == 0);
        }, setupPositionAdjustPattern: function() {
          for (var t2 = m.getPatternPosition(this.typeNumber), e2 = 0; e2 < t2.length; e2++) for (var r2 = 0; r2 < t2.length; r2++) {
            var o2 = t2[e2], n2 = t2[r2];
            if (null == this.modules[o2][n2]) for (var i2 = -2; i2 <= 2; i2++) for (var a2 = -2; a2 <= 2; a2++) this.modules[o2 + i2][n2 + a2] = -2 == i2 || 2 == i2 || -2 == a2 || 2 == a2 || 0 == i2 && 0 == a2;
          }
        }, setupTypeNumber: function(t2) {
          for (var e2 = m.getBCHTypeNumber(this.typeNumber), r2 = 0; r2 < 18; r2++) {
            var o2 = !t2 && 1 == (e2 >> r2 & 1);
            this.modules[Math.floor(r2 / 3)][r2 % 3 + this.moduleCount - 8 - 3] = o2;
          }
          for (r2 = 0; r2 < 18; r2++) {
            o2 = !t2 && 1 == (e2 >> r2 & 1);
            this.modules[r2 % 3 + this.moduleCount - 8 - 3][Math.floor(r2 / 3)] = o2;
          }
        }, setupTypeInfo: function(t2, e2) {
          for (var e2 = this.errorCorrectLevel << 3 | e2, r2 = m.getBCHTypeInfo(e2), o2 = 0; o2 < 15; o2++) {
            var n2 = !t2 && 1 == (r2 >> o2 & 1);
            o2 < 6 ? this.modules[o2][8] = n2 : o2 < 8 ? this.modules[o2 + 1][8] = n2 : this.modules[this.moduleCount - 15 + o2][8] = n2;
          }
          for (o2 = 0; o2 < 15; o2++) {
            n2 = !t2 && 1 == (r2 >> o2 & 1);
            o2 < 8 ? this.modules[8][this.moduleCount - o2 - 1] = n2 : o2 < 9 ? this.modules[8][15 - o2 - 1 + 1] = n2 : this.modules[8][15 - o2 - 1] = n2;
          }
          this.modules[this.moduleCount - 8][8] = !t2;
        }, mapData: function(t2, e2) {
          for (var r2 = -1, o2 = this.moduleCount - 1, n2 = 7, i2 = 0, a2 = this.moduleCount - 1; 0 < a2; a2 -= 2) for (6 == a2 && a2--; ; ) {
            for (var s2, h2, u2 = 0; u2 < 2; u2++) null == this.modules[o2][a2 - u2] && (s2 = false, i2 < t2.length && (s2 = 1 == (t2[i2] >>> n2 & 1)), h2 = m.getMask(e2, o2, a2 - u2), this.modules[o2][a2 - u2] = s2 = h2 ? !s2 : s2, -1 == --n2) && (i2++, n2 = 7);
            if ((o2 += r2) < 0 || this.moduleCount <= o2) {
              o2 -= r2, r2 = -r2;
              break;
            }
          }
        } }, h.PAD0 = 236, h.PAD1 = 17, h.createData = function(t2, e2, r2) {
          for (var o2 = p.getRSBlocks(t2, e2), n2 = new _(), i2 = 0; i2 < r2.length; i2++) {
            var a2 = r2[i2];
            n2.put(a2.mode, 4), n2.put(a2.getLength(), m.getLengthInBits(a2.mode, t2)), a2.write(n2);
          }
          for (var s2 = 0, i2 = 0; i2 < o2.length; i2++) s2 += o2[i2].dataCount;
          if (n2.getLengthInBits() > 8 * s2) throw new Error("code length overflow. (" + n2.getLengthInBits() + ">" + 8 * s2 + ")");
          for (n2.getLengthInBits() + 4 <= 8 * s2 && n2.put(0, 4); n2.getLengthInBits() % 8 != 0; ) n2.putBit(false);
          for (; ; ) {
            if (n2.getLengthInBits() >= 8 * s2) break;
            if (n2.put(h.PAD0, 8), n2.getLengthInBits() >= 8 * s2) break;
            n2.put(h.PAD1, 8);
          }
          return h.createBytes(n2, o2);
        }, h.createBytes = function(t2, e2) {
          for (var r2 = 0, o2 = 0, n2 = 0, i2 = new Array(e2.length), a2 = new Array(e2.length), s2 = 0; s2 < e2.length; s2++) {
            var h2 = e2[s2].dataCount, u2 = e2[s2].totalCount - h2, o2 = Math.max(o2, h2), n2 = Math.max(n2, u2);
            i2[s2] = new Array(h2);
            for (var l2 = 0; l2 < i2[s2].length; l2++) i2[s2][l2] = 255 & t2.buffer[l2 + r2];
            r2 += h2;
            var h2 = m.getErrorCorrectPolynomial(u2), f2 = new C(i2[s2], h2.getLength() - 1).mod(h2);
            a2[s2] = new Array(h2.getLength() - 1);
            for (l2 = 0; l2 < a2[s2].length; l2++) {
              var g2 = l2 + f2.getLength() - a2[s2].length;
              a2[s2][l2] = 0 <= g2 ? f2.get(g2) : 0;
            }
          }
          for (var c2 = 0, l2 = 0; l2 < e2.length; l2++) c2 += e2[l2].totalCount;
          for (var d2 = new Array(c2), p2 = 0, l2 = 0; l2 < o2; l2++) for (s2 = 0; s2 < e2.length; s2++) l2 < i2[s2].length && (d2[p2++] = i2[s2][l2]);
          for (l2 = 0; l2 < n2; l2++) for (s2 = 0; s2 < e2.length; s2++) l2 < a2[s2].length && (d2[p2++] = a2[s2][l2]);
          return d2;
        };
        for (var i = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, u = { L: 1, M: 0, Q: 3, H: 2 }, o = 0, n = 1, a = 2, s = 3, l = 4, f = 5, g = 6, c = 7, m = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(t2) {
          for (var e2 = t2 << 10; 0 <= m.getBCHDigit(e2) - m.getBCHDigit(m.G15); ) e2 ^= m.G15 << m.getBCHDigit(e2) - m.getBCHDigit(m.G15);
          return (t2 << 10 | e2) ^ m.G15_MASK;
        }, getBCHTypeNumber: function(t2) {
          for (var e2 = t2 << 12; 0 <= m.getBCHDigit(e2) - m.getBCHDigit(m.G18); ) e2 ^= m.G18 << m.getBCHDigit(e2) - m.getBCHDigit(m.G18);
          return t2 << 12 | e2;
        }, getBCHDigit: function(t2) {
          for (var e2 = 0; 0 != t2; ) e2++, t2 >>>= 1;
          return e2;
        }, getPatternPosition: function(t2) {
          return m.PATTERN_POSITION_TABLE[t2 - 1];
        }, getMask: function(t2, e2, r2) {
          switch (t2) {
            case o:
              return (e2 + r2) % 2 == 0;
            case n:
              return e2 % 2 == 0;
            case a:
              return r2 % 3 == 0;
            case s:
              return (e2 + r2) % 3 == 0;
            case l:
              return (Math.floor(e2 / 2) + Math.floor(r2 / 3)) % 2 == 0;
            case f:
              return e2 * r2 % 2 + e2 * r2 % 3 == 0;
            case g:
              return (e2 * r2 % 2 + e2 * r2 % 3) % 2 == 0;
            case c:
              return (e2 * r2 % 3 + (e2 + r2) % 2) % 2 == 0;
            default:
              throw new Error("bad maskPattern:" + t2);
          }
        }, getErrorCorrectPolynomial: function(t2) {
          for (var e2 = new C([1], 0), r2 = 0; r2 < t2; r2++) e2 = e2.multiply(new C([1, d.gexp(r2)], 0));
          return e2;
        }, getLengthInBits: function(t2, e2) {
          if (1 <= e2 && e2 < 10) switch (t2) {
            case i.MODE_NUMBER:
              return 10;
            case i.MODE_ALPHA_NUM:
              return 9;
            case i.MODE_8BIT_BYTE:
            case i.MODE_KANJI:
              return 8;
            default:
              throw new Error("mode:" + t2);
          }
          else if (e2 < 27) switch (t2) {
            case i.MODE_NUMBER:
              return 12;
            case i.MODE_ALPHA_NUM:
              return 11;
            case i.MODE_8BIT_BYTE:
              return 16;
            case i.MODE_KANJI:
              return 10;
            default:
              throw new Error("mode:" + t2);
          }
          else {
            if (!(e2 < 41)) throw new Error("type:" + e2);
            switch (t2) {
              case i.MODE_NUMBER:
                return 14;
              case i.MODE_ALPHA_NUM:
                return 13;
              case i.MODE_8BIT_BYTE:
                return 16;
              case i.MODE_KANJI:
                return 12;
              default:
                throw new Error("mode:" + t2);
            }
          }
        }, getLostPoint: function(t2) {
          for (var e2 = t2.getModuleCount(), r2 = 0, o2 = 0; o2 < e2; o2++) for (var n2 = 0; n2 < e2; n2++) {
            for (var i2 = 0, a2 = t2.isDark(o2, n2), s2 = -1; s2 <= 1; s2++) if (!(o2 + s2 < 0 || e2 <= o2 + s2)) for (var h2 = -1; h2 <= 1; h2++) n2 + h2 < 0 || e2 <= n2 + h2 || 0 == s2 && 0 == h2 || a2 == t2.isDark(o2 + s2, n2 + h2) && i2++;
            5 < i2 && (r2 += 3 + i2 - 5);
          }
          for (o2 = 0; o2 < e2 - 1; o2++) for (n2 = 0; n2 < e2 - 1; n2++) {
            var u2 = 0;
            t2.isDark(o2, n2) && u2++, t2.isDark(o2 + 1, n2) && u2++, t2.isDark(o2, n2 + 1) && u2++, t2.isDark(o2 + 1, n2 + 1) && u2++, 0 != u2 && 4 != u2 || (r2 += 3);
          }
          for (o2 = 0; o2 < e2; o2++) for (n2 = 0; n2 < e2 - 6; n2++) t2.isDark(o2, n2) && !t2.isDark(o2, n2 + 1) && t2.isDark(o2, n2 + 2) && t2.isDark(o2, n2 + 3) && t2.isDark(o2, n2 + 4) && !t2.isDark(o2, n2 + 5) && t2.isDark(o2, n2 + 6) && (r2 += 40);
          for (n2 = 0; n2 < e2; n2++) for (o2 = 0; o2 < e2 - 6; o2++) t2.isDark(o2, n2) && !t2.isDark(o2 + 1, n2) && t2.isDark(o2 + 2, n2) && t2.isDark(o2 + 3, n2) && t2.isDark(o2 + 4, n2) && !t2.isDark(o2 + 5, n2) && t2.isDark(o2 + 6, n2) && (r2 += 40);
          for (var l2 = 0, n2 = 0; n2 < e2; n2++) for (o2 = 0; o2 < e2; o2++) t2.isDark(o2, n2) && l2++;
          return r2 += 10 * (Math.abs(100 * l2 / e2 / e2 - 50) / 5);
        } }, d = { glog: function(t2) {
          if (t2 < 1) throw new Error("glog(" + t2 + ")");
          return d.LOG_TABLE[t2];
        }, gexp: function(t2) {
          for (; t2 < 0; ) t2 += 255;
          for (; 256 <= t2; ) t2 -= 255;
          return d.EXP_TABLE[t2];
        }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, t = 0; t < 8; t++) d.EXP_TABLE[t] = 1 << t;
        for (t = 8; t < 256; t++) d.EXP_TABLE[t] = d.EXP_TABLE[t - 4] ^ d.EXP_TABLE[t - 5] ^ d.EXP_TABLE[t - 6] ^ d.EXP_TABLE[t - 8];
        for (t = 0; t < 255; t++) d.LOG_TABLE[d.EXP_TABLE[t]] = t;
        function C(t2, e2) {
          if (null == t2.length) throw new Error(t2.length + "/" + e2);
          for (var r2 = 0; r2 < t2.length && 0 == t2[r2]; ) r2++;
          this.num = new Array(t2.length - r2 + e2);
          for (var o2 = 0; o2 < t2.length - r2; o2++) this.num[o2] = t2[o2 + r2];
        }
        function p(t2, e2) {
          this.totalCount = t2, this.dataCount = e2;
        }
        function _() {
          this.buffer = [], this.length = 0;
        }
        C.prototype = { get: function(t2) {
          return this.num[t2];
        }, getLength: function() {
          return this.num.length;
        }, multiply: function(t2) {
          for (var e2 = new Array(this.getLength() + t2.getLength() - 1), r2 = 0; r2 < this.getLength(); r2++) for (var o2 = 0; o2 < t2.getLength(); o2++) e2[r2 + o2] ^= d.gexp(d.glog(this.get(r2)) + d.glog(t2.get(o2)));
          return new C(e2, 0);
        }, mod: function(t2) {
          if (this.getLength() - t2.getLength() < 0) return this;
          for (var e2 = d.glog(this.get(0)) - d.glog(t2.get(0)), r2 = new Array(this.getLength()), o2 = 0; o2 < this.getLength(); o2++) r2[o2] = this.get(o2);
          for (o2 = 0; o2 < t2.getLength(); o2++) r2[o2] ^= d.gexp(d.glog(t2.get(o2)) + e2);
          return new C(r2, 0).mod(t2);
        } }, p.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], p.getRSBlocks = function(t2, e2) {
          var r2 = p.getRsBlockTable(t2, e2);
          if (null == r2) throw new Error("bad rs block @ typeNumber:" + t2 + "/errorCorrectLevel:" + e2);
          for (var o2 = r2.length / 3, n2 = [], i2 = 0; i2 < o2; i2++) for (var a2 = r2[3 * i2 + 0], s2 = r2[3 * i2 + 1], h2 = r2[3 * i2 + 2], u2 = 0; u2 < a2; u2++) n2.push(new p(s2, h2));
          return n2;
        }, p.getRsBlockTable = function(t2, e2) {
          switch (e2) {
            case u.L:
              return p.RS_BLOCK_TABLE[4 * (t2 - 1) + 0];
            case u.M:
              return p.RS_BLOCK_TABLE[4 * (t2 - 1) + 1];
            case u.Q:
              return p.RS_BLOCK_TABLE[4 * (t2 - 1) + 2];
            case u.H:
              return p.RS_BLOCK_TABLE[4 * (t2 - 1) + 3];
            default:
              return;
          }
        }, _.prototype = { get: function(t2) {
          var e2 = Math.floor(t2 / 8);
          return 1 == (this.buffer[e2] >>> 7 - t2 % 8 & 1);
        }, put: function(t2, e2) {
          for (var r2 = 0; r2 < e2; r2++) this.putBit(1 == (t2 >>> e2 - r2 - 1 & 1));
        }, getLengthInBits: function() {
          return this.length;
        }, putBit: function(t2) {
          var e2 = Math.floor(this.length / 8);
          this.buffer.length <= e2 && this.buffer.push(0), t2 && (this.buffer[e2] |= 128 >>> this.length % 8), this.length++;
        } };
        var v = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]], D = (r.prototype.draw = function(t2) {
          var e2 = this._oContext, r2 = this._htOption, o2 = t2.getModuleCount(), n2 = r2.width / o2, i2 = r2.height / o2, a2 = Math.round(n2), s2 = Math.round(i2);
          this.clear();
          for (var h2 = 0; h2 < o2; h2++) for (var u2 = 0; u2 < o2; u2++) {
            var l2 = t2.isDark(h2, u2), f2 = u2 * n2, g2 = h2 * i2;
            e2.strokeStyle = l2 ? r2.colorDark : r2.colorLight, e2.lineWidth = 1, e2.fillStyle = l2 ? r2.colorDark : r2.colorLight, e2.fillRect(f2, g2, n2, i2), e2.strokeRect(Math.floor(f2) + 0.5, Math.floor(g2) + 0.5, a2, s2), e2.strokeRect(Math.ceil(f2) - 0.5, Math.ceil(g2) - 0.5, a2, s2);
          }
          this._bIsPainted = true;
        }, r.prototype.isPainted = function() {
          return this._bIsPainted;
        }, r.prototype.clear = function() {
          this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height), this._bIsPainted = false;
        }, r.prototype.getCanvas = function() {
          return this._elCanvas;
        }, r.prototype.round = function(t2) {
          return t2 && Math.floor(1e3 * t2) / 1e3;
        }, r);
        function r(t2, e2) {
          this._bIsPainted = false, this._htOption = e2, this._elCanvas = null, "undefined" != typeof document ? (this._elCanvas = document.createElement("canvas"), this._elCanvas.width = e2.width, this._elCanvas.height = e2.height) : this._elCanvas = new OffscreenCanvas(e2.width, e2.height), t2 && t2.appendChild(this._elCanvas), this._el = t2, this._oContext = this._elCanvas.getContext("2d"), this._bIsPainted = false, this._bSupportDataURI = null;
        }
        function L(t2, e2) {
          for (var r2, o2 = 1, n2 = (t2 = t2, (r2 = encodeURI(t2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a")).length + (r2.length != t2 ? 3 : 0)), i2 = 0, a2 = v.length; i2 <= a2; i2++) {
            var s2 = 0;
            switch (e2) {
              case u.L:
                s2 = v[i2][0];
                break;
              case u.M:
                s2 = v[i2][1];
                break;
              case u.Q:
                s2 = v[i2][2];
                break;
              case u.H:
                s2 = v[i2][3];
            }
            if (n2 <= s2) break;
            o2++;
          }
          if (v.length < o2) throw new Error("Too long data");
          return o2;
        }
        self.C3_QRCode = function(t2, e2) {
          if (this._htOption = { width: 256, height: 256, typeNumber: 4, colorDark: "#000000", colorLight: "#ffffff", correctLevel: u.H }, e2 = "string" == typeof e2 ? { text: e2 } : e2) for (var r2 in e2) this._htOption[r2] = e2[r2];
          "string" == typeof t2 && (t2 = document.getElementById(t2)), this._el = t2, this._oQRCode = null, this._oDrawing = new D(this._el, this._htOption), this.makeCode(this._htOption.text);
        }, self.C3_QRCode.prototype.makeCode = function(t2) {
          this._oQRCode = new h(L(t2, this._htOption.correctLevel), this._htOption.correctLevel), this._oQRCode.addData(t2), this._oQRCode.make(), this._oDrawing.draw(this._oQRCode);
        }, self.C3_QRCode.prototype.clear = function() {
          this._oDrawing.clear();
        }, self.C3_QRCode.prototype.getCanvas = function() {
          return this._oDrawing.getCanvas();
        }, self.C3_QRCode.CorrectLevel = u;
      }();
    }
    {
      {
        const a = self.C3;
        a.Plugins.Json = class extends a.SDKPluginBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Plugins.Json.Type = class extends d.SDKTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IInstance, j = (g.Plugins.Json.Instance = class extends g.SDKInstanceBase {
          constructor(t, e) {
            super(t), this._valueCache = [null, null], this._locationCache = [null, null], this._data = {}, this._path = [], this._currentKey = "", this._currentValue = 0;
          }
          Release() {
            super.Release();
          }
          _InvalidateValueCache() {
            this._valueCache[0] = null, this._valueCache[1] = null;
          }
          _HasValueCache(a, t) {
            const s = this._valueCache[0];
            if (null !== a && null !== s) {
              if (s === a || g.arraysEqual(s, a)) return true;
              if (t && 0 < s.length) {
                for (let t2 = 0, e = Math.min(a.length, s.length); t2 < e; ++t2) if (a[t2] !== s[t2]) return false;
                return true;
              }
            }
            return false;
          }
          _GetValueCache() {
            return this._valueCache[1];
          }
          _UpdateValueCache(t, e) {
            this._valueCache[0] = t, this._valueCache[1] = e;
          }
          _InvalidateLocationCache() {
            this._locationCache[0] = null, this._locationCache[1] = null;
          }
          _HasLocationCache(t) {
            return this._locationCache[0] === t;
          }
          _GetLocationCache() {
            return this._locationCache[1];
          }
          _UpdateLocationCache(t, e) {
            this._locationCache[0] = t, this._locationCache[1] = e;
          }
          _SetData(t) {
            this._data = t, this._InvalidateValueCache(), this._SetPath("");
          }
          _GetData() {
            return this._data;
          }
          _SetPath(t) {
            this._path = this._ParsePathUnsafe(t), this._InvalidateLocationCache();
          }
          _ParsePath(t) {
            return g.cloneArray(this._ParsePathUnsafe(t));
          }
          _ParsePathUnsafe(t) {
            const e = [];
            let a = false, s;
            if (this._HasLocationCache(t)) return this._GetLocationCache();
            "." === t[0] ? (s = g.cloneArray(this._path), t = t.slice(1)) : s = [];
            for (const r of t) a ? (e.push(r), a = false) : "\\" === r ? a = true : "." === r ? (s.push(e.join("")), g.clearArray(e)) : e.push(r);
            return 0 !== e.length && s.push(e.join("")), this._UpdateLocationCache(t, s), s;
          }
          _GetValueAtFullPath(t, e) {
            if (this._HasValueCache(t, false)) return this._GetValueCache();
            let a = this._data;
            for (const s of t) if (Array.isArray(a)) {
              const r = parseInt(s, 10);
              if (r < 0 || r >= a.length || !isFinite(r)) {
                a = null;
                break;
              }
              a = a[r];
            } else {
              if ("object" != typeof a || null === a) {
                a = null;
                break;
              }
              if (a.hasOwnProperty(s)) a = a[s];
              else {
                if (!e) {
                  a = null;
                  break;
                }
                {
                  const n = {};
                  a[s] = n, a = n;
                }
              }
            }
            return this._UpdateValueCache(t, a), a;
          }
          _GetValue(t) {
            const e = this._ParsePath(t);
            if (!e.length) return this._data;
            const a = e.pop(), s = this._GetValueAtFullPath(e, false);
            if (Array.isArray(s)) {
              const r = parseInt(a, 10);
              return 0 <= r && r < s.length ? s[r] : null;
            }
            return "object" == typeof s && null !== s && s.hasOwnProperty(a) ? s[a] : null;
          }
          _JSONTypeOf(t) {
            return null === t ? "null" : Array.isArray(t) ? "array" : typeof t;
          }
          _GetTypeOf(t) {
            const e = this._GetValue(t);
            return this._JSONTypeOf(e);
          }
          _ToSafeValue(t) {
            const e = typeof t;
            return "number" == e || "string" == e ? t : "boolean" == e && t ? 1 : 0;
          }
          _GetSafeValue(t) {
            return this._ToSafeValue(this._GetValue(t));
          }
          _HasKey(t) {
            const e = this._ParsePath(t);
            if (!e.length) return false;
            const a = e.pop(), s = this._GetValueAtFullPath(e, false);
            if (Array.isArray(s)) {
              const r = parseInt(a, 10);
              return 0 <= r && r < s.length;
            }
            return "object" == typeof s && null !== s && s.hasOwnProperty(a);
          }
          _SetValue(t, e) {
            const a = this._ParsePath(t);
            if (!a.length) return false;
            this._HasValueCache(a, true) && this._InvalidateValueCache();
            const s = a.pop(), r = this._GetValueAtFullPath(a, true);
            if (Array.isArray(r)) {
              const n = parseInt(s, 10);
              return !isFinite(n) || n < 0 || n >= r.length ? false : (r[n] = e, true);
            }
            return "object" == typeof r && null !== r && (r[s] = e, true);
          }
          _DeleteKey(t) {
            const e = this._ParsePath(t);
            if (!e.length) return false;
            this._HasValueCache(e, true) && this._InvalidateValueCache();
            const a = e.pop(), s = this._GetValueAtFullPath(e, false);
            return !Array.isArray(s) && "object" == typeof s && null !== s && (delete s[a], true);
          }
          SaveToJson() {
            return { "path": this._path, "data": this._data };
          }
          LoadFromJson(t) {
            this._InvalidateValueCache(), this._InvalidateLocationCache(), this._path = t["path"], this._data = t["data"];
          }
          _SanitizeValue(t) {
            const e = typeof t;
            return "number" == e ? isFinite(t) ? t : 0 : "object" == typeof t ? JSON.stringify(t) : t + "";
          }
          GetDebuggerProperties() {
            const t = "plugins.json.debugger";
            let e;
            try {
              e = this._SanitizeValue(this._data);
            } catch (t2) {
              e = '"invalid"';
            }
            return [{ title: t + ".title", properties: [{ name: t + ".data", value: e, onedit: (t2) => {
              try {
                const e2 = JSON.parse(t2);
                this._SetData(e2);
              } catch (t3) {
              }
            } }, { name: t + ".path", value: this._path.map((t2) => t2.replace(/\./g, "\\.")).join(".") }] }];
          }
          GetScriptInterfaceClass() {
            return self.IJSONInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IJSONInstance = class extends i {
          constructor() {
            super(), j.set(this, i._GetInitInst().GetSdkInstance());
          }
          getJsonDataCopy() {
            const t = j.get(this)._GetData();
            return JSON.parse(JSON.stringify(t));
          }
          setJsonDataCopy(t) {
            try {
              const e = JSON.parse(JSON.stringify(t));
              j.get(this)._SetData(e);
            } catch (t2) {
              throw console.error("[JSON plugin] setJsonData: object is not valid JSON: ", t2), t2;
            }
          }
          setJsonString(t) {
            h.RequireString(t);
            try {
              const e = JSON.parse(t);
              j.get(this)._SetData(e);
            } catch (t2) {
              throw console.error("[JSON plugin] setJsonString: string is not valid JSON: ", t2), t2;
            }
          }
          toCompactString() {
            return JSON.stringify(j.get(this)._GetData());
          }
          toBeautifiedString() {
            return JSON.stringify(j.get(this)._GetData(), null, 4);
          }
        };
      }
      {
        const Ba = self.C3, Ca = ["null", "boolean", "number", "string", "object", "array"];
        Ba.Plugins.Json.Cnds = { HasKey(t) {
          return this._HasKey(t);
        }, CompareType(t, e) {
          return this._GetTypeOf(t) === Ca[e];
        }, CompareValue(t, e, a) {
          return Ba.compare(this._GetSafeValue(t), e, a);
        }, IsBooleanSet(t) {
          return true === this._GetValue(t);
        }, ForEach(t) {
          const e = this._GetValue(t);
          if ("object" == typeof e && null !== e) {
            const a = this._runtime, s = a.GetEventSheetManager(), r = a.GetCurrentEvent(), n = r.GetSolModifiers(), i = a.GetEventStack(), l = i.GetCurrentStackFrame(), h = i.Push(r), u = this._path, o = this._currentKey, c = this._currentValue, _ = this._ParsePathUnsafe(t);
            a.SetDebuggingEnabled(false);
            for (const [p, y] of Object.entries(e)) {
              this._path = Ba.cloneArray(_), this._path.push(p), this._currentKey = p, this._currentValue = y, s.PushCopySol(n);
              const S = this.GetObjectClass().GetCurrentSol();
              S.PickOne(this.GetInstance()), r.Retrigger(l, h), s.PopSol(n);
            }
            a.SetDebuggingEnabled(true), this._path = u, this._InvalidateLocationCache(), this._currentKey = o, this._currentValue = c, i.Pop();
          }
          return false;
        }, OnParseError() {
          return true;
        } };
      }
      {
        const $a = self.C3;
        $a.Plugins.Json.Acts = { Parse(t) {
          try {
            this._SetData(JSON.parse(t));
          } catch (t2) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", t2), this._SetData({}), this.Trigger($a.Plugins.Json.Cnds.OnParseError);
          }
        }, SetPath(t) {
          this._SetPath(t);
        }, SetValue(t, e) {
          this._SetValue(t, e);
        }, SetArray(t, e) {
          let a = this._GetValue(t);
          Array.isArray(a) ? $a.resizeArray(a, e, 0) : (a = [], $a.extendArray(a, e, 0), this._SetValue(t, a));
        }, SetObject(t) {
          this._SetValue(t, {});
        }, SetJSON(t, e) {
          let a = null;
          try {
            a = JSON.parse(e);
          } catch (t2) {
            console.warn("[JSON plugin] Failed to parse JSON data: ", t2), this.Trigger($a.Plugins.Json.Cnds.OnParseError);
          }
          this._SetValue(t, a);
        }, SetNull(t) {
          this._SetValue(t, null);
        }, SetBoolean(t, e) {
          this._SetValue(t, 0 !== e);
        }, ToggleBoolean(t) {
          const e = this._GetValue(t);
          "boolean" == typeof e && this._SetValue(t, !e);
        }, AddTo(t, e) {
          const a = this._GetValue(t);
          "number" == typeof a && this._SetValue(t, a + e);
        }, SubtractFrom(t, e) {
          const a = this._GetValue(t);
          "number" == typeof a && this._SetValue(t, a - e);
        }, DeleteKey(t) {
          this._DeleteKey(t);
        }, PushValue(t, e, a) {
          const s = this._GetValue(e);
          Array.isArray(s) && (0 === t ? s.push(a) : s.unshift(a), this._InvalidateValueCache());
        }, PopValue(t, e) {
          const a = this._GetValue(e);
          Array.isArray(a) && (0 === t ? a.pop() : a.shift(), this._InvalidateValueCache());
        }, InsertValue(t, e, a) {
          const s = this._GetValue(e);
          Array.isArray(s) && (s.splice(a, 0, t), this._InvalidateValueCache());
        }, RemoveValues(t, e, a) {
          const s = this._GetValue(e);
          Array.isArray(s) && 0 < t && (s.splice(a, t), this._InvalidateValueCache());
        } };
      }
      {
        const N0 = self.C3;
        N0.Plugins.Json.Exps = { ToCompactString() {
          try {
            return JSON.stringify(this._data);
          } catch (t) {
            return "";
          }
        }, ToBeautifiedString() {
          try {
            return JSON.stringify(this._data, null, 4);
          } catch (t) {
            return "";
          }
        }, Get(t) {
          return this._GetSafeValue(t);
        }, GetAsCompactString(t) {
          const e = this._GetValue(t);
          return JSON.stringify(e);
        }, GetAsBeautifiedString(t) {
          const e = this._GetValue(t);
          return JSON.stringify(e, null, 4);
        }, Front(t) {
          const e = this._GetValue(t);
          if (Array.isArray(e)) {
            const a = e[0];
            return this._ToSafeValue(a);
          }
          return -1;
        }, Back(t) {
          const e = this._GetValue(t);
          if (Array.isArray(e)) {
            const a = e.at(-1);
            return this._ToSafeValue(a);
          }
          return -1;
        }, Type(t) {
          return this._GetTypeOf(t);
        }, ArraySize(t) {
          const e = this._GetValue(t);
          return Array.isArray(e) ? e.length : -1;
        }, Path() {
          return this._path.map((t) => t.replace(/\./g, "\\.")).join(".");
        }, CurrentKey() {
          return this._currentKey;
        }, CurrentValue() {
          return this._ToSafeValue(this._currentValue);
        }, CurrentType() {
          return this._JSONTypeOf(this._currentValue);
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Behaviors.Anchor = class extends a.SDKBehaviorBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Behaviors.Anchor.Type = class extends d.SDKBehaviorTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IBehaviorInstance, j = 0, k = 1, l = 2, m = 3, n = 4, o = (g.Behaviors.Anchor.Instance = class extends g.SDKBehaviorInstanceBase {
          constructor(t, e) {
            super(t), this._anchorLeft = 2, this._anchorTop = 2, this._anchorRight = 0, this._anchorBottom = 0, this._isEnabled = true;
            const i2 = this._inst.GetWorldInfo().GetBoundingBox(), s = (this._xLeft = i2.getLeft(), this._yTop = i2.getTop(), this._xRight = this._runtime.GetOriginalViewportWidth() - i2.getLeft(), this._yBottom = this._runtime.GetOriginalViewportHeight() - i2.getTop(), this._rDiff = this._runtime.GetOriginalViewportWidth() - i2.getRight(), this._bDiff = this._runtime.GetOriginalViewportHeight() - i2.getBottom(), e && (this._anchorLeft = e[j], this._anchorTop = e[k], this._anchorRight = e[l], this._anchorBottom = e[m], this._isEnabled = !!e[n]), this._runtime.Dispatcher());
            this._disposables = new g.CompositeDisposable(g.Disposable.From(s, "layoutchange", () => this._OnLayoutChange())), this._isEnabled && this._StartTicking();
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "xl": this._xLeft, "yt": this._yTop, "xr": this._xRight, "yb": this._yBottom, "rd": this._rDiff, "bd": this._bDiff, "al": this._anchorLeft, "at": this._anchorTop, "ar": this._anchorRight, "ab": this._anchorBottom, "e": this._isEnabled };
          }
          LoadFromJson(t) {
            this._xLeft = t["xl"], this._yTop = t["yt"], this._xRight = t["xr"], this._yBottom = t["yb"], this._rDiff = t["rd"], this._bDiff = t["bd"], this._anchorLeft = t["al"], this._anchorTop = t["at"], this._anchorRight = t["ar"], this._anchorBottom = t["ab"], this._isEnabled = t["e"], this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _SetEnabled(t) {
            if (this._isEnabled && !t) this._isEnabled = false, this._StopTicking();
            else if (!this._isEnabled && t) {
              const e = this._inst.GetWorldInfo().GetBoundingBox();
              this._xLeft = e.getLeft(), this._yTop = e.getTop(), this._xRight = this._runtime.GetOriginalViewportWidth() - e.getLeft(), this._yBottom = this._runtime.GetOriginalViewportHeight() - e.getTop(), this._rDiff = this._runtime.GetOriginalViewportWidth() - e.getRight(), this._bDiff = this._runtime.GetOriginalViewportHeight() - e.getBottom(), this._isEnabled = true, this._StartTicking();
            }
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          _UpdatePosition() {
            if (this._isEnabled) {
              const t = this._inst.GetWorldInfo(), e = t.GetLayer().GetViewport();
              if (0 === this._anchorLeft) {
                const i2 = e.getLeft() + this._xLeft - t.GetBoundingBox().getLeft();
                0 != i2 && (t.OffsetX(i2), t.SetBboxChanged());
              } else if (1 === this._anchorLeft) {
                const s = e.getRight() - this._xRight - t.GetBoundingBox().getLeft();
                0 != s && (t.OffsetX(s), t.SetBboxChanged());
              }
              if (0 === this._anchorTop) {
                const h2 = e.getTop() + this._yTop - t.GetBoundingBox().getTop();
                0 != h2 && (t.OffsetY(h2), t.SetBboxChanged());
              } else if (1 === this._anchorTop) {
                const o2 = e.getBottom() - this._yBottom - t.GetBoundingBox().getTop();
                0 != o2 && (t.OffsetY(o2), t.SetBboxChanged());
              }
              if (1 === this._anchorRight) {
                const n2 = e.getRight() - this._rDiff - t.GetBoundingBox().getRight();
                0 != n2 && (t.OffsetX(t.GetOriginX() * n2), t.SetWidth(Math.max(t.GetWidth() + n2), 0), t.SetBboxChanged(), this._rDiff = e.getRight() - t.GetBoundingBox().getRight());
              }
              if (1 === this._anchorBottom) {
                const a = e.getBottom() - this._bDiff - t.GetBoundingBox().getBottom();
                0 != a && (t.OffsetY(t.GetOriginY() * a), t.SetHeight(Math.max(t.GetHeight() + a, 0)), t.SetBboxChanged(), this._bDiff = e.getBottom() - t.GetBoundingBox().getBottom());
              }
            }
          }
          Tick() {
            this._UpdatePosition();
          }
          _OnLayoutChange() {
            this._UpdatePosition();
          }
          GetPropertyValueByIndex(t) {
            switch (t) {
              case j:
                return this._anchorLeft;
              case k:
                return this._anchorTop;
              case l:
                return this._anchorRight;
              case m:
                return this._anchorBottom;
              case n:
                return this._isEnabled;
            }
          }
          SetPropertyValueByIndex(t, e) {
            switch (t) {
              case j:
                this._anchorLeft = e;
                break;
              case k:
                this._anchorTop = e;
                break;
              case l:
                this._anchorRight = e;
                break;
              case m:
                this._anchorBottom = e;
                break;
              case n:
                this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : this._StopTicking();
            }
          }
          GetDebuggerProperties() {
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.anchor.properties.enabled.name", value: this._IsEnabled(), onedit: (t) => this._SetEnabled(t) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IAnchorBehaviorInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IAnchorBehaviorInstance = class extends i {
          constructor() {
            super(), o.set(this, i._GetInitInst().GetSdkInstance());
          }
          get isEnabled() {
            return o.get(this)._IsEnabled();
          }
          set isEnabled(t) {
            o.get(this)._SetEnabled(t);
          }
        };
      }
      {
        const M = self.C3;
        M.Behaviors.Anchor.Cnds = { IsEnabled() {
          return this._IsEnabled();
        } };
      }
      {
        const N = self.C3;
        N.Behaviors.Anchor.Acts = { SetEnabled(t) {
          this._SetEnabled(0 !== t);
        } };
      }
      {
        const P = self.C3;
        P.Behaviors.Anchor.Exps = {};
      }
    }
    {
      {
        const a = self.C3;
        a.Behaviors.Sin = class extends a.SDKBehaviorBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Behaviors.Sin.Type = class extends d.SDKBehaviorTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IBehaviorInstance, j = 0, k = 1, l = 2, m = 3, n = 4, o = 5, p = 6, q = 7, r = 8, s = 0, t = 1, u = 2, v = 3, w = 4, x = 5, y = 6, z = 7, A = 8, B = 9, C = 0, D = 1, E = 2, F = 3, G = 4, H = 2 * Math.PI, I = Math.PI / 2, J = 3 * Math.PI / 2, K = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7], L = (g.Behaviors.Sin.Instance = class extends g.SDKBehaviorInstanceBase {
          constructor(e, t2) {
            super(e), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = true, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, t2 && (this._movement = K[t2[j]], this._wave = t2[k], this._periodRandom = this._runtime.Random() * t2[m], this._basePeriod = t2[l], this._period = t2[l], this._period += this._periodRandom, this._basePeriodOffset = t2[n], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * t2[o], this._i = t2[n] / this._period * H, this._i += this._periodOffsetRandom / this._period * H), this._magnitudeRandom = this._runtime.Random() * t2[q], this._baseMag = t2[p], this._mag = t2[p], this._mag += this._magnitudeRandom, this._isEnabled = !!t2[r]), this._movement === x && (this._mag = g.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking();
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "i": this._i, "e": this._isEnabled, "mv": this._movement, "w": this._wave, "p": this._period, "mag": this._mag, "iv": this._initialValue, "iv2": this._initialValue2, "r": this._ratio, "lkv": this._lastKnownValue, "lkv2": this._lastKnownValue2 };
          }
          LoadFromJson(e) {
            this._i = e["i"], this._SetEnabled(e["e"]), this._movement = e["mv"], this._wave = e["w"], this._period = e["p"], this._mag = e["mag"], this._initialValue = e["iv"], this._initialValue2 = e["iv2"], this._ratio = e["r"], this._lastKnownValue = e["lkv"], this._lastKnownValue2 = e["lkv2"];
          }
          Init() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
              case s:
                this._initialValue = e.GetX();
                break;
              case t:
                this._initialValue = e.GetY();
                break;
              case u:
                this._initialValue = e.GetWidth(), this._ratio = e.GetHeight() / e.GetWidth();
                break;
              case v:
                this._initialValue = e.GetWidth();
                break;
              case w:
                this._initialValue = e.GetHeight();
                break;
              case x:
                this._initialValue = e.GetAngle();
                break;
              case y:
                this._initialValue = e.GetOpacity();
                break;
              case z:
                this._initialValue = 0;
                break;
              case A:
                this._initialValue = e.GetX(), this._initialValue2 = e.GetY();
                break;
              case B:
                this._initialValue = e.GetZElevation();
            }
            this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2;
          }
          WaveFunc(e) {
            switch (e %= H, this._wave) {
              case C:
                return Math.sin(e);
              case D:
                return e <= I ? e / I : e <= J ? 1 - 2 * (e - I) / Math.PI : (e - J) / I - 1;
              case E:
                return 2 * e / H - 1;
              case F:
                return -2 * e / H + 1;
              case G:
                return e < Math.PI ? -1 : 1;
            }
            return 0;
          }
          Tick() {
            const e = this._runtime.GetDt(this._inst);
            this._isEnabled && 0 !== e && (0 === this._period ? this._i = 0 : this._i = (this._i + e / this._period * H) % H, this._UpdateFromPhase());
          }
          _UpdateFromPhase() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
              case s:
                e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX();
                break;
              case t:
                e.GetY() !== this._lastKnownValue && (this._initialValue += e.GetY() - this._lastKnownValue), e.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetY();
                break;
              case u:
                e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), e.SetHeight(e.GetWidth() * this._ratio);
                break;
              case v:
                e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
              case w:
                e.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
              case x:
                e.GetAngle() !== this._lastKnownValue && (this._initialValue = g.clampAngle(this._initialValue + (e.GetAngle() - this._lastKnownValue))), e.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetAngle();
                break;
              case y:
                e.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
                break;
              case A:
                e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.GetY() !== this._lastKnownValue2 && (this._initialValue2 += e.GetY() - this._lastKnownValue2), e.SetX(this._initialValue + Math.cos(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), e.SetY(this._initialValue2 + Math.sin(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX(), this._lastKnownValue2 = e.GetY();
                break;
              case B:
                e.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
            }
            e.SetBboxChanged();
          }
          _OnSpriteFrameChanged(e, t2) {
          }
          _SetPeriod(e) {
            this._period = e;
          }
          _GetPeriod() {
            return this._period;
          }
          _SetMagnitude(e) {
            this._mag = e;
          }
          _SetMagnitude_ConvertAngle(e) {
            5 === this._movement && (e = g.toRadians(e)), this._SetMagnitude(e);
          }
          _GetMagnitude() {
            return this._mag;
          }
          _GetMagnitude_ConvertAngle() {
            let e = this._GetMagnitude();
            return e = 5 === this._movement ? g.toDegrees(e) : e;
          }
          _SetMovement(e) {
            5 === this._movement && 5 !== e && (this._mag = g.toDegrees(this._mag)), this._movement = e, this.Init();
          }
          _GetMovement() {
            return this._movement;
          }
          _SetWave(e) {
            this._wave = e;
          }
          _GetWave() {
            return this._wave;
          }
          _SetPhase(e) {
            this._i = g.clamp(e, 0, 2 * Math.PI), this._UpdateFromPhase();
          }
          _GetPhase() {
            return this._i;
          }
          _SetEnabled(e) {
            this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case j:
                return this._movement;
              case k:
                return this._wave;
              case l:
                return this._basePeriod;
              case p:
                return this._baseMag;
              case r:
                return this._isEnabled;
            }
          }
          SetPropertyValueByIndex(e, t2) {
            switch (e) {
              case j:
                this._movement = K[t2], this.Init();
                break;
              case k:
                this._wave = t2;
                break;
              case l:
                this._basePeriod = t2, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * H, this._i += this._periodOffsetRandom / this._period * H) : this._i = 0);
                break;
              case p:
                this._baseMag = t2, this._mag = this._baseMag + this._magnitudeRandom, this._movement === x && (this._mag = g.toRadians(this._mag));
                break;
              case r:
                this._isEnabled = !!t2;
            }
          }
          GetDebuggerProperties() {
            const e = "behaviors.sin";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }, { name: e + ".properties.period.name", value: this._GetPeriod(), onedit: (e2) => this._SetPeriod(e2) }, { name: e + ".properties.magnitude.name", value: this._GetMagnitude_ConvertAngle(), onedit: (e2) => this._SetMagnitude_ConvertAngle(e2) }, { name: e + ".debugger.value", value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle() }] }];
          }
          GetScriptInterfaceClass() {
            return self.ISineBehaviorInstance;
          }
        }, /* @__PURE__ */ new WeakMap()), M = ["horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation"], N = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
        self.ISineBehaviorInstance = class extends i {
          constructor() {
            super(), L.set(this, i._GetInitInst().GetSdkInstance());
          }
          set period(e) {
            h.RequireFiniteNumber(e), L.get(this)._SetPeriod(e);
          }
          get period() {
            return L.get(this)._GetPeriod();
          }
          set magnitude(e) {
            h.RequireFiniteNumber(e), L.get(this)._SetMagnitude(e);
          }
          get magnitude() {
            return L.get(this)._GetMagnitude();
          }
          set phase(e) {
            L.get(this)._SetPhase(e);
          }
          get phase() {
            return L.get(this)._GetPhase();
          }
          set movement(e) {
            h.RequireString(e);
            const t2 = M.indexOf(e);
            if (-1 === t2) throw new Error("invalid movement");
            L.get(this)._SetMovement(t2);
          }
          get movement() {
            return M[L.get(this)._GetMovement()];
          }
          set wave(e) {
            h.RequireString(e);
            const t2 = N.indexOf(e);
            if (-1 === t2) throw new Error("invalid wave");
            L.get(this)._SetWave(t2);
          }
          get wave() {
            return N[L.get(this)._GetWave()];
          }
          get value() {
            const e = L.get(this);
            return e.WaveFunc(e._GetPhase()) * e._GetMagnitude();
          }
          updateInitialState() {
            L.get(this).Init();
          }
          set isEnabled(e) {
            L.get(this)._SetEnabled(!!e);
          }
          get isEnabled() {
            return L.get(this)._IsEnabled();
          }
        };
      }
      {
        const va = self.C3;
        va.Behaviors.Sin.Cnds = { IsEnabled() {
          return this._IsEnabled();
        }, CompareMovement(e) {
          return this._GetMovement() === e;
        }, ComparePeriod(e, t) {
          return va.compare(this._GetPeriod(), e, t);
        }, CompareMagnitude(e, t) {
          return va.compare(this._GetMagnitude_ConvertAngle(), e, t);
        }, CompareWave(e) {
          return this._GetWave() === e;
        } };
      }
      {
        const Ca = self.C3;
        Ca.Behaviors.Sin.Acts = { SetEnabled(e) {
          this._SetEnabled(0 !== e);
        }, SetPeriod(e) {
          this._SetPeriod(e);
        }, SetMagnitude(e) {
          this._SetMagnitude_ConvertAngle(e);
        }, SetMovement(e) {
          this._SetMovement(e);
        }, SetWave(e) {
          this._wave = e;
        }, SetPhase(e) {
          const t = 2 * Math.PI;
          this._SetPhase(e * t % t);
        }, UpdateInitialState() {
          this.Init();
        } };
      }
      {
        const Ka = self.C3;
        Ka.Behaviors.Sin.Exps = { CyclePosition() {
          return this._GetPhase() / (2 * Math.PI);
        }, Period() {
          return this._GetPeriod();
        }, Magnitude() {
          return this._GetMagnitude_ConvertAngle();
        }, Value() {
          return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Behaviors.Fade = class extends a.SDKBehaviorBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Behaviors.Fade.Type = class extends d.SDKBehaviorTypeBase {
          constructor(t) {
            super(t);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IBehaviorInstance, j = 0, k = 1, l = 2, m = 3, n = 4, o = (g.Behaviors.Fade.Instance = class extends g.SDKBehaviorInstanceBase {
          constructor(t, e) {
            super(t), this._fadeInTime = 0, this._waitTime = 0, this._fadeOutTime = 0, this._destroy = true, this._activeAtStart = true, this._setMaxOpacity = false, this._stage = 0, this._stageTime = g.New(g.KahanSum), this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, e && (this._fadeInTime = e[j], this._waitTime = e[k], this._fadeOutTime = e[l], this._destroy = !!e[m], this._activeAtStart = !!e[n], this._stage = this._activeAtStart ? 0 : 3), this._activeAtStart && (0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender())), this._StartTicking();
          }
          Release() {
            super.Release();
          }
          SaveToJson() {
            return { "fit": this._fadeInTime, "wt": this._waitTime, "fot": this._fadeOutTime, "d": this._destroy, "s": this._stage, "st": this._stageTime.Get(), "mo": this._maxOpacity };
          }
          LoadFromJson(t) {
            this._fadeInTime = t["fit"], this._waitTime = t["wt"], this._fadeOutTime = t["fot"], this._destroy = t["d"], this._stage = t["s"], this._stageTime.Set(t["st"]), this._maxOpacity = t["mo"], 3 === this._stage ? this._StopTicking() : this._StartTicking();
          }
          Tick() {
            const t = this._runtime.GetDt(this._inst), e = (this._stageTime.Add(t), this._inst.GetWorldInfo());
            0 === this._stage && (e.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity), this._runtime.UpdateRender(), e.GetOpacity() >= this._maxOpacity) && (e.SetOpacity(this._maxOpacity), this._stage = 1, this._stageTime.Reset(), this.DispatchScriptEvent("fadeinend"), this.Trigger(g.Behaviors.Fade.Cnds.OnFadeInEnd)), 1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2, this._stageTime.Reset(), this.DispatchScriptEvent("waitend"), this.Trigger(g.Behaviors.Fade.Cnds.OnWaitEnd)), 2 === this._stage && (0 !== this._fadeOutTime ? (e.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity), this._runtime.UpdateRender(), e.GetOpacity() <= 0 && (this._stage = 3, this._stageTime.Reset(), this.DispatchScriptEvent("fadeoutend"), this.Trigger(g.Behaviors.Fade.Cnds.OnFadeOutEnd), this._destroy) && this._runtime.DestroyInstance(this._inst)) : (this._stage = 3, this._stageTime.Reset())), 3 === this._stage && this._StopTicking();
          }
          _StartFade() {
            this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, this._setMaxOpacity = true), 3 === this._stage && this.Start();
          }
          _RestartFade() {
            this.Start();
          }
          Start() {
            this._stage = 0, this._stageTime.Reset(), 0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender()), this._StartTicking();
          }
          _SetFadeInTime(t) {
            this._fadeInTime = Math.max(t, 0);
          }
          _GetFadeInTime() {
            return this._fadeInTime;
          }
          _SetWaitTime(t) {
            this._waitTime = Math.max(t, 0);
          }
          _GetWaitTime() {
            return this._waitTime;
          }
          _SetFadeOutTime(t) {
            this._fadeOutTime = Math.max(t, 0);
          }
          _GetFadeOutTime() {
            return this._fadeOutTime;
          }
          GetPropertyValueByIndex(t) {
            switch (t) {
              case j:
                return this._GetFadeInTime();
              case k:
                return this._GetWaitTime();
              case l:
                return this._GetFadeOutTime();
              case m:
                return this._destroy;
            }
          }
          SetPropertyValueByIndex(t, e) {
            switch (t) {
              case j:
                this._SetFadeInTime(e);
                break;
              case k:
                this._SetWaitTime(e);
                break;
              case l:
                this._SetFadeOutTime(e);
                break;
              case m:
                this._destroy = !!e;
            }
          }
          GetDebuggerProperties() {
            const t = "behaviors.fade";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t + ".properties.fade-in-time.name", value: this._GetFadeInTime(), onedit: (t2) => this._SetFadeInTime(t2) }, { name: t + ".properties.wait-time.name", value: this._GetWaitTime(), onedit: (t2) => this._SetWaitTime(t2) }, { name: t + ".properties.fade-out-time.name", value: this._GetFadeOutTime(), onedit: (t2) => this._SetFadeOutTime(t2) }, { name: t + ".debugger.stage", value: [t + ".debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]] }] }];
          }
          GetScriptInterfaceClass() {
            return self.IFadeBehaviorInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IFadeBehaviorInstance = class extends i {
          constructor() {
            super(), o.set(this, i._GetInitInst().GetSdkInstance());
          }
          startFade() {
            o.get(this)._StartFade();
          }
          restartFade() {
            o.get(this)._RestartFade();
          }
          set fadeInTime(t) {
            h.RequireFiniteNumber(t), o.get(this)._SetFadeInTime(t);
          }
          get fadeInTime() {
            return o.get(this)._GetFadeInTime();
          }
          set waitTime(t) {
            h.RequireFiniteNumber(t), o.get(this)._SetWaitTime(t);
          }
          get waitTime() {
            return o.get(this)._GetWaitTime();
          }
          set fadeOutTime(t) {
            h.RequireFiniteNumber(t), o.get(this)._SetFadeOutTime(t);
          }
          get fadeOutTime() {
            return o.get(this)._GetFadeOutTime();
          }
        };
      }
      {
        const J = self.C3;
        J.Behaviors.Fade.Cnds = { OnFadeOutEnd() {
          return true;
        }, OnFadeInEnd() {
          return true;
        }, OnWaitEnd() {
          return true;
        } };
      }
      {
        const K = self.C3;
        K.Behaviors.Fade.Acts = { StartFade() {
          this._StartFade();
        }, RestartFade() {
          this._RestartFade();
        }, SetFadeInTime(t) {
          this._SetFadeInTime(t);
        }, SetWaitTime(t) {
          this._SetWaitTime(t);
        }, SetFadeOutTime(t) {
          this._SetFadeOutTime(t);
        } };
      }
      {
        const O = self.C3;
        O.Behaviors.Fade.Exps = { FadeInTime() {
          return this._GetFadeInTime();
        }, WaitTime() {
          return this._GetWaitTime();
        }, FadeOutTime() {
          return this._GetFadeOutTime();
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Behaviors.Rotate = class extends a.SDKBehaviorBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Behaviors.Rotate.Type = class extends d.SDKBehaviorTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = self.C3X, i = self.IBehaviorInstance, j = 0, k = 1, l = 2, m = (g.Behaviors.Rotate.Instance = class extends g.SDKBehaviorInstanceBase {
          constructor(e, t) {
            super(e), this._speed = 0, this._acceleration = 0, this._isEnabled = true, t && (this._speed = g.toRadians(t[j]), this._acceleration = g.toRadians(t[k]), this._isEnabled = t[l]), this._isEnabled && this._StartTicking();
          }
          Release() {
            super.Release();
          }
          _SetSpeed(e) {
            this._speed = e;
          }
          _GetSpeed() {
            return this._speed;
          }
          _SetAcceleration(e) {
            this._acceleration = e;
          }
          _GetAcceleration() {
            return this._acceleration;
          }
          SaveToJson() {
            return { "s": this._speed, "a": this._acceleration, "e": this._isEnabled };
          }
          LoadFromJson(e) {
            this._speed = e["s"], this._acceleration = e["a"], this._SetEnabled(e["e"]);
          }
          Tick() {
            if (this._isEnabled) {
              const e = this._runtime.GetDt(this._inst);
              if (0 !== e && (0 !== this._acceleration && (this._speed += this._acceleration * e), 0 !== this._speed)) {
                const t = this._inst.GetWorldInfo();
                t.SetAngle(t.GetAngle() + this._speed * e), t.SetBboxChanged();
              }
            }
          }
          GetPropertyValueByIndex(e) {
            switch (e) {
              case j:
                return g.toDegrees(this._GetSpeed());
              case k:
                return g.toDegrees(this._GetAcceleration());
              case l:
                return this._IsEnabled();
            }
          }
          SetPropertyValueByIndex(e, t) {
            switch (e) {
              case j:
                this._SetSpeed(g.toRadians(t));
                break;
              case k:
                this._SetAcceleration(g.toRadians(t));
                break;
              case l:
                this._SetEnabled(t);
            }
          }
          _SetEnabled(e) {
            this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : this._StopTicking();
          }
          _IsEnabled() {
            return this._isEnabled;
          }
          GetDebuggerProperties() {
            const e = "behaviors.rotate";
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e + ".properties.speed.name", value: g.toDegrees(this._GetSpeed()), onedit: (e2) => this._SetSpeed(g.toRadians(e2)) }, { name: e + ".properties.acceleration.name", value: g.toDegrees(this._GetAcceleration()), onedit: (e2) => this._SetAcceleration(g.toRadians(e2)) }, { name: e + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
          }
          GetScriptInterfaceClass() {
            return self.IRotateBehaviorInstance;
          }
        }, /* @__PURE__ */ new WeakMap());
        self.IRotateBehaviorInstance = class extends i {
          constructor() {
            super(), m.set(this, i._GetInitInst().GetSdkInstance());
          }
          set speed(e) {
            h.RequireFiniteNumber(e), m.get(this)._SetSpeed(e);
          }
          get speed() {
            return m.get(this)._GetSpeed();
          }
          set acceleration(e) {
            h.RequireFiniteNumber(e), m.get(this)._SetAcceleration(e);
          }
          get acceleration() {
            return m.get(this)._GetAcceleration();
          }
          get isEnabled() {
            return m.get(this)._IsEnabled();
          }
          set isEnabled(e) {
            m.get(this)._SetEnabled(e);
          }
        };
      }
      {
        const H = self.C3;
        H.Behaviors.Rotate.Cnds = { IsEnabled() {
          return this._IsEnabled();
        } };
      }
      {
        const I = self.C3;
        I.Behaviors.Rotate.Acts = { SetSpeed(e) {
          this._SetSpeed(I.toRadians(e));
        }, SetAcceleration(e) {
          this._SetAcceleration(I.toRadians(e));
        }, SetEnabled(e) {
          this._SetEnabled(e);
        } };
      }
      {
        const M = self.C3;
        M.Behaviors.Rotate.Exps = { Speed() {
          return M.toDegrees(this._GetSpeed());
        }, Acceleration() {
          return M.toDegrees(this._GetAcceleration());
        } };
      }
    }
    {
      {
        const a = self.C3;
        a.Behaviors.Tween = class extends a.SDKBehaviorBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
        };
      }
      {
        const d = self.C3;
        d.Behaviors.Tween.Type = class extends d.SDKBehaviorTypeBase {
          constructor(e) {
            super(e);
          }
          Release() {
            super.Release();
          }
          OnCreate() {
          }
        };
      }
      {
        const g = self.C3, h = g.Behaviors.Tween, i = 0;
        h.Instance = class extends g.SDKBehaviorInstanceBase {
          constructor(e, s) {
            super(e), this._allowMultiple = false, this._enabled = true, s && (this._allowMultiple = false, this._enabled = !!s[i]), this._activeTweens = /* @__PURE__ */ new Map(), this._disabledTweens = [], this._waitingForReleaseTweens = /* @__PURE__ */ new Map(), this._finishingTween = null, this._activeTweensJson = null, this._disabledTweensJson = null, this._waitingForReleaseTweensJson = null, this._finishingTweenName = "", this._triggerTweens = [], this._afterLoad = (e2) => this._OnAfterLoad(), this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);
          }
          Release() {
            this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad), this._afterLoad = null, this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null), this.ReleaseAndCompleteTweens(), this._tweens = null, this.ClearDisabledList(), this._disabledTweens = null, this._ReleaseWaitingTweens(), this._waitingForReleaseTweens = null, this._triggerTweens = null, super.Release();
          }
          PushTriggerTween(e) {
            this._triggerTweens.push(e);
          }
          PopTriggerTween() {
            this._triggerTweens.pop();
          }
          GetTriggerTween() {
            return this._triggerTweens[this._triggerTweens.length - 1];
          }
          SetEnabled(e) {
            this._enabled = !!e, e ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
            for (const s of this.AllTweens()) e ? this.IsInDisabledList(s) && s.Resume() : ((s.IsPlaying() || s.IsScheduled()) && this.AddToDisabledList(s), s.Stop());
            e && this.ClearDisabledList();
          }
          IsEnabled() {
            return this._enabled;
          }
          AddToDisabledList(e) {
            this._disabledTweens.push(e);
          }
          IsInDisabledList(e) {
            return this._disabledTweens.includes(e);
          }
          ClearDisabledList() {
            g.clearArray(this._disabledTweens);
          }
          GetFinishingTween() {
            return this._finishingTween;
          }
          IsInstanceValid() {
            const e = this.GetObjectInstance();
            return !!e && !e.IsDestroyed();
          }
          GetTween(e, s, t = false) {
            const n = s ? this.PropertyTweens(s, t) : this.AllTweens(t);
            if (n && n.length) {
              for (const i2 of n) if (i2.HasTags(e)) return i2;
            }
          }
          CheckTweensWithTags(e, s) {
            for (const t of this._activeTweens.values()) for (const n of t) if (!n.IsReleased() && n.HasTags(e) && s(n)) return true;
            for (const i2 of this._waitingForReleaseTweens.values()) for (const a of i2) if (!a.IsReleased() && a.HasTags(e) && s(a)) return true;
            return false;
          }
          CheckTweens(e) {
            for (const s of this._activeTweens.values()) for (const t of s) if (!t.IsReleased() && e(t)) return true;
            for (const n of this._waitingForReleaseTweens.values()) for (const i2 of n) if (!i2.IsReleased() && e(i2)) return true;
            return false;
          }
          GetTweenIncludingWaitingForRelease(e, s) {
            return this.GetTween(e, s, true);
          }
          *GetTweens(e, s, t = false) {
            const n = s ? this.PropertyTweens(s, t) : this.AllTweens(t);
            if (n && n.length) for (const i2 of n) i2.HasTags(e) && (yield i2);
          }
          *GetTweensIncludingWaitingForRelease(e, s) {
            yield* this.GetTweens(e, s, true);
          }
          PropertyTweens(t, e) {
            if (e) {
              let e2 = this._activeTweens.get(t), s = this._waitingForReleaseTweens.get(t);
              return e2 = e2 || [], s = s || [], e2.concat(s).filter((e3) => e3).filter((e3) => !e3.IsReleased());
            }
            {
              let e2 = this._activeTweens.get(t);
              return (e2 = e2 || []).filter((e3) => e3).filter((e3) => !e3.IsReleased());
            }
          }
          AllTweens(e) {
            if (e) {
              const s = [...this._activeTweens.values()].flat(), t = [...this._waitingForReleaseTweens.values()].flat();
              return s.concat(t).filter((e2) => e2).filter((e2) => !e2.IsReleased());
            }
            {
              const n = [...this._activeTweens.values()].flat();
              return n.filter((e2) => e2).filter((e2) => !e2.IsReleased());
            }
          }
          AllTweensIncludingWaitingForRelease() {
            return this.AllTweens(true);
          }
          SaveToJson(e = 0) {
            return { "s": false, "e": !!this._enabled, "at": this._SaveActiveTweensToJson(), "dt": this._SaveDisabledTweensToJson(), "wt": this._SaveWaitingForReleaseTweensToJson(), "ft": this._SaveFinishingTweenToJson() };
          }
          LoadFromJson(e, s = "full") {
            e && (this._activeTweensJson = e["at"], this._disabledTweensJson = e["dt"], this._waitingForReleaseTweensJson = e["wt"], this._finishingTweenName = e["ft"], this._allowMultiple = false, this._enabled = !!e["e"], "state" === s) && this._OnAfterLoad();
          }
          _OnAfterLoad() {
            const e = this.GetRuntime().GetTimelineManager();
            if (this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, e), this._disabledTweensJson) {
              g.clearArray(this._disabledTweens);
              for (const s of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, s, e);
            }
            this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, e), this._finishingTween = this._GetTween(this._finishingTweenName, e), this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
          }
          _PopulateTweenMap(s, t, n) {
            if (s) for (const i2 in s) {
              let e = t.get(i2);
              e ? g.clearArray(e) : e = [];
              const a = s[i2];
              for (const r of a) {
                const o = this._PopulateTweenArray(e, r["name"], n);
                if (o) this._LoadTweenFromJson(r["name"], r, n);
                else {
                  const l = g.TweenState.Build({ runtime: this.GetRuntime(), json: r });
                  g.TweenState.SetInstanceUID(l, this.GetObjectInstance().GetUID()), l.AddCompletedCallback((e2) => this._FinishTriggers(e2)), n.AddScheduledTimeline(l), this._PopulateTweenArray(e, l, n);
                }
              }
              t.set(i2, e);
            }
          }
          _GetTween(e, s) {
            return s.GetScheduledOrPlayingTimelineByName(e);
          }
          _PopulateTweenArray(e, s, t) {
            if ("string" != typeof s) return !!e.push(s);
            {
              const n = this._GetTween(s, t);
              if (n) return !!e.push(n);
            }
            return false;
          }
          _LoadTweenFromJson(e, s, t) {
            if ("string" == typeof e) {
              const n = this._GetTween(e, t);
              n && (n._LoadFromJson(s), g.TweenState.SetInstanceUID(n, this.GetObjectInstance().GetUID()));
            } else e._LoadFromJson(s), g.TweenState.SetInstanceUID(e, this.GetObjectInstance().GetUID());
          }
          _SaveActiveTweensToJson() {
            const e = {};
            for (const [s, t] of this._activeTweens) e[s] = t.filter((e2) => !e2.IsReleased()).map((e2) => e2._SaveToJson());
            return e;
          }
          _SaveDisabledTweensToJson() {
            return this._disabledTweens.filter((e) => !e.IsReleased()).map((e) => e.GetName());
          }
          _SaveWaitingForReleaseTweensToJson() {
            const e = {};
            for (const [s, t] of this._waitingForReleaseTweens) e[s] = t.map((e2) => e2._SaveToJson());
            return e;
          }
          _SaveFinishingTweenToJson() {
            return this._finishingTween ? this._finishingTween.GetName() : "";
          }
          Tick2() {
            this._ReleaseWaitingTweens();
          }
          CreateTween(e) {
            const s = h.Config.GetPropertyTracksConfig(e.property, e.startValue, e.endValue, e.ease, e.resultMode, this.GetObjectInstance()), t = h.Maps.GetPropertyFromIndex(e.property), n = (h.Maps.IsValueId(t) || this.ReleaseTweens(e.property), g.TweenState.Build({ runtime: this.GetRuntime(), id: t, tags: e.tags, time: e.time, instance: this.GetObjectInstance(), releaseOnComplete: !!e.releaseOnComplete, loop: !!e.loop, pingPong: !!e.pingPong, repeatCount: e.repeatCount, initialValueMode: e.initialValueMode, propertyTracksConfig: s }));
            return n.AddCompletedCallback((e2) => this._FinishTriggers(e2)), this._AddTween(n, e.property), n;
          }
          _MaybeRemoveFromActiveTweenMap(e) {
            const s = e.GetId();
            if (this._activeTweens.has(s)) {
              const t = this._activeTweens.get(s);
              if (t) {
                const n = t.indexOf(e);
                -1 !== n && t.splice(n, 1);
              }
            }
          }
          ReleaseTween(e, s = false) {
            this._MaybeRemoveFromActiveTweenMap(e), e.IsReleased() || this._IsInWaitingList(e) || (e.Stop(s), this._AddToWaitingList(e));
          }
          ReleaseTweens(e, s = false) {
            if (g.IsFiniteNumber(e)) {
              const t = h.Maps.GetPropertyFromIndex(e);
              if (this._activeTweens.has(t)) {
                const n = this._activeTweens.get(t), i2 = this.GetFinishingTween();
                for (const a of n) a === i2 || a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(s), a.Release());
                g.clearArray(n);
              }
            } else {
              const r = this.GetFinishingTween();
              for (const o of this.AllTweens()) o === r || o.IsReleased() || this._IsInWaitingList(o) || (o.Stop(s), o.Release());
              for (const l of this._activeTweens.keys()) g.clearArray(this._activeTweens.get(l)), this._activeTweens.delete(l);
              this._activeTweens.clear();
            }
          }
          ReleaseAndCompleteTween(e) {
            this.ReleaseTween(e, true);
          }
          ReleaseAndCompleteTweens() {
            this.ReleaseTweens(NaN, true);
          }
          GetPropertyValueByIndex(e) {
            if (e === i) return this._enabled;
          }
          SetPropertyValueByIndex(e, s) {
            e === i && (this._enabled = !!s);
          }
          _GetBehaviorType(e) {
            const s = e.GetInstance(), t = s.GetBehaviorInstances();
            for (const n of t) {
              const i2 = n.GetBehaviorType();
              if (i2.GetInstanceSdkCtor() === this.constructor) return i2;
            }
          }
          Trigger(e, s, t, n) {
            return this._runtime ? super.Trigger(e) : s.Trigger(e, t, n);
          }
          _FinishTriggers(e) {
            this._finishingTween = e, h.Cnds.SetFinishingTween(e);
            let s, t;
            if (this.GetRuntime()) s = this._inst, t = this._runtime, this.Trigger(h.Cnds.OnTweensFinished), this.Trigger(h.Cnds.OnAnyTweensFinished), this.ReleaseTween(e);
            else {
              if (!(s = e.GetInstance())) return;
              if (s && s.IsDestroyed()) return;
              t = s.GetRuntime();
              const n = this._GetBehaviorType(e);
              this.Trigger(h.Cnds.OnTweensFinished, t, s, n), this.Trigger(h.Cnds.OnAnyTweensFinished, t, s, n), e.Stop();
            }
            this._finishingTween = null, h.Cnds.SetFinishingTween(null), e.GetDestroyInstanceOnComplete() && t.DestroyInstance(s);
          }
          _AddTween(e, s) {
            const t = h.Maps.GetPropertyFromIndex(s), n = (this._activeTweens.has(t) || this._activeTweens.set(t, []), this._activeTweens.get(t));
            n.push(e);
          }
          _AddToWaitingList(e) {
            const s = e.GetId();
            this._waitingForReleaseTweens.has(s) || this._waitingForReleaseTweens.set(s, []), this._waitingForReleaseTweens.get(s).push(e), this.IsTicking2() || this._StartTicking2();
          }
          _IsInWaitingList(e) {
            const s = e.GetId();
            return !!this._waitingForReleaseTweens.has(s) && this._waitingForReleaseTweens.get(s).includes(e);
          }
          _ReleaseWaitingTweens() {
            if (this._waitingForReleaseTweens.size) {
              for (const e of this._waitingForReleaseTweens.values()) {
                for (const s of e) s.IsReleased() || s.Release();
                g.clearArray(e);
              }
              this._waitingForReleaseTweens.clear(), this.IsTicking2() && this._StopTicking2();
            }
          }
          GetDebuggerProperties() {
            return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.tween.properties.enabled.name", value: this.IsEnabled(), onedit: (e) => this.SetEnabled(e) }] }];
          }
          GetScriptInterfaceClass() {
            return self.ITweenBehaviorInstance;
          }
        };
      }
      {
        const M0 = self.C3;
        let s = null;
        M0.Behaviors.Tween.Cnds = { OnAnyTweenLoop() {
          return true;
        }, OnTweensLoop(e) {
          const s2 = this.GetTriggerTween();
          return !!s2 && s2.HasTags(e);
        }, OnAnyTweenPingPong(e) {
          const s2 = this.GetTriggerTween();
          return !!s2 && (s2.GetPingPongState() === e || 2 === e);
        }, OnTweensPingPong(e, s2) {
          const t = this.GetTriggerTween();
          return !!t && (t.GetPingPongState() === s2 || 2 === s2) && t.HasTags(e);
        }, SetFinishingTween(e) {
          s = e;
        }, OnTweensFinished(e) {
          return s.HasTags(e);
        }, OnAnyTweensFinished() {
          return true;
        }, IsPlaying(e) {
          return this.CheckTweensWithTags(e, M0.TweenState.IsPlaying);
        }, IsAnyPlaying() {
          return this.CheckTweens(M0.TweenState.IsPlaying);
        }, IsPaused(e) {
          return this.CheckTweensWithTags(e, M0.TweenState.IsPaused);
        }, IsAnyPaused() {
          return this.CheckTweens(M0.TweenState.IsPaused);
        }, IsPingPong(e, s2) {
          return 0 === s2 ? this.CheckTweensWithTags(e, M0.TweenState.IsPing) : 1 === s2 && this.CheckTweensWithTags(e, M0.TweenState.IsPong);
        }, IsAnyPingPong(e) {
          return 0 === e ? this.CheckTweens(M0.TweenState.IsPing) : 1 === e && this.CheckTweens(M0.TweenState.IsPong);
        } };
      }
      {
        const ab = self.C3, bb = self.Ease, cb = ab.Behaviors.Tween;
        cb.Acts = { SetEnabled(e) {
          this.SetEnabled(!!e);
        }, async TweenOneProperty(...e) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const s = this.CreateTween(cb.TweenArguments.OneProperty(this, ...e));
            s.Play() && await s.GetPlayPromise();
          }
        }, async TweenTwoProperties(...e) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const s = this.CreateTween(cb.TweenArguments.TwoProperties(this, ...e));
            s.Play() && await s.GetPlayPromise();
          }
        }, async TweenValue(...e) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const s = this.CreateTween(cb.TweenArguments.ValueProperty(this, ...e));
            s.Play() && await s.GetPlayPromise();
          }
        }, PauseTweens(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) s.Stop();
        }, PauseAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) e.Stop();
        }, ResumeTweens(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) s.Resume();
        }, ResumeAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) e.Resume();
        }, StopTweens(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) this.ReleaseTween(s);
        }, StopAllTweens() {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) this.ReleaseTween(e);
        }, SetOnePropertyTweensEndValue(e, s, t) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const n = ab.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(s);
            for (const i of this.GetTweens(e)) i.BeforeSetEndValues([n]), i.SetEndValue(t, n);
          }
        }, SetTwoPropertiesTweensEndValue(e, s, t, n) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const i = ab.Behaviors.Tween.Maps.GetRealProperties(s);
            for (const a of this.GetTweens(e)) a.BeforeSetEndValues(i), a.SetEndValue(t, i[0]), a.SetEndValue(n, i[1]);
          }
        }, SetValuePropertyTweensStartValue(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e, "value")) t.SetStartValue(s, "value");
        }, SetValuePropertyTweensEndValue(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e, "value")) t.BeforeSetEndValues(["value"]), t.SetEndValue(s, "value");
        }, SetTweensEase(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const t = bb.GetEaseFromIndex(s);
            for (const n of this.GetTweens(e)) n.SetEase(t);
          }
        }, SetAllTweensEase(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) {
            const s = bb.GetEaseFromIndex(e);
            for (const t of this.AllTweens()) t.SetEase(s);
          }
        }, SetTweensTime(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetTime(s);
        }, SetAllTweensTime(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetTime(e);
        }, SetTweensPlaybackRate(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetPlaybackRate(s);
        }, SetAllTweensPlaybackRate(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetPlaybackRate(e);
        }, SetTweensDestroyOnComplete(e, s) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetDestroyInstanceOnComplete(!!s);
        }, SetAllTweensDestroyOnComplete(e) {
          if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetDestroyInstanceOnComplete(!!e);
        } };
      }
      {
        const e1 = self.C3;
        e1.Behaviors.Tween.Exps = { Time(e) {
          const s = this.GetTweenIncludingWaitingForRelease(e);
          return s ? s.GetTime() : 0;
        }, Progress(e) {
          const s = this.GetTweenIncludingWaitingForRelease(e);
          return s ? s.GetTime() / s.GetTotalTime() : 0;
        }, PlaybackRate(e) {
          const s = this.GetTweenIncludingWaitingForRelease(e);
          return s ? s.GetPlaybackRate() : 0;
        }, Value(e) {
          const s = this.GetTweenIncludingWaitingForRelease(e, "value");
          return s ? s.GetPropertyTrack("value").GetSourceAdapterValue() : 0;
        }, Tags() {
          let e = this.GetFinishingTween();
          return (e = e || this.GetTriggerTween()) ? e.GetStringTags() : "";
        } };
      }
    }
    {
      const C33 = self.C3, Ease = self.Ease, PAIR_PROPERTIES = ["position", "size", "scale"], SINGLE_PROPERTIES = ["offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY"], VALUE_PROPERTIES = ["value"], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = { "position": ["offsetX", "offsetY"], "size": ["offsetWidth", "offsetHeight"], "scale": ["offsetScaleX", "offsetScaleY"] }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((e, t) => Object.assign({}, e, { [t]: [t] }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
      C33.Behaviors.Tween.Maps = class {
        constructor() {
        }
        static GetEases() {
          return [...Ease.GetRuntimeEaseNames()];
        }
        static GetEaseFromIndex(e) {
          return [...Ease.GetRuntimeEaseNames()][e];
        }
        static GetPropertyFromIndex(e) {
          return PROPERTY_INDEX_TO_NAME[e];
        }
        static GetPropertyIndexFromName(e) {
          return PROPERTY_INDEX_TO_NAME.indexOf(e);
        }
        static GetPairPropertyFromIndex(e) {
          return PAIR_PROPERTIES[e];
        }
        static GetSinglePropertyFromIndex(e) {
          return SINGLE_PROPERTIES[e];
        }
        static GetValuePropertyFromIndex(e) {
          return VALUE_PROPERTIES[e];
        }
        static GetPairProperties(e) {
          return PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
        }
        static GetRealProperties(e) {
          return C33.IsString(e) ? ALL_REAL_PROPERTIES[e] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[e]];
        }
        static IsPairId(e) {
          return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[e];
        }
        static IsColorId(e) {
          return "offsetColor" === e;
        }
        static IsAngleId(e) {
          return "offsetAngle" === e;
        }
        static IsOpacityId(e) {
          return "offsetOpacity" === e;
        }
        static IsValueId(e) {
          return "value" === e;
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TWEEN_CONFIGURATIONS = /* @__PURE__ */ new Map();
      NAMESPACE.Config = class {
        constructor() {
        }
        static GetPropertyTracksConfig(e, t, r, o, a, s) {
          0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
          const n = NAMESPACE.PropertyTypes.Pick(e);
          let i = TWEEN_CONFIGURATIONS.get(n);
          return C33.IsFiniteNumber(e) && (e = NAMESPACE.Maps.GetPropertyFromIndex(e)), this._GetConfig(i, e, t, r, o, a, s);
        }
        static TransformValue(e, t) {
          const r = C33.Behaviors.Tween.GetPropertyTracksConfig(e);
          return r.valueGetter(t);
        }
        static _CreateConfigObjects() {
          const e = NAMESPACE.PropertyTypes, t = NAMESPACE.ValueGetters;
          this._AddConfigObject(e.PAIR, this._GetPairConfig, t._GetPropertyValue), this._AddConfigObject(e.COLOR, this._GetColorConfig, t._GetColorPropertyValue), this._AddConfigObject(e.ANGLE, this._GetAngleConfig, t._GetPropertyAngleValue), this._AddConfigObject(e.VALUE, this._GetValueConfig, t._GetPropertyValue), this._AddConfigObject(e.OTHER, this._GetCommonConfig, t._GetPropertyValue);
        }
        static _AddConfigObject(e, t, r) {
          TWEEN_CONFIGURATIONS.set(e, this._CreateConfigObject(e, t, r));
        }
        static _CreateConfigObject(e, t, r) {
          return { name: e, configFunc: t, valueGetter: r };
        }
        static _GetConfig(e, t, r, o, a, s, n) {
          return e.configFunc(t, e.valueGetter(r), e.valueGetter(o), a, s, n);
        }
        static _GetPairConfig(e, r, o, a, s, t) {
          const n = NAMESPACE.Maps.GetPairProperties(e);
          return n.map((e2, t2) => ({ sourceId: "world-instance", property: e2, type: "float", valueType: "numeric", startValue: r[t2], endValue: o[t2], ease: NAMESPACE.Maps.GetEaseFromIndex(a), resultMode: s }));
        }
        static _GetColorConfig(e, t, r, o, a, s) {
          return C33.Plugins.Text && s.GetPlugin() instanceof C33.Plugins.Text ? { sourceId: "plugin", sourceArgs: [7], property: "color", type: "color", valueType: "color", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a } : { sourceId: "world-instance", property: e, type: "color", valueType: "color", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
        }
        static _GetAngleConfig(e, t, r, o, a, s) {
          return { sourceId: "world-instance", property: e, type: "angle", valueType: "angle", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
        }
        static _GetCommonConfig(e, t, r, o, a, s) {
          return { sourceId: "world-instance", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
        }
        static _GetValueConfig(e, t, r, o, a, s) {
          return { sourceId: "value", property: e, type: "float", valueType: "numeric", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, COMMON_FIXED_ARGS = { resultMode: "absolute" }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, { tags: "", property: "", time: 0, ease: 0, releaseOnComplete: 0, loop: false, pingPong: false, repeatCount: 1 }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: 0, endValue: 0 }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0], endValue: [0, 0] }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: "current-state", startValue: [0, 0, 0], endValue: [0, 0, 0] }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, { initialValueMode: "start-value" }), X = 0, Y = 1, R = 0, G = 1, B = 2;
      NAMESPACE.TweenArguments = class {
        constructor() {
        }
        static _SetCommonProperties(e, t, R2, r, P, a, E, O) {
          e.tags = t, e.time = R2, e.ease = r, e.releaseOnComplete = P, e.loop = a, e.pingPong = E, e.repeatCount = O;
        }
        static OneProperty(e, t, r, P, a, E, O, A, _, o) {
          const s = "string" == typeof r ? r : NAMESPACE.Maps.GetSinglePropertyFromIndex(r), n = NAMESPACE.Maps.IsColorId(s) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
          return this._SetCommonProperties(n, t, a, E, O, A, _, o), NAMESPACE.Maps.IsColorId(s) ? (COLOR_PROPERTY_ARGS.endValue[R] = C33.GetRValue(P), COLOR_PROPERTY_ARGS.endValue[G] = C33.GetGValue(P), COLOR_PROPERTY_ARGS.endValue[B] = C33.GetBValue(P), COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s)) : NAMESPACE.Maps.IsOpacityId(s) ? ONE_PROPERTY_ARGS.endValue = P / 100 : ONE_PROPERTY_ARGS.endValue = P, n.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), n;
        }
        static TwoProperties(e, t, R2, r, P, a, E, O, A, _, o) {
          this._SetCommonProperties(TWO_PROPERTIES_ARGS, t, a, E, O, A, _, o);
          const s = "string" == typeof R2 ? R2 : NAMESPACE.Maps.GetPairPropertyFromIndex(R2);
          return TWO_PROPERTIES_ARGS.endValue[X] = r, TWO_PROPERTIES_ARGS.endValue[Y] = P, TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), TWO_PROPERTIES_ARGS;
        }
        static ValueProperty(e, t, R2, r, P, a, E, O, A, _) {
          return this._SetCommonProperties(VALUE_PROPERTY_ARGS, t, P, a, E, O, A, _), VALUE_PROPERTY_ARGS.startValue = R2, VALUE_PROPERTY_ARGS.endValue = r, VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName("value"), VALUE_PROPERTY_ARGS;
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TYPE_CHECK_OBJECTS = [];
      NAMESPACE.PropertyTypes = class {
        constructor() {
        }
        static Pick(t) {
          if (0 === TYPE_CHECK_OBJECTS.length) {
            const e = TYPE_CHECK_OBJECTS;
            e.push({ checkFunc: NAMESPACE.Maps.IsPairId, result: this.PAIR }), e.push({ checkFunc: NAMESPACE.Maps.IsColorId, result: this.COLOR }), e.push({ checkFunc: NAMESPACE.Maps.IsAngleId, result: this.ANGLE }), e.push({ checkFunc: NAMESPACE.Maps.IsValueId, result: this.VALUE }), e.push({ checkFunc: () => true, result: this.OTHER });
          }
          C33.IsFiniteNumber(t) && (t = C33.Behaviors.Tween.Maps.GetPropertyFromIndex(t));
          for (const s of TYPE_CHECK_OBJECTS) if (s.checkFunc(t)) return s.result;
        }
        static get PAIR() {
          return "pair";
        }
        static get COLOR() {
          return "color";
        }
        static get ANGLE() {
          return "angle";
        }
        static get VALUE() {
          return "value";
        }
        static get OTHER() {
          return "other";
        }
      };
    }
    {
      const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween;
      NAMESPACE.ValueGetters = class {
        constructor() {
        }
        static _GetPropertyAngleValue(e) {
          const t = C33.toRadians(parseFloat(e));
          return C33.clampAngle(t);
        }
        static _GetColorPropertyValue(e) {
          return e.slice(0);
        }
        static _GetPropertyValue(e) {
          return e;
        }
      };
    }
    {
      let getIndexForEase2 = function(e) {
        C3X.RequireString(e);
        const t = Ease.ToInternal(e);
        let n;
        if (-1 === (n = t ? Ease.GetIndexForEase(t, null) : Ease.GetIndexForEase(e, null))) throw new Error(`invalid ease name '${e}'`);
        return n;
      }, ValidateTags2 = function(e, t = false) {
        if (!(t && null == e || "string" == typeof e || Array.isArray(e))) throw new Error("invalid tags");
      };
      getIndexForEase = getIndexForEase2, ValidateTags = ValidateTags2;
      const C33 = self.C3, C3X = self.C3X, IBehaviorInstance = self.IBehaviorInstance, Ease = self.Ease, NAMESPACE = C33.Behaviors.Tween, map = /* @__PURE__ */ new WeakMap(), TWEEN_PROPERTIES = /* @__PURE__ */ new Map([["x", { name: "offsetX", type: "one" }], ["y", { name: "offsetY", type: "one" }], ["width", { name: "offsetWidth", type: "one" }], ["height", { name: "offsetHeight", type: "one" }], ["angle", { name: "offsetAngle", type: "one" }], ["opacity", { name: "offsetOpacity", type: "one" }], ["color", { name: "offsetColor", type: "color" }], ["z-elevation", { name: "offsetZElevation", type: "one" }], ["x-scale", { name: "offsetScaleX", type: "one" }], ["y-scale", { name: "offsetScaleY", type: "one" }], ["position", { name: "position", type: "two" }], ["size", { name: "size", type: "two" }], ["scale", { name: "scale", type: "two" }], ["value", { name: "value", type: "value" }]]);
      const TWEEN_OPTS = { tags: "", destroyOnComplete: false, loop: false, pingPong: false, repeatCount: 1, startValue: 0 }, I_TWEEN_OPTS = { easeToIndexFunc: getIndexForEase2 };
      self.ITweenBehaviorInstance = class extends IBehaviorInstance {
        constructor() {
          super(), map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance());
        }
        startTween(e, t, n, a, o) {
          const s = map.get(this);
          if (!s.IsEnabled() || !s.IsInstanceValid()) return null;
          const r = TWEEN_PROPERTIES.get(e);
          if (!r) throw new Error("invalid tween property");
          "one" === r.type || "value" === r.type ? C3X.RequireNumber(t) : (C3X.RequireArray(t), "two" === r.type ? (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1])) : "color" === r.type && (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1]), C3X.RequireNumber(t[2]))), "angle" === e ? t = C33.toDegrees(t) : "opacity" === e ? t *= 100 : "color" === e && (t = C33.PackRGBEx(t[0], t[1], t[2]));
          const l = getIndexForEase2(a);
          C3X.RequireFiniteNumber(n), o = Object.assign({}, TWEEN_OPTS, o), "value" === r.type && C3X.RequireNumber(o.startValue), ValidateTags2(o.tags, true);
          let i;
          if ("one" === r.type || "color" === r.type ? i = s.CreateTween(NAMESPACE.TweenArguments.OneProperty(s, o.tags, r.name, t, n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : "two" === r.type ? i = s.CreateTween(NAMESPACE.TweenArguments.TwoProperties(s, o.tags, r.name, t[0], t[1], n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : "value" === r.type && (i = s.CreateTween(NAMESPACE.TweenArguments.ValueProperty(s, o.tags, o.startValue, t, n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount))), i.Play()) return i.GetITweenState(s, I_TWEEN_OPTS);
          throw new Error("failed to start tween");
        }
        *allTweens() {
          const e = map.get(this);
          for (const t of e.AllTweens()) yield t.GetITweenState(e, I_TWEEN_OPTS);
        }
        *tweensByTags(e) {
          ValidateTags2(e);
          const t = map.get(this);
          for (const n of t.GetTweens(e)) yield n.GetITweenState(t, I_TWEEN_OPTS);
        }
        get isEnabled() {
          return map.get(this).IsEnabled();
        }
        set isEnabled(e) {
          map.get(this).SetEnabled(e);
        }
      };
    }
    var getIndexForEase;
    var ValidateTags;
    {
      let unaryminus2 = function(n) {
        return typeof n === "number" ? -n : n;
      }, bothNumbers2 = function(a, b) {
        return typeof a === "number" && typeof b === "number";
      }, add2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l + r;
        else
          return l;
      }, subtract2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l - r;
        else
          return l;
      }, multiply2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l * r;
        else
          return l;
      }, divide2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l / r;
        else
          return l;
      }, mod2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l % r;
        else
          return l;
      }, pow2 = function(l, r) {
        if (bothNumbers2(l, r))
          return Math.pow(l, r);
        else
          return l;
      }, and2 = function(l, r) {
        if (typeof l === "string" || typeof r === "string") {
          let lstr, rstr;
          if (typeof l === "number")
            lstr = (Math.round(l * 1e10) / 1e10).toString();
          else
            lstr = l;
          if (typeof r === "number")
            rstr = (Math.round(r * 1e10) / 1e10).toString();
          else
            rstr = r;
          return lstr + rstr;
        } else {
          return l && r ? 1 : 0;
        }
      }, or2 = function(l, r) {
        if (bothNumbers2(l, r))
          return l || r ? 1 : 0;
        else
          return l;
      };
      unaryminus = unaryminus2, bothNumbers = bothNumbers2, add = add2, subtract = subtract2, multiply = multiply2, divide = divide2, mod = mod2, pow = pow2, and = and2, or = or2;
      const C33 = self.C3;
      self.C3_ExpressionFuncs = [
        () => "infromation_block",
        () => 1,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0();
        },
        () => "list",
        (p) => {
          const v0 = p._GetNode(0).GetVar();
          return () => v0.GetValue();
        },
        () => 500,
        () => 0,
        () => "NO!",
        () => 3,
        () => "GooD!",
        () => "",
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject() - 10;
        },
        () => 0.2,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject();
        },
        (p) => {
          const n0 = p._GetNode(0);
          const n1 = p._GetNode(1);
          const n2 = p._GetNode(2);
          const n3 = p._GetNode(3);
          const v4 = p._GetNode(4).GetVar();
          return () => and2("<tr class='Item'><td class='Item'>" + n0.ExpObject(n1.ExpObject(n2.ExpObject(), n3.ExpObject())) + "</td><td class='numeric'>[", v4.GetValue()) + "]</td></tr>";
        },
        () => "tbody",
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          const n1 = p._GetNode(1);
          return () => f0(n1.ExpInstVar());
        },
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpInstVar();
        },
        () => "setting",
        () => "Pass",
        () => 0.3,
        () => "Array",
        () => "PassEnter",
        () => 2,
        (p) => {
          const f0 = p._GetNode(0).GetBoundMethod();
          return () => f0("2025-02-03");
        },
        () => "Start",
        () => "getMap",
        () => "https://ipinfo.io/json",
        () => 10,
        (p) => {
          const n0 = p._GetNode(0);
          return () => n0.ExpObject("country");
        },
        () => "US",
        () => "IE",
        () => "CN",
        () => "SET NEW PASSWORD",
        () => "Hiden",
        () => "ENTER PASSWORD"
      ];
    }
    var unaryminus;
    var bothNumbers;
    var add;
    var subtract;
    var multiply;
    var divide;
    var mod;
    var pow;
    var and;
    var or;
  }
});

// file-map:scripts/c3main.js
var import_c3runtime = __toESM(require_c3runtime());

// file-map:scripts/objRefTable.js
var C32 = self.C3;
self.C3_GetObjectRefTable = function() {
  return [
    C32.Plugins.HTMLElement,
    C32.Plugins.Browser,
    C32.Plugins.Sprite,
    C32.Plugins.UserMedia,
    C32.Plugins.Text,
    C32.Behaviors.Anchor,
    C32.Behaviors.Sin,
    C32.Plugins.Touch,
    C32.Plugins.List,
    C32.Plugins.Dictionary,
    C32.Plugins.Arr,
    C32.Plugins.AJAX,
    C32.Plugins.Clipboard,
    C32.Plugins.LocalStorage,
    C32.Plugins.TextBox,
    C32.Behaviors.Fade,
    C32.Behaviors.Rotate,
    C32.Plugins.Date,
    C32.Plugins.qrcode,
    C32.Behaviors.Tween,
    C32.Plugins.Json,
    C32.ScriptsInEvents.EventSheet1_Event2_Act1,
    C32.Plugins.UserMedia.Acts.Stop,
    C32.ScriptsInEvents.EventSheet1_Event4_Act2,
    C32.Plugins.System.Cnds.OnLayoutStart,
    C32.Plugins.System.Acts.SetLayerVisible,
    C32.Plugins.System.Acts.SetLayerInteractive,
    C32.Plugins.System.Acts.Wait,
    C32.Plugins.UserMedia.Acts.GetMediaSources,
    C32.Plugins.System.Cnds.Compare,
    C32.Plugins.System.Exps.layoutname,
    C32.Plugins.UserMedia.Acts.RequestCamera,
    C32.Plugins.UserMedia.Cnds.OnMediaSources,
    C32.Plugins.UserMedia.Cnds.OnDeclined,
    C32.Plugins.Text.Acts.SetText,
    C32.Plugins.UserMedia.Cnds.OnApproved,
    C32.Plugins.Touch.Cnds.OnTapGestureObject,
    C32.Behaviors.Tween.Acts.TweenTwoProperties,
    C32.Plugins.Sprite.Exps.Width,
    C32.Plugins.Sprite.Exps.Height,
    C32.Plugins.System.Acts.WaitForPreviousActions,
    C32.Plugins.Arr.Acts.Push,
    C32.Plugins.Text.Exps.Text,
    C32.Plugins.Arr.Exps.AsJSON,
    C32.Plugins.Sprite.Acts.SetVisible,
    C32.Behaviors.Fade.Acts.SetFadeOutTime,
    C32.Plugins.Arr.Cnds.CompareX,
    C32.Plugins.Arr.Acts.Delete,
    C32.Plugins.Arr.Cnds.ArrForEach,
    C32.Plugins.HTMLElement.Acts.InsertContent,
    C32.Plugins.HTMLElement.Exps.EscapeHTML,
    C32.Plugins.Arr.Exps.At,
    C32.Plugins.Arr.Exps.CurX,
    C32.Plugins.Arr.Exps.CurY,
    C32.Plugins.System.Acts.AddVar,
    C32.ScriptsInEvents.EventSheet2_Event6_Act2,
    C32.Plugins.Sprite.Acts.SetInstanceVar,
    C32.Plugins.Sprite.Cnds.IsVisible,
    C32.Plugins.System.Exps.int,
    C32.ScriptsInEvents.EventSheet2_Event10_Act1,
    C32.Plugins.Clipboard.Acts.CopyText,
    C32.Plugins.TextBox.Exps.Text,
    C32.Plugins.LocalStorage.Acts.SetItem,
    C32.Behaviors.Fade.Acts.StartFade,
    C32.Plugins.qrcode.Acts.SetText,
    C32.Plugins.LocalStorage.Acts.CheckItemExists,
    C32.Plugins.LocalStorage.Cnds.OnItemGet,
    C32.Plugins.Arr.Acts.JSONLoad,
    C32.Plugins.LocalStorage.Exps.ItemValue,
    C32.Plugins.LocalStorage.Cnds.OnItemExists,
    C32.Plugins.LocalStorage.Acts.GetItem,
    C32.Plugins.System.Acts.GoToLayout,
    C32.Plugins.Date.Exps.Now,
    C32.Plugins.Date.Exps.Parse,
    C32.Plugins.AJAX.Acts.Request,
    C32.Plugins.AJAX.Cnds.OnComplete,
    C32.Plugins.Json.Acts.Parse,
    C32.Plugins.AJAX.Exps.LastData,
    C32.Plugins.System.Cnds.For,
    C32.Plugins.Json.Exps.Get,
    C32.Plugins.System.Acts.SetVar,
    C32.Plugins.System.Cnds.CompareVar,
    C32.Plugins.LocalStorage.Cnds.OnItemMissing,
    C32.Plugins.LocalStorage.Cnds.OnError,
    C32.Plugins.Text.Cnds.CompareText
  ];
};
self.C3_JsPropNameTable = [
  { HTMLElement: 0 },
  { Browser: 0 },
  { Sprite: 0 },
  { UserMedia: 0 },
  { Text: 0 },
  { Anchor: 0 },
  { headerSprite: 0 },
  { bottom_sprite: 0 },
  { Sprite2: 0 },
  { Sprite3: 0 },
  { Sine: 0 },
  { Sprite4: 0 },
  { qrcodebtn: 0 },
  { switch_camera_128dp_5F6368_FILL0_wght400_GRAD0_opsz: 0 },
  { Touch: 0 },
  { listbtn: 0 },
  { List: 0 },
  { Dictionary: 0 },
  { settingbtn: 0 },
  { Sprite5: 0 },
  { disabled: 0 },
  { post_add: 0 },
  { Text2: 0 },
  { Array: 0 },
  { HTMLElement2: 0 },
  { AJAX: 0 },
  { id: 0 },
  { name: 0 },
  { delete_forever: 0 },
  { Clipboard: 0 },
  { content_copy: 0 },
  { LocalStorage: 0 },
  { Sprite6: 0 },
  { TextInput: 0 },
  { Text3: 0 },
  { Fade: 0 },
  { Sprite7: 0 },
  { Rotate: 0 },
  { sync_256dp_000000_FILL0_wght400_GRAD0_opsz: 0 },
  { Sprite8: 0 },
  { Text4: 0 },
  { Date: 0 },
  { QRCode: 0 },
  { Tween: 0 },
  { qrGenButton: 0 },
  { TextQrCode: 0 },
  { Text5: 0 },
  { HTMLElement3: 0 },
  { Array2: 0 },
  { Dictionary2: 0 },
  { JSON: 0 },
  { btn: 0 },
  { Variable1: 0 },
  { TextInfo: 0 },
  { localindex: 0 },
  { result: 0 },
  { ID: 0 },
  { pass: 0 },
  { ArrayString: 0 },
  { passString: 0 }
];
self.InstanceType = {
  HTMLElement: class extends self.IHTMLElementInstance {
  },
  Browser: class extends self.IInstance {
  },
  Sprite: class extends self.ISpriteInstance {
  },
  UserMedia: class extends self.IWorldInstance {
  },
  Text: class extends self.ITextInstance {
  },
  headerSprite: class extends self.ISpriteInstance {
  },
  bottom_sprite: class extends self.ISpriteInstance {
  },
  Sprite2: class extends self.ISpriteInstance {
  },
  Sprite3: class extends self.ISpriteInstance {
  },
  Sprite4: class extends self.ISpriteInstance {
  },
  qrcodebtn: class extends self.ISpriteInstance {
  },
  switch_camera_128dp_5F6368_FILL0_wght400_GRAD0_opsz: class extends self.ISpriteInstance {
  },
  Touch: class extends self.IInstance {
  },
  listbtn: class extends self.ISpriteInstance {
  },
  List: class extends self.IListInstance {
  },
  Dictionary: class extends self.IDictionaryInstance {
  },
  settingbtn: class extends self.ISpriteInstance {
  },
  Sprite5: class extends self.ISpriteInstance {
  },
  disabled: class extends self.ISpriteInstance {
  },
  post_add: class extends self.ISpriteInstance {
  },
  Text2: class extends self.ITextInstance {
  },
  Array: class extends self.IArrayInstance {
  },
  HTMLElement2: class extends self.IHTMLElementInstance {
  },
  AJAX: class extends self.IInstance {
  },
  delete_forever: class extends self.ISpriteInstance {
  },
  Clipboard: class extends self.IInstance {
  },
  content_copy: class extends self.ISpriteInstance {
  },
  LocalStorage: class extends self.IInstance {
  },
  Sprite6: class extends self.ISpriteInstance {
  },
  TextInput: class extends self.ITextInputInstance {
  },
  Text3: class extends self.ITextInstance {
  },
  Sprite7: class extends self.ISpriteInstance {
  },
  sync_256dp_000000_FILL0_wght400_GRAD0_opsz: class extends self.ISpriteInstance {
  },
  Sprite8: class extends self.ISpriteInstance {
  },
  Text4: class extends self.ITextInstance {
  },
  Date: class extends self.IInstance {
  },
  QRCode: class extends self.IQRCodeInstance {
  },
  qrGenButton: class extends self.ISpriteInstance {
  },
  TextQrCode: class extends self.ITextInputInstance {
  },
  Text5: class extends self.ITextInstance {
  },
  HTMLElement3: class extends self.IHTMLElementInstance {
  },
  Array2: class extends self.IArrayInstance {
  },
  Dictionary2: class extends self.IDictionaryInstance {
  },
  JSON: class extends self.IJSONInstance {
  },
  btn: class extends self.ISpriteInstance {
  }
};

// file-map:scripts/project/main.js
runOnStartup(async (runtime) => {
  runtime.addEventListener("beforeprojectstart", () => OnBeforeProjectStart(runtime));
});
async function OnBeforeProjectStart(runtime) {
  runtime.addEventListener("tick", () => Tick(runtime));
}
function Tick(runtime) {
}

// file-map:scripts/project/scriptsInEvents.js
var scriptsInEvents = {
  async EventSheet1_Event2_Act1(runtime, localVars) {
    const html5QrCode2 = new Html5Qrcode(
      "reader",
      /* verbose= */
      true
    );
    Html5Qrcode.getCameras().then((devices) => {
      if (devices && devices.length) {
        var divaceId = runtime.globalVars.Variable1;
        var cameraId = devices[divaceId].id;
        runtime.callFunction("requestCamer");
        const html5QrCode3 = new Html5Qrcode(
          /* element id */
          "reader"
        );
        html5QrCode3.start(
          cameraId,
          {
            fps: 10,
            // Optional, frame per seconds for qr code scanning
            //aspectRatio: 9.16,
            //qrbox: { width: 250, height: 250 },
            facingMode: { exact: "environment" }
            // Optional, if you want bounded box UI
          },
          (decodedText, decodedResult) => {
            console.log(decodedText);
            console.log(decodedResult);
            runtime.callFunction("viewBlock", [String(decodedText)]);
          },
          (errorMessage) => {
          }
        ).catch((err) => {
        });
      }
    }).catch((err) => {
      alert(err);
      console.log(err);
    });
  },
  async EventSheet1_Event4_Act2(runtime, localVars) {
    html5QrCode.stop().then((ignore) => {
    }).catch((err) => {
    });
  },
  async EventSheet2_Event6_Act2(runtime, localVars) {
    var cells = document.querySelectorAll(".resultstable tr.Item");
    cells = Array.prototype.slice.call(cells);
    cells.forEach(function(cell) {
      cell.addEventListener("click", function() {
        cells.forEach(function(c) {
          c.classList.remove("selected");
        });
        this.classList.add("selected");
        var cellText = this.textContent || this.innerText;
        let result2 = cellText.split("[")[0];
        let resultID = cellText.match(/\[(.*?)\]/);
        console.log(result2);
        console.log(resultID[0]);
        runtime.callFunction("OnCellClicked", result2, resultID[0]);
      });
    });
  },
  async EventSheet2_Event10_Act1(runtime, localVars) {
    deleteSelectedCell();
    function deleteSelectedCell() {
      var selectedCell = document.querySelector(".resultstable tr.Item.selected");
      if (selectedCell) {
        selectedCell.remove();
      }
    }
  }
};
self.C3.ScriptsInEvents = scriptsInEvents;
